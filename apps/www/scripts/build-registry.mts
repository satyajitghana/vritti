import { promises as fs } from 'fs'
import path from 'path'

const REGISTRY_BASE = path.join(process.cwd(), 'registry', 'components')
const BLOCKS_BASE = path.join(process.cwd(), 'registry', 'blocks')
const INDEX_OUTPUT = path.join(process.cwd(), 'registry', '__index__.tsx')
const COMPONENT_LIST_OUTPUT = path.join(process.cwd(), 'registry', 'component-list.ts')
const BLOCK_LIST_OUTPUT = path.join(process.cwd(), 'registry', 'block-list.ts')

const CATEGORIES = [
  'animations',
  'backgrounds',
  'text',
  'buttons',
  'layouts',
  'inputs',
  'media',
  'special',
]

const BLOCK_CATEGORIES = [
  'hero',
  'pricing',
  'auth',
  'testimonial',
  'contact',
  'faq',
  'footer',
  'blog',
  'ecommerce',
  'billing',
  'modal',
  'account',
  'special',
]

function toTitleCase(str: string): string {
  return str
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

interface ComponentMeta {
  name: string
  title: string
  description: string
  category: string
  type: 'component' | 'block'
  dependencies?: string[]
  registryDependencies?: string[]
  meta?: Record<string, unknown>
}

async function scanDirectory(basePath: string, categories: string[], itemType: 'component' | 'block'): Promise<ComponentMeta[]> {
  const items: ComponentMeta[] = []

  for (const category of categories) {
    const categoryPath = path.join(basePath, category)
    let entries: string[]
    try {
      entries = await fs.readdir(categoryPath)
    } catch {
      continue
    }

    for (const name of entries) {
      const componentDir = path.join(categoryPath, name)
      const stat = await fs.stat(componentDir)
      if (!stat.isDirectory()) continue

      // Read component.json for metadata
      let metadata: Record<string, unknown> = {}
      try {
        const jsonContent = await fs.readFile(
          path.join(componentDir, 'component.json'),
          'utf-8'
        )
        metadata = JSON.parse(jsonContent)
      } catch {
        // Use defaults if no component.json
      }

      // Check if component.tsx exists
      const hasComponent = await fs
        .access(path.join(componentDir, 'component.tsx'))
        .then(() => true)
        .catch(() => false)

      if (!hasComponent) continue

      items.push({
        name,
        title: (metadata.title as string) || toTitleCase(name),
        description: (metadata.description as string) || `${toTitleCase(name)} ${itemType}.`,
        category,
        type: itemType,
        dependencies: metadata.dependencies as string[] | undefined,
        registryDependencies: metadata.registryDependencies as string[] | undefined,
        meta: metadata.meta as Record<string, unknown> | undefined,
      })
    }
  }

  return items.sort((a, b) => a.name.localeCompare(b.name))
}

async function buildRegistryIndex(components: ComponentMeta[], blocks: ComponentMeta[]) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.mts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`

  // Build component entries
  for (const comp of components) {
    const componentRelPath = `registry/components/${comp.category}/${comp.name}/component.tsx`
    const exampleRelPath = `registry/components/${comp.category}/${comp.name}/example.tsx`
    const componentImportPath = `@/registry/components/${comp.category}/${comp.name}/component`
    const exampleImportPath = `@/registry/components/${comp.category}/${comp.name}/example`

    const hasExample = await fs
      .access(
        path.join(REGISTRY_BASE, comp.category, comp.name, 'example.tsx')
      )
      .then(() => true)
      .catch(() => false)

    index += `
  "${comp.name}": {
    name: "${comp.name}",
    description: "${(comp.description || '').replace(/"/g, '\\"')}",
    type: "registry:ui",
    category: "${comp.category}",
    registryDependencies: ${JSON.stringify(comp.registryDependencies || undefined)},
    dependencies: ${JSON.stringify(comp.dependencies || [])},
    files: [{
      path: "${componentRelPath}",
      type: "registry:ui",
      target: ""
    }],
    component: React.lazy(async () => {
      const mod = await import("${componentImportPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object')
      return { default: mod.default || mod[exportName] }
    }),
    meta: ${JSON.stringify(comp.meta)},
  },`

    if (hasExample) {
      index += `
  "${comp.name}-demo": {
    name: "${comp.name}-demo",
    description: "${(comp.description || '').replace(/"/g, '\\"')} (demo)",
    type: "registry:example",
    category: "${comp.category}",
    registryDependencies: ["${comp.name}"],
    files: [{
      path: "${exampleRelPath}",
      type: "registry:example",
      target: ""
    }],
    component: React.lazy(() => import("${exampleImportPath}")),
    meta: ${JSON.stringify(comp.meta)},
  },`
    }
  }

  // Build block entries
  for (const block of blocks) {
    const componentRelPath = `registry/blocks/${block.category}/${block.name}/component.tsx`
    const exampleRelPath = `registry/blocks/${block.category}/${block.name}/example.tsx`
    const componentImportPath = `@/registry/blocks/${block.category}/${block.name}/component`
    const exampleImportPath = `@/registry/blocks/${block.category}/${block.name}/example`

    const hasExample = await fs
      .access(
        path.join(BLOCKS_BASE, block.category, block.name, 'example.tsx')
      )
      .then(() => true)
      .catch(() => false)

    index += `
  "${block.name}": {
    name: "${block.name}",
    description: "${(block.description || '').replace(/"/g, '\\"')}",
    type: "registry:block",
    category: "${block.category}",
    registryDependencies: ${JSON.stringify(block.registryDependencies || undefined)},
    dependencies: ${JSON.stringify(block.dependencies || [])},
    files: [{
      path: "${componentRelPath}",
      type: "registry:block",
      target: ""
    }],
    component: React.lazy(async () => {
      const mod = await import("${componentImportPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object')
      return { default: mod.default || mod[exportName] }
    }),
    meta: ${JSON.stringify(block.meta)},
  },`

    if (hasExample) {
      index += `
  "${block.name}-demo": {
    name: "${block.name}-demo",
    description: "${(block.description || '').replace(/"/g, '\\"')} (demo)",
    type: "registry:example",
    category: "${block.category}",
    registryDependencies: ["${block.name}"],
    files: [{
      path: "${exampleRelPath}",
      type: "registry:example",
      target: ""
    }],
    component: React.lazy(() => import("${exampleImportPath}")),
    meta: ${JSON.stringify(block.meta)},
  },`
    }
  }

  index += `
}
`

  await fs.writeFile(INDEX_OUTPUT, index, 'utf-8')
  console.log(
    `Registry index built: ${components.length} components + ${blocks.length} blocks -> ${INDEX_OUTPUT}`
  )
}

async function buildComponentList(components: ComponentMeta[]) {
  const entries = components.map(
    (c) =>
      `  { name: "${c.name}", title: "${c.title.replace(/"/g, '\\"')}", category: "${c.category}" },`
  )

  const content = `// This file is autogenerated by scripts/build-registry.mts
// Do not edit this file directly.

export const componentList: Array<{ name: string; title: string; category: string }> = [
${entries.join('\n')}
]
`

  await fs.writeFile(COMPONENT_LIST_OUTPUT, content, 'utf-8')
  console.log(`Component list built: ${components.length} entries -> ${COMPONENT_LIST_OUTPUT}`)
}

async function buildBlockList(blocks: ComponentMeta[]) {
  const entries = blocks.map(
    (b) =>
      `  { name: "${b.name}", title: "${b.title.replace(/"/g, '\\"')}", category: "${b.category}" },`
  )

  const content = `// This file is autogenerated by scripts/build-registry.mts
// Do not edit this file directly.

export const blockList: Array<{ name: string; title: string; category: string }> = [
${entries.join('\n')}
]
`

  await fs.writeFile(BLOCK_LIST_OUTPUT, content, 'utf-8')
  console.log(`Block list built: ${blocks.length} entries -> ${BLOCK_LIST_OUTPUT}`)
}

async function main() {
  console.log('Scanning components...')
  const components = await scanDirectory(REGISTRY_BASE, CATEGORIES, 'component')
  console.log(`Found ${components.length} components across ${CATEGORIES.length} categories`)

  console.log('Scanning blocks...')
  const blocks = await scanDirectory(BLOCKS_BASE, BLOCK_CATEGORIES, 'block')
  console.log(`Found ${blocks.length} blocks across ${BLOCK_CATEGORIES.length} categories`)

  await buildRegistryIndex(components, blocks)
  await buildComponentList(components)
  await buildBlockList(blocks)

  console.log('Done!')
}

main().catch((error) => {
  console.error('Failed to build registry:', error)
  process.exit(1)
})
