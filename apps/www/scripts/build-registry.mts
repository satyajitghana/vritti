import { promises as fs } from 'fs'
import path from 'path'

const REGISTRY_BASE = path.join(process.cwd(), 'registry', 'components')
const INDEX_OUTPUT = path.join(process.cwd(), 'registry', '__index__.tsx')
const LIST_OUTPUT = path.join(process.cwd(), 'registry', 'component-list.ts')

const CATEGORIES = [
  'animations',
  'backgrounds',
  'text',
  'buttons',
  'layouts',
  'special',
]

function toTitleCase(str: string): string {
  return str
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

interface ComponentMeta {
  name: string
  title: string
  description: string
  category: string
  dependencies?: string[]
  registryDependencies?: string[]
  meta?: Record<string, unknown>
}

async function scanComponents(): Promise<ComponentMeta[]> {
  const components: ComponentMeta[] = []

  for (const category of CATEGORIES) {
    const categoryPath = path.join(REGISTRY_BASE, category)
    let items: string[]
    try {
      items = await fs.readdir(categoryPath)
    } catch {
      continue
    }

    for (const name of items) {
      const componentDir = path.join(categoryPath, name)
      const stat = await fs.stat(componentDir)
      if (!stat.isDirectory()) continue

      // Read component.json for metadata
      let metadata: Record<string, unknown> = {}
      try {
        const jsonContent = await fs.readFile(
          path.join(componentDir, 'component.json'),
          'utf-8'
        )
        metadata = JSON.parse(jsonContent)
      } catch {
        // Use defaults if no component.json
      }

      // Check if component.tsx exists
      const hasComponent = await fs
        .access(path.join(componentDir, 'component.tsx'))
        .then(() => true)
        .catch(() => false)

      if (!hasComponent) continue

      components.push({
        name,
        title: (metadata.title as string) || toTitleCase(name),
        description: (metadata.description as string) || `${toTitleCase(name)} component.`,
        category,
        dependencies: metadata.dependencies as string[] | undefined,
        registryDependencies: metadata.registryDependencies as string[] | undefined,
        meta: metadata.meta as Record<string, unknown> | undefined,
      })
    }
  }

  return components.sort((a, b) => a.name.localeCompare(b.name))
}

async function buildRegistryIndex(components: ComponentMeta[]) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.mts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`

  for (const comp of components) {
    const componentRelPath = `registry/components/${comp.category}/${comp.name}/component.tsx`
    const exampleRelPath = `registry/components/${comp.category}/${comp.name}/example.tsx`
    const componentImportPath = `@/registry/components/${comp.category}/${comp.name}/component`
    const exampleImportPath = `@/registry/components/${comp.category}/${comp.name}/example`

    const hasExample = await fs
      .access(
        path.join(REGISTRY_BASE, comp.category, comp.name, 'example.tsx')
      )
      .then(() => true)
      .catch(() => false)

    // Component entry (used by ComponentSource)
    index += `
  "${comp.name}": {
    name: "${comp.name}",
    description: "${(comp.description || '').replace(/"/g, '\\"')}",
    type: "registry:ui",
    category: "${comp.category}",
    registryDependencies: ${JSON.stringify(comp.registryDependencies || undefined)},
    dependencies: ${JSON.stringify(comp.dependencies || [])},
    files: [{
      path: "${componentRelPath}",
      type: "registry:ui",
      target: ""
    }],
    component: React.lazy(async () => {
      const mod = await import("${componentImportPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object')
      return { default: mod.default || mod[exportName] }
    }),
    meta: ${JSON.stringify(comp.meta)},
  },`

    // Example/demo entry (used by ComponentPreview)
    if (hasExample) {
      index += `
  "${comp.name}-demo": {
    name: "${comp.name}-demo",
    description: "${(comp.description || '').replace(/"/g, '\\"')} (demo)",
    type: "registry:example",
    category: "${comp.category}",
    registryDependencies: ["${comp.name}"],
    files: [{
      path: "${exampleRelPath}",
      type: "registry:example",
      target: ""
    }],
    component: React.lazy(() => import("${exampleImportPath}")),
    meta: ${JSON.stringify(comp.meta)},
  },`
    }
  }

  index += `
}
`

  await fs.writeFile(INDEX_OUTPUT, index, 'utf-8')
  console.log(
    `Registry index built: ${components.length} components + examples -> ${INDEX_OUTPUT}`
  )
}

async function buildComponentList(components: ComponentMeta[]) {
  const entries = components.map(
    (c) =>
      `  { name: "${c.name}", title: "${c.title.replace(/"/g, '\\"')}", category: "${c.category}" },`
  )

  const content = `// This file is autogenerated by scripts/build-registry.mts
// Do not edit this file directly.

export const componentList: Array<{ name: string; title: string; category: string }> = [
${entries.join('\n')}
]
`

  await fs.writeFile(LIST_OUTPUT, content, 'utf-8')
  console.log(`Component list built: ${components.length} entries -> ${LIST_OUTPUT}`)
}

async function main() {
  console.log('Scanning components...')
  const components = await scanComponents()
  console.log(`Found ${components.length} components across ${CATEGORIES.length} categories`)

  await buildRegistryIndex(components)
  await buildComponentList(components)

  console.log('Done!')
}

main().catch((error) => {
  console.error('Failed to build registry:', error)
  process.exit(1)
})
