{
  "components": [
    {
      "name": "animated-grid-pattern",
      "type": "component",
      "description": "A backgrounds animated grid pattern component",
      "category": "backgrounds",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/animated-grid-pattern.tsx",
          "content": "\"use client\"\n\nimport {\n  ComponentPropsWithoutRef,\n  useCallback,\n  useEffect,\n  useId,\n  useRef,\n  useState,\n} from \"react\"\nimport { motion } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface AnimatedGridPatternProps extends ComponentPropsWithoutRef<\"svg\"> {\n  width?: number\n  height?: number\n  x?: number\n  y?: number\n  strokeDasharray?: number\n  numSquares?: number\n  maxOpacity?: number\n  duration?: number\n  repeatDelay?: number\n}\n\ntype Square = {\n  id: number\n  pos: [number, number]\n  iteration: number\n}\n\nexport function AnimatedGridPattern({\n  width = 40,\n  height = 40,\n  x = -1,\n  y = -1,\n  strokeDasharray = 0,\n  numSquares = 50,\n  className,\n  maxOpacity = 0.5,\n  duration = 4,\n  repeatDelay = 0.5,\n  ...props\n}: AnimatedGridPatternProps) {\n  const id = useId()\n  const containerRef = useRef<SVGSVGElement | null>(null)\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })\n  const [squares, setSquares] = useState<Array<Square>>([])\n\n  const getPos = useCallback((): [number, number] => {\n    return [\n      Math.floor((Math.random() * dimensions.width) / width),\n      Math.floor((Math.random() * dimensions.height) / height),\n    ]\n  }, [dimensions.height, dimensions.width, height, width])\n\n  const generateSquares = useCallback(\n    (count: number) => {\n      return Array.from({ length: count }, (_, i) => ({\n        id: i,\n        pos: getPos(),\n        iteration: 0,\n      }))\n    },\n    [getPos]\n  )\n\n  const updateSquarePosition = useCallback(\n    (squareId: number) => {\n      setSquares((currentSquares) => {\n        const current = currentSquares[squareId]\n        if (!current || current.id !== squareId) return currentSquares\n\n        const nextSquares = currentSquares.slice()\n        nextSquares[squareId] = {\n          ...current,\n          pos: getPos(),\n          iteration: current.iteration + 1,\n        }\n\n        return nextSquares\n      })\n    },\n    [getPos]\n  )\n\n  useEffect(() => {\n    if (dimensions.width && dimensions.height) {\n      setSquares(generateSquares(numSquares))\n    }\n  }, [dimensions.width, dimensions.height, generateSquares, numSquares])\n\n  useEffect(() => {\n    const element = containerRef.current\n    if (!element) return\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        setDimensions((currentDimensions) => {\n          const nextWidth = entry.contentRect.width\n          const nextHeight = entry.contentRect.height\n          if (\n            currentDimensions.width === nextWidth &&\n            currentDimensions.height === nextHeight\n          ) {\n            return currentDimensions\n          }\n          return { width: nextWidth, height: nextHeight }\n        })\n      }\n    })\n\n    resizeObserver.observe(element)\n\n    return () => {\n      resizeObserver.disconnect()\n    }\n  }, [])\n\n  return (\n    <svg\n      ref={containerRef}\n      aria-hidden=\"true\"\n      className={cn(\n        \"pointer-events-none absolute inset-0 h-full w-full fill-gray-400/30 stroke-gray-400/30\",\n        className\n      )}\n      {...props}\n    >\n      <defs>\n        <pattern\n          id={id}\n          width={width}\n          height={height}\n          patternUnits=\"userSpaceOnUse\"\n          x={x}\n          y={y}\n        >\n          <path\n            d={`M.5 ${height}V.5H${width}`}\n            fill=\"none\"\n            strokeDasharray={strokeDasharray}\n          />\n        </pattern>\n      </defs>\n      <rect width=\"100%\" height=\"100%\" fill={`url(#${id})`} />\n      <svg x={x} y={y} className=\"overflow-visible\">\n        {squares.map(({ pos: [squareX, squareY], id, iteration }, index) => (\n          <motion.rect\n            initial={{ opacity: 0 }}\n            animate={{ opacity: maxOpacity }}\n            transition={{\n              duration,\n              repeat: 1,\n              delay: index * 0.1,\n              repeatType: \"reverse\",\n              repeatDelay,\n            }}\n            onAnimationComplete={() => updateSquarePosition(id)}\n            key={`${id}-${iteration}`}\n            width={width - 1}\n            height={height - 1}\n            x={squareX * width + 1}\n            y={squareY * height + 1}\n            fill=\"currentColor\"\n            strokeWidth=\"0\"\n          />\n        ))}\n      </svg>\n    </svg>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "backgrounds"
        ]
      }
    },
    {
      "name": "aurora",
      "type": "component",
      "description": "An aurora borealis background effect with animated light bands.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/aurora.tsx",
          "content": "import { useEffect, useRef } from 'react';\nimport { Renderer, Program, Mesh, Color, Triangle } from 'ogl';\n\nconst VERT = `#version 300 es\nin vec2 position;\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst FRAG = `#version 300 es\nprecision highp float;\n\nuniform float uTime;\nuniform float uAmplitude;\nuniform vec3 uColorStops[3];\nuniform vec2 uResolution;\nuniform float uBlend;\n\nout vec4 fragColor;\n\nvec3 permute(vec3 x) {\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(\n      0.211324865405187, 0.366025403784439,\n      -0.577350269189626, 0.024390243902439\n  );\n  vec2 i  = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n\n  vec3 p = permute(\n      permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0)\n  );\n\n  vec3 m = max(\n      0.5 - vec3(\n          dot(x0, x0),\n          dot(x12.xy, x12.xy),\n          dot(x12.zw, x12.zw)\n      ), \n      0.0\n  );\n  m = m * m;\n  m = m * m;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nstruct ColorStop {\n  vec3 color;\n  float position;\n};\n\n#define COLOR_RAMP(colors, factor, finalColor) {              \\\n  int index = 0;                                            \\\n  for (int i = 0; i < 2; i++) {                               \\\n     ColorStop currentColor = colors[i];                    \\\n     bool isInBetween = currentColor.position <= factor;    \\\n     index = int(mix(float(index), float(i), float(isInBetween))); \\\n  }                                                         \\\n  ColorStop currentColor = colors[index];                   \\\n  ColorStop nextColor = colors[index + 1];                  \\\n  float range = nextColor.position - currentColor.position; \\\n  float lerpFactor = (factor - currentColor.position) / range; \\\n  finalColor = mix(currentColor.color, nextColor.color, lerpFactor); \\\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / uResolution;\n  \n  ColorStop colors[3];\n  colors[0] = ColorStop(uColorStops[0], 0.0);\n  colors[1] = ColorStop(uColorStops[1], 0.5);\n  colors[2] = ColorStop(uColorStops[2], 1.0);\n  \n  vec3 rampColor;\n  COLOR_RAMP(colors, uv.x, rampColor);\n  \n  float height = snoise(vec2(uv.x * 2.0 + uTime * 0.1, uTime * 0.25)) * 0.5 * uAmplitude;\n  height = exp(height);\n  height = (uv.y * 2.0 - height + 0.2);\n  float intensity = 0.6 * height;\n  \n  float midPoint = 0.20;\n  float auroraAlpha = smoothstep(midPoint - uBlend * 0.5, midPoint + uBlend * 0.5, intensity);\n  \n  vec3 auroraColor = intensity * rampColor;\n  \n  fragColor = vec4(auroraColor * auroraAlpha, auroraAlpha);\n}\n`;\n\ninterface AuroraProps {\n  colorStops?: string[];\n  amplitude?: number;\n  blend?: number;\n  time?: number;\n  speed?: number;\n}\n\nexport default function Aurora(props: AuroraProps) {\n  const { colorStops = ['#5227FF', '#7cff67', '#5227FF'], amplitude = 1.0, blend = 0.5 } = props;\n  const propsRef = useRef<AuroraProps>(props);\n  propsRef.current = props;\n\n  const ctnDom = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const ctn = ctnDom.current;\n    if (!ctn) return;\n\n    const renderer = new Renderer({\n      alpha: true,\n      premultipliedAlpha: true,\n      antialias: true\n    });\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.canvas.style.backgroundColor = 'transparent';\n\n    let program: Program | undefined;\n\n    function resize() {\n      if (!ctn) return;\n      const width = ctn.offsetWidth;\n      const height = ctn.offsetHeight;\n      renderer.setSize(width, height);\n      if (program) {\n        program.uniforms.uResolution.value = [width, height];\n      }\n    }\n    window.addEventListener('resize', resize);\n\n    const geometry = new Triangle(gl);\n    if (geometry.attributes.uv) {\n      delete geometry.attributes.uv;\n    }\n\n    const colorStopsArray = colorStops.map(hex => {\n      const c = new Color(hex);\n      return [c.r, c.g, c.b];\n    });\n\n    program = new Program(gl, {\n      vertex: VERT,\n      fragment: FRAG,\n      uniforms: {\n        uTime: { value: 0 },\n        uAmplitude: { value: amplitude },\n        uColorStops: { value: colorStopsArray },\n        uResolution: { value: [ctn.offsetWidth, ctn.offsetHeight] },\n        uBlend: { value: blend }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n    ctn.appendChild(gl.canvas);\n\n    let animateId = 0;\n    const update = (t: number) => {\n      animateId = requestAnimationFrame(update);\n      const { time = t * 0.01, speed = 1.0 } = propsRef.current;\n      if (program) {\n        program.uniforms.uTime.value = time * speed * 0.1;\n        program.uniforms.uAmplitude.value = propsRef.current.amplitude ?? 1.0;\n        program.uniforms.uBlend.value = propsRef.current.blend ?? blend;\n        const stops = propsRef.current.colorStops ?? colorStops;\n        program.uniforms.uColorStops.value = stops.map((hex: string) => {\n          const c = new Color(hex);\n          return [c.r, c.g, c.b];\n        });\n        renderer.render({ scene: mesh });\n      }\n    };\n    animateId = requestAnimationFrame(update);\n\n    resize();\n\n    return () => {\n      cancelAnimationFrame(animateId);\n      window.removeEventListener('resize', resize);\n      if (ctn && gl.canvas.parentNode === ctn) {\n        ctn.removeChild(gl.canvas);\n      }\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n    };\n  }, [amplitude]);\n\n  return <div ref={ctnDom} className=\"w-full h-full\" />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "balatro",
      "type": "component",
      "description": "A psychedelic warping background effect inspired by the game Balatro.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/balatro.tsx",
          "content": "import { Renderer, Program, Mesh, Triangle } from 'ogl';\nimport { useEffect, useRef } from 'react';\n\ninterface BalatroProps {\n  spinRotation?: number;\n  spinSpeed?: number;\n  offset?: [number, number];\n  color1?: string;\n  color2?: string;\n  color3?: string;\n  contrast?: number;\n  lighting?: number;\n  spinAmount?: number;\n  pixelFilter?: number;\n  spinEase?: number;\n  isRotate?: boolean;\n  mouseInteraction?: boolean;\n}\n\nfunction hexToVec4(hex: string): [number, number, number, number] {\n  let hexStr = hex.replace('#', '');\n  let r = 0,\n    g = 0,\n    b = 0,\n    a = 1;\n  if (hexStr.length === 6) {\n    r = parseInt(hexStr.slice(0, 2), 16) / 255;\n    g = parseInt(hexStr.slice(2, 4), 16) / 255;\n    b = parseInt(hexStr.slice(4, 6), 16) / 255;\n  } else if (hexStr.length === 8) {\n    r = parseInt(hexStr.slice(0, 2), 16) / 255;\n    g = parseInt(hexStr.slice(2, 4), 16) / 255;\n    b = parseInt(hexStr.slice(4, 6), 16) / 255;\n    a = parseInt(hexStr.slice(6, 8), 16) / 255;\n  }\n  return [r, g, b, a];\n}\n\nconst vertexShader = `\nattribute vec2 uv;\nattribute vec2 position;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0, 1);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\n#define PI 3.14159265359\n\nuniform float iTime;\nuniform vec3 iResolution;\nuniform float uSpinRotation;\nuniform float uSpinSpeed;\nuniform vec2 uOffset;\nuniform vec4 uColor1;\nuniform vec4 uColor2;\nuniform vec4 uColor3;\nuniform float uContrast;\nuniform float uLighting;\nuniform float uSpinAmount;\nuniform float uPixelFilter;\nuniform float uSpinEase;\nuniform bool uIsRotate;\nuniform vec2 uMouse;\n\nvarying vec2 vUv;\n\nvec4 effect(vec2 screenSize, vec2 screen_coords) {\n    float pixel_size = length(screenSize.xy) / uPixelFilter;\n    vec2 uv = (floor(screen_coords.xy * (1.0 / pixel_size)) * pixel_size - 0.5 * screenSize.xy) / length(screenSize.xy) - uOffset;\n    float uv_len = length(uv);\n    \n    float speed = (uSpinRotation * uSpinEase * 0.2);\n    if(uIsRotate){\n       speed = iTime * speed;\n    }\n    speed += 302.2;\n    \n    float mouseInfluence = (uMouse.x * 2.0 - 1.0);\n    speed += mouseInfluence * 0.1;\n    \n    float new_pixel_angle = atan(uv.y, uv.x) + speed - uSpinEase * 20.0 * (uSpinAmount * uv_len + (1.0 - uSpinAmount));\n    vec2 mid = (screenSize.xy / length(screenSize.xy)) / 2.0;\n    uv = (vec2(uv_len * cos(new_pixel_angle) + mid.x, uv_len * sin(new_pixel_angle) + mid.y) - mid);\n    \n    uv *= 30.0;\n    float baseSpeed = iTime * uSpinSpeed;\n    speed = baseSpeed + mouseInfluence * 2.0;\n    \n    vec2 uv2 = vec2(uv.x + uv.y);\n    \n    for(int i = 0; i < 5; i++) {\n        uv2 += sin(max(uv.x, uv.y)) + uv;\n        uv += 0.5 * vec2(\n            cos(5.1123314 + 0.353 * uv2.y + speed * 0.131121),\n            sin(uv2.x - 0.113 * speed)\n        );\n        uv -= cos(uv.x + uv.y) - sin(uv.x * 0.711 - uv.y);\n    }\n    \n    float contrast_mod = (0.25 * uContrast + 0.5 * uSpinAmount + 1.2);\n    float paint_res = min(2.0, max(0.0, length(uv) * 0.035 * contrast_mod));\n    float c1p = max(0.0, 1.0 - contrast_mod * abs(1.0 - paint_res));\n    float c2p = max(0.0, 1.0 - contrast_mod * abs(paint_res));\n    float c3p = 1.0 - min(1.0, c1p + c2p);\n    float light = (uLighting - 0.2) * max(c1p * 5.0 - 4.0, 0.0) + uLighting * max(c2p * 5.0 - 4.0, 0.0);\n    \n    return (0.3 / uContrast) * uColor1 + (1.0 - 0.3 / uContrast) * (uColor1 * c1p + uColor2 * c2p + vec4(c3p * uColor3.rgb, c3p * uColor1.a)) + light;\n}\n\nvoid main() {\n    vec2 uv = vUv * iResolution.xy;\n    gl_FragColor = effect(iResolution.xy, uv);\n}\n`;\n\nexport default function Balatro({\n  spinRotation = -2.0,\n  spinSpeed = 7.0,\n  offset = [0.0, 0.0],\n  color1 = '#DE443B',\n  color2 = '#006BB4',\n  color3 = '#162325',\n  contrast = 3.5,\n  lighting = 0.4,\n  spinAmount = 0.25,\n  pixelFilter = 745.0,\n  spinEase = 1.0,\n  isRotate = false,\n  mouseInteraction = true\n}: BalatroProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const container = containerRef.current;\n    const renderer = new Renderer();\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 1);\n\n    let program: Program;\n\n    function resize() {\n      renderer.setSize(container.offsetWidth, container.offsetHeight);\n      if (program) {\n        program.uniforms.iResolution.value = [gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height];\n      }\n    }\n    window.addEventListener('resize', resize);\n    resize();\n\n    const geometry = new Triangle(gl);\n    program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: {\n          value: [gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height]\n        },\n        uSpinRotation: { value: spinRotation },\n        uSpinSpeed: { value: spinSpeed },\n        uOffset: { value: offset },\n        uColor1: { value: hexToVec4(color1) },\n        uColor2: { value: hexToVec4(color2) },\n        uColor3: { value: hexToVec4(color3) },\n        uContrast: { value: contrast },\n        uLighting: { value: lighting },\n        uSpinAmount: { value: spinAmount },\n        uPixelFilter: { value: pixelFilter },\n        uSpinEase: { value: spinEase },\n        uIsRotate: { value: isRotate },\n        uMouse: { value: [0.5, 0.5] }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n    let animationFrameId: number;\n\n    function update(time: number) {\n      animationFrameId = requestAnimationFrame(update);\n      program.uniforms.iTime.value = time * 0.001;\n      renderer.render({ scene: mesh });\n    }\n    animationFrameId = requestAnimationFrame(update);\n    container.appendChild(gl.canvas);\n\n    function handleMouseMove(e: MouseEvent) {\n      if (!mouseInteraction) return;\n      const rect = container.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n      program.uniforms.uMouse.value = [x, y];\n    }\n    container.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n      window.removeEventListener('resize', resize);\n      container.removeEventListener('mousemove', handleMouseMove);\n      container.removeChild(gl.canvas);\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n    };\n  }, [\n    spinRotation,\n    spinSpeed,\n    offset,\n    color1,\n    color2,\n    color3,\n    contrast,\n    lighting,\n    spinAmount,\n    pixelFilter,\n    spinEase,\n    isRotate,\n    mouseInteraction\n  ]);\n\n  return <div ref={containerRef} className=\"w-full h-full\" />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "ballpit",
      "type": "component",
      "description": "An interactive 3D ball pit physics simulation background.",
      "category": "backgrounds",
      "dependencies": [
        "three",
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/ballpit.tsx",
          "content": "import React, { useRef, useEffect } from 'react';\nimport {\n  Clock,\n  PerspectiveCamera,\n  Scene,\n  WebGLRenderer,\n  WebGLRendererParameters,\n  SRGBColorSpace,\n  MathUtils,\n  Vector2,\n  Vector3,\n  MeshPhysicalMaterial,\n  ShaderChunk,\n  Color,\n  Object3D,\n  InstancedMesh,\n  PMREMGenerator,\n  SphereGeometry,\n  AmbientLight,\n  PointLight,\n  ACESFilmicToneMapping,\n  Raycaster,\n  Plane\n} from 'three';\nimport { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js';\nimport { Observer } from 'gsap/Observer';\nimport { gsap } from 'gsap';\n\ngsap.registerPlugin(Observer);\n\ninterface XConfig {\n  canvas?: HTMLCanvasElement;\n  id?: string;\n  rendererOptions?: Partial<WebGLRendererParameters>;\n  size?: 'parent' | { width: number; height: number };\n}\n\ninterface SizeData {\n  width: number;\n  height: number;\n  wWidth: number;\n  wHeight: number;\n  ratio: number;\n  pixelRatio: number;\n}\n\nclass X {\n  #config: XConfig;\n  #postprocessing: any;\n  #resizeObserver?: ResizeObserver;\n  #intersectionObserver?: IntersectionObserver;\n  #resizeTimer?: number;\n  #animationFrameId: number = 0;\n  #clock: Clock = new Clock();\n  #animationState = { elapsed: 0, delta: 0 };\n  #isAnimating: boolean = false;\n  #isVisible: boolean = false;\n\n  canvas!: HTMLCanvasElement;\n  camera!: PerspectiveCamera;\n  cameraMinAspect?: number;\n  cameraMaxAspect?: number;\n  cameraFov!: number;\n  maxPixelRatio?: number;\n  minPixelRatio?: number;\n  scene!: Scene;\n  renderer!: WebGLRenderer;\n  size: SizeData = {\n    width: 0,\n    height: 0,\n    wWidth: 0,\n    wHeight: 0,\n    ratio: 0,\n    pixelRatio: 0\n  };\n\n  render: () => void = this.#render.bind(this);\n  onBeforeRender: (state: { elapsed: number; delta: number }) => void = () => {};\n  onAfterRender: (state: { elapsed: number; delta: number }) => void = () => {};\n  onAfterResize: (size: SizeData) => void = () => {};\n  isDisposed: boolean = false;\n\n  constructor(config: XConfig) {\n    this.#config = { ...config };\n    this.#initCamera();\n    this.#initScene();\n    this.#initRenderer();\n    this.resize();\n    this.#initObservers();\n  }\n\n  #initCamera() {\n    this.camera = new PerspectiveCamera();\n    this.cameraFov = this.camera.fov;\n  }\n\n  #initScene() {\n    this.scene = new Scene();\n  }\n\n  #initRenderer() {\n    if (this.#config.canvas) {\n      this.canvas = this.#config.canvas;\n    } else if (this.#config.id) {\n      const elem = document.getElementById(this.#config.id);\n      if (elem instanceof HTMLCanvasElement) {\n        this.canvas = elem;\n      } else {\n        console.error('Three: Missing canvas or id parameter');\n      }\n    } else {\n      console.error('Three: Missing canvas or id parameter');\n    }\n    this.canvas!.style.display = 'block';\n    const rendererOptions: WebGLRendererParameters = {\n      canvas: this.canvas,\n      powerPreference: 'high-performance',\n      ...(this.#config.rendererOptions ?? {})\n    };\n    this.renderer = new WebGLRenderer(rendererOptions);\n    this.renderer.outputColorSpace = SRGBColorSpace;\n  }\n\n  #initObservers() {\n    if (!(this.#config.size instanceof Object)) {\n      window.addEventListener('resize', this.#onResize.bind(this));\n      if (this.#config.size === 'parent' && this.canvas.parentNode) {\n        this.#resizeObserver = new ResizeObserver(this.#onResize.bind(this));\n        this.#resizeObserver.observe(this.canvas.parentNode as Element);\n      }\n    }\n    this.#intersectionObserver = new IntersectionObserver(this.#onIntersection.bind(this), {\n      root: null,\n      rootMargin: '0px',\n      threshold: 0\n    });\n    this.#intersectionObserver.observe(this.canvas);\n    document.addEventListener('visibilitychange', this.#onVisibilityChange.bind(this));\n  }\n\n  #onResize() {\n    if (this.#resizeTimer) clearTimeout(this.#resizeTimer);\n    this.#resizeTimer = window.setTimeout(this.resize.bind(this), 100);\n  }\n\n  resize() {\n    let w: number, h: number;\n    if (this.#config.size instanceof Object) {\n      w = this.#config.size.width;\n      h = this.#config.size.height;\n    } else if (this.#config.size === 'parent' && this.canvas.parentNode) {\n      w = (this.canvas.parentNode as HTMLElement).offsetWidth;\n      h = (this.canvas.parentNode as HTMLElement).offsetHeight;\n    } else {\n      w = window.innerWidth;\n      h = window.innerHeight;\n    }\n    this.size.width = w;\n    this.size.height = h;\n    this.size.ratio = w / h;\n    this.#updateCamera();\n    this.#updateRenderer();\n    this.onAfterResize(this.size);\n  }\n\n  #updateCamera() {\n    this.camera.aspect = this.size.width / this.size.height;\n    if (this.camera.isPerspectiveCamera && this.cameraFov) {\n      if (this.cameraMinAspect && this.camera.aspect < this.cameraMinAspect) {\n        this.#adjustFov(this.cameraMinAspect);\n      } else if (this.cameraMaxAspect && this.camera.aspect > this.cameraMaxAspect) {\n        this.#adjustFov(this.cameraMaxAspect);\n      } else {\n        this.camera.fov = this.cameraFov;\n      }\n    }\n    this.camera.updateProjectionMatrix();\n    this.updateWorldSize();\n  }\n\n  #adjustFov(aspect: number) {\n    const tanFov = Math.tan(MathUtils.degToRad(this.cameraFov / 2));\n    const newTan = tanFov / (this.camera.aspect / aspect);\n    this.camera.fov = 2 * MathUtils.radToDeg(Math.atan(newTan));\n  }\n\n  updateWorldSize() {\n    if (this.camera.isPerspectiveCamera) {\n      const fovRad = (this.camera.fov * Math.PI) / 180;\n      this.size.wHeight = 2 * Math.tan(fovRad / 2) * this.camera.position.length();\n      this.size.wWidth = this.size.wHeight * this.camera.aspect;\n    } else if ((this.camera as any).isOrthographicCamera) {\n      const cam = this.camera as any;\n      this.size.wHeight = cam.top - cam.bottom;\n      this.size.wWidth = cam.right - cam.left;\n    }\n  }\n\n  #updateRenderer() {\n    this.renderer.setSize(this.size.width, this.size.height);\n    this.#postprocessing?.setSize(this.size.width, this.size.height);\n    let pr = window.devicePixelRatio;\n    if (this.maxPixelRatio && pr > this.maxPixelRatio) {\n      pr = this.maxPixelRatio;\n    } else if (this.minPixelRatio && pr < this.minPixelRatio) {\n      pr = this.minPixelRatio;\n    }\n    this.renderer.setPixelRatio(pr);\n    this.size.pixelRatio = pr;\n  }\n\n  get postprocessing() {\n    return this.#postprocessing;\n  }\n  set postprocessing(value: any) {\n    this.#postprocessing = value;\n    this.render = value.render.bind(value);\n  }\n\n  #onIntersection(entries: IntersectionObserverEntry[]) {\n    this.#isAnimating = entries[0].isIntersecting;\n    this.#isAnimating ? this.#startAnimation() : this.#stopAnimation();\n  }\n\n  #onVisibilityChange() {\n    if (this.#isAnimating) {\n      document.hidden ? this.#stopAnimation() : this.#startAnimation();\n    }\n  }\n\n  #startAnimation() {\n    if (this.#isVisible) return;\n    const animateFrame = () => {\n      this.#animationFrameId = requestAnimationFrame(animateFrame);\n      this.#animationState.delta = this.#clock.getDelta();\n      this.#animationState.elapsed += this.#animationState.delta;\n      this.onBeforeRender(this.#animationState);\n      this.render();\n      this.onAfterRender(this.#animationState);\n    };\n    this.#isVisible = true;\n    this.#clock.start();\n    animateFrame();\n  }\n\n  #stopAnimation() {\n    if (this.#isVisible) {\n      cancelAnimationFrame(this.#animationFrameId);\n      this.#isVisible = false;\n      this.#clock.stop();\n    }\n  }\n\n  #render() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  clear() {\n    this.scene.traverse(obj => {\n      if ((obj as any).isMesh && typeof (obj as any).material === 'object' && (obj as any).material !== null) {\n        Object.keys((obj as any).material).forEach(key => {\n          const matProp = (obj as any).material[key];\n          if (matProp && typeof matProp === 'object' && typeof matProp.dispose === 'function') {\n            matProp.dispose();\n          }\n        });\n        (obj as any).material.dispose();\n        (obj as any).geometry.dispose();\n      }\n    });\n    this.scene.clear();\n  }\n\n  dispose() {\n    this.#onResizeCleanup();\n    this.#stopAnimation();\n    this.clear();\n    this.#postprocessing?.dispose();\n    this.renderer.dispose();\n    this.isDisposed = true;\n  }\n\n  #onResizeCleanup() {\n    window.removeEventListener('resize', this.#onResize.bind(this));\n    this.#resizeObserver?.disconnect();\n    this.#intersectionObserver?.disconnect();\n    document.removeEventListener('visibilitychange', this.#onVisibilityChange.bind(this));\n  }\n}\n\ninterface WConfig {\n  count: number;\n  maxX: number;\n  maxY: number;\n  maxZ: number;\n  maxSize: number;\n  minSize: number;\n  size0: number;\n  gravity: number;\n  friction: number;\n  wallBounce: number;\n  maxVelocity: number;\n  controlSphere0?: boolean;\n  followCursor?: boolean;\n}\n\nclass W {\n  config: WConfig;\n  positionData: Float32Array;\n  velocityData: Float32Array;\n  sizeData: Float32Array;\n  center: Vector3 = new Vector3();\n\n  constructor(config: WConfig) {\n    this.config = config;\n    this.positionData = new Float32Array(3 * config.count).fill(0);\n    this.velocityData = new Float32Array(3 * config.count).fill(0);\n    this.sizeData = new Float32Array(config.count).fill(1);\n    this.center = new Vector3();\n    this.#initializePositions();\n    this.setSizes();\n  }\n\n  #initializePositions() {\n    const { config, positionData } = this;\n    this.center.toArray(positionData, 0);\n    for (let i = 1; i < config.count; i++) {\n      const idx = 3 * i;\n      positionData[idx] = MathUtils.randFloatSpread(2 * config.maxX);\n      positionData[idx + 1] = MathUtils.randFloatSpread(2 * config.maxY);\n      positionData[idx + 2] = MathUtils.randFloatSpread(2 * config.maxZ);\n    }\n  }\n\n  setSizes() {\n    const { config, sizeData } = this;\n    sizeData[0] = config.size0;\n    for (let i = 1; i < config.count; i++) {\n      sizeData[i] = MathUtils.randFloat(config.minSize, config.maxSize);\n    }\n  }\n\n  update(deltaInfo: { delta: number }) {\n    const { config, center, positionData, sizeData, velocityData } = this;\n    let startIdx = 0;\n    if (config.controlSphere0) {\n      startIdx = 1;\n      const firstVec = new Vector3().fromArray(positionData, 0);\n      firstVec.lerp(center, 0.1).toArray(positionData, 0);\n      new Vector3(0, 0, 0).toArray(velocityData, 0);\n    }\n    for (let idx = startIdx; idx < config.count; idx++) {\n      const base = 3 * idx;\n      const pos = new Vector3().fromArray(positionData, base);\n      const vel = new Vector3().fromArray(velocityData, base);\n      vel.y -= deltaInfo.delta * config.gravity * sizeData[idx];\n      vel.multiplyScalar(config.friction);\n      vel.clampLength(0, config.maxVelocity);\n      pos.add(vel);\n      pos.toArray(positionData, base);\n      vel.toArray(velocityData, base);\n    }\n    for (let idx = startIdx; idx < config.count; idx++) {\n      const base = 3 * idx;\n      const pos = new Vector3().fromArray(positionData, base);\n      const vel = new Vector3().fromArray(velocityData, base);\n      const radius = sizeData[idx];\n      for (let jdx = idx + 1; jdx < config.count; jdx++) {\n        const otherBase = 3 * jdx;\n        const otherPos = new Vector3().fromArray(positionData, otherBase);\n        const otherVel = new Vector3().fromArray(velocityData, otherBase);\n        const diff = new Vector3().copy(otherPos).sub(pos);\n        const dist = diff.length();\n        const sumRadius = radius + sizeData[jdx];\n        if (dist < sumRadius) {\n          const overlap = sumRadius - dist;\n          const correction = diff.normalize().multiplyScalar(0.5 * overlap);\n          const velCorrection = correction.clone().multiplyScalar(Math.max(vel.length(), 1));\n          pos.sub(correction);\n          vel.sub(velCorrection);\n          pos.toArray(positionData, base);\n          vel.toArray(velocityData, base);\n          otherPos.add(correction);\n          otherVel.add(correction.clone().multiplyScalar(Math.max(otherVel.length(), 1)));\n          otherPos.toArray(positionData, otherBase);\n          otherVel.toArray(velocityData, otherBase);\n        }\n      }\n      if (config.controlSphere0) {\n        const diff = new Vector3().copy(new Vector3().fromArray(positionData, 0)).sub(pos);\n        const d = diff.length();\n        const sumRadius0 = radius + sizeData[0];\n        if (d < sumRadius0) {\n          const correction = diff.normalize().multiplyScalar(sumRadius0 - d);\n          const velCorrection = correction.clone().multiplyScalar(Math.max(vel.length(), 2));\n          pos.sub(correction);\n          vel.sub(velCorrection);\n        }\n      }\n      if (Math.abs(pos.x) + radius > config.maxX) {\n        pos.x = Math.sign(pos.x) * (config.maxX - radius);\n        vel.x = -vel.x * config.wallBounce;\n      }\n      if (config.gravity === 0) {\n        if (Math.abs(pos.y) + radius > config.maxY) {\n          pos.y = Math.sign(pos.y) * (config.maxY - radius);\n          vel.y = -vel.y * config.wallBounce;\n        }\n      } else if (pos.y - radius < -config.maxY) {\n        pos.y = -config.maxY + radius;\n        vel.y = -vel.y * config.wallBounce;\n      }\n      const maxBoundary = Math.max(config.maxZ, config.maxSize);\n      if (Math.abs(pos.z) + radius > maxBoundary) {\n        pos.z = Math.sign(pos.z) * (config.maxZ - radius);\n        vel.z = -vel.z * config.wallBounce;\n      }\n      pos.toArray(positionData, base);\n      vel.toArray(velocityData, base);\n    }\n  }\n}\n\nclass Y extends MeshPhysicalMaterial {\n  uniforms: { [key: string]: { value: any } } = {\n    thicknessDistortion: { value: 0.1 },\n    thicknessAmbient: { value: 0 },\n    thicknessAttenuation: { value: 0.1 },\n    thicknessPower: { value: 2 },\n    thicknessScale: { value: 10 }\n  };\n\n  constructor(params: any) {\n    super(params);\n    this.defines = { USE_UV: '' };\n    this.onBeforeCompile = shader => {\n      Object.assign(shader.uniforms, this.uniforms);\n      shader.fragmentShader =\n        `\n        uniform float thicknessPower;\n        uniform float thicknessScale;\n        uniform float thicknessDistortion;\n        uniform float thicknessAmbient;\n        uniform float thicknessAttenuation;\n        ` + shader.fragmentShader;\n      shader.fragmentShader = shader.fragmentShader.replace(\n        'void main() {',\n        `\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {\n          vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));\n          float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n          #ifdef USE_COLOR\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * vColor;\n          #else\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * diffuse;\n          #endif\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n        }\n\n        void main() {\n        `\n      );\n      const lightsChunk = ShaderChunk.lights_fragment_begin.replaceAll(\n        'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',\n        `\n          RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n          RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);\n        `\n      );\n      shader.fragmentShader = shader.fragmentShader.replace('#include <lights_fragment_begin>', lightsChunk);\n      if (this.onBeforeCompile2) this.onBeforeCompile2(shader);\n    };\n  }\n  onBeforeCompile2?: (shader: any) => void;\n}\n\nconst XConfig = {\n  count: 200,\n  colors: [0, 0, 0],\n  ambientColor: 0xffffff,\n  ambientIntensity: 1,\n  lightIntensity: 200,\n  materialParams: {\n    metalness: 0.5,\n    roughness: 0.5,\n    clearcoat: 1,\n    clearcoatRoughness: 0.15\n  },\n  minSize: 0.5,\n  maxSize: 1,\n  size0: 1,\n  gravity: 0.5,\n  friction: 0.9975,\n  wallBounce: 0.95,\n  maxVelocity: 0.15,\n  maxX: 5,\n  maxY: 5,\n  maxZ: 2,\n  controlSphere0: false,\n  followCursor: true\n};\n\nconst U = new Object3D();\n\nlet globalPointerActive = false;\nconst pointerPosition = new Vector2();\n\ninterface PointerData {\n  position: Vector2;\n  nPosition: Vector2;\n  hover: boolean;\n  touching: boolean;\n  onEnter: (data: PointerData) => void;\n  onMove: (data: PointerData) => void;\n  onClick: (data: PointerData) => void;\n  onLeave: (data: PointerData) => void;\n  dispose?: () => void;\n}\n\nconst pointerMap = new Map<HTMLElement, PointerData>();\n\nfunction createPointerData(options: Partial<PointerData> & { domElement: HTMLElement }): PointerData {\n  const defaultData: PointerData = {\n    position: new Vector2(),\n    nPosition: new Vector2(),\n    hover: false,\n    touching: false,\n    onEnter: () => {},\n    onMove: () => {},\n    onClick: () => {},\n    onLeave: () => {},\n    ...options\n  };\n  if (!pointerMap.has(options.domElement)) {\n    pointerMap.set(options.domElement, defaultData);\n    if (!globalPointerActive) {\n      document.body.addEventListener('pointermove', onPointerMove as EventListener);\n      document.body.addEventListener('pointerleave', onPointerLeave as EventListener);\n      document.body.addEventListener('click', onPointerClick as EventListener);\n\n      document.body.addEventListener('touchstart', onTouchStart as EventListener, {\n        passive: false\n      });\n      document.body.addEventListener('touchmove', onTouchMove as EventListener, {\n        passive: false\n      });\n      document.body.addEventListener('touchend', onTouchEnd as EventListener, {\n        passive: false\n      });\n      document.body.addEventListener('touchcancel', onTouchEnd as EventListener, {\n        passive: false\n      });\n      globalPointerActive = true;\n    }\n  }\n  defaultData.dispose = () => {\n    pointerMap.delete(options.domElement);\n    if (pointerMap.size === 0) {\n      document.body.removeEventListener('pointermove', onPointerMove as EventListener);\n      document.body.removeEventListener('pointerleave', onPointerLeave as EventListener);\n      document.body.removeEventListener('click', onPointerClick as EventListener);\n\n      document.body.removeEventListener('touchstart', onTouchStart as EventListener);\n      document.body.removeEventListener('touchmove', onTouchMove as EventListener);\n      document.body.removeEventListener('touchend', onTouchEnd as EventListener);\n      document.body.removeEventListener('touchcancel', onTouchEnd as EventListener);\n      globalPointerActive = false;\n    }\n  };\n  return defaultData;\n}\n\nfunction onPointerMove(e: PointerEvent) {\n  pointerPosition.set(e.clientX, e.clientY);\n  processPointerInteraction();\n}\n\nfunction processPointerInteraction() {\n  for (const [elem, data] of pointerMap) {\n    const rect = elem.getBoundingClientRect();\n    if (isInside(rect)) {\n      updatePointerData(data, rect);\n      if (!data.hover) {\n        data.hover = true;\n        data.onEnter(data);\n      }\n      data.onMove(data);\n    } else if (data.hover && !data.touching) {\n      data.hover = false;\n      data.onLeave(data);\n    }\n  }\n}\n\nfunction onTouchStart(e: TouchEvent) {\n  if (e.touches.length > 0) {\n    e.preventDefault();\n    pointerPosition.set(e.touches[0].clientX, e.touches[0].clientY);\n    for (const [elem, data] of pointerMap) {\n      const rect = elem.getBoundingClientRect();\n      if (isInside(rect)) {\n        data.touching = true;\n        updatePointerData(data, rect);\n        if (!data.hover) {\n          data.hover = true;\n          data.onEnter(data);\n        }\n        data.onMove(data);\n      }\n    }\n  }\n}\n\nfunction onTouchMove(e: TouchEvent) {\n  if (e.touches.length > 0) {\n    e.preventDefault();\n    pointerPosition.set(e.touches[0].clientX, e.touches[0].clientY);\n    for (const [elem, data] of pointerMap) {\n      const rect = elem.getBoundingClientRect();\n      updatePointerData(data, rect);\n      if (isInside(rect)) {\n        if (!data.hover) {\n          data.hover = true;\n          data.touching = true;\n          data.onEnter(data);\n        }\n        data.onMove(data);\n      } else if (data.hover && data.touching) {\n        data.onMove(data);\n      }\n    }\n  }\n}\n\nfunction onTouchEnd() {\n  for (const [, data] of pointerMap) {\n    if (data.touching) {\n      data.touching = false;\n      if (data.hover) {\n        data.hover = false;\n        data.onLeave(data);\n      }\n    }\n  }\n}\n\nfunction onPointerClick(e: PointerEvent) {\n  pointerPosition.set(e.clientX, e.clientY);\n  for (const [elem, data] of pointerMap) {\n    const rect = elem.getBoundingClientRect();\n    updatePointerData(data, rect);\n    if (isInside(rect)) data.onClick(data);\n  }\n}\n\nfunction onPointerLeave() {\n  for (const data of pointerMap.values()) {\n    if (data.hover) {\n      data.hover = false;\n      data.onLeave(data);\n    }\n  }\n}\n\nfunction updatePointerData(data: PointerData, rect: DOMRect) {\n  data.position.set(pointerPosition.x - rect.left, pointerPosition.y - rect.top);\n  data.nPosition.set((data.position.x / rect.width) * 2 - 1, (-data.position.y / rect.height) * 2 + 1);\n}\n\nfunction isInside(rect: DOMRect) {\n  return (\n    pointerPosition.x >= rect.left &&\n    pointerPosition.x <= rect.left + rect.width &&\n    pointerPosition.y >= rect.top &&\n    pointerPosition.y <= rect.top + rect.height\n  );\n}\n\nclass Z extends InstancedMesh {\n  config: typeof XConfig;\n  physics: W;\n  ambientLight: AmbientLight | undefined;\n  light: PointLight | undefined;\n\n  constructor(renderer: WebGLRenderer, params: Partial<typeof XConfig> = {}) {\n    const config = { ...XConfig, ...params };\n    const roomEnv = new RoomEnvironment();\n    const pmrem = new PMREMGenerator(renderer);\n    const envTexture = pmrem.fromScene(roomEnv).texture;\n    const geometry = new SphereGeometry();\n    const material = new Y({ envMap: envTexture, ...config.materialParams });\n    material.envMapRotation.x = -Math.PI / 2;\n    super(geometry, material, config.count);\n    this.config = config;\n    this.physics = new W(config);\n    this.#setupLights();\n    this.setColors(config.colors);\n  }\n\n  #setupLights() {\n    this.ambientLight = new AmbientLight(this.config.ambientColor, this.config.ambientIntensity);\n    this.add(this.ambientLight);\n    this.light = new PointLight(this.config.colors[0], this.config.lightIntensity);\n    this.add(this.light);\n  }\n\n  setColors(colors: number[]) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const colorUtils = (function (colorsArr: number[]) {\n        let baseColors: number[] = colorsArr;\n        let colorObjects: Color[] = [];\n        baseColors.forEach(col => {\n          colorObjects.push(new Color(col));\n        });\n        return {\n          setColors: (cols: number[]) => {\n            baseColors = cols;\n            colorObjects = [];\n            baseColors.forEach(col => {\n              colorObjects.push(new Color(col));\n            });\n          },\n          getColorAt: (ratio: number, out: Color = new Color()) => {\n            const clamped = Math.max(0, Math.min(1, ratio));\n            const scaled = clamped * (baseColors.length - 1);\n            const idx = Math.floor(scaled);\n            const start = colorObjects[idx];\n            if (idx >= baseColors.length - 1) return start.clone();\n            const alpha = scaled - idx;\n            const end = colorObjects[idx + 1];\n            out.r = start.r + alpha * (end.r - start.r);\n            out.g = start.g + alpha * (end.g - start.g);\n            out.b = start.b + alpha * (end.b - start.b);\n            return out;\n          }\n        };\n      })(colors);\n      for (let idx = 0; idx < this.count; idx++) {\n        this.setColorAt(idx, colorUtils.getColorAt(idx / this.count));\n        if (idx === 0) {\n          this.light!.color.copy(colorUtils.getColorAt(idx / this.count));\n        }\n      }\n\n      if (!this.instanceColor) return;\n      this.instanceColor.needsUpdate = true;\n    }\n  }\n\n  update(deltaInfo: { delta: number }) {\n    this.physics.update(deltaInfo);\n    for (let idx = 0; idx < this.count; idx++) {\n      U.position.fromArray(this.physics.positionData, 3 * idx);\n      if (idx === 0 && this.config.followCursor === false) {\n        U.scale.setScalar(0);\n      } else {\n        U.scale.setScalar(this.physics.sizeData[idx]);\n      }\n      U.updateMatrix();\n      this.setMatrixAt(idx, U.matrix);\n      if (idx === 0) this.light!.position.copy(U.position);\n    }\n    this.instanceMatrix.needsUpdate = true;\n  }\n}\n\ninterface CreateBallpitReturn {\n  three: X;\n  spheres: Z;\n  setCount: (count: number) => void;\n  togglePause: () => void;\n  dispose: () => void;\n}\n\nfunction createBallpit(canvas: HTMLCanvasElement, config: any = {}): CreateBallpitReturn {\n  const threeInstance = new X({\n    canvas,\n    size: 'parent',\n    rendererOptions: { antialias: true, alpha: true }\n  });\n  let spheres: Z;\n  threeInstance.renderer.toneMapping = ACESFilmicToneMapping;\n  threeInstance.camera.position.set(0, 0, 20);\n  threeInstance.camera.lookAt(0, 0, 0);\n  threeInstance.cameraMaxAspect = 1.5;\n  threeInstance.resize();\n  initialize(config);\n  const raycaster = new Raycaster();\n  const plane = new Plane(new Vector3(0, 0, 1), 0);\n  const intersectionPoint = new Vector3();\n  let isPaused = false;\n\n  canvas.style.touchAction = 'none';\n  canvas.style.userSelect = 'none';\n  (canvas.style as any).webkitUserSelect = 'none';\n\n  const pointerData = createPointerData({\n    domElement: canvas,\n    onMove() {\n      raycaster.setFromCamera(pointerData.nPosition, threeInstance.camera);\n      threeInstance.camera.getWorldDirection(plane.normal);\n      raycaster.ray.intersectPlane(plane, intersectionPoint);\n      spheres.physics.center.copy(intersectionPoint);\n      spheres.config.controlSphere0 = true;\n    },\n    onLeave() {\n      spheres.config.controlSphere0 = false;\n    }\n  });\n  function initialize(cfg: any) {\n    if (spheres) {\n      threeInstance.clear();\n      threeInstance.scene.remove(spheres);\n    }\n    spheres = new Z(threeInstance.renderer, cfg);\n    threeInstance.scene.add(spheres);\n  }\n  threeInstance.onBeforeRender = deltaInfo => {\n    if (!isPaused) spheres.update(deltaInfo);\n  };\n  threeInstance.onAfterResize = size => {\n    spheres.config.maxX = size.wWidth / 2;\n    spheres.config.maxY = size.wHeight / 2;\n  };\n  return {\n    three: threeInstance,\n    get spheres() {\n      return spheres;\n    },\n    setCount(count: number) {\n      initialize({ ...spheres.config, count });\n    },\n    togglePause() {\n      isPaused = !isPaused;\n    },\n    dispose() {\n      pointerData.dispose?.();\n      threeInstance.dispose();\n    }\n  };\n}\n\ninterface BallpitProps {\n  className?: string;\n  followCursor?: boolean;\n  [key: string]: any;\n}\n\nconst Ballpit: React.FC<BallpitProps> = ({ className = '', followCursor = true, ...props }) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const spheresInstanceRef = useRef<CreateBallpitReturn | null>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    spheresInstanceRef.current = createBallpit(canvas, {\n      followCursor,\n      ...props\n    });\n\n    return () => {\n      if (spheresInstanceRef.current) {\n        spheresInstanceRef.current.dispose();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return <canvas className={`${className} w-full h-full`} ref={canvasRef} />;\n};\n\nexport default Ballpit;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "beams",
      "type": "component",
      "description": "Animated volumetric light beams background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three",
        "@react-three/fiber",
        "@react-three/drei"
      ],
      "files": [
        {
          "path": "components/ui/beams.tsx",
          "content": "import { forwardRef, useImperativeHandle, useEffect, useRef, useMemo, FC, ReactNode } from 'react';\n\nimport * as THREE from 'three';\n\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport { PerspectiveCamera } from '@react-three/drei';\nimport { degToRad } from 'three/src/math/MathUtils.js';\n\ntype UniformValue = THREE.IUniform<unknown> | unknown;\n\ninterface ExtendMaterialConfig {\n  header: string;\n  vertexHeader?: string;\n  fragmentHeader?: string;\n  material?: THREE.MeshPhysicalMaterialParameters & { fog?: boolean };\n  uniforms?: Record<string, UniformValue>;\n  vertex?: Record<string, string>;\n  fragment?: Record<string, string>;\n}\n\ntype ShaderWithDefines = THREE.ShaderLibShader & {\n  defines?: Record<string, string | number | boolean>;\n};\n\nfunction extendMaterial<T extends THREE.Material = THREE.Material>(\n  BaseMaterial: new (params?: THREE.MaterialParameters) => T,\n  cfg: ExtendMaterialConfig\n): THREE.ShaderMaterial {\n  const physical = THREE.ShaderLib.physical as ShaderWithDefines;\n  const { vertexShader: baseVert, fragmentShader: baseFrag, uniforms: baseUniforms } = physical;\n  const baseDefines = physical.defines ?? {};\n\n  const uniforms: Record<string, THREE.IUniform> = THREE.UniformsUtils.clone(baseUniforms);\n\n  const defaults = new BaseMaterial(cfg.material || {}) as T & {\n    color?: THREE.Color;\n    roughness?: number;\n    metalness?: number;\n    envMap?: THREE.Texture;\n    envMapIntensity?: number;\n  };\n\n  if (defaults.color) uniforms.diffuse.value = defaults.color;\n  if ('roughness' in defaults) uniforms.roughness.value = defaults.roughness;\n  if ('metalness' in defaults) uniforms.metalness.value = defaults.metalness;\n  if ('envMap' in defaults) uniforms.envMap.value = defaults.envMap;\n  if ('envMapIntensity' in defaults) uniforms.envMapIntensity.value = defaults.envMapIntensity;\n\n  Object.entries(cfg.uniforms ?? {}).forEach(([key, u]) => {\n    uniforms[key] =\n      u !== null && typeof u === 'object' && 'value' in u\n        ? (u as THREE.IUniform<unknown>)\n        : ({ value: u } as THREE.IUniform<unknown>);\n  });\n\n  let vert = `${cfg.header}\\n${cfg.vertexHeader ?? ''}\\n${baseVert}`;\n  let frag = `${cfg.header}\\n${cfg.fragmentHeader ?? ''}\\n${baseFrag}`;\n\n  for (const [inc, code] of Object.entries(cfg.vertex ?? {})) {\n    vert = vert.replace(inc, `${inc}\\n${code}`);\n  }\n  for (const [inc, code] of Object.entries(cfg.fragment ?? {})) {\n    frag = frag.replace(inc, `${inc}\\n${code}`);\n  }\n\n  const mat = new THREE.ShaderMaterial({\n    defines: { ...baseDefines },\n    uniforms,\n    vertexShader: vert,\n    fragmentShader: frag,\n    lights: true,\n    fog: !!cfg.material?.fog\n  });\n\n  return mat;\n}\n\nconst CanvasWrapper: FC<{ children: ReactNode }> = ({ children }) => (\n  <Canvas dpr={[1, 2]} frameloop=\"always\" className=\"w-full h-full relative\">\n    {children}\n  </Canvas>\n);\n\nconst hexToNormalizedRGB = (hex: string): [number, number, number] => {\n  const clean = hex.replace('#', '');\n  const r = parseInt(clean.substring(0, 2), 16);\n  const g = parseInt(clean.substring(2, 4), 16);\n  const b = parseInt(clean.substring(4, 6), 16);\n  return [r / 255, g / 255, b / 255];\n};\n\nconst noise = `\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n           (c - a)* u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P);\n  vec3 Pi1 = Pi0 + vec3(1.0);\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);\n  vec3 Pf1 = Pf0 - vec3(1.0);\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));\n  g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));\n  g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x,Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x,Pf1.y,Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy,Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy,Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x,Pf0.y,Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x,Pf1.yz));\n  float n111 = dot(g111, Pf1);\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy,n_z.zw,fade_xyz.y);\n  float n_xyz = mix(n_yz.x,n_yz.y,fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n`;\n\ninterface BeamsProps {\n  beamWidth?: number;\n  beamHeight?: number;\n  beamNumber?: number;\n  lightColor?: string;\n  speed?: number;\n  noiseIntensity?: number;\n  scale?: number;\n  rotation?: number;\n}\n\nconst Beams: FC<BeamsProps> = ({\n  beamWidth = 2,\n  beamHeight = 15,\n  beamNumber = 12,\n  lightColor = '#ffffff',\n  speed = 2,\n  noiseIntensity = 1.75,\n  scale = 0.2,\n  rotation = 0\n}) => {\n  const meshRef = useRef<THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>>(null!);\n\n  const beamMaterial = useMemo(\n    () =>\n      extendMaterial(THREE.MeshStandardMaterial, {\n        header: `\n  varying vec3 vEye;\n  varying float vNoise;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  uniform float time;\n  uniform float uSpeed;\n  uniform float uNoiseIntensity;\n  uniform float uScale;\n  ${noise}`,\n        vertexHeader: `\n  float getPos(vec3 pos) {\n    vec3 noisePos =\n      vec3(pos.x * 0., pos.y - uv.y, pos.z + time * uSpeed * 3.) * uScale;\n    return cnoise(noisePos);\n  }\n  vec3 getCurrentPos(vec3 pos) {\n    vec3 newpos = pos;\n    newpos.z += getPos(pos);\n    return newpos;\n  }\n  vec3 getNormal(vec3 pos) {\n    vec3 curpos = getCurrentPos(pos);\n    vec3 nextposX = getCurrentPos(pos + vec3(0.01, 0.0, 0.0));\n    vec3 nextposZ = getCurrentPos(pos + vec3(0.0, -0.01, 0.0));\n    vec3 tangentX = normalize(nextposX - curpos);\n    vec3 tangentZ = normalize(nextposZ - curpos);\n    return normalize(cross(tangentZ, tangentX));\n  }`,\n        fragmentHeader: '',\n        vertex: {\n          '#include <begin_vertex>': `transformed.z += getPos(transformed.xyz);`,\n          '#include <beginnormal_vertex>': `objectNormal = getNormal(position.xyz);`\n        },\n        fragment: {\n          '#include <dithering_fragment>': `\n    float randomNoise = noise(gl_FragCoord.xy);\n    gl_FragColor.rgb -= randomNoise / 15. * uNoiseIntensity;`\n        },\n        material: { fog: true },\n        uniforms: {\n          diffuse: new THREE.Color(...hexToNormalizedRGB('#000000')),\n          time: { shared: true, mixed: true, linked: true, value: 0 },\n          roughness: 0.3,\n          metalness: 0.3,\n          uSpeed: { shared: true, mixed: true, linked: true, value: speed },\n          envMapIntensity: 10,\n          uNoiseIntensity: noiseIntensity,\n          uScale: scale\n        }\n      }),\n    [speed, noiseIntensity, scale]\n  );\n\n  return (\n    <CanvasWrapper>\n      <group rotation={[0, 0, degToRad(rotation)]}>\n        <PlaneNoise ref={meshRef} material={beamMaterial} count={beamNumber} width={beamWidth} height={beamHeight} />\n        <DirLight color={lightColor} position={[0, 3, 10]} />\n      </group>\n      <ambientLight intensity={1} />\n      <color attach=\"background\" args={['#000000']} />\n      <PerspectiveCamera makeDefault position={[0, 0, 20]} fov={30} />\n    </CanvasWrapper>\n  );\n};\n\nfunction createStackedPlanesBufferGeometry(\n  n: number,\n  width: number,\n  height: number,\n  spacing: number,\n  heightSegments: number\n): THREE.BufferGeometry {\n  const geometry = new THREE.BufferGeometry();\n  const numVertices = n * (heightSegments + 1) * 2;\n  const numFaces = n * heightSegments * 2;\n  const positions = new Float32Array(numVertices * 3);\n  const indices = new Uint32Array(numFaces * 3);\n  const uvs = new Float32Array(numVertices * 2);\n\n  let vertexOffset = 0;\n  let indexOffset = 0;\n  let uvOffset = 0;\n  const totalWidth = n * width + (n - 1) * spacing;\n  const xOffsetBase = -totalWidth / 2;\n\n  for (let i = 0; i < n; i++) {\n    const xOffset = xOffsetBase + i * (width + spacing);\n    const uvXOffset = Math.random() * 300;\n    const uvYOffset = Math.random() * 300;\n\n    for (let j = 0; j <= heightSegments; j++) {\n      const y = height * (j / heightSegments - 0.5);\n      const v0 = [xOffset, y, 0];\n      const v1 = [xOffset + width, y, 0];\n      positions.set([...v0, ...v1], vertexOffset * 3);\n\n      const uvY = j / heightSegments;\n      uvs.set([uvXOffset, uvY + uvYOffset, uvXOffset + 1, uvY + uvYOffset], uvOffset);\n\n      if (j < heightSegments) {\n        const a = vertexOffset,\n          b = vertexOffset + 1,\n          c = vertexOffset + 2,\n          d = vertexOffset + 3;\n        indices.set([a, b, c, c, b, d], indexOffset);\n        indexOffset += 6;\n      }\n      vertexOffset += 2;\n      uvOffset += 4;\n    }\n  }\n\n  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n  geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n  geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n  geometry.computeVertexNormals();\n  return geometry;\n}\n\nconst MergedPlanes = forwardRef<\n  THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>,\n  {\n    material: THREE.ShaderMaterial;\n    width: number;\n    count: number;\n    height: number;\n  }\n>(({ material, width, count, height }, ref) => {\n  const mesh = useRef<THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>>(null!);\n  useImperativeHandle(ref, () => mesh.current);\n  const geometry = useMemo(\n    () => createStackedPlanesBufferGeometry(count, width, height, 0, 100),\n    [count, width, height]\n  );\n  useFrame((_, delta) => {\n    mesh.current.material.uniforms.time.value += 0.1 * delta;\n  });\n  return <mesh ref={mesh} geometry={geometry} material={material} />;\n});\nMergedPlanes.displayName = 'MergedPlanes';\n\nconst PlaneNoise = forwardRef<\n  THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>,\n  {\n    material: THREE.ShaderMaterial;\n    width: number;\n    count: number;\n    height: number;\n  }\n>((props, ref) => (\n  <MergedPlanes ref={ref} material={props.material} width={props.width} count={props.count} height={props.height} />\n));\nPlaneNoise.displayName = 'PlaneNoise';\n\nconst DirLight: FC<{ position: [number, number, number]; color: string }> = ({ position, color }) => {\n  const dir = useRef<THREE.DirectionalLight>(null!);\n  useEffect(() => {\n    if (!dir.current) return;\n    const cam = dir.current.shadow.camera as THREE.Camera & {\n      top: number;\n      bottom: number;\n      left: number;\n      right: number;\n      far: number;\n    };\n    cam.top = 24;\n    cam.bottom = -24;\n    cam.left = -24;\n    cam.right = 24;\n    cam.far = 64;\n    dir.current.shadow.bias = -0.004;\n  }, []);\n  return <directionalLight ref={dir} color={color} intensity={1} position={position} />;\n};\n\nexport default Beams;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "color-bends",
      "type": "component",
      "description": "A colorful bending gradient background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/color-bends.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\n\ntype ColorBendsProps = {\n  className?: string;\n  style?: React.CSSProperties;\n  rotation?: number;\n  speed?: number;\n  colors?: string[];\n  transparent?: boolean;\n  autoRotate?: number;\n  scale?: number;\n  frequency?: number;\n  warpStrength?: number;\n  mouseInfluence?: number;\n  parallax?: number;\n  noise?: number;\n};\n\nconst MAX_COLORS = 8 as const;\n\nconst frag = `\n#define MAX_COLORS ${MAX_COLORS}\nuniform vec2 uCanvas;\nuniform float uTime;\nuniform float uSpeed;\nuniform vec2 uRot;\nuniform int uColorCount;\nuniform vec3 uColors[MAX_COLORS];\nuniform int uTransparent;\nuniform float uScale;\nuniform float uFrequency;\nuniform float uWarpStrength;\nuniform vec2 uPointer; // in NDC [-1,1]\nuniform float uMouseInfluence;\nuniform float uParallax;\nuniform float uNoise;\nvarying vec2 vUv;\n\nvoid main() {\n  float t = uTime * uSpeed;\n  vec2 p = vUv * 2.0 - 1.0;\n  p += uPointer * uParallax * 0.1;\n  vec2 rp = vec2(p.x * uRot.x - p.y * uRot.y, p.x * uRot.y + p.y * uRot.x);\n  vec2 q = vec2(rp.x * (uCanvas.x / uCanvas.y), rp.y);\n  q /= max(uScale, 0.0001);\n  q /= 0.5 + 0.2 * dot(q, q);\n  q += 0.2 * cos(t) - 7.56;\n  vec2 toward = (uPointer - rp);\n  q += toward * uMouseInfluence * 0.2;\n\n    vec3 col = vec3(0.0);\n    float a = 1.0;\n\n    if (uColorCount > 0) {\n      vec2 s = q;\n      vec3 sumCol = vec3(0.0);\n      float cover = 0.0;\n      for (int i = 0; i < MAX_COLORS; ++i) {\n            if (i >= uColorCount) break;\n            s -= 0.01;\n            vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));\n            float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(i)) / 4.0);\n            float kBelow = clamp(uWarpStrength, 0.0, 1.0);\n            float kMix = pow(kBelow, 0.3); // strong response across 0..1\n            float gain = 1.0 + max(uWarpStrength - 1.0, 0.0); // allow >1 to amplify displacement\n            vec2 disp = (r - s) * kBelow;\n            vec2 warped = s + disp * gain;\n            float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(i)) / 4.0);\n            float m = mix(m0, m1, kMix);\n            float w = 1.0 - exp(-6.0 / exp(6.0 * m));\n            sumCol += uColors[i] * w;\n            cover = max(cover, w);\n      }\n      col = clamp(sumCol, 0.0, 1.0);\n      a = uTransparent > 0 ? cover : 1.0;\n    } else {\n        vec2 s = q;\n        for (int k = 0; k < 3; ++k) {\n            s -= 0.01;\n            vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));\n            float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(k)) / 4.0);\n            float kBelow = clamp(uWarpStrength, 0.0, 1.0);\n            float kMix = pow(kBelow, 0.3);\n            float gain = 1.0 + max(uWarpStrength - 1.0, 0.0);\n            vec2 disp = (r - s) * kBelow;\n            vec2 warped = s + disp * gain;\n            float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(k)) / 4.0);\n            float m = mix(m0, m1, kMix);\n            col[k] = 1.0 - exp(-6.0 / exp(6.0 * m));\n        }\n        a = uTransparent > 0 ? max(max(col.r, col.g), col.b) : 1.0;\n    }\n\n    if (uNoise > 0.0001) {\n      float n = fract(sin(dot(gl_FragCoord.xy + vec2(uTime), vec2(12.9898, 78.233))) * 43758.5453123);\n      col += (n - 0.5) * uNoise;\n      col = clamp(col, 0.0, 1.0);\n    }\n\n    vec3 rgb = (uTransparent > 0) ? col * a : col;\n    gl_FragColor = vec4(rgb, a);\n}\n`;\n\nconst vert = `\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n`;\n\nexport default function ColorBends({\n  className,\n  style,\n  rotation = 45,\n  speed = 0.2,\n  colors = [],\n  transparent = true,\n  autoRotate = 0,\n  scale = 1,\n  frequency = 1,\n  warpStrength = 1,\n  mouseInfluence = 1,\n  parallax = 0.5,\n  noise = 0.1\n}: ColorBendsProps) {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const rafRef = useRef<number | null>(null);\n  const materialRef = useRef<THREE.ShaderMaterial | null>(null);\n  const resizeObserverRef = useRef<ResizeObserver | null>(null);\n  const rotationRef = useRef<number>(rotation);\n  const autoRotateRef = useRef<number>(autoRotate);\n  const pointerTargetRef = useRef<THREE.Vector2>(new THREE.Vector2(0, 0));\n  const pointerCurrentRef = useRef<THREE.Vector2>(new THREE.Vector2(0, 0));\n  const pointerSmoothRef = useRef<number>(8);\n\n  useEffect(() => {\n    const container = containerRef.current!;\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n    const geometry = new THREE.PlaneGeometry(2, 2);\n    const uColorsArray = Array.from({ length: MAX_COLORS }, () => new THREE.Vector3(0, 0, 0));\n    const material = new THREE.ShaderMaterial({\n      vertexShader: vert,\n      fragmentShader: frag,\n      uniforms: {\n        uCanvas: { value: new THREE.Vector2(1, 1) },\n        uTime: { value: 0 },\n        uSpeed: { value: speed },\n        uRot: { value: new THREE.Vector2(1, 0) },\n        uColorCount: { value: 0 },\n        uColors: { value: uColorsArray },\n        uTransparent: { value: transparent ? 1 : 0 },\n        uScale: { value: scale },\n        uFrequency: { value: frequency },\n        uWarpStrength: { value: warpStrength },\n        uPointer: { value: new THREE.Vector2(0, 0) },\n        uMouseInfluence: { value: mouseInfluence },\n        uParallax: { value: parallax },\n        uNoise: { value: noise }\n      },\n      premultipliedAlpha: true,\n      transparent: true\n    });\n    materialRef.current = material;\n\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    const renderer = new THREE.WebGLRenderer({\n      antialias: false,\n      powerPreference: 'high-performance',\n      alpha: true\n    });\n    rendererRef.current = renderer;\n    (renderer as any).outputColorSpace = (THREE as any).SRGBColorSpace;\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n    renderer.setClearColor(0x000000, transparent ? 0 : 1);\n    renderer.domElement.style.width = '100%';\n    renderer.domElement.style.height = '100%';\n    renderer.domElement.style.display = 'block';\n    container.appendChild(renderer.domElement);\n\n    const clock = new THREE.Clock();\n\n    const handleResize = () => {\n      const w = container.clientWidth || 1;\n      const h = container.clientHeight || 1;\n      renderer.setSize(w, h, false);\n      (material.uniforms.uCanvas.value as THREE.Vector2).set(w, h);\n    };\n\n    handleResize();\n\n    if ('ResizeObserver' in window) {\n      const ro = new ResizeObserver(handleResize);\n      ro.observe(container);\n      resizeObserverRef.current = ro;\n    } else {\n      (window as Window).addEventListener('resize', handleResize);\n    }\n\n    const loop = () => {\n      const dt = clock.getDelta();\n      const elapsed = clock.elapsedTime;\n      material.uniforms.uTime.value = elapsed;\n\n      const deg = (rotationRef.current % 360) + autoRotateRef.current * elapsed;\n      const rad = (deg * Math.PI) / 180;\n      const c = Math.cos(rad);\n      const s = Math.sin(rad);\n      (material.uniforms.uRot.value as THREE.Vector2).set(c, s);\n\n      const cur = pointerCurrentRef.current;\n      const tgt = pointerTargetRef.current;\n      const amt = Math.min(1, dt * pointerSmoothRef.current);\n      cur.lerp(tgt, amt);\n      (material.uniforms.uPointer.value as THREE.Vector2).copy(cur);\n      renderer.render(scene, camera);\n      rafRef.current = requestAnimationFrame(loop);\n    };\n    rafRef.current = requestAnimationFrame(loop);\n\n    return () => {\n      if (rafRef.current !== null) cancelAnimationFrame(rafRef.current);\n      if (resizeObserverRef.current) resizeObserverRef.current.disconnect();\n      else (window as Window).removeEventListener('resize', handleResize);\n      geometry.dispose();\n      material.dispose();\n      renderer.dispose();\n      if (renderer.domElement && renderer.domElement.parentElement === container) {\n        container.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    const material = materialRef.current;\n    const renderer = rendererRef.current;\n    if (!material) return;\n\n    rotationRef.current = rotation;\n    autoRotateRef.current = autoRotate;\n    material.uniforms.uSpeed.value = speed;\n    material.uniforms.uScale.value = scale;\n    material.uniforms.uFrequency.value = frequency;\n    material.uniforms.uWarpStrength.value = warpStrength;\n    material.uniforms.uMouseInfluence.value = mouseInfluence;\n    material.uniforms.uParallax.value = parallax;\n    material.uniforms.uNoise.value = noise;\n\n    const toVec3 = (hex: string) => {\n      const h = hex.replace('#', '').trim();\n      const v =\n        h.length === 3\n          ? [parseInt(h[0] + h[0], 16), parseInt(h[1] + h[1], 16), parseInt(h[2] + h[2], 16)]\n          : [parseInt(h.slice(0, 2), 16), parseInt(h.slice(2, 4), 16), parseInt(h.slice(4, 6), 16)];\n      return new THREE.Vector3(v[0] / 255, v[1] / 255, v[2] / 255);\n    };\n\n    const arr = (colors || []).filter(Boolean).slice(0, MAX_COLORS).map(toVec3);\n    for (let i = 0; i < MAX_COLORS; i++) {\n      const vec = (material.uniforms.uColors.value as THREE.Vector3[])[i];\n      if (i < arr.length) vec.copy(arr[i]);\n      else vec.set(0, 0, 0);\n    }\n    material.uniforms.uColorCount.value = arr.length;\n\n    material.uniforms.uTransparent.value = transparent ? 1 : 0;\n    if (renderer) renderer.setClearColor(0x000000, transparent ? 0 : 1);\n  }, [\n    rotation,\n    autoRotate,\n    speed,\n    scale,\n    frequency,\n    warpStrength,\n    mouseInfluence,\n    parallax,\n    noise,\n    colors,\n    transparent\n  ]);\n\n  useEffect(() => {\n    const material = materialRef.current;\n    const container = containerRef.current;\n    if (!material || !container) return;\n\n    const handlePointerMove = (e: PointerEvent) => {\n      const rect = container.getBoundingClientRect();\n      const x = ((e.clientX - rect.left) / (rect.width || 1)) * 2 - 1;\n      const y = -(((e.clientY - rect.top) / (rect.height || 1)) * 2 - 1);\n      pointerTargetRef.current.set(x, y);\n    };\n\n    container.addEventListener('pointermove', handlePointerMove);\n    return () => {\n      container.removeEventListener('pointermove', handlePointerMove);\n    };\n  }, []);\n\n  return <div ref={containerRef} className={`w-full h-full relative overflow-hidden ${className}`} style={style} />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "dark-veil",
      "type": "component",
      "description": "A dark translucent veil overlay background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/dark-veil.tsx",
          "content": "import { useRef, useEffect } from 'react';\nimport { Renderer, Program, Mesh, Triangle, Vec2 } from 'ogl';\n\nconst vertex = `\nattribute vec2 position;\nvoid main(){gl_Position=vec4(position,0.0,1.0);}\n`;\n\nconst fragment = `\n#ifdef GL_ES\nprecision lowp float;\n#endif\nuniform vec2 uResolution;\nuniform float uTime;\nuniform float uHueShift;\nuniform float uNoise;\nuniform float uScan;\nuniform float uScanFreq;\nuniform float uWarp;\n#define iTime uTime\n#define iResolution uResolution\n\nvec4 buf[8];\nfloat rand(vec2 c){return fract(sin(dot(c,vec2(12.9898,78.233)))*43758.5453);}\n\nmat3 rgb2yiq=mat3(0.299,0.587,0.114,0.596,-0.274,-0.322,0.211,-0.523,0.312);\nmat3 yiq2rgb=mat3(1.0,0.956,0.621,1.0,-0.272,-0.647,1.0,-1.106,1.703);\n\nvec3 hueShiftRGB(vec3 col,float deg){\n    vec3 yiq=rgb2yiq*col;\n    float rad=radians(deg);\n    float cosh=cos(rad),sinh=sin(rad);\n    vec3 yiqShift=vec3(yiq.x,yiq.y*cosh-yiq.z*sinh,yiq.y*sinh+yiq.z*cosh);\n    return clamp(yiq2rgb*yiqShift,0.0,1.0);\n}\n\nvec4 sigmoid(vec4 x){return 1./(1.+exp(-x));}\n\nvec4 cppn_fn(vec2 coordinate,float in0,float in1,float in2){\n    buf[6]=vec4(coordinate.x,coordinate.y,0.3948333106474662+in0,0.36+in1);\n    buf[7]=vec4(0.14+in2,sqrt(coordinate.x*coordinate.x+coordinate.y*coordinate.y),0.,0.);\n    buf[0]=mat4(vec4(6.5404263,-3.6126034,0.7590882,-1.13613),vec4(2.4582713,3.1660357,1.2219609,0.06276096),vec4(-5.478085,-6.159632,1.8701609,-4.7742867),vec4(6.039214,-5.542865,-0.90925294,3.251348))*buf[6]+mat4(vec4(0.8473259,-5.722911,3.975766,1.6522468),vec4(-0.24321538,0.5839259,-1.7661959,-5.350116),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.))*buf[7]+vec4(0.21808943,1.1243913,-1.7969975,5.0294676);\n    buf[1]=mat4(vec4(-3.3522482,-6.0612736,0.55641043,-4.4719114),vec4(0.8631464,1.7432913,5.643898,1.6106541),vec4(2.4941394,-3.5012043,1.7184316,6.357333),vec4(3.310376,8.209261,1.1355612,-1.165539))*buf[6]+mat4(vec4(5.24046,-13.034365,0.009859298,15.870829),vec4(2.987511,3.129433,-0.89023495,-1.6822904),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.))*buf[7]+vec4(-5.9457836,-6.573602,-0.8812491,1.5436668);\n    buf[0]=sigmoid(buf[0]);buf[1]=sigmoid(buf[1]);\n    buf[2]=mat4(vec4(-15.219568,8.095543,-2.429353,-1.9381982),vec4(-5.951362,4.3115187,2.6393783,1.274315),vec4(-7.3145227,6.7297835,5.2473326,5.9411426),vec4(5.0796127,8.979051,-1.7278991,-1.158976))*buf[6]+mat4(vec4(-11.967154,-11.608155,6.1486754,11.237008),vec4(2.124141,-6.263192,-1.7050359,-0.7021966),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.))*buf[7]+vec4(-4.17164,-3.2281182,-4.576417,-3.6401186);\n    buf[3]=mat4(vec4(3.1832156,-13.738922,1.879223,3.233465),vec4(0.64300746,12.768129,1.9141049,0.50990224),vec4(-0.049295485,4.4807224,1.4733979,1.801449),vec4(5.0039253,13.000481,3.3991797,-4.5561905))*buf[6]+mat4(vec4(-0.1285731,7.720628,-3.1425676,4.742367),vec4(0.6393625,3.714393,-0.8108378,-0.39174938),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.))*buf[7]+vec4(-1.1811101,-21.621881,0.7851888,1.2329718);\n    buf[2]=sigmoid(buf[2]);buf[3]=sigmoid(buf[3]);\n    buf[4]=mat4(vec4(5.214916,-7.183024,2.7228765,2.6592617),vec4(-5.601878,-25.3591,4.067988,0.4602802),vec4(-10.57759,24.286327,21.102104,37.546658),vec4(4.3024497,-1.9625226,2.3458803,-1.372816))*buf[0]+mat4(vec4(-17.6526,-10.507558,2.2587414,12.462782),vec4(6.265566,-502.75443,-12.642513,0.9112289),vec4(-10.983244,20.741234,-9.701768,-0.7635988),vec4(5.383626,1.4819539,-4.1911616,-4.8444734))*buf[1]+mat4(vec4(12.785233,-16.345072,-0.39901125,1.7955981),vec4(-30.48365,-1.8345358,1.4542528,-1.1118771),vec4(19.872723,-7.337935,-42.941723,-98.52709),vec4(8.337645,-2.7312303,-2.2927687,-36.142323))*buf[2]+mat4(vec4(-16.298317,3.5471997,-0.44300047,-9.444417),vec4(57.5077,-35.609753,16.163465,-4.1534753),vec4(-0.07470326,-3.8656476,-7.0901804,3.1523974),vec4(-12.559385,-7.077619,1.490437,-0.8211543))*buf[3]+vec4(-7.67914,15.927437,1.3207729,-1.6686112);\n    buf[5]=mat4(vec4(-1.4109162,-0.372762,-3.770383,-21.367174),vec4(-6.2103205,-9.35908,0.92529047,8.82561),vec4(11.460242,-22.348068,13.625772,-18.693201),vec4(-0.3429052,-3.9905605,-2.4626114,-0.45033523))*buf[0]+mat4(vec4(7.3481627,-4.3661838,-6.3037653,-3.868115),vec4(1.5462853,6.5488915,1.9701879,-0.58291394),vec4(6.5858274,-2.2180402,3.7127688,-1.3730392),vec4(-5.7973905,10.134961,-2.3395722,-5.965605))*buf[1]+mat4(vec4(-2.5132585,-6.6685553,-1.4029363,-0.16285264),vec4(-0.37908727,0.53738135,4.389061,-1.3024765),vec4(-0.70647055,2.0111287,-5.1659346,-3.728635),vec4(-13.562562,10.487719,-0.9173751,-2.6487076))*buf[2]+mat4(vec4(-8.645013,6.5546675,-6.3944063,-5.5933375),vec4(-0.57783127,-1.077275,36.91025,5.736769),vec4(14.283112,3.7146652,7.1452246,-4.5958776),vec4(2.7192075,3.6021907,-4.366337,-2.3653464))*buf[3]+vec4(-5.9000807,-4.329569,1.2427121,8.59503);\n    buf[4]=sigmoid(buf[4]);buf[5]=sigmoid(buf[5]);\n    buf[6]=mat4(vec4(-1.61102,0.7970257,1.4675229,0.20917463),vec4(-28.793737,-7.1390953,1.5025433,4.656581),vec4(-10.94861,39.66238,0.74318546,-10.095605),vec4(-0.7229728,-1.5483948,0.7301322,2.1687684))*buf[0]+mat4(vec4(3.2547753,21.489103,-1.0194173,-3.3100595),vec4(-3.7316632,-3.3792162,-7.223193,-0.23685838),vec4(13.1804495,0.7916005,5.338587,5.687114),vec4(-4.167605,-17.798311,-6.815736,-1.6451967))*buf[1]+mat4(vec4(0.604885,-7.800309,-7.213122,-2.741014),vec4(-3.522382,-0.12359311,-0.5258442,0.43852118),vec4(9.6752825,-22.853785,2.062431,0.099892326),vec4(-4.3196306,-17.730087,2.5184598,5.30267))*buf[2]+mat4(vec4(-6.545563,-15.790176,-6.0438633,-5.415399),vec4(-43.591583,28.551912,-16.00161,18.84728),vec4(4.212382,8.394307,3.0958717,8.657522),vec4(-5.0237565,-4.450633,-4.4768,-5.5010443))*buf[3]+mat4(vec4(1.6985557,-67.05806,6.897715,1.9004834),vec4(1.8680354,2.3915145,2.5231109,4.081538),vec4(11.158006,1.7294737,2.0738268,7.386411),vec4(-4.256034,-306.24686,8.258898,-17.132736))*buf[4]+mat4(vec4(1.6889864,-4.5852966,3.8534803,-6.3482175),vec4(1.3543309,-1.2640043,9.932754,2.9079645),vec4(-5.2770967,0.07150358,-0.13962056,3.3269649),vec4(28.34703,-4.918278,6.1044083,4.085355))*buf[5]+vec4(6.6818056,12.522166,-3.7075126,-4.104386);\n    buf[7]=mat4(vec4(-8.265602,-4.7027016,5.098234,0.7509808),vec4(8.6507845,-17.15949,16.51939,-8.884479),vec4(-4.036479,-2.3946867,-2.6055532,-1.9866527),vec4(-2.2167742,-1.8135649,-5.9759874,4.8846445))*buf[0]+mat4(vec4(6.7790847,3.5076547,-2.8191125,-2.7028968),vec4(-5.743024,-0.27844876,1.4958696,-5.0517144),vec4(13.122226,15.735168,-2.9397483,-4.101023),vec4(-14.375265,-5.030483,-6.2599335,2.9848232))*buf[1]+mat4(vec4(4.0950394,-0.94011575,-5.674733,4.755022),vec4(4.3809423,4.8310084,1.7425908,-3.437416),vec4(2.117492,0.16342592,-104.56341,16.949184),vec4(-5.22543,-2.994248,3.8350096,-1.9364246))*buf[2]+mat4(vec4(-5.900337,1.7946124,-13.604192,-3.8060522),vec4(6.6583457,31.911177,25.164474,91.81147),vec4(11.840538,4.1503043,-0.7314397,6.768467),vec4(-6.3967767,4.034772,6.1714606,-0.32874924))*buf[3]+mat4(vec4(3.4992442,-196.91893,-8.923708,2.8142626),vec4(3.4806502,-3.1846354,5.1725626,5.1804223),vec4(-2.4009497,15.585794,1.2863957,2.0252278),vec4(-71.25271,-62.441242,-8.138444,0.50670296))*buf[4]+mat4(vec4(-12.291733,-11.176166,-7.3474145,4.390294),vec4(10.805477,5.6337385,-0.9385842,-4.7348723),vec4(-12.869276,-7.039391,5.3029537,7.5436664),vec4(1.4593618,8.91898,3.5101583,5.840625))*buf[5]+vec4(2.2415268,-6.705987,-0.98861027,-2.117676);\n    buf[6]=sigmoid(buf[6]);buf[7]=sigmoid(buf[7]);\n    buf[0]=mat4(vec4(1.6794263,1.3817469,2.9625452,0.),vec4(-1.8834411,-1.4806935,-3.5924516,0.),vec4(-1.3279216,-1.0918057,-2.3124623,0.),vec4(0.2662234,0.23235129,0.44178495,0.))*buf[0]+mat4(vec4(-0.6299101,-0.5945583,-0.9125601,0.),vec4(0.17828953,0.18300213,0.18182953,0.),vec4(-2.96544,-2.5819945,-4.9001055,0.),vec4(1.4195864,1.1868085,2.5176322,0.))*buf[1]+mat4(vec4(-1.2584374,-1.0552157,-2.1688404,0.),vec4(-0.7200217,-0.52666044,-1.438251,0.),vec4(0.15345335,0.15196142,0.272854,0.),vec4(0.945728,0.8861938,1.2766753,0.))*buf[2]+mat4(vec4(-2.4218085,-1.968602,-4.35166,0.),vec4(-22.683098,-18.0544,-41.954372,0.),vec4(0.63792,0.5470648,1.1078634,0.),vec4(-1.5489894,-1.3075932,-2.6444845,0.))*buf[3]+mat4(vec4(-0.49252132,-0.39877754,-0.91366625,0.),vec4(0.95609266,0.7923952,1.640221,0.),vec4(0.30616966,0.15693925,0.8639857,0.),vec4(1.1825981,0.94504964,2.176963,0.))*buf[4]+mat4(vec4(0.35446745,0.3293795,0.59547555,0.),vec4(-0.58784515,-0.48177817,-1.0614829,0.),vec4(2.5271258,1.9991658,4.6846647,0.),vec4(0.13042648,0.08864098,0.30187556,0.))*buf[5]+mat4(vec4(-1.7718065,-1.4033192,-3.3355875,0.),vec4(3.1664357,2.638297,5.378702,0.),vec4(-3.1724713,-2.6107926,-5.549295,0.),vec4(-2.851368,-2.249092,-5.3013067,0.))*buf[6]+mat4(vec4(1.5203838,1.2212278,2.8404984,0.),vec4(1.5210563,1.2651345,2.683903,0.),vec4(2.9789467,2.4364579,5.2347264,0.),vec4(2.2270417,1.8825914,3.8028636,0.))*buf[7]+vec4(-1.5468478,-3.6171484,0.24762098,0.);\n    buf[0]=sigmoid(buf[0]);\n    return vec4(buf[0].x,buf[0].y,buf[0].z,1.);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/uResolution.xy*2.-1.;\n    uv.y*=-1.;\n    uv+=uWarp*vec2(sin(uv.y*6.283+uTime*0.5),cos(uv.x*6.283+uTime*0.5))*0.05;\n    fragColor=cppn_fn(uv,0.1*sin(0.3*uTime),0.1*sin(0.69*uTime),0.1*sin(0.44*uTime));\n}\n\nvoid main(){\n    vec4 col;mainImage(col,gl_FragCoord.xy);\n    col.rgb=hueShiftRGB(col.rgb,uHueShift);\n    float scanline_val=sin(gl_FragCoord.y*uScanFreq)*0.5+0.5;\n    col.rgb*=1.-(scanline_val*scanline_val)*uScan;\n    col.rgb+=(rand(gl_FragCoord.xy+uTime)-0.5)*uNoise;\n    gl_FragColor=vec4(clamp(col.rgb,0.0,1.0),1.0);\n}\n`;\n\ntype Props = {\n  hueShift?: number;\n  noiseIntensity?: number;\n  scanlineIntensity?: number;\n  speed?: number;\n  scanlineFrequency?: number;\n  warpAmount?: number;\n  resolutionScale?: number;\n};\n\nexport default function DarkVeil({\n  hueShift = 0,\n  noiseIntensity = 0,\n  scanlineIntensity = 0,\n  speed = 0.5,\n  scanlineFrequency = 0,\n  warpAmount = 0,\n  resolutionScale = 1\n}: Props) {\n  const ref = useRef<HTMLCanvasElement>(null);\n  useEffect(() => {\n    const canvas = ref.current as HTMLCanvasElement;\n    const parent = canvas.parentElement as HTMLElement;\n\n    const renderer = new Renderer({\n      dpr: Math.min(window.devicePixelRatio, 2),\n      canvas\n    });\n\n    const gl = renderer.gl;\n    const geometry = new Triangle(gl);\n\n    const program = new Program(gl, {\n      vertex,\n      fragment,\n      uniforms: {\n        uTime: { value: 0 },\n        uResolution: { value: new Vec2() },\n        uHueShift: { value: hueShift },\n        uNoise: { value: noiseIntensity },\n        uScan: { value: scanlineIntensity },\n        uScanFreq: { value: scanlineFrequency },\n        uWarp: { value: warpAmount }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    const resize = () => {\n      const w = parent.clientWidth,\n        h = parent.clientHeight;\n      renderer.setSize(w * resolutionScale, h * resolutionScale);\n      program.uniforms.uResolution.value.set(w, h);\n    };\n\n    window.addEventListener('resize', resize);\n    resize();\n\n    const start = performance.now();\n    let frame = 0;\n\n    const loop = () => {\n      program.uniforms.uTime.value = ((performance.now() - start) / 1000) * speed;\n      program.uniforms.uHueShift.value = hueShift;\n      program.uniforms.uNoise.value = noiseIntensity;\n      program.uniforms.uScan.value = scanlineIntensity;\n      program.uniforms.uScanFreq.value = scanlineFrequency;\n      program.uniforms.uWarp.value = warpAmount;\n      renderer.render({ scene: mesh });\n      frame = requestAnimationFrame(loop);\n    };\n\n    loop();\n\n    return () => {\n      cancelAnimationFrame(frame);\n      window.removeEventListener('resize', resize);\n    };\n  }, [hueShift, noiseIntensity, scanlineIntensity, speed, scanlineFrequency, warpAmount, resolutionScale]);\n  return <canvas ref={ref} className=\"w-full h-full block\" />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "dither",
      "type": "component",
      "description": "A dithered gradient background effect with post-processing.",
      "category": "backgrounds",
      "dependencies": [
        "three",
        "@react-three/fiber",
        "@react-three/postprocessing",
        "postprocessing"
      ],
      "files": [
        {
          "path": "components/ui/dither.tsx",
          "content": "/* eslint-disable react/no-unknown-property */\nimport { useRef, useState, useEffect, forwardRef } from 'react';\nimport { Canvas, useFrame, useThree, ThreeEvent } from '@react-three/fiber';\nimport { EffectComposer, wrapEffect } from '@react-three/postprocessing';\nimport { Effect } from 'postprocessing';\nimport * as THREE from 'three';\n\nconst waveVertexShader = `\nprecision highp float;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n  vec4 viewPosition = viewMatrix * modelPosition;\n  gl_Position = projectionMatrix * viewPosition;\n}\n`;\n\nconst waveFragmentShader = `\nprecision highp float;\nuniform vec2 resolution;\nuniform float time;\nuniform float waveSpeed;\nuniform float waveFrequency;\nuniform float waveAmplitude;\nuniform vec3 waveColor;\nuniform vec2 mousePos;\nuniform int enableMouseInteraction;\nuniform float mouseRadius;\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat cnoise(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);\n  Pi = mod289(Pi);\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11)));\n  g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);\n}\n\nconst int OCTAVES = 4;\nfloat fbm(vec2 p) {\n  float value = 0.0;\n  float amp = 1.0;\n  float freq = waveFrequency;\n  for (int i = 0; i < OCTAVES; i++) {\n    value += amp * abs(cnoise(p));\n    p *= freq;\n    amp *= waveAmplitude;\n  }\n  return value;\n}\n\nfloat pattern(vec2 p) {\n  vec2 p2 = p - time * waveSpeed;\n  return fbm(p + fbm(p2)); \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  uv -= 0.5;\n  uv.x *= resolution.x / resolution.y;\n  float f = pattern(uv);\n  if (enableMouseInteraction == 1) {\n    vec2 mouseNDC = (mousePos / resolution - 0.5) * vec2(1.0, -1.0);\n    mouseNDC.x *= resolution.x / resolution.y;\n    float dist = length(uv - mouseNDC);\n    float effect = 1.0 - smoothstep(0.0, mouseRadius, dist);\n    f -= 0.5 * effect;\n  }\n  vec3 col = mix(vec3(0.0), waveColor, f);\n  gl_FragColor = vec4(col, 1.0);\n}\n`;\n\nconst ditherFragmentShader = `\nprecision highp float;\nuniform float colorNum;\nuniform float pixelSize;\nconst float bayerMatrix8x8[64] = float[64](\n  0.0/64.0, 48.0/64.0, 12.0/64.0, 60.0/64.0,  3.0/64.0, 51.0/64.0, 15.0/64.0, 63.0/64.0,\n  32.0/64.0,16.0/64.0, 44.0/64.0, 28.0/64.0, 35.0/64.0,19.0/64.0, 47.0/64.0, 31.0/64.0,\n  8.0/64.0, 56.0/64.0,  4.0/64.0, 52.0/64.0, 11.0/64.0,59.0/64.0,  7.0/64.0, 55.0/64.0,\n  40.0/64.0,24.0/64.0, 36.0/64.0, 20.0/64.0, 43.0/64.0,27.0/64.0, 39.0/64.0, 23.0/64.0,\n  2.0/64.0, 50.0/64.0, 14.0/64.0, 62.0/64.0,  1.0/64.0,49.0/64.0, 13.0/64.0, 61.0/64.0,\n  34.0/64.0,18.0/64.0, 46.0/64.0, 30.0/64.0, 33.0/64.0,17.0/64.0, 45.0/64.0, 29.0/64.0,\n  10.0/64.0,58.0/64.0,  6.0/64.0, 54.0/64.0,  9.0/64.0,57.0/64.0,  5.0/64.0, 53.0/64.0,\n  42.0/64.0,26.0/64.0, 38.0/64.0, 22.0/64.0, 41.0/64.0,25.0/64.0, 37.0/64.0, 21.0/64.0\n);\n\nvec3 dither(vec2 uv, vec3 color) {\n  vec2 scaledCoord = floor(uv * resolution / pixelSize);\n  int x = int(mod(scaledCoord.x, 8.0));\n  int y = int(mod(scaledCoord.y, 8.0));\n  float threshold = bayerMatrix8x8[y * 8 + x] - 0.25;\n  float step = 1.0 / (colorNum - 1.0);\n  color += threshold * step;\n  float bias = 0.2;\n  color = clamp(color - bias, 0.0, 1.0);\n  return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);\n}\n\nvoid mainImage(in vec4 inputColor, in vec2 uv, out vec4 outputColor) {\n  vec2 normalizedPixelSize = pixelSize / resolution;\n  vec2 uvPixel = normalizedPixelSize * floor(uv / normalizedPixelSize);\n  vec4 color = texture2D(inputBuffer, uvPixel);\n  color.rgb = dither(uv, color.rgb);\n  outputColor = color;\n}\n`;\n\nclass RetroEffectImpl extends Effect {\n  public uniforms: Map<string, THREE.Uniform<any>>;\n  constructor() {\n    const uniforms = new Map<string, THREE.Uniform<any>>([\n      ['colorNum', new THREE.Uniform(4.0)],\n      ['pixelSize', new THREE.Uniform(2.0)]\n    ]);\n    super('RetroEffect', ditherFragmentShader, { uniforms });\n    this.uniforms = uniforms;\n  }\n  set colorNum(value: number) {\n    this.uniforms.get('colorNum')!.value = value;\n  }\n  get colorNum(): number {\n    return this.uniforms.get('colorNum')!.value;\n  }\n  set pixelSize(value: number) {\n    this.uniforms.get('pixelSize')!.value = value;\n  }\n  get pixelSize(): number {\n    return this.uniforms.get('pixelSize')!.value;\n  }\n}\n\nconst RetroEffect = forwardRef<RetroEffectImpl, { colorNum: number; pixelSize: number }>((props, ref) => {\n  const { colorNum, pixelSize } = props;\n  const WrappedRetroEffect = wrapEffect(RetroEffectImpl);\n  return <WrappedRetroEffect ref={ref} colorNum={colorNum} pixelSize={pixelSize} />;\n});\n\nRetroEffect.displayName = 'RetroEffect';\n\ninterface WaveUniforms {\n  [key: string]: THREE.Uniform<any>;\n  time: THREE.Uniform<number>;\n  resolution: THREE.Uniform<THREE.Vector2>;\n  waveSpeed: THREE.Uniform<number>;\n  waveFrequency: THREE.Uniform<number>;\n  waveAmplitude: THREE.Uniform<number>;\n  waveColor: THREE.Uniform<THREE.Color>;\n  mousePos: THREE.Uniform<THREE.Vector2>;\n  enableMouseInteraction: THREE.Uniform<number>;\n  mouseRadius: THREE.Uniform<number>;\n}\n\ninterface DitheredWavesProps {\n  waveSpeed: number;\n  waveFrequency: number;\n  waveAmplitude: number;\n  waveColor: [number, number, number];\n  colorNum: number;\n  pixelSize: number;\n  disableAnimation: boolean;\n  enableMouseInteraction: boolean;\n  mouseRadius: number;\n}\n\nfunction DitheredWaves({\n  waveSpeed,\n  waveFrequency,\n  waveAmplitude,\n  waveColor,\n  colorNum,\n  pixelSize,\n  disableAnimation,\n  enableMouseInteraction,\n  mouseRadius\n}: DitheredWavesProps) {\n  const mesh = useRef<THREE.Mesh>(null);\n  const mouseRef = useRef(new THREE.Vector2());\n  const { viewport, size, gl } = useThree();\n\n  const waveUniformsRef = useRef<WaveUniforms>({\n    time: new THREE.Uniform(0),\n    resolution: new THREE.Uniform(new THREE.Vector2(0, 0)),\n    waveSpeed: new THREE.Uniform(waveSpeed),\n    waveFrequency: new THREE.Uniform(waveFrequency),\n    waveAmplitude: new THREE.Uniform(waveAmplitude),\n    waveColor: new THREE.Uniform(new THREE.Color(...waveColor)),\n    mousePos: new THREE.Uniform(new THREE.Vector2(0, 0)),\n    enableMouseInteraction: new THREE.Uniform(enableMouseInteraction ? 1 : 0),\n    mouseRadius: new THREE.Uniform(mouseRadius)\n  });\n\n  useEffect(() => {\n    const dpr = gl.getPixelRatio();\n    const newWidth = Math.floor(size.width * dpr);\n    const newHeight = Math.floor(size.height * dpr);\n    const currentRes = waveUniformsRef.current.resolution.value;\n    if (currentRes.x !== newWidth || currentRes.y !== newHeight) {\n      currentRes.set(newWidth, newHeight);\n    }\n  }, [size, gl]);\n\n  const prevColor = useRef([...waveColor]);\n  useFrame(({ clock }) => {\n    const u = waveUniformsRef.current;\n\n    if (!disableAnimation) {\n      u.time.value = clock.getElapsedTime();\n    }\n\n    if (u.waveSpeed.value !== waveSpeed) u.waveSpeed.value = waveSpeed;\n    if (u.waveFrequency.value !== waveFrequency) u.waveFrequency.value = waveFrequency;\n    if (u.waveAmplitude.value !== waveAmplitude) u.waveAmplitude.value = waveAmplitude;\n\n    if (!prevColor.current.every((v, i) => v === waveColor[i])) {\n      u.waveColor.value.set(...waveColor);\n      prevColor.current = [...waveColor];\n    }\n\n    u.enableMouseInteraction.value = enableMouseInteraction ? 1 : 0;\n    u.mouseRadius.value = mouseRadius;\n\n    if (enableMouseInteraction) {\n      u.mousePos.value.copy(mouseRef.current);\n    }\n  });\n\n  const handlePointerMove = (e: ThreeEvent<PointerEvent>) => {\n    if (!enableMouseInteraction) return;\n    const rect = gl.domElement.getBoundingClientRect();\n    const dpr = gl.getPixelRatio();\n    mouseRef.current.set((e.clientX - rect.left) * dpr, (e.clientY - rect.top) * dpr);\n  };\n\n  return (\n    <>\n      <mesh ref={mesh} scale={[viewport.width, viewport.height, 1]}>\n        <planeGeometry args={[1, 1]} />\n        <shaderMaterial\n          vertexShader={waveVertexShader}\n          fragmentShader={waveFragmentShader}\n          uniforms={waveUniformsRef.current}\n        />\n      </mesh>\n\n      <EffectComposer>\n        <RetroEffect colorNum={colorNum} pixelSize={pixelSize} />\n      </EffectComposer>\n\n      <mesh\n        onPointerMove={handlePointerMove}\n        position={[0, 0, 0.01]}\n        scale={[viewport.width, viewport.height, 1]}\n        visible={false}\n      >\n        <planeGeometry args={[1, 1]} />\n        <meshBasicMaterial transparent opacity={0} />\n      </mesh>\n    </>\n  );\n}\n\ninterface DitherProps {\n  waveSpeed?: number;\n  waveFrequency?: number;\n  waveAmplitude?: number;\n  waveColor?: [number, number, number];\n  colorNum?: number;\n  pixelSize?: number;\n  disableAnimation?: boolean;\n  enableMouseInteraction?: boolean;\n  mouseRadius?: number;\n}\n\nexport default function Dither({\n  waveSpeed = 0.05,\n  waveFrequency = 3,\n  waveAmplitude = 0.3,\n  waveColor = [0.5, 0.5, 0.5],\n  colorNum = 4,\n  pixelSize = 2,\n  disableAnimation = false,\n  enableMouseInteraction = true,\n  mouseRadius = 1\n}: DitherProps) {\n  return (\n    <Canvas\n      className=\"w-full h-full relative\"\n      camera={{ position: [0, 0, 6] }}\n      dpr={1}\n      gl={{ antialias: true, preserveDrawingBuffer: true }}\n    >\n      <DitheredWaves\n        waveSpeed={waveSpeed}\n        waveFrequency={waveFrequency}\n        waveAmplitude={waveAmplitude}\n        waveColor={waveColor}\n        colorNum={colorNum}\n        pixelSize={pixelSize}\n        disableAnimation={disableAnimation}\n        enableMouseInteraction={enableMouseInteraction}\n        mouseRadius={mouseRadius}\n      />\n    </Canvas>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "dot-grid",
      "type": "component",
      "description": "An interactive animated dot grid background.",
      "category": "backgrounds",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/dot-grid.tsx",
          "content": "'use client';\nimport React, { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { gsap } from 'gsap';\nimport { InertiaPlugin } from 'gsap/InertiaPlugin';\n\ngsap.registerPlugin(InertiaPlugin);\n\nconst throttle = (func: (...args: any[]) => void, limit: number) => {\n  let lastCall = 0;\n  return function (this: any, ...args: any[]) {\n    const now = performance.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      func.apply(this, args);\n    }\n  };\n};\n\ninterface Dot {\n  cx: number;\n  cy: number;\n  xOffset: number;\n  yOffset: number;\n  _inertiaApplied: boolean;\n}\n\nexport interface DotGridProps {\n  dotSize?: number;\n  gap?: number;\n  baseColor?: string;\n  activeColor?: string;\n  proximity?: number;\n  speedTrigger?: number;\n  shockRadius?: number;\n  shockStrength?: number;\n  maxSpeed?: number;\n  resistance?: number;\n  returnDuration?: number;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nfunction hexToRgb(hex: string) {\n  const m = hex.match(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n  if (!m) return { r: 0, g: 0, b: 0 };\n  return {\n    r: parseInt(m[1], 16),\n    g: parseInt(m[2], 16),\n    b: parseInt(m[3], 16)\n  };\n}\n\nconst DotGrid: React.FC<DotGridProps> = ({\n  dotSize = 16,\n  gap = 32,\n  baseColor = '#5227FF',\n  activeColor = '#5227FF',\n  proximity = 150,\n  speedTrigger = 100,\n  shockRadius = 250,\n  shockStrength = 5,\n  maxSpeed = 5000,\n  resistance = 750,\n  returnDuration = 1.5,\n  className = '',\n  style\n}) => {\n  const wrapperRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const dotsRef = useRef<Dot[]>([]);\n  const pointerRef = useRef({\n    x: 0,\n    y: 0,\n    vx: 0,\n    vy: 0,\n    speed: 0,\n    lastTime: 0,\n    lastX: 0,\n    lastY: 0\n  });\n\n  const baseRgb = useMemo(() => hexToRgb(baseColor), [baseColor]);\n  const activeRgb = useMemo(() => hexToRgb(activeColor), [activeColor]);\n\n  const circlePath = useMemo(() => {\n    if (typeof window === 'undefined' || !window.Path2D) return null;\n\n    const p = new Path2D();\n    p.arc(0, 0, dotSize / 2, 0, Math.PI * 2);\n    return p;\n  }, [dotSize]);\n\n  const buildGrid = useCallback(() => {\n    const wrap = wrapperRef.current;\n    const canvas = canvasRef.current;\n    if (!wrap || !canvas) return;\n\n    const { width, height } = wrap.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    const ctx = canvas.getContext('2d');\n    if (ctx) ctx.scale(dpr, dpr);\n\n    const cols = Math.floor((width + gap) / (dotSize + gap));\n    const rows = Math.floor((height + gap) / (dotSize + gap));\n    const cell = dotSize + gap;\n\n    const gridW = cell * cols - gap;\n    const gridH = cell * rows - gap;\n\n    const extraX = width - gridW;\n    const extraY = height - gridH;\n\n    const startX = extraX / 2 + dotSize / 2;\n    const startY = extraY / 2 + dotSize / 2;\n\n    const dots: Dot[] = [];\n    for (let y = 0; y < rows; y++) {\n      for (let x = 0; x < cols; x++) {\n        const cx = startX + x * cell;\n        const cy = startY + y * cell;\n        dots.push({ cx, cy, xOffset: 0, yOffset: 0, _inertiaApplied: false });\n      }\n    }\n    dotsRef.current = dots;\n  }, [dotSize, gap]);\n\n  useEffect(() => {\n    if (!circlePath) return;\n\n    let rafId: number;\n    const proxSq = proximity * proximity;\n\n    const draw = () => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      const { x: px, y: py } = pointerRef.current;\n\n      for (const dot of dotsRef.current) {\n        const ox = dot.cx + dot.xOffset;\n        const oy = dot.cy + dot.yOffset;\n        const dx = dot.cx - px;\n        const dy = dot.cy - py;\n        const dsq = dx * dx + dy * dy;\n\n        let style = baseColor;\n        if (dsq <= proxSq) {\n          const dist = Math.sqrt(dsq);\n          const t = 1 - dist / proximity;\n          const r = Math.round(baseRgb.r + (activeRgb.r - baseRgb.r) * t);\n          const g = Math.round(baseRgb.g + (activeRgb.g - baseRgb.g) * t);\n          const b = Math.round(baseRgb.b + (activeRgb.b - baseRgb.b) * t);\n          style = `rgb(${r},${g},${b})`;\n        }\n\n        ctx.save();\n        ctx.translate(ox, oy);\n        ctx.fillStyle = style;\n        ctx.fill(circlePath);\n        ctx.restore();\n      }\n\n      rafId = requestAnimationFrame(draw);\n    };\n\n    draw();\n    return () => cancelAnimationFrame(rafId);\n  }, [proximity, baseColor, activeRgb, baseRgb, circlePath]);\n\n  useEffect(() => {\n    buildGrid();\n    let ro: ResizeObserver | null = null;\n    if ('ResizeObserver' in window) {\n      ro = new ResizeObserver(buildGrid);\n      wrapperRef.current && ro.observe(wrapperRef.current);\n    } else {\n      (window as Window).addEventListener('resize', buildGrid);\n    }\n    return () => {\n      if (ro) ro.disconnect();\n      else window.removeEventListener('resize', buildGrid);\n    };\n  }, [buildGrid]);\n\n  useEffect(() => {\n    const onMove = (e: MouseEvent) => {\n      const now = performance.now();\n      const pr = pointerRef.current;\n      const dt = pr.lastTime ? now - pr.lastTime : 16;\n      const dx = e.clientX - pr.lastX;\n      const dy = e.clientY - pr.lastY;\n      let vx = (dx / dt) * 1000;\n      let vy = (dy / dt) * 1000;\n      let speed = Math.hypot(vx, vy);\n      if (speed > maxSpeed) {\n        const scale = maxSpeed / speed;\n        vx *= scale;\n        vy *= scale;\n        speed = maxSpeed;\n      }\n      pr.lastTime = now;\n      pr.lastX = e.clientX;\n      pr.lastY = e.clientY;\n      pr.vx = vx;\n      pr.vy = vy;\n      pr.speed = speed;\n\n      const rect = canvasRef.current!.getBoundingClientRect();\n      pr.x = e.clientX - rect.left;\n      pr.y = e.clientY - rect.top;\n\n      for (const dot of dotsRef.current) {\n        const dist = Math.hypot(dot.cx - pr.x, dot.cy - pr.y);\n        if (speed > speedTrigger && dist < proximity && !dot._inertiaApplied) {\n          dot._inertiaApplied = true;\n          gsap.killTweensOf(dot);\n          const pushX = dot.cx - pr.x + vx * 0.005;\n          const pushY = dot.cy - pr.y + vy * 0.005;\n          gsap.to(dot, {\n            inertia: { xOffset: pushX, yOffset: pushY, resistance },\n            onComplete: () => {\n              gsap.to(dot, {\n                xOffset: 0,\n                yOffset: 0,\n                duration: returnDuration,\n                ease: 'elastic.out(1,0.75)'\n              });\n              dot._inertiaApplied = false;\n            }\n          });\n        }\n      }\n    };\n\n    const onClick = (e: MouseEvent) => {\n      const rect = canvasRef.current!.getBoundingClientRect();\n      const cx = e.clientX - rect.left;\n      const cy = e.clientY - rect.top;\n      for (const dot of dotsRef.current) {\n        const dist = Math.hypot(dot.cx - cx, dot.cy - cy);\n        if (dist < shockRadius && !dot._inertiaApplied) {\n          dot._inertiaApplied = true;\n          gsap.killTweensOf(dot);\n          const falloff = Math.max(0, 1 - dist / shockRadius);\n          const pushX = (dot.cx - cx) * shockStrength * falloff;\n          const pushY = (dot.cy - cy) * shockStrength * falloff;\n          gsap.to(dot, {\n            inertia: { xOffset: pushX, yOffset: pushY, resistance },\n            onComplete: () => {\n              gsap.to(dot, {\n                xOffset: 0,\n                yOffset: 0,\n                duration: returnDuration,\n                ease: 'elastic.out(1,0.75)'\n              });\n              dot._inertiaApplied = false;\n            }\n          });\n        }\n      }\n    };\n\n    const throttledMove = throttle(onMove, 50);\n    window.addEventListener('mousemove', throttledMove, { passive: true });\n    window.addEventListener('click', onClick);\n\n    return () => {\n      window.removeEventListener('mousemove', throttledMove);\n      window.removeEventListener('click', onClick);\n    };\n  }, [maxSpeed, speedTrigger, proximity, resistance, returnDuration, shockRadius, shockStrength]);\n\n  return (\n    <section className={`p-4 flex items-center justify-center h-full w-full relative ${className}`} style={style}>\n      <div ref={wrapperRef} className=\"w-full h-full relative\">\n        <canvas ref={canvasRef} className=\"absolute inset-0 w-full h-full pointer-events-none\" />\n      </div>\n    </section>\n  );\n};\n\nexport default DotGrid;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "dot-pattern",
      "type": "component",
      "description": "A background dot pattern made with SVGs, fully customizable using Tailwind CSS.",
      "category": "backgrounds",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/dot-pattern.tsx",
          "content": "'use client';\n\nimport React, { useEffect, useId, useRef, useState } from 'react';\nimport { motion } from 'motion/react';\n\nimport { cn } from '@/lib/utils';\n\n/**\n *  DotPattern Component Props\n *\n * @param {number} [width=16] - The horizontal spacing between dots\n * @param {number} [height=16] - The vertical spacing between dots\n * @param {number} [x=0] - The x-offset of the entire pattern\n * @param {number} [y=0] - The y-offset of the entire pattern\n * @param {number} [cx=1] - The x-offset of individual dots\n * @param {number} [cy=1] - The y-offset of individual dots\n * @param {number} [cr=1] - The radius of each dot\n * @param {string} [className] - Additional CSS classes to apply to the SVG container\n * @param {boolean} [glow=false] - Whether dots should have a glowing animation effect\n */\ninterface DotPatternProps extends React.SVGProps<SVGSVGElement> {\n  width?: number;\n  height?: number;\n  x?: number;\n  y?: number;\n  cx?: number;\n  cy?: number;\n  cr?: number;\n  className?: string;\n  glow?: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * DotPattern Component\n *\n * A React component that creates an animated or static dot pattern background using SVG.\n * The pattern automatically adjusts to fill its container and can optionally display glowing dots.\n *\n * @component\n *\n * @see DotPatternProps for the props interface.\n *\n * @example\n * // Basic usage\n * <DotPattern />\n *\n * // With glowing effect and custom spacing\n * <DotPattern\n *   width={20}\n *   height={20}\n *   glow={true}\n *   className=\"opacity-50\"\n * />\n *\n * @notes\n * - The component is client-side only (\"use client\")\n * - Automatically responds to container size changes\n * - When glow is enabled, dots will animate with random delays and durations\n * - Uses Motion for animations\n * - Dots color can be controlled via the text color utility classes\n */\n\nexport function DotPattern({\n  width = 16,\n  height = 16,\n  x = 0,\n  y = 0,\n  cx = 1,\n  cy = 1,\n  cr = 1,\n  className,\n  glow = false,\n  ...props\n}: DotPatternProps) {\n  const id = useId();\n  const containerRef = useRef<SVGSVGElement>(null);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const { width, height } = containerRef.current.getBoundingClientRect();\n        setDimensions({ width, height });\n      }\n    };\n\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, []);\n\n  const dots = Array.from(\n    {\n      length:\n        Math.ceil(dimensions.width / width) * Math.ceil(dimensions.height / height),\n    },\n    (_, i) => {\n      const col = i % Math.ceil(dimensions.width / width);\n      const row = Math.floor(i / Math.ceil(dimensions.width / width));\n      return {\n        x: col * width + cx,\n        y: row * height + cy,\n        delay: Math.random() * 5,\n        duration: Math.random() * 3 + 2,\n      };\n    }\n  );\n\n  return (\n    <svg\n      ref={containerRef}\n      aria-hidden=\"true\"\n      className={cn(\n        'pointer-events-none absolute inset-0 h-full w-full text-neutral-400/80',\n        className\n      )}\n      {...props}\n    >\n      <defs>\n        <radialGradient id={`${id}-gradient`}>\n          <stop offset=\"0%\" stopColor=\"currentColor\" stopOpacity=\"1\" />\n          <stop offset=\"100%\" stopColor=\"currentColor\" stopOpacity=\"0\" />\n        </radialGradient>\n      </defs>\n      {dots.map((dot, index) => (\n        <motion.circle\n          key={`${dot.x}-${dot.y}`}\n          cx={dot.x}\n          cy={dot.y}\n          r={cr}\n          fill={glow ? `url(#${id}-gradient)` : 'currentColor'}\n          initial={glow ? { opacity: 0.4, scale: 1 } : {}}\n          animate={\n            glow\n              ? {\n                  opacity: [0.4, 1, 0.4],\n                  scale: [1, 1.5, 1],\n                }\n              : {}\n          }\n          transition={\n            glow\n              ? {\n                  duration: dot.duration,\n                  repeat: Infinity,\n                  repeatType: 'reverse' as const,\n                  delay: dot.delay,\n                  ease: 'easeInOut',\n                }\n              : {}\n          }\n        />\n      ))}\n    </svg>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background",
          "pattern",
          "svg",
          "dots"
        ],
        "featured": true
      }
    },
    {
      "name": "faulty-terminal",
      "type": "component",
      "description": "A glitchy terminal-style background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/faulty-terminal.tsx",
          "content": "import { Renderer, Program, Mesh, Color, Triangle } from 'ogl';\nimport React, { useEffect, useRef, useMemo, useCallback } from 'react';\n\ntype Vec2 = [number, number];\n\nexport interface FaultyTerminalProps extends React.HTMLAttributes<HTMLDivElement> {\n  scale?: number;\n  gridMul?: Vec2;\n  digitSize?: number;\n  timeScale?: number;\n  pause?: boolean;\n  scanlineIntensity?: number;\n  glitchAmount?: number;\n  flickerAmount?: number;\n  noiseAmp?: number;\n  chromaticAberration?: number;\n  dither?: number | boolean;\n  curvature?: number;\n  tint?: string;\n  mouseReact?: boolean;\n  mouseStrength?: number;\n  dpr?: number;\n  pageLoadAnimation?: boolean;\n  brightness?: number;\n}\n\nconst vertexShader = `\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision mediump float;\n\nvarying vec2 vUv;\n\nuniform float iTime;\nuniform vec3  iResolution;\nuniform float uScale;\n\nuniform vec2  uGridMul;\nuniform float uDigitSize;\nuniform float uScanlineIntensity;\nuniform float uGlitchAmount;\nuniform float uFlickerAmount;\nuniform float uNoiseAmp;\nuniform float uChromaticAberration;\nuniform float uDither;\nuniform float uCurvature;\nuniform vec3  uTint;\nuniform vec2  uMouse;\nuniform float uMouseStrength;\nuniform float uUseMouse;\nuniform float uPageLoadProgress;\nuniform float uUsePageLoadAnimation;\nuniform float uBrightness;\n\nfloat time;\n\nfloat hash21(vec2 p){\n  p = fract(p * 234.56);\n  p += dot(p, p + 34.56);\n  return fract(p.x * p.y);\n}\n\nfloat noise(vec2 p)\n{\n  return sin(p.x * 10.0) * sin(p.y * (3.0 + sin(time * 0.090909))) + 0.2; \n}\n\nmat2 rotate(float angle)\n{\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\n\nfloat fbm(vec2 p)\n{\n  p *= 1.1;\n  float f = 0.0;\n  float amp = 0.5 * uNoiseAmp;\n  \n  mat2 modify0 = rotate(time * 0.02);\n  f += amp * noise(p);\n  p = modify0 * p * 2.0;\n  amp *= 0.454545;\n  \n  mat2 modify1 = rotate(time * 0.02);\n  f += amp * noise(p);\n  p = modify1 * p * 2.0;\n  amp *= 0.454545;\n  \n  mat2 modify2 = rotate(time * 0.08);\n  f += amp * noise(p);\n  \n  return f;\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n  vec2 offset1 = vec2(1.0);\n  vec2 offset0 = vec2(0.0);\n  mat2 rot01 = rotate(0.1 * time);\n  mat2 rot1 = rotate(0.1);\n  \n  q = vec2(fbm(p + offset1), fbm(rot01 * p + offset1));\n  r = vec2(fbm(rot1 * q + offset0), fbm(q + offset0));\n  return fbm(p + r);\n}\n\nfloat digit(vec2 p){\n    vec2 grid = uGridMul * 15.0;\n    vec2 s = floor(p * grid) / grid;\n    p = p * grid;\n    vec2 q, r;\n    float intensity = pattern(s * 0.1, q, r) * 1.3 - 0.03;\n    \n    if(uUseMouse > 0.5){\n        vec2 mouseWorld = uMouse * uScale;\n        float distToMouse = distance(s, mouseWorld);\n        float mouseInfluence = exp(-distToMouse * 8.0) * uMouseStrength * 10.0;\n        intensity += mouseInfluence;\n        \n        float ripple = sin(distToMouse * 20.0 - iTime * 5.0) * 0.1 * mouseInfluence;\n        intensity += ripple;\n    }\n    \n    if(uUsePageLoadAnimation > 0.5){\n        float cellRandom = fract(sin(dot(s, vec2(12.9898, 78.233))) * 43758.5453);\n        float cellDelay = cellRandom * 0.8;\n        float cellProgress = clamp((uPageLoadProgress - cellDelay) / 0.2, 0.0, 1.0);\n        \n        float fadeAlpha = smoothstep(0.0, 1.0, cellProgress);\n        intensity *= fadeAlpha;\n    }\n    \n    p = fract(p);\n    p *= uDigitSize;\n    \n    float px5 = p.x * 5.0;\n    float py5 = (1.0 - p.y) * 5.0;\n    float x = fract(px5);\n    float y = fract(py5);\n    \n    float i = floor(py5) - 2.0;\n    float j = floor(px5) - 2.0;\n    float n = i * i + j * j;\n    float f = n * 0.0625;\n    \n    float isOn = step(0.1, intensity - f);\n    float brightness = isOn * (0.2 + y * 0.8) * (0.75 + x * 0.25);\n    \n    return step(0.0, p.x) * step(p.x, 1.0) * step(0.0, p.y) * step(p.y, 1.0) * brightness;\n}\n\nfloat onOff(float a, float b, float c)\n{\n  return step(c, sin(iTime + a * cos(iTime * b))) * uFlickerAmount;\n}\n\nfloat displace(vec2 look)\n{\n    float y = look.y - mod(iTime * 0.25, 1.0);\n    float window = 1.0 / (1.0 + 50.0 * y * y);\n    return sin(look.y * 20.0 + iTime) * 0.0125 * onOff(4.0, 2.0, 0.8) * (1.0 + cos(iTime * 60.0)) * window;\n}\n\nvec3 getColor(vec2 p){\n    \n    float bar = step(mod(p.y + time * 20.0, 1.0), 0.2) * 0.4 + 1.0;\n    bar *= uScanlineIntensity;\n    \n    float displacement = displace(p);\n    p.x += displacement;\n\n    if (uGlitchAmount != 1.0) {\n      float extra = displacement * (uGlitchAmount - 1.0);\n      p.x += extra;\n    }\n\n    float middle = digit(p);\n    \n    const float off = 0.002;\n    float sum = digit(p + vec2(-off, -off)) + digit(p + vec2(0.0, -off)) + digit(p + vec2(off, -off)) +\n                digit(p + vec2(-off, 0.0)) + digit(p + vec2(0.0, 0.0)) + digit(p + vec2(off, 0.0)) +\n                digit(p + vec2(-off, off)) + digit(p + vec2(0.0, off)) + digit(p + vec2(off, off));\n    \n    vec3 baseColor = vec3(0.9) * middle + sum * 0.1 * vec3(1.0) * bar;\n    return baseColor;\n}\n\nvec2 barrel(vec2 uv){\n  vec2 c = uv * 2.0 - 1.0;\n  float r2 = dot(c, c);\n  c *= 1.0 + uCurvature * r2;\n  return c * 0.5 + 0.5;\n}\n\nvoid main() {\n    time = iTime * 0.333333;\n    vec2 uv = vUv;\n\n    if(uCurvature != 0.0){\n      uv = barrel(uv);\n    }\n    \n    vec2 p = uv * uScale;\n    vec3 col = getColor(p);\n\n    if(uChromaticAberration != 0.0){\n      vec2 ca = vec2(uChromaticAberration) / iResolution.xy;\n      col.r = getColor(p + ca).r;\n      col.b = getColor(p - ca).b;\n    }\n\n    col *= uTint;\n    col *= uBrightness;\n\n    if(uDither > 0.0){\n      float rnd = hash21(gl_FragCoord.xy);\n      col += (rnd - 0.5) * (uDither * 0.003922);\n    }\n\n    gl_FragColor = vec4(col, 1.0);\n}\n`;\n\nfunction hexToRgb(hex: string): [number, number, number] {\n  let h = hex.replace('#', '').trim();\n  if (h.length === 3)\n    h = h\n      .split('')\n      .map(c => c + c)\n      .join('');\n  const num = parseInt(h, 16);\n  return [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];\n}\n\nexport default function FaultyTerminal({\n  scale = 1,\n  gridMul = [2, 1],\n  digitSize = 1.5,\n  timeScale = 0.3,\n  pause = false,\n  scanlineIntensity = 0.3,\n  glitchAmount = 1,\n  flickerAmount = 1,\n  noiseAmp = 1,\n  chromaticAberration = 0,\n  dither = 0,\n  curvature = 0.2,\n  tint = '#ffffff',\n  mouseReact = true,\n  mouseStrength = 0.2,\n  dpr = Math.min(window.devicePixelRatio || 1, 2),\n  pageLoadAnimation = true,\n  brightness = 1,\n  className,\n  style,\n  ...rest\n}: FaultyTerminalProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const programRef = useRef<Program>(null);\n  const rendererRef = useRef<Renderer>(null);\n  const mouseRef = useRef({ x: 0.5, y: 0.5 });\n  const smoothMouseRef = useRef({ x: 0.5, y: 0.5 });\n  const frozenTimeRef = useRef(0);\n  const rafRef = useRef<number>(0);\n  const loadAnimationStartRef = useRef<number>(0);\n  const timeOffsetRef = useRef<number>(Math.random() * 100);\n\n  const tintVec = useMemo(() => hexToRgb(tint), [tint]);\n\n  const ditherValue = useMemo(() => (typeof dither === 'boolean' ? (dither ? 1 : 0) : dither), [dither]);\n\n  const handleMouseMove = useCallback((e: MouseEvent) => {\n    const ctn = containerRef.current;\n    if (!ctn) return;\n    const rect = ctn.getBoundingClientRect();\n    const x = (e.clientX - rect.left) / rect.width;\n    const y = 1 - (e.clientY - rect.top) / rect.height;\n    mouseRef.current = { x, y };\n  }, []);\n\n  useEffect(() => {\n    const ctn = containerRef.current;\n    if (!ctn) return;\n\n    const renderer = new Renderer({ dpr });\n    rendererRef.current = renderer;\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 1);\n\n    const geometry = new Triangle(gl);\n\n    const program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: {\n          value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n        },\n        uScale: { value: scale },\n\n        uGridMul: { value: new Float32Array(gridMul) },\n        uDigitSize: { value: digitSize },\n        uScanlineIntensity: { value: scanlineIntensity },\n        uGlitchAmount: { value: glitchAmount },\n        uFlickerAmount: { value: flickerAmount },\n        uNoiseAmp: { value: noiseAmp },\n        uChromaticAberration: { value: chromaticAberration },\n        uDither: { value: ditherValue },\n        uCurvature: { value: curvature },\n        uTint: { value: new Color(tintVec[0], tintVec[1], tintVec[2]) },\n        uMouse: {\n          value: new Float32Array([smoothMouseRef.current.x, smoothMouseRef.current.y])\n        },\n        uMouseStrength: { value: mouseStrength },\n        uUseMouse: { value: mouseReact ? 1 : 0 },\n        uPageLoadProgress: { value: pageLoadAnimation ? 0 : 1 },\n        uUsePageLoadAnimation: { value: pageLoadAnimation ? 1 : 0 },\n        uBrightness: { value: brightness }\n      }\n    });\n    programRef.current = program;\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    function resize() {\n      if (!ctn || !renderer) return;\n      renderer.setSize(ctn.offsetWidth, ctn.offsetHeight);\n      program.uniforms.iResolution.value = new Color(\n        gl.canvas.width,\n        gl.canvas.height,\n        gl.canvas.width / gl.canvas.height\n      );\n    }\n\n    const resizeObserver = new ResizeObserver(() => resize());\n    resizeObserver.observe(ctn);\n    resize();\n\n    const update = (t: number) => {\n      rafRef.current = requestAnimationFrame(update);\n\n      if (pageLoadAnimation && loadAnimationStartRef.current === 0) {\n        loadAnimationStartRef.current = t;\n      }\n\n      if (!pause) {\n        const elapsed = (t * 0.001 + timeOffsetRef.current) * timeScale;\n        program.uniforms.iTime.value = elapsed;\n        frozenTimeRef.current = elapsed;\n      } else {\n        program.uniforms.iTime.value = frozenTimeRef.current;\n      }\n\n      if (pageLoadAnimation && loadAnimationStartRef.current > 0) {\n        const animationDuration = 2000;\n        const animationElapsed = t - loadAnimationStartRef.current;\n        const progress = Math.min(animationElapsed / animationDuration, 1);\n        program.uniforms.uPageLoadProgress.value = progress;\n      }\n\n      if (mouseReact) {\n        const dampingFactor = 0.08;\n        const smoothMouse = smoothMouseRef.current;\n        const mouse = mouseRef.current;\n        smoothMouse.x += (mouse.x - smoothMouse.x) * dampingFactor;\n        smoothMouse.y += (mouse.y - smoothMouse.y) * dampingFactor;\n\n        const mouseUniform = program.uniforms.uMouse.value as Float32Array;\n        mouseUniform[0] = smoothMouse.x;\n        mouseUniform[1] = smoothMouse.y;\n      }\n\n      renderer.render({ scene: mesh });\n    };\n    rafRef.current = requestAnimationFrame(update);\n    ctn.appendChild(gl.canvas);\n\n    if (mouseReact) ctn.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      cancelAnimationFrame(rafRef.current);\n      resizeObserver.disconnect();\n      if (mouseReact) ctn.removeEventListener('mousemove', handleMouseMove);\n      if (gl.canvas.parentElement === ctn) ctn.removeChild(gl.canvas);\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n      loadAnimationStartRef.current = 0;\n      timeOffsetRef.current = Math.random() * 100;\n    };\n  }, [\n    dpr,\n    pause,\n    timeScale,\n    scale,\n    gridMul,\n    digitSize,\n    scanlineIntensity,\n    glitchAmount,\n    flickerAmount,\n    noiseAmp,\n    chromaticAberration,\n    ditherValue,\n    curvature,\n    tintVec,\n    mouseReact,\n    mouseStrength,\n    pageLoadAnimation,\n    brightness,\n    handleMouseMove\n  ]);\n\n  return (\n    <div ref={containerRef} className={`w-full h-full relative overflow-hidden ${className}`} style={style} {...rest} />\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "flickering-grid",
      "type": "component",
      "description": "A backgrounds flickering grid component",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/flickering-grid.tsx",
          "content": "\"use client\"\n\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface FlickeringGridProps extends React.HTMLAttributes<HTMLDivElement> {\n  squareSize?: number\n  gridGap?: number\n  flickerChance?: number\n  color?: string\n  width?: number\n  height?: number\n  className?: string\n  maxOpacity?: number\n}\n\nexport const FlickeringGrid: React.FC<FlickeringGridProps> = ({\n  squareSize = 4,\n  gridGap = 6,\n  flickerChance = 0.3,\n  color = \"rgb(0, 0, 0)\",\n  width,\n  height,\n  className,\n  maxOpacity = 0.3,\n  ...props\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const [isInView, setIsInView] = useState(false)\n  const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 })\n\n  const memoizedColor = useMemo(() => {\n    const toRGBA = (color: string) => {\n      if (typeof window === \"undefined\") {\n        return `rgba(0, 0, 0,`\n      }\n      const canvas = document.createElement(\"canvas\")\n      canvas.width = canvas.height = 1\n      const ctx = canvas.getContext(\"2d\")\n      if (!ctx) return \"rgba(255, 0, 0,\"\n      ctx.fillStyle = color\n      ctx.fillRect(0, 0, 1, 1)\n      const [r, g, b] = Array.from(ctx.getImageData(0, 0, 1, 1).data)\n      return `rgba(${r}, ${g}, ${b},`\n    }\n    return toRGBA(color)\n  }, [color])\n\n  const setupCanvas = useCallback(\n    (canvas: HTMLCanvasElement, width: number, height: number) => {\n      const dpr = window.devicePixelRatio || 1\n      canvas.width = width * dpr\n      canvas.height = height * dpr\n      canvas.style.width = `${width}px`\n      canvas.style.height = `${height}px`\n      const cols = Math.floor(width / (squareSize + gridGap))\n      const rows = Math.floor(height / (squareSize + gridGap))\n\n      const squares = new Float32Array(cols * rows)\n      for (let i = 0; i < squares.length; i++) {\n        squares[i] = Math.random() * maxOpacity\n      }\n\n      return { cols, rows, squares, dpr }\n    },\n    [squareSize, gridGap, maxOpacity]\n  )\n\n  const updateSquares = useCallback(\n    (squares: Float32Array, deltaTime: number) => {\n      for (let i = 0; i < squares.length; i++) {\n        if (Math.random() < flickerChance * deltaTime) {\n          squares[i] = Math.random() * maxOpacity\n        }\n      }\n    },\n    [flickerChance, maxOpacity]\n  )\n\n  const drawGrid = useCallback(\n    (\n      ctx: CanvasRenderingContext2D,\n      width: number,\n      height: number,\n      cols: number,\n      rows: number,\n      squares: Float32Array,\n      dpr: number\n    ) => {\n      ctx.clearRect(0, 0, width, height)\n      ctx.fillStyle = \"transparent\"\n      ctx.fillRect(0, 0, width, height)\n\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < rows; j++) {\n          const opacity = squares[i * rows + j]\n          ctx.fillStyle = `${memoizedColor}${opacity})`\n          ctx.fillRect(\n            i * (squareSize + gridGap) * dpr,\n            j * (squareSize + gridGap) * dpr,\n            squareSize * dpr,\n            squareSize * dpr\n          )\n        }\n      }\n    },\n    [memoizedColor, squareSize, gridGap]\n  )\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    const container = containerRef.current\n    if (!canvas || !container) return\n\n    const ctx = canvas.getContext(\"2d\")\n    if (!ctx) return\n\n    let animationFrameId: number\n    let gridParams: ReturnType<typeof setupCanvas>\n\n    const updateCanvasSize = () => {\n      const newWidth = width || container.clientWidth\n      const newHeight = height || container.clientHeight\n      setCanvasSize({ width: newWidth, height: newHeight })\n      gridParams = setupCanvas(canvas, newWidth, newHeight)\n    }\n\n    updateCanvasSize()\n\n    let lastTime = 0\n    const animate = (time: number) => {\n      if (!isInView) return\n\n      const deltaTime = (time - lastTime) / 1000\n      lastTime = time\n\n      updateSquares(gridParams.squares, deltaTime)\n      drawGrid(\n        ctx,\n        canvas.width,\n        canvas.height,\n        gridParams.cols,\n        gridParams.rows,\n        gridParams.squares,\n        gridParams.dpr\n      )\n      animationFrameId = requestAnimationFrame(animate)\n    }\n\n    const resizeObserver = new ResizeObserver(() => {\n      updateCanvasSize()\n    })\n\n    resizeObserver.observe(container)\n\n    const intersectionObserver = new IntersectionObserver(\n      ([entry]) => {\n        setIsInView(entry.isIntersecting)\n      },\n      { threshold: 0 }\n    )\n\n    intersectionObserver.observe(canvas)\n\n    if (isInView) {\n      animationFrameId = requestAnimationFrame(animate)\n    }\n\n    return () => {\n      cancelAnimationFrame(animationFrameId)\n      resizeObserver.disconnect()\n      intersectionObserver.disconnect()\n    }\n  }, [setupCanvas, updateSquares, drawGrid, width, height, isInView])\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(`h-full w-full ${className}`)}\n      {...props}\n    >\n      <canvas\n        ref={canvasRef}\n        className=\"pointer-events-none\"\n        style={{\n          width: canvasSize.width,\n          height: canvasSize.height,\n        }}\n      />\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "backgrounds"
        ]
      }
    },
    {
      "name": "floating-lines",
      "type": "component",
      "description": "Animated floating lines background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/floating-lines.tsx",
          "content": "import { useEffect, useRef } from 'react';\nimport {\n  Scene,\n  OrthographicCamera,\n  WebGLRenderer,\n  PlaneGeometry,\n  Mesh,\n  ShaderMaterial,\n  Vector3,\n  Vector2,\n  Clock\n} from 'three';\n\nconst vertexShader = `\nprecision highp float;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\nuniform float iTime;\nuniform vec3  iResolution;\nuniform float animationSpeed;\n\nuniform bool enableTop;\nuniform bool enableMiddle;\nuniform bool enableBottom;\n\nuniform int topLineCount;\nuniform int middleLineCount;\nuniform int bottomLineCount;\n\nuniform float topLineDistance;\nuniform float middleLineDistance;\nuniform float bottomLineDistance;\n\nuniform vec3 topWavePosition;\nuniform vec3 middleWavePosition;\nuniform vec3 bottomWavePosition;\n\nuniform vec2 iMouse;\nuniform bool interactive;\nuniform float bendRadius;\nuniform float bendStrength;\nuniform float bendInfluence;\n\nuniform bool parallax;\nuniform float parallaxStrength;\nuniform vec2 parallaxOffset;\n\nuniform vec3 lineGradient[8];\nuniform int lineGradientCount;\n\nconst vec3 BLACK = vec3(0.0);\nconst vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;\nconst vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;\n\nmat2 rotate(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 background_color(vec2 uv) {\n  vec3 col = vec3(0.0);\n\n  float y = sin(uv.x - 0.2) * 0.3 - 0.1;\n  float m = uv.y - y;\n\n  col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));\n  col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));\n  return col * 0.5;\n}\n\nvec3 getLineColor(float t, vec3 baseColor) {\n  if (lineGradientCount <= 0) {\n    return baseColor;\n  }\n\n  vec3 gradientColor;\n  \n  if (lineGradientCount == 1) {\n    gradientColor = lineGradient[0];\n  } else {\n    float clampedT = clamp(t, 0.0, 0.9999);\n    float scaled = clampedT * float(lineGradientCount - 1);\n    int idx = int(floor(scaled));\n    float f = fract(scaled);\n    int idx2 = min(idx + 1, lineGradientCount - 1);\n\n    vec3 c1 = lineGradient[idx];\n    vec3 c2 = lineGradient[idx2];\n    \n    gradientColor = mix(c1, c2, f);\n  }\n  \n  return gradientColor * 0.5;\n}\n\n  float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {\n  float time = iTime * animationSpeed;\n\n  float x_offset   = offset;\n  float x_movement = time * 0.1;\n  float amp        = sin(offset + time * 0.2) * 0.3;\n  float y          = sin(uv.x + x_offset + x_movement) * amp;\n\n  if (shouldBend) {\n    vec2 d = screenUv - mouseUv;\n    float influence = exp(-dot(d, d) * bendRadius); // radial falloff around cursor\n    float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;\n    y += bendOffset;\n  }\n\n  float m = uv.y - y;\n  return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  baseUv.y *= -1.0;\n  \n  if (parallax) {\n    baseUv += parallaxOffset;\n  }\n\n  vec3 col = vec3(0.0);\n\n  vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);\n\n  vec2 mouseUv = vec2(0.0);\n  if (interactive) {\n    mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;\n    mouseUv.y *= -1.0;\n  }\n  \n  if (enableBottom) {\n    for (int i = 0; i < bottomLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(bottomLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),\n        1.5 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.2;\n    }\n  }\n\n  if (enableMiddle) {\n    for (int i = 0; i < middleLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(middleLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = middleWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),\n        2.0 + 0.15 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      );\n    }\n  }\n\n  if (enableTop) {\n    for (int i = 0; i < topLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(topLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = topWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      ruv.x *= -1.0;\n      col += lineCol * wave(\n        ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),\n        1.0 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.1;\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor = color;\n}\n`;\n\nconst MAX_GRADIENT_STOPS = 8;\n\ntype WavePosition = {\n  x: number;\n  y: number;\n  rotate: number;\n};\n\ntype FloatingLinesProps = {\n  linesGradient?: string[];\n  enabledWaves?: Array<'top' | 'middle' | 'bottom'>;\n  lineCount?: number | number[];\n  lineDistance?: number | number[];\n  topWavePosition?: WavePosition;\n  middleWavePosition?: WavePosition;\n  bottomWavePosition?: WavePosition;\n  animationSpeed?: number;\n  interactive?: boolean;\n  bendRadius?: number;\n  bendStrength?: number;\n  mouseDamping?: number;\n  parallax?: boolean;\n  parallaxStrength?: number;\n  mixBlendMode?: React.CSSProperties['mixBlendMode'];\n};\n\nfunction hexToVec3(hex: string): Vector3 {\n  let value = hex.trim();\n\n  if (value.startsWith('#')) {\n    value = value.slice(1);\n  }\n\n  let r = 255;\n  let g = 255;\n  let b = 255;\n\n  if (value.length === 3) {\n    r = parseInt(value[0] + value[0], 16);\n    g = parseInt(value[1] + value[1], 16);\n    b = parseInt(value[2] + value[2], 16);\n  } else if (value.length === 6) {\n    r = parseInt(value.slice(0, 2), 16);\n    g = parseInt(value.slice(2, 4), 16);\n    b = parseInt(value.slice(4, 6), 16);\n  }\n\n  return new Vector3(r / 255, g / 255, b / 255);\n}\n\nexport default function FloatingLines({\n  linesGradient,\n  enabledWaves = ['top', 'middle', 'bottom'],\n  lineCount = [6],\n  lineDistance = [5],\n  topWavePosition,\n  middleWavePosition,\n  bottomWavePosition = { x: 2.0, y: -0.7, rotate: -1 },\n  animationSpeed = 1,\n  interactive = true,\n  bendRadius = 5.0,\n  bendStrength = -0.5,\n  mouseDamping = 0.05,\n  parallax = true,\n  parallaxStrength = 0.2,\n  mixBlendMode = 'screen'\n}: FloatingLinesProps) {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const targetMouseRef = useRef<Vector2>(new Vector2(-1000, -1000));\n  const currentMouseRef = useRef<Vector2>(new Vector2(-1000, -1000));\n  const targetInfluenceRef = useRef<number>(0);\n  const currentInfluenceRef = useRef<number>(0);\n  const targetParallaxRef = useRef<Vector2>(new Vector2(0, 0));\n  const currentParallaxRef = useRef<Vector2>(new Vector2(0, 0));\n\n  const getLineCount = (waveType: 'top' | 'middle' | 'bottom'): number => {\n    if (typeof lineCount === 'number') return lineCount;\n    if (!enabledWaves.includes(waveType)) return 0;\n    const index = enabledWaves.indexOf(waveType);\n    return lineCount[index] ?? 6;\n  };\n\n  const getLineDistance = (waveType: 'top' | 'middle' | 'bottom'): number => {\n    if (typeof lineDistance === 'number') return lineDistance;\n    if (!enabledWaves.includes(waveType)) return 0.1;\n    const index = enabledWaves.indexOf(waveType);\n    return lineDistance[index] ?? 0.1;\n  };\n\n  const topLineCount = enabledWaves.includes('top') ? getLineCount('top') : 0;\n  const middleLineCount = enabledWaves.includes('middle') ? getLineCount('middle') : 0;\n  const bottomLineCount = enabledWaves.includes('bottom') ? getLineCount('bottom') : 0;\n\n  const topLineDistance = enabledWaves.includes('top') ? getLineDistance('top') * 0.01 : 0.01;\n  const middleLineDistance = enabledWaves.includes('middle') ? getLineDistance('middle') * 0.01 : 0.01;\n  const bottomLineDistance = enabledWaves.includes('bottom') ? getLineDistance('bottom') * 0.01 : 0.01;\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const scene = new Scene();\n\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    camera.position.z = 1;\n\n    const renderer = new WebGLRenderer({ antialias: true, alpha: false });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n    renderer.domElement.style.width = '100%';\n    renderer.domElement.style.height = '100%';\n    containerRef.current.appendChild(renderer.domElement);\n\n    const uniforms = {\n      iTime: { value: 0 },\n      iResolution: { value: new Vector3(1, 1, 1) },\n      animationSpeed: { value: animationSpeed },\n\n      enableTop: { value: enabledWaves.includes('top') },\n      enableMiddle: { value: enabledWaves.includes('middle') },\n      enableBottom: { value: enabledWaves.includes('bottom') },\n\n      topLineCount: { value: topLineCount },\n      middleLineCount: { value: middleLineCount },\n      bottomLineCount: { value: bottomLineCount },\n\n      topLineDistance: { value: topLineDistance },\n      middleLineDistance: { value: middleLineDistance },\n      bottomLineDistance: { value: bottomLineDistance },\n\n      topWavePosition: {\n        value: new Vector3(topWavePosition?.x ?? 10.0, topWavePosition?.y ?? 0.5, topWavePosition?.rotate ?? -0.4)\n      },\n      middleWavePosition: {\n        value: new Vector3(\n          middleWavePosition?.x ?? 5.0,\n          middleWavePosition?.y ?? 0.0,\n          middleWavePosition?.rotate ?? 0.2\n        )\n      },\n      bottomWavePosition: {\n        value: new Vector3(\n          bottomWavePosition?.x ?? 2.0,\n          bottomWavePosition?.y ?? -0.7,\n          bottomWavePosition?.rotate ?? 0.4\n        )\n      },\n\n      iMouse: { value: new Vector2(-1000, -1000) },\n      interactive: { value: interactive },\n      bendRadius: { value: bendRadius },\n      bendStrength: { value: bendStrength },\n      bendInfluence: { value: 0 },\n\n      parallax: { value: parallax },\n      parallaxStrength: { value: parallaxStrength },\n      parallaxOffset: { value: new Vector2(0, 0) },\n\n      lineGradient: {\n        value: Array.from({ length: MAX_GRADIENT_STOPS }, () => new Vector3(1, 1, 1))\n      },\n      lineGradientCount: { value: 0 }\n    };\n\n    if (linesGradient && linesGradient.length > 0) {\n      const stops = linesGradient.slice(0, MAX_GRADIENT_STOPS);\n      uniforms.lineGradientCount.value = stops.length;\n\n      stops.forEach((hex, i) => {\n        const color = hexToVec3(hex);\n        uniforms.lineGradient.value[i].set(color.x, color.y, color.z);\n      });\n    }\n\n    const material = new ShaderMaterial({\n      uniforms,\n      vertexShader,\n      fragmentShader\n    });\n\n    const geometry = new PlaneGeometry(2, 2);\n    const mesh = new Mesh(geometry, material);\n    scene.add(mesh);\n\n    const clock = new Clock();\n\n    const setSize = () => {\n      const el = containerRef.current!;\n      const width = el.clientWidth || 1;\n      const height = el.clientHeight || 1;\n\n      renderer.setSize(width, height, false);\n\n      const canvasWidth = renderer.domElement.width;\n      const canvasHeight = renderer.domElement.height;\n      uniforms.iResolution.value.set(canvasWidth, canvasHeight, 1);\n    };\n\n    setSize();\n\n    const ro = typeof ResizeObserver !== 'undefined' ? new ResizeObserver(setSize) : null;\n\n    if (ro && containerRef.current) {\n      ro.observe(containerRef.current);\n    }\n\n    const handlePointerMove = (event: PointerEvent) => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const dpr = renderer.getPixelRatio();\n\n      targetMouseRef.current.set(x * dpr, (rect.height - y) * dpr);\n      targetInfluenceRef.current = 1.0;\n\n      if (parallax) {\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const offsetX = (x - centerX) / rect.width;\n        const offsetY = -(y - centerY) / rect.height;\n        targetParallaxRef.current.set(offsetX * parallaxStrength, offsetY * parallaxStrength);\n      }\n    };\n\n    const handlePointerLeave = () => {\n      targetInfluenceRef.current = 0.0;\n    };\n\n    if (interactive) {\n      renderer.domElement.addEventListener('pointermove', handlePointerMove);\n      renderer.domElement.addEventListener('pointerleave', handlePointerLeave);\n    }\n\n    let raf = 0;\n    const renderLoop = () => {\n      uniforms.iTime.value = clock.getElapsedTime();\n\n      if (interactive) {\n        currentMouseRef.current.lerp(targetMouseRef.current, mouseDamping);\n        uniforms.iMouse.value.copy(currentMouseRef.current);\n\n        currentInfluenceRef.current += (targetInfluenceRef.current - currentInfluenceRef.current) * mouseDamping;\n        uniforms.bendInfluence.value = currentInfluenceRef.current;\n      }\n\n      if (parallax) {\n        currentParallaxRef.current.lerp(targetParallaxRef.current, mouseDamping);\n        uniforms.parallaxOffset.value.copy(currentParallaxRef.current);\n      }\n\n      renderer.render(scene, camera);\n      raf = requestAnimationFrame(renderLoop);\n    };\n    renderLoop();\n\n    return () => {\n      cancelAnimationFrame(raf);\n      if (ro && containerRef.current) {\n        ro.disconnect();\n      }\n\n      if (interactive) {\n        renderer.domElement.removeEventListener('pointermove', handlePointerMove);\n        renderer.domElement.removeEventListener('pointerleave', handlePointerLeave);\n      }\n\n      geometry.dispose();\n      material.dispose();\n      renderer.dispose();\n      if (renderer.domElement.parentElement) {\n        renderer.domElement.parentElement.removeChild(renderer.domElement);\n      }\n    };\n  }, [\n    linesGradient,\n    enabledWaves,\n    lineCount,\n    lineDistance,\n    topWavePosition,\n    middleWavePosition,\n    bottomWavePosition,\n    animationSpeed,\n    interactive,\n    bendRadius,\n    bendStrength,\n    mouseDamping,\n    parallax,\n    parallaxStrength\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"w-full h-full relative overflow-hidden floating-lines-container\"\n      style={{\n        mixBlendMode: mixBlendMode\n      }}\n    />\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "galaxy",
      "type": "component",
      "description": "A swirling galaxy background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/galaxy.tsx",
          "content": "import { Renderer, Program, Mesh, Color, Triangle } from 'ogl';\nimport { useEffect, useRef } from 'react';\n\nconst vertexShader = `\nattribute vec2 uv;\nattribute vec2 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0, 1);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\nuniform float uTime;\nuniform vec3 uResolution;\nuniform vec2 uFocal;\nuniform vec2 uRotation;\nuniform float uStarSpeed;\nuniform float uDensity;\nuniform float uHueShift;\nuniform float uSpeed;\nuniform vec2 uMouse;\nuniform float uGlowIntensity;\nuniform float uSaturation;\nuniform bool uMouseRepulsion;\nuniform float uTwinkleIntensity;\nuniform float uRotationSpeed;\nuniform float uRepulsionStrength;\nuniform float uMouseActiveFactor;\nuniform float uAutoCenterRepulsion;\nuniform bool uTransparent;\n\nvarying vec2 vUv;\n\n#define NUM_LAYER 4.0\n#define STAR_COLOR_CUTOFF 0.2\n#define MAT45 mat2(0.7071, -0.7071, 0.7071, 0.7071)\n#define PERIOD 3.0\n\nfloat Hash21(vec2 p) {\n  p = fract(p * vec2(123.34, 456.21));\n  p += dot(p, p + 45.32);\n  return fract(p.x * p.y);\n}\n\nfloat tri(float x) {\n  return abs(fract(x) * 2.0 - 1.0);\n}\n\nfloat tris(float x) {\n  float t = fract(x);\n  return 1.0 - smoothstep(0.0, 1.0, abs(2.0 * t - 1.0));\n}\n\nfloat trisn(float x) {\n  float t = fract(x);\n  return 2.0 * (1.0 - smoothstep(0.0, 1.0, abs(2.0 * t - 1.0))) - 1.0;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat Star(vec2 uv, float flare) {\n  float d = length(uv);\n  float m = (0.05 * uGlowIntensity) / d;\n  float rays = smoothstep(0.0, 1.0, 1.0 - abs(uv.x * uv.y * 1000.0));\n  m += rays * flare * uGlowIntensity;\n  uv *= MAT45;\n  rays = smoothstep(0.0, 1.0, 1.0 - abs(uv.x * uv.y * 1000.0));\n  m += rays * 0.3 * flare * uGlowIntensity;\n  m *= smoothstep(1.0, 0.2, d);\n  return m;\n}\n\nvec3 StarLayer(vec2 uv) {\n  vec3 col = vec3(0.0);\n\n  vec2 gv = fract(uv) - 0.5; \n  vec2 id = floor(uv);\n\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 offset = vec2(float(x), float(y));\n      vec2 si = id + vec2(float(x), float(y));\n      float seed = Hash21(si);\n      float size = fract(seed * 345.32);\n      float glossLocal = tri(uStarSpeed / (PERIOD * seed + 1.0));\n      float flareSize = smoothstep(0.9, 1.0, size) * glossLocal;\n\n      float red = smoothstep(STAR_COLOR_CUTOFF, 1.0, Hash21(si + 1.0)) + STAR_COLOR_CUTOFF;\n      float blu = smoothstep(STAR_COLOR_CUTOFF, 1.0, Hash21(si + 3.0)) + STAR_COLOR_CUTOFF;\n      float grn = min(red, blu) * seed;\n      vec3 base = vec3(red, grn, blu);\n      \n      float hue = atan(base.g - base.r, base.b - base.r) / (2.0 * 3.14159) + 0.5;\n      hue = fract(hue + uHueShift / 360.0);\n      float sat = length(base - vec3(dot(base, vec3(0.299, 0.587, 0.114)))) * uSaturation;\n      float val = max(max(base.r, base.g), base.b);\n      base = hsv2rgb(vec3(hue, sat, val));\n\n      vec2 pad = vec2(tris(seed * 34.0 + uTime * uSpeed / 10.0), tris(seed * 38.0 + uTime * uSpeed / 30.0)) - 0.5;\n\n      float star = Star(gv - offset - pad, flareSize);\n      vec3 color = base;\n\n      float twinkle = trisn(uTime * uSpeed + seed * 6.2831) * 0.5 + 1.0;\n      twinkle = mix(1.0, twinkle, uTwinkleIntensity);\n      star *= twinkle;\n      \n      col += star * size * color;\n    }\n  }\n\n  return col;\n}\n\nvoid main() {\n  vec2 focalPx = uFocal * uResolution.xy;\n  vec2 uv = (vUv * uResolution.xy - focalPx) / uResolution.y;\n\n  vec2 mouseNorm = uMouse - vec2(0.5);\n  \n  if (uAutoCenterRepulsion > 0.0) {\n    vec2 centerUV = vec2(0.0, 0.0);\n    float centerDist = length(uv - centerUV);\n    vec2 repulsion = normalize(uv - centerUV) * (uAutoCenterRepulsion / (centerDist + 0.1));\n    uv += repulsion * 0.05;\n  } else if (uMouseRepulsion) {\n    vec2 mousePosUV = (uMouse * uResolution.xy - focalPx) / uResolution.y;\n    float mouseDist = length(uv - mousePosUV);\n    vec2 repulsion = normalize(uv - mousePosUV) * (uRepulsionStrength / (mouseDist + 0.1));\n    uv += repulsion * 0.05 * uMouseActiveFactor;\n  } else {\n    vec2 mouseOffset = mouseNorm * 0.1 * uMouseActiveFactor;\n    uv += mouseOffset;\n  }\n\n  float autoRotAngle = uTime * uRotationSpeed;\n  mat2 autoRot = mat2(cos(autoRotAngle), -sin(autoRotAngle), sin(autoRotAngle), cos(autoRotAngle));\n  uv = autoRot * uv;\n\n  uv = mat2(uRotation.x, -uRotation.y, uRotation.y, uRotation.x) * uv;\n\n  vec3 col = vec3(0.0);\n\n  for (float i = 0.0; i < 1.0; i += 1.0 / NUM_LAYER) {\n    float depth = fract(i + uStarSpeed * uSpeed);\n    float scale = mix(20.0 * uDensity, 0.5 * uDensity, depth);\n    float fade = depth * smoothstep(1.0, 0.9, depth);\n    col += StarLayer(uv * scale + i * 453.32) * fade;\n  }\n\n  if (uTransparent) {\n    float alpha = length(col);\n    alpha = smoothstep(0.0, 0.3, alpha);\n    alpha = min(alpha, 1.0);\n    gl_FragColor = vec4(col, alpha);\n  } else {\n    gl_FragColor = vec4(col, 1.0);\n  }\n}\n`;\n\ninterface GalaxyProps {\n  focal?: [number, number];\n  rotation?: [number, number];\n  starSpeed?: number;\n  density?: number;\n  hueShift?: number;\n  disableAnimation?: boolean;\n  speed?: number;\n  mouseInteraction?: boolean;\n  glowIntensity?: number;\n  saturation?: number;\n  mouseRepulsion?: boolean;\n  twinkleIntensity?: number;\n  rotationSpeed?: number;\n  repulsionStrength?: number;\n  autoCenterRepulsion?: number;\n  transparent?: boolean;\n}\n\nexport default function Galaxy({\n  focal = [0.5, 0.5],\n  rotation = [1.0, 0.0],\n  starSpeed = 0.5,\n  density = 1,\n  hueShift = 140,\n  disableAnimation = false,\n  speed = 1.0,\n  mouseInteraction = true,\n  glowIntensity = 0.3,\n  saturation = 0.0,\n  mouseRepulsion = true,\n  repulsionStrength = 2,\n  twinkleIntensity = 0.3,\n  rotationSpeed = 0.1,\n  autoCenterRepulsion = 0,\n  transparent = true,\n  ...rest\n}: GalaxyProps) {\n  const ctnDom = useRef<HTMLDivElement>(null);\n  const targetMousePos = useRef({ x: 0.5, y: 0.5 });\n  const smoothMousePos = useRef({ x: 0.5, y: 0.5 });\n  const targetMouseActive = useRef(0.0);\n  const smoothMouseActive = useRef(0.0);\n\n  useEffect(() => {\n    if (!ctnDom.current) return;\n    const ctn = ctnDom.current;\n    const renderer = new Renderer({\n      alpha: transparent,\n      premultipliedAlpha: false\n    });\n    const gl = renderer.gl;\n\n    if (transparent) {\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      gl.clearColor(0, 0, 0, 0);\n    } else {\n      gl.clearColor(0, 0, 0, 1);\n    }\n\n    let program: Program;\n\n    function resize() {\n      const scale = 1;\n      renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n      if (program) {\n        program.uniforms.uResolution.value = new Color(\n          gl.canvas.width,\n          gl.canvas.height,\n          gl.canvas.width / gl.canvas.height\n        );\n      }\n    }\n    window.addEventListener('resize', resize, false);\n    resize();\n\n    const geometry = new Triangle(gl);\n    program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        uTime: { value: 0 },\n        uResolution: {\n          value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n        },\n        uFocal: { value: new Float32Array(focal) },\n        uRotation: { value: new Float32Array(rotation) },\n        uStarSpeed: { value: starSpeed },\n        uDensity: { value: density },\n        uHueShift: { value: hueShift },\n        uSpeed: { value: speed },\n        uMouse: {\n          value: new Float32Array([smoothMousePos.current.x, smoothMousePos.current.y])\n        },\n        uGlowIntensity: { value: glowIntensity },\n        uSaturation: { value: saturation },\n        uMouseRepulsion: { value: mouseRepulsion },\n        uTwinkleIntensity: { value: twinkleIntensity },\n        uRotationSpeed: { value: rotationSpeed },\n        uRepulsionStrength: { value: repulsionStrength },\n        uMouseActiveFactor: { value: 0.0 },\n        uAutoCenterRepulsion: { value: autoCenterRepulsion },\n        uTransparent: { value: transparent }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n    let animateId: number;\n\n    function update(t: number) {\n      animateId = requestAnimationFrame(update);\n      if (!disableAnimation) {\n        program.uniforms.uTime.value = t * 0.001;\n        program.uniforms.uStarSpeed.value = (t * 0.001 * starSpeed) / 10.0;\n      }\n\n      const lerpFactor = 0.05;\n      smoothMousePos.current.x += (targetMousePos.current.x - smoothMousePos.current.x) * lerpFactor;\n      smoothMousePos.current.y += (targetMousePos.current.y - smoothMousePos.current.y) * lerpFactor;\n\n      smoothMouseActive.current += (targetMouseActive.current - smoothMouseActive.current) * lerpFactor;\n\n      program.uniforms.uMouse.value[0] = smoothMousePos.current.x;\n      program.uniforms.uMouse.value[1] = smoothMousePos.current.y;\n      program.uniforms.uMouseActiveFactor.value = smoothMouseActive.current;\n\n      renderer.render({ scene: mesh });\n    }\n    animateId = requestAnimationFrame(update);\n    ctn.appendChild(gl.canvas);\n\n    function handleMouseMove(e: MouseEvent) {\n      const rect = ctn.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n      targetMousePos.current = { x, y };\n      targetMouseActive.current = 1.0;\n    }\n\n    function handleMouseLeave() {\n      targetMouseActive.current = 0.0;\n    }\n\n    if (mouseInteraction) {\n      ctn.addEventListener('mousemove', handleMouseMove);\n      ctn.addEventListener('mouseleave', handleMouseLeave);\n    }\n\n    return () => {\n      cancelAnimationFrame(animateId);\n      window.removeEventListener('resize', resize);\n      if (mouseInteraction) {\n        ctn.removeEventListener('mousemove', handleMouseMove);\n        ctn.removeEventListener('mouseleave', handleMouseLeave);\n      }\n      ctn.removeChild(gl.canvas);\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n    };\n  }, [\n    focal,\n    rotation,\n    starSpeed,\n    density,\n    hueShift,\n    disableAnimation,\n    speed,\n    mouseInteraction,\n    glowIntensity,\n    saturation,\n    mouseRepulsion,\n    twinkleIntensity,\n    rotationSpeed,\n    repulsionStrength,\n    autoCenterRepulsion,\n    transparent\n  ]);\n\n  return <div ref={ctnDom} className=\"w-full h-full relative\" {...rest} />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "gradient-blinds",
      "type": "component",
      "description": "Animated gradient blinds background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/gradient-blinds.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { Renderer, Program, Mesh, Triangle } from 'ogl';\n\nexport interface GradientBlindsProps {\n  className?: string;\n  dpr?: number;\n  paused?: boolean;\n  gradientColors?: string[];\n  angle?: number;\n  noise?: number;\n  blindCount?: number;\n  blindMinWidth?: number;\n  mouseDampening?: number;\n  mirrorGradient?: boolean;\n  spotlightRadius?: number;\n  spotlightSoftness?: number;\n  spotlightOpacity?: number;\n  distortAmount?: number;\n  shineDirection?: 'left' | 'right';\n  mixBlendMode?: string;\n}\n\nconst MAX_COLORS = 8;\nconst hexToRGB = (hex: string): [number, number, number] => {\n  const c = hex.replace('#', '').padEnd(6, '0');\n  const r = parseInt(c.slice(0, 2), 16) / 255;\n  const g = parseInt(c.slice(2, 4), 16) / 255;\n  const b = parseInt(c.slice(4, 6), 16) / 255;\n  return [r, g, b];\n};\nconst prepStops = (stops?: string[]) => {\n  const base = (stops && stops.length ? stops : ['#FF9FFC', '#5227FF']).slice(0, MAX_COLORS);\n  if (base.length === 1) base.push(base[0]);\n  while (base.length < MAX_COLORS) base.push(base[base.length - 1]);\n  const arr: [number, number, number][] = [];\n  for (let i = 0; i < MAX_COLORS; i++) arr.push(hexToRGB(base[i]));\n  const count = Math.max(2, Math.min(MAX_COLORS, stops?.length ?? 2));\n  return { arr, count };\n};\n\nconst GradientBlinds: React.FC<GradientBlindsProps> = ({\n  className,\n  dpr,\n  paused = false,\n  gradientColors,\n  angle = 0,\n  noise = 0.3,\n  blindCount = 16,\n  blindMinWidth = 60,\n  mouseDampening = 0.15,\n  mirrorGradient = false,\n  spotlightRadius = 0.5,\n  spotlightSoftness = 1,\n  spotlightOpacity = 1,\n  distortAmount = 0,\n  shineDirection = 'left',\n  mixBlendMode = 'lighten'\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const rafRef = useRef<number | null>(null);\n  const programRef = useRef<Program | null>(null);\n  const meshRef = useRef<Mesh<Triangle> | null>(null);\n  const geometryRef = useRef<Triangle | null>(null);\n  const rendererRef = useRef<Renderer | null>(null);\n  const mouseTargetRef = useRef<[number, number]>([0, 0]);\n  const lastTimeRef = useRef<number>(0);\n  const firstResizeRef = useRef<boolean>(true);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const renderer = new Renderer({\n      dpr: dpr ?? (typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1),\n      alpha: true,\n      antialias: true\n    });\n    rendererRef.current = renderer;\n    const gl = renderer.gl;\n    const canvas = gl.canvas as HTMLCanvasElement;\n\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.display = 'block';\n    container.appendChild(canvas);\n\n    const vertex = `\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\n    const fragment = `\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec3  iResolution;\nuniform vec2  iMouse;\nuniform float iTime;\n\nuniform float uAngle;\nuniform float uNoise;\nuniform float uBlindCount;\nuniform float uSpotlightRadius;\nuniform float uSpotlightSoftness;\nuniform float uSpotlightOpacity;\nuniform float uMirror;\nuniform float uDistort;\nuniform float uShineFlip;\nuniform vec3  uColor0;\nuniform vec3  uColor1;\nuniform vec3  uColor2;\nuniform vec3  uColor3;\nuniform vec3  uColor4;\nuniform vec3  uColor5;\nuniform vec3  uColor6;\nuniform vec3  uColor7;\nuniform int   uColorCount;\n\nvarying vec2 vUv;\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rotate2D(vec2 p, float a){\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c) * p;\n}\n\nvec3 getGradientColor(float t){\n  float tt = clamp(t, 0.0, 1.0);\n  int count = uColorCount;\n  if (count < 2) count = 2;\n  float scaled = tt * float(count - 1);\n  float seg = floor(scaled);\n  float f = fract(scaled);\n\n  if (seg < 1.0) return mix(uColor0, uColor1, f);\n  if (seg < 2.0 && count > 2) return mix(uColor1, uColor2, f);\n  if (seg < 3.0 && count > 3) return mix(uColor2, uColor3, f);\n  if (seg < 4.0 && count > 4) return mix(uColor3, uColor4, f);\n  if (seg < 5.0 && count > 5) return mix(uColor4, uColor5, f);\n  if (seg < 6.0 && count > 6) return mix(uColor5, uColor6, f);\n  if (seg < 7.0 && count > 7) return mix(uColor6, uColor7, f);\n  if (count > 7) return uColor7;\n  if (count > 6) return uColor6;\n  if (count > 5) return uColor5;\n  if (count > 4) return uColor4;\n  if (count > 3) return uColor3;\n  if (count > 2) return uColor2;\n  return uColor1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n    vec2 p = uv0 * 2.0 - 1.0;\n    p.x *= aspect;\n    vec2 pr = rotate2D(p, uAngle);\n    pr.x /= aspect;\n    vec2 uv = pr * 0.5 + 0.5;\n\n    vec2 uvMod = uv;\n    if (uDistort > 0.0) {\n      float a = uvMod.y * 6.0;\n      float b = uvMod.x * 6.0;\n      float w = 0.01 * uDistort;\n      uvMod.x += sin(a) * w;\n      uvMod.y += cos(b) * w;\n    }\n    float t = uvMod.x;\n    if (uMirror > 0.5) {\n      t = 1.0 - abs(1.0 - 2.0 * fract(t));\n    }\n    vec3 base = getGradientColor(t);\n\n    vec2 offset = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n  float d = length(uv0 - offset);\n  float r = max(uSpotlightRadius, 1e-4);\n  float dn = d / r;\n  float spot = (1.0 - 2.0 * pow(dn, uSpotlightSoftness)) * uSpotlightOpacity;\n  vec3 cir = vec3(spot);\n  float stripe = fract(uvMod.x * max(uBlindCount, 1.0));\n  if (uShineFlip > 0.5) stripe = 1.0 - stripe;\n    vec3 ran = vec3(stripe);\n\n    vec3 col = cir + base - ran;\n    col += (rand(gl_FragCoord.xy + iTime) - 0.5) * uNoise;\n\n    fragColor = vec4(col, 1.0);\n}\n\nvoid main() {\n    vec4 color;\n    mainImage(color, vUv * iResolution.xy);\n    gl_FragColor = color;\n}\n`;\n\n    const { arr: colorArr, count: colorCount } = prepStops(gradientColors);\n    const uniforms: {\n      iResolution: { value: [number, number, number] };\n      iMouse: { value: [number, number] };\n      iTime: { value: number };\n      uAngle: { value: number };\n      uNoise: { value: number };\n      uBlindCount: { value: number };\n      uSpotlightRadius: { value: number };\n      uSpotlightSoftness: { value: number };\n      uSpotlightOpacity: { value: number };\n      uMirror: { value: number };\n      uDistort: { value: number };\n      uShineFlip: { value: number };\n      uColor0: { value: [number, number, number] };\n      uColor1: { value: [number, number, number] };\n      uColor2: { value: [number, number, number] };\n      uColor3: { value: [number, number, number] };\n      uColor4: { value: [number, number, number] };\n      uColor5: { value: [number, number, number] };\n      uColor6: { value: [number, number, number] };\n      uColor7: { value: [number, number, number] };\n      uColorCount: { value: number };\n    } = {\n      iResolution: {\n        value: [gl.drawingBufferWidth, gl.drawingBufferHeight, 1]\n      },\n      iMouse: { value: [0, 0] },\n      iTime: { value: 0 },\n      uAngle: { value: (angle * Math.PI) / 180 },\n      uNoise: { value: noise },\n      uBlindCount: { value: Math.max(1, blindCount) },\n      uSpotlightRadius: { value: spotlightRadius },\n      uSpotlightSoftness: { value: spotlightSoftness },\n      uSpotlightOpacity: { value: spotlightOpacity },\n      uMirror: { value: mirrorGradient ? 1 : 0 },\n      uDistort: { value: distortAmount },\n      uShineFlip: { value: shineDirection === 'right' ? 1 : 0 },\n      uColor0: { value: colorArr[0] },\n      uColor1: { value: colorArr[1] },\n      uColor2: { value: colorArr[2] },\n      uColor3: { value: colorArr[3] },\n      uColor4: { value: colorArr[4] },\n      uColor5: { value: colorArr[5] },\n      uColor6: { value: colorArr[6] },\n      uColor7: { value: colorArr[7] },\n      uColorCount: { value: colorCount }\n    };\n\n    const program = new Program(gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    programRef.current = program;\n\n    const geometry = new Triangle(gl);\n    geometryRef.current = geometry;\n    const mesh = new Mesh(gl, { geometry, program });\n    meshRef.current = mesh;\n\n    const resize = () => {\n      const rect = container.getBoundingClientRect();\n      renderer.setSize(rect.width, rect.height);\n      uniforms.iResolution.value = [gl.drawingBufferWidth, gl.drawingBufferHeight, 1];\n\n      if (blindMinWidth && blindMinWidth > 0) {\n        const maxByMinWidth = Math.max(1, Math.floor(rect.width / blindMinWidth));\n\n        const effective = blindCount ? Math.min(blindCount, maxByMinWidth) : maxByMinWidth;\n        uniforms.uBlindCount.value = Math.max(1, effective);\n      } else {\n        uniforms.uBlindCount.value = Math.max(1, blindCount);\n      }\n\n      if (firstResizeRef.current) {\n        firstResizeRef.current = false;\n        const cx = gl.drawingBufferWidth / 2;\n        const cy = gl.drawingBufferHeight / 2;\n        uniforms.iMouse.value = [cx, cy];\n        mouseTargetRef.current = [cx, cy];\n      }\n    };\n\n    resize();\n    const ro = new ResizeObserver(resize);\n    ro.observe(container);\n\n    const onPointerMove = (e: PointerEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      const scale = (renderer as unknown as { dpr?: number }).dpr || 1;\n      const x = (e.clientX - rect.left) * scale;\n      const y = (rect.height - (e.clientY - rect.top)) * scale;\n      mouseTargetRef.current = [x, y];\n      if (mouseDampening <= 0) {\n        uniforms.iMouse.value = [x, y];\n      }\n    };\n    canvas.addEventListener('pointermove', onPointerMove);\n\n    const loop = (t: number) => {\n      rafRef.current = requestAnimationFrame(loop);\n      uniforms.iTime.value = t * 0.001;\n      if (mouseDampening > 0) {\n        if (!lastTimeRef.current) lastTimeRef.current = t;\n        const dt = (t - lastTimeRef.current) / 1000;\n        lastTimeRef.current = t;\n        const tau = Math.max(1e-4, mouseDampening);\n        let factor = 1 - Math.exp(-dt / tau);\n        if (factor > 1) factor = 1;\n        const target = mouseTargetRef.current;\n        const cur = uniforms.iMouse.value;\n        cur[0] += (target[0] - cur[0]) * factor;\n        cur[1] += (target[1] - cur[1]) * factor;\n      } else {\n        lastTimeRef.current = t;\n      }\n      if (!paused && programRef.current && meshRef.current) {\n        try {\n          renderer.render({ scene: meshRef.current });\n        } catch (e) {\n          console.error(e);\n        }\n      }\n    };\n    rafRef.current = requestAnimationFrame(loop);\n\n    return () => {\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      canvas.removeEventListener('pointermove', onPointerMove);\n      ro.disconnect();\n      if (canvas.parentElement === container) {\n        container.removeChild(canvas);\n      }\n      const callIfFn = <T extends object, K extends keyof T>(obj: T | null, key: K) => {\n        if (obj && typeof obj[key] === 'function') {\n          (obj[key] as unknown as () => void).call(obj);\n        }\n      };\n      callIfFn(programRef.current, 'remove');\n      callIfFn(geometryRef.current, 'remove');\n      callIfFn(meshRef.current as unknown as { remove?: () => void }, 'remove');\n      callIfFn(rendererRef.current as unknown as { destroy?: () => void }, 'destroy');\n      programRef.current = null;\n      geometryRef.current = null;\n      meshRef.current = null;\n      rendererRef.current = null;\n    };\n  }, [\n    dpr,\n    paused,\n    gradientColors,\n    angle,\n    noise,\n    blindCount,\n    blindMinWidth,\n    mouseDampening,\n    mirrorGradient,\n    spotlightRadius,\n    spotlightSoftness,\n    spotlightOpacity,\n    distortAmount,\n    shineDirection\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`w-full h-full overflow-hidden relative ${className}`}\n      style={{\n        ...(mixBlendMode && {\n          mixBlendMode: mixBlendMode as React.CSSProperties['mixBlendMode']\n        })\n      }}\n    />\n  );\n};\n\nexport default GradientBlinds;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "grainient",
      "type": "component",
      "description": "A grainy gradient background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/grainient.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { Renderer, Program, Mesh, Triangle } from 'ogl';\n\ninterface GrainientProps {\n  timeSpeed?: number;\n  colorBalance?: number;\n  warpStrength?: number;\n  warpFrequency?: number;\n  warpSpeed?: number;\n  warpAmplitude?: number;\n  blendAngle?: number;\n  blendSoftness?: number;\n  rotationAmount?: number;\n  noiseScale?: number;\n  grainAmount?: number;\n  grainScale?: number;\n  grainAnimated?: boolean;\n  contrast?: number;\n  gamma?: number;\n  saturation?: number;\n  centerX?: number;\n  centerY?: number;\n  zoom?: number;\n  color1?: string;\n  color2?: string;\n  color3?: string;\n  className?: string;\n}\n\nconst hexToRgb = (hex: string): [number, number, number] => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  if (!result) return [1, 1, 1];\n  return [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255];\n};\n\nconst vertex = `#version 300 es\nin vec2 position;\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst fragment = `#version 300 es\nprecision highp float;\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float uTimeSpeed;\nuniform float uColorBalance;\nuniform float uWarpStrength;\nuniform float uWarpFrequency;\nuniform float uWarpSpeed;\nuniform float uWarpAmplitude;\nuniform float uBlendAngle;\nuniform float uBlendSoftness;\nuniform float uRotationAmount;\nuniform float uNoiseScale;\nuniform float uGrainAmount;\nuniform float uGrainScale;\nuniform float uGrainAnimated;\nuniform float uContrast;\nuniform float uGamma;\nuniform float uSaturation;\nuniform vec2 uCenterOffset;\nuniform float uZoom;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColor3;\nout vec4 fragColor;\n#define S(a,b,t) smoothstep(a,b,t)\nmat2 Rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);} \nvec2 hash(vec2 p){p=vec2(dot(p,vec2(2127.1,81.17)),dot(p,vec2(1269.5,283.37)));return fract(sin(p)*43758.5453);} \nfloat noise(vec2 p){vec2 i=floor(p),f=fract(p),u=f*f*(3.0-2.0*f);float n=mix(mix(dot(-1.0+2.0*hash(i+vec2(0.0,0.0)),f-vec2(0.0,0.0)),dot(-1.0+2.0*hash(i+vec2(1.0,0.0)),f-vec2(1.0,0.0)),u.x),mix(dot(-1.0+2.0*hash(i+vec2(0.0,1.0)),f-vec2(0.0,1.0)),dot(-1.0+2.0*hash(i+vec2(1.0,1.0)),f-vec2(1.0,1.0)),u.x),u.y);return 0.5+0.5*n;}\nvoid mainImage(out vec4 o, vec2 C){\n  float t=iTime*uTimeSpeed;\n  vec2 uv=C/iResolution.xy;\n  float ratio=iResolution.x/iResolution.y;\n  vec2 tuv=uv-0.5+uCenterOffset;\n  tuv/=max(uZoom,0.001);\n\n  float degree=noise(vec2(t*0.1,tuv.x*tuv.y)*uNoiseScale);\n  tuv.y*=1.0/ratio;\n  tuv*=Rot(radians((degree-0.5)*uRotationAmount+180.0));\n  tuv.y*=ratio;\n\n  float frequency=uWarpFrequency;\n  float ws=max(uWarpStrength,0.001);\n  float amplitude=uWarpAmplitude/ws;\n  float warpTime=t*uWarpSpeed;\n  tuv.x+=sin(tuv.y*frequency+warpTime)/amplitude;\n  tuv.y+=sin(tuv.x*(frequency*1.5)+warpTime)/(amplitude*0.5);\n\n  vec3 colLav=uColor1;\n  vec3 colOrg=uColor2;\n  vec3 colDark=uColor3;\n  float b=uColorBalance;\n  float s=max(uBlendSoftness,0.0);\n  mat2 blendRot=Rot(radians(uBlendAngle));\n  float blendX=(tuv*blendRot).x;\n  float edge0=-0.3-b-s;\n  float edge1=0.2-b+s;\n  float v0=0.5-b+s;\n  float v1=-0.3-b-s;\n  vec3 layer1=mix(colDark,colOrg,S(edge0,edge1,blendX));\n  vec3 layer2=mix(colOrg,colLav,S(edge0,edge1,blendX));\n  vec3 col=mix(layer1,layer2,S(v0,v1,tuv.y));\n\n  vec2 grainUv=uv*max(uGrainScale,0.001);\n  if(uGrainAnimated>0.5){grainUv+=vec2(iTime*0.05);} \n  float grain=fract(sin(dot(grainUv,vec2(12.9898,78.233)))*43758.5453);\n  col+=(grain-0.5)*uGrainAmount;\n\n  col=(col-0.5)*uContrast+0.5;\n  float luma=dot(col,vec3(0.2126,0.7152,0.0722));\n  col=mix(vec3(luma),col,uSaturation);\n  col=pow(max(col,0.0),vec3(1.0/max(uGamma,0.001)));\n  col=clamp(col,0.0,1.0);\n\n  o=vec4(col,1.0);\n}\nvoid main(){\n  vec4 o=vec4(0.0);\n  mainImage(o,gl_FragCoord.xy);\n  fragColor=o;\n}\n`;\n\nconst Grainient: React.FC<GrainientProps> = ({\n  timeSpeed = 0.25,\n  colorBalance = 0.0,\n  warpStrength = 1.0,\n  warpFrequency = 5.0,\n  warpSpeed = 2.0,\n  warpAmplitude = 50.0,\n  blendAngle = 0.0,\n  blendSoftness = 0.05,\n  rotationAmount = 500.0,\n  noiseScale = 2.0,\n  grainAmount = 0.1,\n  grainScale = 2.0,\n  grainAnimated = false,\n  contrast = 1.5,\n  gamma = 1.0,\n  saturation = 1.0,\n  centerX = 0.0,\n  centerY = 0.0,\n  zoom = 0.9,\n  color1 = '#FF9FFC',\n  color2 = '#5227FF',\n  color3 = '#B19EEF',\n  className = ''\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const renderer = new Renderer({\n      webgl: 2,\n      alpha: true,\n      antialias: false,\n      dpr: Math.min(window.devicePixelRatio || 1, 2)\n    });\n\n    const gl = renderer.gl;\n    const canvas = gl.canvas as HTMLCanvasElement;\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.display = 'block';\n\n    const container = containerRef.current;\n    container.appendChild(canvas);\n\n    const geometry = new Triangle(gl);\n    const program = new Program(gl, {\n      vertex,\n      fragment,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: { value: new Float32Array([1, 1]) },\n        uTimeSpeed: { value: timeSpeed },\n        uColorBalance: { value: colorBalance },\n        uWarpStrength: { value: warpStrength },\n        uWarpFrequency: { value: warpFrequency },\n        uWarpSpeed: { value: warpSpeed },\n        uWarpAmplitude: { value: warpAmplitude },\n        uBlendAngle: { value: blendAngle },\n        uBlendSoftness: { value: blendSoftness },\n        uRotationAmount: { value: rotationAmount },\n        uNoiseScale: { value: noiseScale },\n        uGrainAmount: { value: grainAmount },\n        uGrainScale: { value: grainScale },\n        uGrainAnimated: { value: grainAnimated ? 1.0 : 0.0 },\n        uContrast: { value: contrast },\n        uGamma: { value: gamma },\n        uSaturation: { value: saturation },\n        uCenterOffset: { value: new Float32Array([centerX, centerY]) },\n        uZoom: { value: zoom },\n        uColor1: { value: new Float32Array(hexToRgb(color1)) },\n        uColor2: { value: new Float32Array(hexToRgb(color2)) },\n        uColor3: { value: new Float32Array(hexToRgb(color3)) }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    const setSize = () => {\n      const rect = container.getBoundingClientRect();\n      const width = Math.max(1, Math.floor(rect.width));\n      const height = Math.max(1, Math.floor(rect.height));\n      renderer.setSize(width, height);\n      const res = (program.uniforms.iResolution as { value: Float32Array }).value;\n      res[0] = gl.drawingBufferWidth;\n      res[1] = gl.drawingBufferHeight;\n    };\n\n    const ro = new ResizeObserver(setSize);\n    ro.observe(container);\n    setSize();\n\n    let raf = 0;\n    const t0 = performance.now();\n    const loop = (t: number) => {\n      (program.uniforms.iTime as { value: number }).value = (t - t0) * 0.001;\n      renderer.render({ scene: mesh });\n      raf = requestAnimationFrame(loop);\n    };\n    raf = requestAnimationFrame(loop);\n\n    return () => {\n      cancelAnimationFrame(raf);\n      ro.disconnect();\n      try {\n        container.removeChild(canvas);\n      } catch {\n        // Ignore\n      }\n    };\n  }, [\n    timeSpeed,\n    colorBalance,\n    warpStrength,\n    warpFrequency,\n    warpSpeed,\n    warpAmplitude,\n    blendAngle,\n    blendSoftness,\n    rotationAmount,\n    noiseScale,\n    grainAmount,\n    grainScale,\n    grainAnimated,\n    contrast,\n    gamma,\n    saturation,\n    centerX,\n    centerY,\n    zoom,\n    color1,\n    color2,\n    color3\n  ]);\n\n  return <div ref={containerRef} className={`relative h-full w-full overflow-hidden ${className}`.trim()} />;\n};\n\nexport default Grainient;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "grid-distortion",
      "type": "component",
      "description": "An interactive grid distortion background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/grid-distortion.tsx",
          "content": "import React, { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\n\ninterface GridDistortionProps {\n  grid?: number;\n  mouse?: number;\n  strength?: number;\n  relaxation?: number;\n  imageSrc: string;\n  className?: string;\n}\n\nconst vertexShader = `\nuniform float time;\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvoid main() {\n  vUv = uv;\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nuniform sampler2D uDataTexture;\nuniform sampler2D uTexture;\nuniform vec4 resolution;\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n  vec4 offset = texture2D(uDataTexture, vUv);\n  gl_FragColor = texture2D(uTexture, uv - 0.02 * offset.rg);\n}\n`;\n\nconst GridDistortion: React.FC<GridDistortionProps> = ({\n  grid = 15,\n  mouse = 0.1,\n  strength = 0.15,\n  relaxation = 0.9,\n  imageSrc,\n  className = ''\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const cameraRef = useRef<THREE.OrthographicCamera | null>(null);\n  const planeRef = useRef<THREE.Mesh | null>(null);\n  const imageAspectRef = useRef<number>(1);\n  const animationIdRef = useRef<number | null>(null);\n  const resizeObserverRef = useRef<ResizeObserver | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const container = containerRef.current;\n\n    const scene = new THREE.Scene();\n    sceneRef.current = scene;\n\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: true,\n      powerPreference: 'high-performance'\n    });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.setClearColor(0x000000, 0);\n    rendererRef.current = renderer;\n\n    container.innerHTML = '';\n    container.appendChild(renderer.domElement);\n\n    const camera = new THREE.OrthographicCamera(0, 0, 0, 0, -1000, 1000);\n    camera.position.z = 2;\n    cameraRef.current = camera;\n\n    const uniforms = {\n      time: { value: 0 },\n      resolution: { value: new THREE.Vector4() },\n      uTexture: { value: null as THREE.Texture | null },\n      uDataTexture: { value: null as THREE.DataTexture | null }\n    };\n\n    const textureLoader = new THREE.TextureLoader();\n    textureLoader.load(imageSrc, texture => {\n      texture.minFilter = THREE.LinearFilter;\n      texture.magFilter = THREE.LinearFilter;\n      texture.wrapS = THREE.ClampToEdgeWrapping;\n      texture.wrapT = THREE.ClampToEdgeWrapping;\n      imageAspectRef.current = texture.image.width / texture.image.height;\n      uniforms.uTexture.value = texture;\n      handleResize();\n    });\n\n    const size = grid;\n    const data = new Float32Array(4 * size * size);\n    for (let i = 0; i < size * size; i++) {\n      data[i * 4] = Math.random() * 255 - 125;\n      data[i * 4 + 1] = Math.random() * 255 - 125;\n    }\n\n    const dataTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);\n    dataTexture.needsUpdate = true;\n    uniforms.uDataTexture.value = dataTexture;\n\n    const material = new THREE.ShaderMaterial({\n      side: THREE.DoubleSide,\n      uniforms,\n      vertexShader,\n      fragmentShader,\n      transparent: true\n    });\n\n    const geometry = new THREE.PlaneGeometry(1, 1, size - 1, size - 1);\n    const plane = new THREE.Mesh(geometry, material);\n    planeRef.current = plane;\n    scene.add(plane);\n\n    const handleResize = () => {\n      if (!container || !renderer || !camera) return;\n\n      const rect = container.getBoundingClientRect();\n      const width = rect.width;\n      const height = rect.height;\n\n      if (width === 0 || height === 0) return;\n\n      const containerAspect = width / height;\n\n      renderer.setSize(width, height);\n\n      if (plane) {\n        plane.scale.set(containerAspect, 1, 1);\n      }\n\n      const frustumHeight = 1;\n      const frustumWidth = frustumHeight * containerAspect;\n      camera.left = -frustumWidth / 2;\n      camera.right = frustumWidth / 2;\n      camera.top = frustumHeight / 2;\n      camera.bottom = -frustumHeight / 2;\n      camera.updateProjectionMatrix();\n\n      uniforms.resolution.value.set(width, height, 1, 1);\n    };\n\n    if (window.ResizeObserver) {\n      const resizeObserver = new ResizeObserver(() => {\n        handleResize();\n      });\n      resizeObserver.observe(container);\n      resizeObserverRef.current = resizeObserver;\n    } else {\n      window.addEventListener('resize', handleResize);\n    }\n\n    const mouseState = {\n      x: 0,\n      y: 0,\n      prevX: 0,\n      prevY: 0,\n      vX: 0,\n      vY: 0\n    };\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = container.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = 1 - (e.clientY - rect.top) / rect.height;\n      mouseState.vX = x - mouseState.prevX;\n      mouseState.vY = y - mouseState.prevY;\n      Object.assign(mouseState, { x, y, prevX: x, prevY: y });\n    };\n\n    const handleMouseLeave = () => {\n      if (dataTexture) {\n        dataTexture.needsUpdate = true;\n      }\n      Object.assign(mouseState, {\n        x: 0,\n        y: 0,\n        prevX: 0,\n        prevY: 0,\n        vX: 0,\n        vY: 0\n      });\n    };\n\n    container.addEventListener('mousemove', handleMouseMove);\n    container.addEventListener('mouseleave', handleMouseLeave);\n\n    handleResize();\n\n    const animate = () => {\n      animationIdRef.current = requestAnimationFrame(animate);\n\n      if (!renderer || !scene || !camera) return;\n\n      uniforms.time.value += 0.05;\n\n      if (!(dataTexture.image.data instanceof Float32Array)) {\n        console.error('dataTexture.image.data is not a Float32Array');\n        return;\n      }\n      const data: Float32Array = dataTexture.image.data;\n      for (let i = 0; i < size * size; i++) {\n        data[i * 4] *= relaxation;\n        data[i * 4 + 1] *= relaxation;\n      }\n\n      const gridMouseX = size * mouseState.x;\n      const gridMouseY = size * mouseState.y;\n      const maxDist = size * mouse;\n\n      for (let i = 0; i < size; i++) {\n        for (let j = 0; j < size; j++) {\n          const distSq = Math.pow(gridMouseX - i, 2) + Math.pow(gridMouseY - j, 2);\n          if (distSq < maxDist * maxDist) {\n            const index = 4 * (i + size * j);\n            const power = Math.min(maxDist / Math.sqrt(distSq), 10);\n            data[index] += strength * 100 * mouseState.vX * power;\n            data[index + 1] -= strength * 100 * mouseState.vY * power;\n          }\n        }\n      }\n\n      dataTexture.needsUpdate = true;\n      renderer.render(scene, camera);\n    };\n\n    animate();\n\n    return () => {\n      if (animationIdRef.current) {\n        cancelAnimationFrame(animationIdRef.current);\n      }\n\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.disconnect();\n      } else {\n        window.removeEventListener('resize', handleResize);\n      }\n\n      container.removeEventListener('mousemove', handleMouseMove);\n      container.removeEventListener('mouseleave', handleMouseLeave);\n\n      if (renderer) {\n        renderer.dispose();\n        if (container.contains(renderer.domElement)) {\n          container.removeChild(renderer.domElement);\n        }\n      }\n\n      if (geometry) geometry.dispose();\n      if (material) material.dispose();\n      if (dataTexture) dataTexture.dispose();\n      if (uniforms.uTexture.value) uniforms.uTexture.value.dispose();\n\n      sceneRef.current = null;\n      rendererRef.current = null;\n      cameraRef.current = null;\n      planeRef.current = null;\n    };\n  }, [grid, mouse, strength, relaxation, imageSrc]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`relative overflow-hidden ${className}`}\n      style={{\n        width: '100%',\n        height: '100%',\n        minWidth: '0',\n        minHeight: '0'\n      }}\n    />\n  );\n};\n\nexport default GridDistortion;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "grid-motion",
      "type": "component",
      "description": "An animated grid motion background with content cells.",
      "category": "backgrounds",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/grid-motion.tsx",
          "content": "import { useEffect, useRef, FC, ReactNode } from 'react';\nimport { gsap } from 'gsap';\n\ninterface GridMotionProps {\n  items?: (string | ReactNode)[];\n  gradientColor?: string;\n}\n\nconst GridMotion: FC<GridMotionProps> = ({ items = [], gradientColor = 'black' }) => {\n  const gridRef = useRef<HTMLDivElement>(null);\n  const rowRefs = useRef<(HTMLDivElement | null)[]>([]);\n  const mouseXRef = useRef<number>(window.innerWidth / 2);\n\n  const totalItems = 28;\n  const defaultItems = Array.from({ length: totalItems }, (_, index) => `Item ${index + 1}`);\n  const combinedItems = items.length > 0 ? items.slice(0, totalItems) : defaultItems;\n\n  useEffect(() => {\n    gsap.ticker.lagSmoothing(0);\n\n    const handleMouseMove = (e: MouseEvent): void => {\n      mouseXRef.current = e.clientX;\n    };\n\n    const updateMotion = (): void => {\n      const maxMoveAmount = 300;\n      const baseDuration = 0.8;\n      const inertiaFactors = [0.6, 0.4, 0.3, 0.2];\n\n      rowRefs.current.forEach((row, index) => {\n        if (row) {\n          const direction = index % 2 === 0 ? 1 : -1;\n          const moveAmount = ((mouseXRef.current / window.innerWidth) * maxMoveAmount - maxMoveAmount / 2) * direction;\n\n          gsap.to(row, {\n            x: moveAmount,\n            duration: baseDuration + inertiaFactors[index % inertiaFactors.length],\n            ease: 'power3.out',\n            overwrite: 'auto'\n          });\n        }\n      });\n    };\n\n    const removeAnimationLoop = gsap.ticker.add(updateMotion);\n    window.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove);\n      removeAnimationLoop();\n    };\n  }, []);\n\n  return (\n    <div ref={gridRef} className=\"h-full w-full overflow-hidden\">\n      <section\n        className=\"w-full h-screen overflow-hidden relative flex items-center justify-center\"\n        style={{\n          background: `radial-gradient(circle, ${gradientColor} 0%, transparent 100%)`\n        }}\n      >\n        <div className=\"absolute inset-0 pointer-events-none z-[4] bg-[length:250px]\"></div>\n        <div className=\"gap-4 flex-none relative w-[150vw] h-[150vh] grid grid-rows-4 grid-cols-1 rotate-[-15deg] origin-center z-[2]\">\n          {Array.from({ length: 4 }, (_, rowIndex) => (\n            <div\n              key={rowIndex}\n              className=\"grid gap-4 grid-cols-7\"\n              style={{ willChange: 'transform, filter' }}\n              ref={el => {\n                if (el) rowRefs.current[rowIndex] = el;\n              }}\n            >\n              {Array.from({ length: 7 }, (_, itemIndex) => {\n                const content = combinedItems[rowIndex * 7 + itemIndex];\n                return (\n                  <div key={itemIndex} className=\"relative\">\n                    <div className=\"relative w-full h-full overflow-hidden rounded-[10px] bg-[#111] flex items-center justify-center text-white text-[1.5rem]\">\n                      {typeof content === 'string' && content.startsWith('http') ? (\n                        <div\n                          className=\"w-full h-full bg-cover bg-center absolute top-0 left-0\"\n                          style={{ backgroundImage: `url(${content})` }}\n                        ></div>\n                      ) : (\n                        <div className=\"p-4 text-center z-[1]\">{content}</div>\n                      )}\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          ))}\n        </div>\n        <div className=\"relative w-full h-full top-0 left-0 pointer-events-none\"></div>\n      </section>\n    </div>\n  );\n};\n\nexport default GridMotion;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "grid-pattern",
      "type": "component",
      "description": "A background grid pattern made with SVGs, fully customizable using Tailwind CSS.",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/grid-pattern.tsx",
          "content": "import { useId } from 'react';\n\nimport { cn } from '@/lib/utils';\n\ninterface GridPatternProps extends React.SVGProps<SVGSVGElement> {\n  width?: number;\n  height?: number;\n  x?: number;\n  y?: number;\n  squares?: Array<[x: number, y: number]>;\n  strokeDasharray?: string;\n  className?: string;\n  [key: string]: unknown;\n}\n\nexport function GridPattern({\n  width = 40,\n  height = 40,\n  x = -1,\n  y = -1,\n  strokeDasharray = '0',\n  squares,\n  className,\n  ...props\n}: GridPatternProps) {\n  const id = useId();\n\n  return (\n    <svg\n      aria-hidden=\"true\"\n      className={cn(\n        'pointer-events-none absolute inset-0 h-full w-full fill-gray-400/30 stroke-gray-400/30',\n        className\n      )}\n      {...props}\n    >\n      <defs>\n        <pattern\n          id={id}\n          width={width}\n          height={height}\n          patternUnits=\"userSpaceOnUse\"\n          x={x}\n          y={y}\n        >\n          <path\n            d={`M.5 ${height}V.5H${width}`}\n            fill=\"none\"\n            strokeDasharray={strokeDasharray}\n          />\n        </pattern>\n      </defs>\n      <rect width=\"100%\" height=\"100%\" strokeWidth={0} fill={`url(#${id})`} />\n      {squares && (\n        <svg x={x} y={y} className=\"overflow-visible\">\n          {squares.map(([x, y]) => (\n            <rect\n              strokeWidth=\"0\"\n              key={`${x}-${y}`}\n              width={width - 1}\n              height={height - 1}\n              x={x * width + 1}\n              y={y * height + 1}\n            />\n          ))}\n        </svg>\n      )}\n    </svg>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background",
          "pattern",
          "svg",
          "grid"
        ],
        "featured": true
      }
    },
    {
      "name": "grid-scan",
      "type": "component",
      "description": "A grid scanning background effect with optional face detection.",
      "category": "backgrounds",
      "dependencies": [
        "three",
        "postprocessing",
        "face-api.js"
      ],
      "files": [
        {
          "path": "components/ui/grid-scan.tsx",
          "content": "import React, { useEffect, useRef, useState } from 'react';\nimport { EffectComposer, RenderPass, EffectPass, BloomEffect, ChromaticAberrationEffect } from 'postprocessing';\nimport * as THREE from 'three';\nimport * as faceapi from 'face-api.js';\n\ntype GridScanProps = {\n  enableWebcam?: boolean;\n  showPreview?: boolean;\n  modelsPath?: string;\n  sensitivity?: number;\n\n  lineThickness?: number;\n  linesColor?: string;\n\n  gridScale?: number;\n  lineStyle?: 'solid' | 'dashed' | 'dotted';\n  lineJitter?: number;\n\n  enablePost?: boolean;\n  bloomIntensity?: number;\n  bloomThreshold?: number;\n  bloomSmoothing?: number;\n  chromaticAberration?: number;\n  noiseIntensity?: number;\n\n  scanColor?: string;\n  scanOpacity?: number;\n  scanDirection?: 'forward' | 'backward' | 'pingpong';\n  scanSoftness?: number;\n  scanGlow?: number;\n  scanPhaseTaper?: number;\n  scanDuration?: number;\n  scanDelay?: number;\n  enableGyro?: boolean;\n  scanOnClick?: boolean;\n  snapBackDelay?: number;\n  className?: string;\n  style?: React.CSSProperties;\n};\n\nconst vert = `\nvarying vec2 vUv;\nvoid main(){\n  vUv = uv;\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n}\n`;\n\nconst frag = `\nprecision highp float;\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec2 uSkew;\nuniform float uTilt;\nuniform float uYaw;\nuniform float uLineThickness;\nuniform vec3 uLinesColor;\nuniform vec3 uScanColor;\nuniform float uGridScale;\nuniform float uLineStyle;\nuniform float uLineJitter;\nuniform float uScanOpacity;\nuniform float uScanDirection;\nuniform float uNoise;\nuniform float uBloomOpacity;\nuniform float uScanGlow;\nuniform float uScanSoftness;\nuniform float uPhaseTaper;\nuniform float uScanDuration;\nuniform float uScanDelay;\nvarying vec2 vUv;\n\nuniform float uScanStarts[8];\nuniform float uScanCount;\n\nconst int MAX_SCANS = 8;\n\nfloat smoother01(float a, float b, float x){\n  float t = clamp((x - a) / max(1e-5, (b - a)), 0.0, 1.0);\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0);\n    vec3 rd = normalize(vec3(p, 2.0));\n\n    float cR = cos(uTilt), sR = sin(uTilt);\n    rd.xy = mat2(cR, -sR, sR, cR) * rd.xy;\n\n    float cY = cos(uYaw), sY = sin(uYaw);\n    rd.xz = mat2(cY, -sY, sY, cY) * rd.xz;\n\n    vec2 skew = clamp(uSkew, vec2(-0.7), vec2(0.7));\n    rd.xy += skew * rd.z;\n\n    vec3 color = vec3(0.0);\n  float minT = 1e20;\n  float gridScale = max(1e-5, uGridScale);\n    float fadeStrength = 2.0;\n    vec2 gridUV = vec2(0.0);\n\n  float hitIsY = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        float isY = float(i < 2);\n        float pos = mix(-0.2, 0.2, float(i)) * isY + mix(-0.5, 0.5, float(i - 2)) * (1.0 - isY);\n        float num = pos - (isY * ro.y + (1.0 - isY) * ro.x);\n        float den = isY * rd.y + (1.0 - isY) * rd.x;\n        float t = num / den;\n        vec3 h = ro + rd * t;\n\n        float depthBoost = smoothstep(0.0, 3.0, h.z);\n        h.xy += skew * 0.15 * depthBoost;\n\n    bool use = t > 0.0 && t < minT;\n    gridUV = use ? mix(h.zy, h.xz, isY) / gridScale : gridUV;\n    minT = use ? t : minT;\n    hitIsY = use ? isY : hitIsY;\n    }\n\n    vec3 hit = ro + rd * minT;\n    float dist = length(hit - ro);\n\n  float jitterAmt = clamp(uLineJitter, 0.0, 1.0);\n  if (jitterAmt > 0.0) {\n    vec2 j = vec2(\n      sin(gridUV.y * 2.7 + iTime * 1.8),\n      cos(gridUV.x * 2.3 - iTime * 1.6)\n    ) * (0.15 * jitterAmt);\n    gridUV += j;\n  }\n  float fx = fract(gridUV.x);\n  float fy = fract(gridUV.y);\n  float ax = min(fx, 1.0 - fx);\n  float ay = min(fy, 1.0 - fy);\n  float wx = fwidth(gridUV.x);\n  float wy = fwidth(gridUV.y);\n  float halfPx = max(0.0, uLineThickness) * 0.5;\n\n  float tx = halfPx * wx;\n  float ty = halfPx * wy;\n\n  float aax = wx;\n  float aay = wy;\n\n  float lineX = 1.0 - smoothstep(tx, tx + aax, ax);\n  float lineY = 1.0 - smoothstep(ty, ty + aay, ay);\n  if (uLineStyle > 0.5) {\n    float dashRepeat = 4.0;\n    float dashDuty = 0.5;\n    float vy = fract(gridUV.y * dashRepeat);\n    float vx = fract(gridUV.x * dashRepeat);\n    float dashMaskY = step(vy, dashDuty);\n    float dashMaskX = step(vx, dashDuty);\n    if (uLineStyle < 1.5) {\n      lineX *= dashMaskY;\n      lineY *= dashMaskX;\n    } else {\n      float dotRepeat = 6.0;\n      float dotWidth = 0.18;\n      float cy = abs(fract(gridUV.y * dotRepeat) - 0.5);\n      float cx = abs(fract(gridUV.x * dotRepeat) - 0.5);\n      float dotMaskY = 1.0 - smoothstep(dotWidth, dotWidth + fwidth(gridUV.y * dotRepeat), cy);\n      float dotMaskX = 1.0 - smoothstep(dotWidth, dotWidth + fwidth(gridUV.x * dotRepeat), cx);\n      lineX *= dotMaskY;\n      lineY *= dotMaskX;\n    }\n  }\n  float primaryMask = max(lineX, lineY);\n\n  vec2 gridUV2 = (hitIsY > 0.5 ? hit.xz : hit.zy) / gridScale;\n  if (jitterAmt > 0.0) {\n    vec2 j2 = vec2(\n      cos(gridUV2.y * 2.1 - iTime * 1.4),\n      sin(gridUV2.x * 2.5 + iTime * 1.7)\n    ) * (0.15 * jitterAmt);\n    gridUV2 += j2;\n  }\n  float fx2 = fract(gridUV2.x);\n  float fy2 = fract(gridUV2.y);\n  float ax2 = min(fx2, 1.0 - fx2);\n  float ay2 = min(fy2, 1.0 - fy2);\n  float wx2 = fwidth(gridUV2.x);\n  float wy2 = fwidth(gridUV2.y);\n  float tx2 = halfPx * wx2;\n  float ty2 = halfPx * wy2;\n  float aax2 = wx2;\n  float aay2 = wy2;\n  float lineX2 = 1.0 - smoothstep(tx2, tx2 + aax2, ax2);\n  float lineY2 = 1.0 - smoothstep(ty2, ty2 + aay2, ay2);\n  if (uLineStyle > 0.5) {\n    float dashRepeat2 = 4.0;\n    float dashDuty2 = 0.5;\n    float vy2m = fract(gridUV2.y * dashRepeat2);\n    float vx2m = fract(gridUV2.x * dashRepeat2);\n    float dashMaskY2 = step(vy2m, dashDuty2);\n    float dashMaskX2 = step(vx2m, dashDuty2);\n    if (uLineStyle < 1.5) {\n      lineX2 *= dashMaskY2;\n      lineY2 *= dashMaskX2;\n    } else {\n      float dotRepeat2 = 6.0;\n      float dotWidth2 = 0.18;\n      float cy2 = abs(fract(gridUV2.y * dotRepeat2) - 0.5);\n      float cx2 = abs(fract(gridUV2.x * dotRepeat2) - 0.5);\n      float dotMaskY2 = 1.0 - smoothstep(dotWidth2, dotWidth2 + fwidth(gridUV2.y * dotRepeat2), cy2);\n      float dotMaskX2 = 1.0 - smoothstep(dotWidth2, dotWidth2 + fwidth(gridUV2.x * dotRepeat2), cx2);\n      lineX2 *= dotMaskY2;\n      lineY2 *= dotMaskX2;\n    }\n  }\n    float altMask = max(lineX2, lineY2);\n\n    float edgeDistX = min(abs(hit.x - (-0.5)), abs(hit.x - 0.5));\n    float edgeDistY = min(abs(hit.y - (-0.2)), abs(hit.y - 0.2));\n    float edgeDist = mix(edgeDistY, edgeDistX, hitIsY);\n    float edgeGate = 1.0 - smoothstep(gridScale * 0.5, gridScale * 2.0, edgeDist);\n    altMask *= edgeGate;\n\n  float lineMask = max(primaryMask, altMask);\n\n    float fade = exp(-dist * fadeStrength);\n\n    float dur = max(0.05, uScanDuration);\n    float del = max(0.0, uScanDelay);\n    float scanZMax = 2.0;\n    float widthScale = max(0.1, uScanGlow);\n    float sigma = max(0.001, 0.18 * widthScale * uScanSoftness);\n    float sigmaA = sigma * 2.0;\n\n    float combinedPulse = 0.0;\n    float combinedAura = 0.0;\n\n    float cycle = dur + del;\n    float tCycle = mod(iTime, cycle);\n    float scanPhase = clamp((tCycle - del) / dur, 0.0, 1.0);\n    float phase = scanPhase;\n    if (uScanDirection > 0.5 && uScanDirection < 1.5) {\n      phase = 1.0 - phase;\n    } else if (uScanDirection > 1.5) {\n      float t2 = mod(max(0.0, iTime - del), 2.0 * dur);\n      phase = (t2 < dur) ? (t2 / dur) : (1.0 - (t2 - dur) / dur);\n    }\n    float scanZ = phase * scanZMax;\n    float dz = abs(hit.z - scanZ);\n    float lineBand = exp(-0.5 * (dz * dz) / (sigma * sigma));\n    float taper = clamp(uPhaseTaper, 0.0, 0.49);\n    float headW = taper;\n    float tailW = taper;\n    float headFade = smoother01(0.0, headW, phase);\n    float tailFade = 1.0 - smoother01(1.0 - tailW, 1.0, phase);\n    float phaseWindow = headFade * tailFade;\n    float pulseBase = lineBand * phaseWindow;\n    combinedPulse += pulseBase * clamp(uScanOpacity, 0.0, 1.0);\n    float auraBand = exp(-0.5 * (dz * dz) / (sigmaA * sigmaA));\n    combinedAura += (auraBand * 0.25) * phaseWindow * clamp(uScanOpacity, 0.0, 1.0);\n\n    for (int i = 0; i < MAX_SCANS; i++) {\n      if (float(i) >= uScanCount) break;\n      float tActiveI = iTime - uScanStarts[i];\n      float phaseI = clamp(tActiveI / dur, 0.0, 1.0);\n      if (uScanDirection > 0.5 && uScanDirection < 1.5) {\n        phaseI = 1.0 - phaseI;\n      } else if (uScanDirection > 1.5) {\n        phaseI = (phaseI < 0.5) ? (phaseI * 2.0) : (1.0 - (phaseI - 0.5) * 2.0);\n      }\n      float scanZI = phaseI * scanZMax;\n      float dzI = abs(hit.z - scanZI);\n      float lineBandI = exp(-0.5 * (dzI * dzI) / (sigma * sigma));\n      float headFadeI = smoother01(0.0, headW, phaseI);\n      float tailFadeI = 1.0 - smoother01(1.0 - tailW, 1.0, phaseI);\n      float phaseWindowI = headFadeI * tailFadeI;\n      combinedPulse += lineBandI * phaseWindowI * clamp(uScanOpacity, 0.0, 1.0);\n      float auraBandI = exp(-0.5 * (dzI * dzI) / (sigmaA * sigmaA));\n      combinedAura += (auraBandI * 0.25) * phaseWindowI * clamp(uScanOpacity, 0.0, 1.0);\n    }\n\n  float lineVis = lineMask;\n  vec3 gridCol = uLinesColor * lineVis * fade;\n  vec3 scanCol = uScanColor * combinedPulse;\n  vec3 scanAura = uScanColor * combinedAura;\n\n    color = gridCol + scanCol + scanAura;\n\n  float n = fract(sin(dot(gl_FragCoord.xy + vec2(iTime * 123.4), vec2(12.9898,78.233))) * 43758.5453123);\n  color += (n - 0.5) * uNoise;\n  color = clamp(color, 0.0, 1.0);\n  float alpha = clamp(max(lineVis, combinedPulse), 0.0, 1.0);\n  float gx = 1.0 - smoothstep(tx * 2.0, tx * 2.0 + aax * 2.0, ax);\n  float gy = 1.0 - smoothstep(ty * 2.0, ty * 2.0 + aay * 2.0, ay);\n  float halo = max(gx, gy) * fade;\n  alpha = max(alpha, halo * clamp(uBloomOpacity, 0.0, 1.0));\n  fragColor = vec4(color, alpha);\n}\n\nvoid main(){\n  vec4 c;\n  mainImage(c, vUv * iResolution.xy);\n  gl_FragColor = c;\n}\n`;\n\nexport const GridScan: React.FC<GridScanProps> = ({\n  enableWebcam = false,\n  showPreview = false,\n  modelsPath = 'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights',\n  sensitivity = 0.55,\n  lineThickness = 1,\n  linesColor = '#392e4e',\n  scanColor = '#FF9FFC',\n  scanOpacity = 0.4,\n  gridScale = 0.1,\n  lineStyle = 'solid',\n  lineJitter = 0.1,\n  scanDirection = 'pingpong',\n  enablePost = true,\n  bloomIntensity = 0,\n  bloomThreshold = 0,\n  bloomSmoothing = 0,\n  chromaticAberration = 0.002,\n  noiseIntensity = 0.01,\n  scanGlow = 0.5,\n  scanSoftness = 2,\n  scanPhaseTaper = 0.9,\n  scanDuration = 2.0,\n  scanDelay = 2.0,\n  enableGyro = false,\n  scanOnClick = false,\n  snapBackDelay = 250,\n  className,\n  style\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const videoRef = useRef<HTMLVideoElement | null>(null);\n\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const materialRef = useRef<THREE.ShaderMaterial | null>(null);\n  const composerRef = useRef<EffectComposer | null>(null);\n  const bloomRef = useRef<BloomEffect | null>(null);\n  const chromaRef = useRef<ChromaticAberrationEffect | null>(null);\n  const rafRef = useRef<number | null>(null);\n\n  const [modelsReady, setModelsReady] = useState(false);\n  const [uiFaceActive, setUiFaceActive] = useState(false);\n\n  const lookTarget = useRef(new THREE.Vector2(0, 0));\n  const tiltTarget = useRef(0);\n  const yawTarget = useRef(0);\n\n  const lookCurrent = useRef(new THREE.Vector2(0, 0));\n  const lookVel = useRef(new THREE.Vector2(0, 0));\n  const tiltCurrent = useRef(0);\n  const tiltVel = useRef(0);\n  const yawCurrent = useRef(0);\n  const yawVel = useRef(0);\n\n  const MAX_SCANS = 8;\n  const scanStartsRef = useRef<number[]>([]);\n\n  const pushScan = (t: number) => {\n    const arr = scanStartsRef.current.slice();\n    if (arr.length >= MAX_SCANS) arr.shift();\n    arr.push(t);\n    scanStartsRef.current = arr;\n    if (materialRef.current) {\n      const u = materialRef.current.uniforms;\n      const buf = new Array(MAX_SCANS).fill(0);\n      for (let i = 0; i < arr.length && i < MAX_SCANS; i++) buf[i] = arr[i];\n      u.uScanStarts.value = buf;\n      u.uScanCount.value = arr.length;\n    }\n  };\n\n  const bufX = useRef<number[]>([]);\n  const bufY = useRef<number[]>([]);\n  const bufT = useRef<number[]>([]);\n  const bufYaw = useRef<number[]>([]);\n\n  const s = THREE.MathUtils.clamp(sensitivity, 0, 1);\n  const skewScale = THREE.MathUtils.lerp(0.06, 0.2, s);\n  const tiltScale = THREE.MathUtils.lerp(0.12, 0.3, s);\n  const yawScale = THREE.MathUtils.lerp(0.1, 0.28, s);\n  const depthResponse = THREE.MathUtils.lerp(0.25, 0.45, s);\n  const smoothTime = THREE.MathUtils.lerp(0.45, 0.12, s);\n  const maxSpeed = Infinity;\n\n  const yBoost = THREE.MathUtils.lerp(1.2, 1.6, s);\n\n  useEffect(() => {\n    const el = containerRef.current;\n    if (!el) return;\n    let leaveTimer: number | null = null;\n    const onMove = (e: MouseEvent) => {\n      if (uiFaceActive) return;\n      if (leaveTimer) {\n        clearTimeout(leaveTimer);\n        leaveTimer = null;\n      }\n      const rect = el.getBoundingClientRect();\n      const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n      const ny = -(((e.clientY - rect.top) / rect.height) * 2 - 1);\n      lookTarget.current.set(nx, ny);\n    };\n    const onClick = async () => {\n      const nowSec = performance.now() / 1000;\n      if (scanOnClick) pushScan(nowSec);\n      if (\n        enableGyro &&\n        typeof window !== 'undefined' &&\n        (window as any).DeviceOrientationEvent &&\n        (DeviceOrientationEvent as any).requestPermission\n      ) {\n        try {\n          await (DeviceOrientationEvent as any).requestPermission();\n        } catch {}\n      }\n    };\n    const onEnter = () => {\n      if (leaveTimer) {\n        clearTimeout(leaveTimer);\n        leaveTimer = null;\n      }\n    };\n    const onLeave = () => {\n      if (uiFaceActive) return;\n      if (leaveTimer) clearTimeout(leaveTimer);\n      leaveTimer = window.setTimeout(\n        () => {\n          lookTarget.current.set(0, 0);\n          tiltTarget.current = 0;\n          yawTarget.current = 0;\n        },\n        Math.max(0, snapBackDelay || 0)\n      );\n    };\n    el.addEventListener('mousemove', onMove);\n    el.addEventListener('mouseenter', onEnter);\n    if (scanOnClick) el.addEventListener('click', onClick);\n    el.addEventListener('mouseleave', onLeave);\n    return () => {\n      el.removeEventListener('mousemove', onMove);\n      el.removeEventListener('mouseenter', onEnter);\n      el.removeEventListener('mouseleave', onLeave);\n      if (scanOnClick) el.removeEventListener('click', onClick);\n      if (leaveTimer) clearTimeout(leaveTimer);\n    };\n  }, [uiFaceActive, snapBackDelay, scanOnClick, enableGyro]);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    rendererRef.current = renderer;\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n    renderer.setSize(container.clientWidth, container.clientHeight);\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.toneMapping = THREE.NoToneMapping;\n    renderer.autoClear = false;\n    renderer.setClearColor(0x000000, 0);\n    container.appendChild(renderer.domElement);\n\n    const uniforms = {\n      iResolution: {\n        value: new THREE.Vector3(container.clientWidth, container.clientHeight, renderer.getPixelRatio())\n      },\n      iTime: { value: 0 },\n      uSkew: { value: new THREE.Vector2(0, 0) },\n      uTilt: { value: 0 },\n      uYaw: { value: 0 },\n      uLineThickness: { value: lineThickness },\n      uLinesColor: { value: srgbColor(linesColor) },\n      uScanColor: { value: srgbColor(scanColor) },\n      uGridScale: { value: gridScale },\n      uLineStyle: { value: lineStyle === 'dashed' ? 1 : lineStyle === 'dotted' ? 2 : 0 },\n      uLineJitter: { value: Math.max(0, Math.min(1, lineJitter || 0)) },\n      uScanOpacity: { value: scanOpacity },\n      uNoise: { value: noiseIntensity },\n      uBloomOpacity: { value: bloomIntensity },\n      uScanGlow: { value: scanGlow },\n      uScanSoftness: { value: scanSoftness },\n      uPhaseTaper: { value: scanPhaseTaper },\n      uScanDuration: { value: scanDuration },\n      uScanDelay: { value: scanDelay },\n      uScanDirection: { value: scanDirection === 'backward' ? 1 : scanDirection === 'pingpong' ? 2 : 0 },\n      uScanStarts: { value: new Array(MAX_SCANS).fill(0) },\n      uScanCount: { value: 0 }\n    };\n\n    const material = new THREE.ShaderMaterial({\n      uniforms,\n      vertexShader: vert,\n      fragmentShader: frag,\n      transparent: true,\n      depthWrite: false,\n      depthTest: false\n    });\n    materialRef.current = material;\n\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);\n    scene.add(quad);\n\n    let composer: EffectComposer | null = null;\n    if (enablePost) {\n      composer = new EffectComposer(renderer);\n      composerRef.current = composer;\n      const renderPass = new RenderPass(scene, camera);\n      composer.addPass(renderPass);\n\n      const bloom = new BloomEffect({\n        intensity: 1.0,\n        luminanceThreshold: bloomThreshold,\n        luminanceSmoothing: bloomSmoothing\n      });\n      bloom.blendMode.opacity.value = Math.max(0, bloomIntensity);\n      bloomRef.current = bloom;\n\n      const chroma = new ChromaticAberrationEffect({\n        offset: new THREE.Vector2(chromaticAberration, chromaticAberration),\n        radialModulation: true,\n        modulationOffset: 0.0\n      });\n      chromaRef.current = chroma;\n\n      const effectPass = new EffectPass(camera, bloom, chroma);\n      effectPass.renderToScreen = true;\n      composer.addPass(effectPass);\n    }\n\n    const onResize = () => {\n      renderer.setSize(container.clientWidth, container.clientHeight);\n      material.uniforms.iResolution.value.set(container.clientWidth, container.clientHeight, renderer.getPixelRatio());\n      if (composerRef.current) composerRef.current.setSize(container.clientWidth, container.clientHeight);\n    };\n    window.addEventListener('resize', onResize);\n\n    let last = performance.now();\n    const tick = () => {\n      const now = performance.now();\n      const dt = Math.max(0, Math.min(0.1, (now - last) / 1000));\n      last = now;\n\n      lookCurrent.current.copy(\n        smoothDampVec2(lookCurrent.current, lookTarget.current, lookVel.current, smoothTime, maxSpeed, dt)\n      );\n\n      const tiltSm = smoothDampFloat(\n        tiltCurrent.current,\n        tiltTarget.current,\n        { v: tiltVel.current },\n        smoothTime,\n        maxSpeed,\n        dt\n      );\n      tiltCurrent.current = tiltSm.value;\n      tiltVel.current = tiltSm.v;\n\n      const yawSm = smoothDampFloat(\n        yawCurrent.current,\n        yawTarget.current,\n        { v: yawVel.current },\n        smoothTime,\n        maxSpeed,\n        dt\n      );\n      yawCurrent.current = yawSm.value;\n      yawVel.current = yawSm.v;\n\n      const skew = new THREE.Vector2(lookCurrent.current.x * skewScale, -lookCurrent.current.y * yBoost * skewScale);\n      material.uniforms.uSkew.value.set(skew.x, skew.y);\n      material.uniforms.uTilt.value = tiltCurrent.current * tiltScale;\n      material.uniforms.uYaw.value = THREE.MathUtils.clamp(yawCurrent.current * yawScale, -0.6, 0.6);\n\n      material.uniforms.iTime.value = now / 1000;\n      renderer.clear(true, true, true);\n      if (composerRef.current) {\n        composerRef.current.render(dt);\n      } else {\n        renderer.render(scene, camera);\n      }\n      rafRef.current = requestAnimationFrame(tick);\n    };\n    rafRef.current = requestAnimationFrame(tick);\n\n    return () => {\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      window.removeEventListener('resize', onResize);\n      material.dispose();\n      (quad.geometry as THREE.BufferGeometry).dispose();\n      if (composerRef.current) {\n        composerRef.current.dispose();\n        composerRef.current = null;\n      }\n      renderer.dispose();\n      container.removeChild(renderer.domElement);\n    };\n  }, [\n    sensitivity,\n    lineThickness,\n    linesColor,\n    scanColor,\n    scanOpacity,\n    gridScale,\n    lineStyle,\n    lineJitter,\n    scanDirection,\n    enablePost\n  ]);\n\n  useEffect(() => {\n    const m = materialRef.current;\n    if (m) {\n      const u = m.uniforms;\n      u.uLineThickness.value = lineThickness;\n      (u.uLinesColor.value as THREE.Color).copy(srgbColor(linesColor));\n      (u.uScanColor.value as THREE.Color).copy(srgbColor(scanColor));\n      u.uGridScale.value = gridScale;\n      u.uLineStyle.value = lineStyle === 'dashed' ? 1 : lineStyle === 'dotted' ? 2 : 0;\n      u.uLineJitter.value = Math.max(0, Math.min(1, lineJitter || 0));\n      u.uBloomOpacity.value = Math.max(0, bloomIntensity);\n      u.uNoise.value = Math.max(0, noiseIntensity);\n      u.uScanGlow.value = scanGlow;\n      u.uScanOpacity.value = Math.max(0, Math.min(1, scanOpacity));\n      u.uScanDirection.value = scanDirection === 'backward' ? 1 : scanDirection === 'pingpong' ? 2 : 0;\n      u.uScanSoftness.value = scanSoftness;\n      u.uPhaseTaper.value = scanPhaseTaper;\n      u.uScanDuration.value = Math.max(0.05, scanDuration);\n      u.uScanDelay.value = Math.max(0.0, scanDelay);\n    }\n    if (bloomRef.current) {\n      bloomRef.current.blendMode.opacity.value = Math.max(0, bloomIntensity);\n      (bloomRef.current as any).luminanceMaterial.threshold = bloomThreshold;\n      (bloomRef.current as any).luminanceMaterial.smoothing = bloomSmoothing;\n    }\n    if (chromaRef.current) {\n      chromaRef.current.offset.set(chromaticAberration, chromaticAberration);\n    }\n  }, [\n    lineThickness,\n    linesColor,\n    scanColor,\n    gridScale,\n    lineStyle,\n    lineJitter,\n    bloomIntensity,\n    bloomThreshold,\n    bloomSmoothing,\n    chromaticAberration,\n    noiseIntensity,\n    scanGlow,\n    scanOpacity,\n    scanDirection,\n    scanSoftness,\n    scanPhaseTaper,\n    scanDuration,\n    scanDelay\n  ]);\n\n  useEffect(() => {\n    if (!enableGyro) return;\n    const handler = (e: DeviceOrientationEvent) => {\n      if (uiFaceActive) return;\n      const gamma = e.gamma ?? 0;\n      const beta = e.beta ?? 0;\n      const nx = THREE.MathUtils.clamp(gamma / 45, -1, 1);\n      const ny = THREE.MathUtils.clamp(-beta / 30, -1, 1);\n      lookTarget.current.set(nx, ny);\n      tiltTarget.current = THREE.MathUtils.degToRad(gamma) * 0.4;\n    };\n    window.addEventListener('deviceorientation', handler);\n    return () => {\n      window.removeEventListener('deviceorientation', handler);\n    };\n  }, [enableGyro, uiFaceActive]);\n\n  useEffect(() => {\n    let canceled = false;\n    const load = async () => {\n      try {\n        await Promise.all([\n          faceapi.nets.tinyFaceDetector.loadFromUri(modelsPath),\n          faceapi.nets.faceLandmark68TinyNet.loadFromUri(modelsPath)\n        ]);\n        if (!canceled) setModelsReady(true);\n      } catch {\n        if (!canceled) setModelsReady(false);\n      }\n    };\n    load();\n    return () => {\n      canceled = true;\n    };\n  }, [modelsPath]);\n\n  useEffect(() => {\n    let stop = false;\n    let lastDetect = 0;\n\n    const start = async () => {\n      if (!enableWebcam || !modelsReady) return;\n      const video = videoRef.current;\n      if (!video) return;\n\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },\n          audio: false\n        });\n        video.srcObject = stream;\n        await video.play();\n      } catch {\n        return;\n      }\n\n      const opts = new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.5 });\n\n      const detect = async (ts: number) => {\n        if (stop) return;\n\n        if (ts - lastDetect >= 33) {\n          lastDetect = ts;\n          try {\n            const res = await faceapi.detectSingleFace(video, opts).withFaceLandmarks(true);\n            if (res && res.detection) {\n              const det = res.detection;\n              const box = det.box;\n              const vw = video.videoWidth || 1;\n              const vh = video.videoHeight || 1;\n\n              const cx = box.x + box.width * 0.5;\n              const cy = box.y + box.height * 0.5;\n              const nx = (cx / vw) * 2 - 1;\n              const ny = (cy / vh) * 2 - 1;\n              medianPush(bufX.current, nx, 5);\n              medianPush(bufY.current, ny, 5);\n              const nxm = median(bufX.current);\n              const nym = median(bufY.current);\n\n              const look = new THREE.Vector2(Math.tanh(nxm), Math.tanh(nym));\n\n              const faceSize = Math.min(1, Math.hypot(box.width / vw, box.height / vh));\n              const depthScale = 1 + depthResponse * (faceSize - 0.25);\n              lookTarget.current.copy(look.multiplyScalar(depthScale));\n\n              const leftEye = res.landmarks.getLeftEye();\n              const rightEye = res.landmarks.getRightEye();\n              const lc = centroid(leftEye);\n              const rc = centroid(rightEye);\n              const tilt = Math.atan2(rc.y - lc.y, rc.x - lc.x);\n              medianPush(bufT.current, tilt, 5);\n              tiltTarget.current = median(bufT.current);\n\n              const nose = res.landmarks.getNose();\n              const tip = nose[nose.length - 1] || nose[Math.floor(nose.length / 2)];\n              const jaw = res.landmarks.getJawOutline();\n              const leftCheek = jaw[3] || jaw[2];\n              const rightCheek = jaw[13] || jaw[14];\n              const dL = dist2(tip, leftCheek);\n              const dR = dist2(tip, rightCheek);\n              const eyeDist = Math.hypot(rc.x - lc.x, rc.y - lc.y) + 1e-6;\n              let yawSignal = THREE.MathUtils.clamp((dR - dL) / (eyeDist * 1.6), -1, 1);\n              yawSignal = Math.tanh(yawSignal);\n              medianPush(bufYaw.current, yawSignal, 5);\n              yawTarget.current = median(bufYaw.current);\n\n              setUiFaceActive(true);\n            } else {\n              setUiFaceActive(false);\n            }\n          } catch {\n            setUiFaceActive(false);\n          }\n        }\n\n        if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\n          (video as any).requestVideoFrameCallback(() => detect(performance.now()));\n        } else {\n          requestAnimationFrame(detect);\n        }\n      };\n\n      requestAnimationFrame(detect);\n    };\n\n    start();\n\n    return () => {\n      stop = true;\n      const video = videoRef.current;\n      if (video) {\n        const stream = video.srcObject as MediaStream | null;\n        if (stream) stream.getTracks().forEach(t => t.stop());\n        video.pause();\n        video.srcObject = null;\n      }\n    };\n  }, [enableWebcam, modelsReady, depthResponse]);\n\n  return (\n    <div ref={containerRef} className={`relative w-full h-full overflow-hidden ${className ?? ''}`} style={style}>\n      {showPreview && (\n        <div className=\"absolute right-3 bottom-3 w-[220px] h-[132px] rounded-lg overflow-hidden border border-white/25 shadow-[0_4px_16px_rgba(0,0,0,0.4)] bg-black text-white text-[12px] leading-[1.2] font-sans pointer-events-none\">\n          <video ref={videoRef} muted playsInline autoPlay className=\"w-full h-full object-cover -scale-x-100\" />\n          <div className=\"absolute left-2 top-2 px-[6px] py-[2px] bg-black/50 rounded-[6px] backdrop-blur-[4px]\">\n            {enableWebcam\n              ? modelsReady\n                ? uiFaceActive\n                  ? 'Face: tracking'\n                  : 'Face: searching'\n                : 'Loading models'\n              : 'Webcam disabled'}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nfunction srgbColor(hex: string) {\n  const c = new THREE.Color(hex);\n  return c.convertSRGBToLinear();\n}\n\nfunction smoothDampVec2(\n  current: THREE.Vector2,\n  target: THREE.Vector2,\n  currentVelocity: THREE.Vector2,\n  smoothTime: number,\n  maxSpeed: number,\n  deltaTime: number\n): THREE.Vector2 {\n  const out = current.clone();\n  smoothTime = Math.max(0.0001, smoothTime);\n  const omega = 2 / smoothTime;\n  const x = omega * deltaTime;\n  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);\n\n  let change = current.clone().sub(target);\n  const originalTo = target.clone();\n\n  const maxChange = maxSpeed * smoothTime;\n  if (change.length() > maxChange) change.setLength(maxChange);\n\n  target = current.clone().sub(change);\n  const temp = currentVelocity.clone().addScaledVector(change, omega).multiplyScalar(deltaTime);\n  currentVelocity.sub(temp.clone().multiplyScalar(omega));\n  currentVelocity.multiplyScalar(exp);\n\n  out.copy(target.clone().add(change.add(temp).multiplyScalar(exp)));\n\n  const origMinusCurrent = originalTo.clone().sub(current);\n  const outMinusOrig = out.clone().sub(originalTo);\n  if (origMinusCurrent.dot(outMinusOrig) > 0) {\n    out.copy(originalTo);\n    currentVelocity.set(0, 0);\n  }\n  return out;\n}\n\nfunction smoothDampFloat(\n  current: number,\n  target: number,\n  velRef: { v: number },\n  smoothTime: number,\n  maxSpeed: number,\n  deltaTime: number\n): { value: number; v: number } {\n  smoothTime = Math.max(0.0001, smoothTime);\n  const omega = 2 / smoothTime;\n  const x = omega * deltaTime;\n  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);\n\n  let change = current - target;\n  const originalTo = target;\n\n  const maxChange = maxSpeed * smoothTime;\n  change = Math.sign(change) * Math.min(Math.abs(change), maxChange);\n\n  target = current - change;\n  const temp = (velRef.v + omega * change) * deltaTime;\n  velRef.v = (velRef.v - omega * temp) * exp;\n\n  let out = target + (change + temp) * exp;\n\n  const origMinusCurrent = originalTo - current;\n  const outMinusOrig = out - originalTo;\n  if (origMinusCurrent * outMinusOrig > 0) {\n    out = originalTo;\n    velRef.v = 0;\n  }\n  return { value: out, v: velRef.v };\n}\n\nfunction medianPush(buf: number[], v: number, maxLen: number) {\n  buf.push(v);\n  if (buf.length > maxLen) buf.shift();\n}\n\nfunction median(buf: number[]) {\n  if (buf.length === 0) return 0;\n  const a = [...buf].sort((x, y) => x - y);\n  const mid = Math.floor(a.length / 2);\n  return a.length % 2 ? a[mid] : (a[mid - 1] + a[mid]) * 0.5;\n}\n\nfunction centroid(points: { x: number; y: number }[]) {\n  let x = 0,\n    y = 0;\n  const n = points.length || 1;\n  for (const p of points) {\n    x += p.x;\n    y += p.y;\n  }\n  return { x: x / n, y: y / n };\n}\n\nfunction dist2(a: { x: number; y: number }, b: { x: number; y: number }) {\n  return Math.hypot(a.x - b.x, a.y - b.y);\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "hyperspeed",
      "type": "component",
      "description": "A hyperspeed driving simulation background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three",
        "postprocessing"
      ],
      "files": [
        {
          "path": "components/ui/hyperspeed.tsx",
          "content": "import { useEffect, useRef, FC } from 'react';\nimport * as THREE from 'three';\nimport { BloomEffect, EffectComposer, EffectPass, RenderPass, SMAAEffect, SMAAPreset } from 'postprocessing';\n\ninterface Distortion {\n  uniforms: Record<string, { value: any }>;\n  getDistortion: string;\n  getJS?: (progress: number, time: number) => THREE.Vector3;\n}\n\ninterface Distortions {\n  [key: string]: Distortion;\n}\n\ninterface Colors {\n  roadColor: number;\n  islandColor: number;\n  background: number;\n  shoulderLines: number;\n  brokenLines: number;\n  leftCars: number[];\n  rightCars: number[];\n  sticks: number;\n}\n\ninterface HyperspeedOptions {\n  onSpeedUp?: (ev: MouseEvent | TouchEvent) => void;\n  onSlowDown?: (ev: MouseEvent | TouchEvent) => void;\n  distortion?: string | Distortion;\n  length: number;\n  roadWidth: number;\n  islandWidth: number;\n  lanesPerRoad: number;\n  fov: number;\n  fovSpeedUp: number;\n  speedUp: number;\n  carLightsFade: number;\n  totalSideLightSticks: number;\n  lightPairsPerRoadWay: number;\n  shoulderLinesWidthPercentage: number;\n  brokenLinesWidthPercentage: number;\n  brokenLinesLengthPercentage: number;\n  lightStickWidth: [number, number];\n  lightStickHeight: [number, number];\n  movingAwaySpeed: [number, number];\n  movingCloserSpeed: [number, number];\n  carLightsLength: [number, number];\n  carLightsRadius: [number, number];\n  carWidthPercentage: [number, number];\n  carShiftX: [number, number];\n  carFloorSeparation: [number, number];\n  colors: Colors;\n  isHyper?: boolean;\n}\n\ninterface HyperspeedProps {\n  effectOptions?: Partial<HyperspeedOptions>;\n}\n\nconst defaultOptions: HyperspeedOptions = {\n  onSpeedUp: () => {},\n  onSlowDown: () => {},\n  distortion: 'turbulentDistortion',\n  length: 400,\n  roadWidth: 10,\n  islandWidth: 2,\n  lanesPerRoad: 4,\n  fov: 90,\n  fovSpeedUp: 150,\n  speedUp: 2,\n  carLightsFade: 0.4,\n  totalSideLightSticks: 20,\n  lightPairsPerRoadWay: 40,\n  shoulderLinesWidthPercentage: 0.05,\n  brokenLinesWidthPercentage: 0.1,\n  brokenLinesLengthPercentage: 0.5,\n  lightStickWidth: [0.12, 0.5],\n  lightStickHeight: [1.3, 1.7],\n  movingAwaySpeed: [60, 80],\n  movingCloserSpeed: [-120, -160],\n  carLightsLength: [400 * 0.03, 400 * 0.2],\n  carLightsRadius: [0.05, 0.14],\n  carWidthPercentage: [0.3, 0.5],\n  carShiftX: [-0.8, 0.8],\n  carFloorSeparation: [0, 5],\n  colors: {\n    roadColor: 0x080808,\n    islandColor: 0x0a0a0a,\n    background: 0x000000,\n    shoulderLines: 0xffffff,\n    brokenLines: 0xffffff,\n    leftCars: [0xd856bf, 0x6750a2, 0xc247ac],\n    rightCars: [0x03b3c3, 0x0e5ea5, 0x324555],\n    sticks: 0x03b3c3\n  }\n};\n\nfunction nsin(val: number) {\n  return Math.sin(val) * 0.5 + 0.5;\n}\n\nconst mountainUniforms = {\n  uFreq: { value: new THREE.Vector3(3, 6, 10) },\n  uAmp: { value: new THREE.Vector3(30, 30, 20) }\n};\n\nconst xyUniforms = {\n  uFreq: { value: new THREE.Vector2(5, 2) },\n  uAmp: { value: new THREE.Vector2(25, 15) }\n};\n\nconst LongRaceUniforms = {\n  uFreq: { value: new THREE.Vector2(2, 3) },\n  uAmp: { value: new THREE.Vector2(35, 10) }\n};\n\nconst turbulentUniforms = {\n  uFreq: { value: new THREE.Vector4(4, 8, 8, 1) },\n  uAmp: { value: new THREE.Vector4(25, 5, 10, 10) }\n};\n\nconst deepUniforms = {\n  uFreq: { value: new THREE.Vector2(4, 8) },\n  uAmp: { value: new THREE.Vector2(10, 20) },\n  uPowY: { value: new THREE.Vector2(20, 2) }\n};\n\nconst distortions: Distortions = {\n  mountainDistortion: {\n    uniforms: mountainUniforms,\n    getDistortion: `\n      uniform vec3 uAmp;\n      uniform vec3 uFreq;\n      #define PI 3.14159265358979\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      vec3 getDistortion(float progress){\n        float movementProgressFix = 0.02;\n        return vec3( \n          cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n          nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\n          nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\n        );\n      }\n    `,\n    getJS: (progress: number, time: number) => {\n      const movementProgressFix = 0.02;\n      const uFreq = mountainUniforms.uFreq.value;\n      const uAmp = mountainUniforms.uAmp.value;\n      const distortion = new THREE.Vector3(\n        Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\n          Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\n        nsin(progress * Math.PI * uFreq.y + time) * uAmp.y -\n          nsin(movementProgressFix * Math.PI * uFreq.y + time) * uAmp.y,\n        nsin(progress * Math.PI * uFreq.z + time) * uAmp.z -\n          nsin(movementProgressFix * Math.PI * uFreq.z + time) * uAmp.z\n      );\n      const lookAtAmp = new THREE.Vector3(2, 2, 2);\n      const lookAtOffset = new THREE.Vector3(0, 0, -5);\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\n    }\n  },\n  xyDistortion: {\n    uniforms: xyUniforms,\n    getDistortion: `\n      uniform vec2 uFreq;\n      uniform vec2 uAmp;\n      #define PI 3.14159265358979\n      vec3 getDistortion(float progress){\n        float movementProgressFix = 0.02;\n        return vec3( \n          cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n          sin(progress * PI * uFreq.y + PI/2. + uTime) * uAmp.y - sin(movementProgressFix * PI * uFreq.y + PI/2. + uTime) * uAmp.y,\n          0.\n        );\n      }\n    `,\n    getJS: (progress: number, time: number) => {\n      const movementProgressFix = 0.02;\n      const uFreq = xyUniforms.uFreq.value;\n      const uAmp = xyUniforms.uAmp.value;\n      const distortion = new THREE.Vector3(\n        Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\n          Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\n        Math.sin(progress * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y -\n          Math.sin(movementProgressFix * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y,\n        0\n      );\n      const lookAtAmp = new THREE.Vector3(2, 0.4, 1);\n      const lookAtOffset = new THREE.Vector3(0, 0, -3);\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\n    }\n  },\n  LongRaceDistortion: {\n    uniforms: LongRaceUniforms,\n    getDistortion: `\n      uniform vec2 uFreq;\n      uniform vec2 uAmp;\n      #define PI 3.14159265358979\n      vec3 getDistortion(float progress){\n        float camProgress = 0.0125;\n        return vec3( \n          sin(progress * PI * uFreq.x + uTime) * uAmp.x - sin(camProgress * PI * uFreq.x + uTime) * uAmp.x,\n          sin(progress * PI * uFreq.y + uTime) * uAmp.y - sin(camProgress * PI * uFreq.y + uTime) * uAmp.y,\n          0.\n        );\n      }\n    `,\n    getJS: (progress: number, time: number) => {\n      const camProgress = 0.0125;\n      const uFreq = LongRaceUniforms.uFreq.value;\n      const uAmp = LongRaceUniforms.uAmp.value;\n      const distortion = new THREE.Vector3(\n        Math.sin(progress * Math.PI * uFreq.x + time) * uAmp.x -\n          Math.sin(camProgress * Math.PI * uFreq.x + time) * uAmp.x,\n        Math.sin(progress * Math.PI * uFreq.y + time) * uAmp.y -\n          Math.sin(camProgress * Math.PI * uFreq.y + time) * uAmp.y,\n        0\n      );\n      const lookAtAmp = new THREE.Vector3(1, 1, 0);\n      const lookAtOffset = new THREE.Vector3(0, 0, -5);\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\n    }\n  },\n  turbulentDistortion: {\n    uniforms: turbulentUniforms,\n    getDistortion: `\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          cos(PI * progress * uFreq.r + uTime) * uAmp.r +\n          pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +\n          -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.0125),\n          getDistortionY(progress) - getDistortionY(0.0125),\n          0.\n        );\n      }\n    `,\n    getJS: (progress: number, time: number) => {\n      const uFreq = turbulentUniforms.uFreq.value;\n      const uAmp = turbulentUniforms.uAmp.value;\n\n      const getX = (p: number) =>\n        Math.cos(Math.PI * p * uFreq.x + time) * uAmp.x +\n        Math.pow(Math.cos(Math.PI * p * uFreq.y + time * (uFreq.y / uFreq.x)), 2) * uAmp.y;\n\n      const getY = (p: number) =>\n        -nsin(Math.PI * p * uFreq.z + time) * uAmp.z -\n        Math.pow(nsin(Math.PI * p * uFreq.w + time / (uFreq.z / uFreq.w)), 5) * uAmp.w;\n\n      const distortion = new THREE.Vector3(\n        getX(progress) - getX(progress + 0.007),\n        getY(progress) - getY(progress + 0.007),\n        0\n      );\n      const lookAtAmp = new THREE.Vector3(-2, -5, 0);\n      const lookAtOffset = new THREE.Vector3(0, 0, -10);\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\n    }\n  },\n  turbulentDistortionStill: {\n    uniforms: turbulentUniforms,\n    getDistortion: `\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          cos(PI * progress * uFreq.r) * uAmp.r +\n          pow(cos(PI * progress * uFreq.g * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          -nsin(PI * progress * uFreq.b) * uAmp.b +\n          -pow(nsin(PI * progress * uFreq.a / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.02),\n          0.\n        );\n      }\n    `\n  },\n  deepDistortionStill: {\n    uniforms: deepUniforms,\n    getDistortion: `\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      uniform vec2 uPowY;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          sin(progress * PI * uFreq.x) * uAmp.x * 2.\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y) * uAmp.y\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.05),\n          0.\n        );\n      }\n    `\n  },\n  deepDistortion: {\n    uniforms: deepUniforms,\n    getDistortion: `\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      uniform vec2 uPowY;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          sin(progress * PI * uFreq.x + uTime) * uAmp.x\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.02),\n          0.\n        );\n      }\n    `,\n    getJS: (progress: number, time: number) => {\n      const uFreq = deepUniforms.uFreq.value;\n      const uAmp = deepUniforms.uAmp.value;\n      const uPowY = deepUniforms.uPowY.value;\n\n      const getX = (p: number) => Math.sin(p * Math.PI * uFreq.x + time) * uAmp.x;\n      const getY = (p: number) => Math.pow(p * uPowY.x, uPowY.y) + Math.sin(p * Math.PI * uFreq.y + time) * uAmp.y;\n\n      const distortion = new THREE.Vector3(\n        getX(progress) - getX(progress + 0.01),\n        getY(progress) - getY(progress + 0.01),\n        0\n      );\n      const lookAtAmp = new THREE.Vector3(-2, -4, 0);\n      const lookAtOffset = new THREE.Vector3(0, 0, -10);\n      return distortion.multiply(lookAtAmp).add(lookAtOffset);\n    }\n  }\n};\n\nconst distortion_uniforms = {\n  uDistortionX: { value: new THREE.Vector2(80, 3) },\n  uDistortionY: { value: new THREE.Vector2(-40, 2.5) }\n};\n\nconst distortion_vertex = `\n  #define PI 3.14159265358979\n  uniform vec2 uDistortionX;\n  uniform vec2 uDistortionY;\n  float nsin(float val){\n    return sin(val) * 0.5 + 0.5;\n  }\n  vec3 getDistortion(float progress){\n    progress = clamp(progress, 0., 1.);\n    float xAmp = uDistortionX.r;\n    float xFreq = uDistortionX.g;\n    float yAmp = uDistortionY.r;\n    float yFreq = uDistortionY.g;\n    return vec3( \n      xAmp * nsin(progress * PI * xFreq - PI / 2.),\n      yAmp * nsin(progress * PI * yFreq - PI / 2.),\n      0.\n    );\n  }\n`;\n\nfunction random(base: number | [number, number]): number {\n  if (Array.isArray(base)) {\n    return Math.random() * (base[1] - base[0]) + base[0];\n  }\n  return Math.random() * base;\n}\n\nfunction pickRandom<T>(arr: T | T[]): T {\n  if (Array.isArray(arr)) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  }\n  return arr;\n}\n\nfunction lerp(current: number, target: number, speed = 0.1, limit = 0.001): number {\n  let change = (target - current) * speed;\n  if (Math.abs(change) < limit) {\n    change = target - current;\n  }\n  return change;\n}\n\nclass CarLights {\n  webgl: App;\n  options: HyperspeedOptions;\n  colors: number[] | THREE.Color;\n  speed: [number, number];\n  fade: THREE.Vector2;\n  mesh!: THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>;\n\n  constructor(\n    webgl: App,\n    options: HyperspeedOptions,\n    colors: number[] | THREE.Color,\n    speed: [number, number],\n    fade: THREE.Vector2\n  ) {\n    this.webgl = webgl;\n    this.options = options;\n    this.colors = colors;\n    this.speed = speed;\n    this.fade = fade;\n  }\n\n  init() {\n    const options = this.options;\n    const curve = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1));\n    const geometry = new THREE.TubeGeometry(curve, 40, 1, 8, false);\n\n    const instanced = new THREE.InstancedBufferGeometry().copy(geometry as any) as THREE.InstancedBufferGeometry;\n    instanced.instanceCount = options.lightPairsPerRoadWay * 2;\n\n    const laneWidth = options.roadWidth / options.lanesPerRoad;\n\n    const aOffset: number[] = [];\n    const aMetrics: number[] = [];\n    const aColor: number[] = [];\n\n    let colorArray: THREE.Color[];\n    if (Array.isArray(this.colors)) {\n      colorArray = this.colors.map(c => new THREE.Color(c));\n    } else {\n      colorArray = [new THREE.Color(this.colors)];\n    }\n\n    for (let i = 0; i < options.lightPairsPerRoadWay; i++) {\n      const radius = random(options.carLightsRadius);\n      const length = random(options.carLightsLength);\n      const spd = random(this.speed);\n\n      const carLane = i % options.lanesPerRoad;\n      let laneX = carLane * laneWidth - options.roadWidth / 2 + laneWidth / 2;\n\n      const carWidth = random(options.carWidthPercentage) * laneWidth;\n      const carShiftX = random(options.carShiftX) * laneWidth;\n      laneX += carShiftX;\n\n      const offsetY = random(options.carFloorSeparation) + radius * 1.3;\n      const offsetZ = -random(options.length);\n\n      aOffset.push(laneX - carWidth / 2);\n      aOffset.push(offsetY);\n      aOffset.push(offsetZ);\n\n      aOffset.push(laneX + carWidth / 2);\n      aOffset.push(offsetY);\n      aOffset.push(offsetZ);\n\n      aMetrics.push(radius);\n      aMetrics.push(length);\n      aMetrics.push(spd);\n\n      aMetrics.push(radius);\n      aMetrics.push(length);\n      aMetrics.push(spd);\n\n      const color = pickRandom<THREE.Color>(colorArray);\n      aColor.push(color.r);\n      aColor.push(color.g);\n      aColor.push(color.b);\n\n      aColor.push(color.r);\n      aColor.push(color.g);\n      aColor.push(color.b);\n    }\n\n    instanced.setAttribute('aOffset', new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false));\n    instanced.setAttribute('aMetrics', new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 3, false));\n    instanced.setAttribute('aColor', new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false));\n\n    const material = new THREE.ShaderMaterial({\n      fragmentShader: carLightsFragment,\n      vertexShader: carLightsVertex,\n      transparent: true,\n      uniforms: Object.assign(\n        {\n          uTime: { value: 0 },\n          uTravelLength: { value: options.length },\n          uFade: { value: this.fade }\n        },\n        this.webgl.fogUniforms,\n        (typeof this.options.distortion === 'object' ? this.options.distortion.uniforms : {}) || {}\n      )\n    });\n\n    material.onBeforeCompile = shader => {\n      shader.vertexShader = shader.vertexShader.replace(\n        '#include <getDistortion_vertex>',\n        typeof this.options.distortion === 'object' ? this.options.distortion.getDistortion : ''\n      );\n    };\n\n    const mesh = new THREE.Mesh(instanced, material);\n    mesh.frustumCulled = false;\n    this.webgl.scene.add(mesh);\n    this.mesh = mesh;\n  }\n\n  update(time: number) {\n    if (this.mesh.material.uniforms.uTime) {\n      this.mesh.material.uniforms.uTime.value = time;\n    }\n  }\n}\n\nconst carLightsFragment = `\n  #define USE_FOG;\n  ${THREE.ShaderChunk['fog_pars_fragment']}\n  varying vec3 vColor;\n  varying vec2 vUv; \n  uniform vec2 uFade;\n  void main() {\n    vec3 color = vec3(vColor);\n    float alpha = smoothstep(uFade.x, uFade.y, vUv.x);\n    gl_FragColor = vec4(color, alpha);\n    if (gl_FragColor.a < 0.0001) discard;\n    ${THREE.ShaderChunk['fog_fragment']}\n  }\n`;\n\nconst carLightsVertex = `\n  #define USE_FOG;\n  ${THREE.ShaderChunk['fog_pars_vertex']}\n  attribute vec3 aOffset;\n  attribute vec3 aMetrics;\n  attribute vec3 aColor;\n  uniform float uTravelLength;\n  uniform float uTime;\n  varying vec2 vUv; \n  varying vec3 vColor; \n  #include <getDistortion_vertex>\n  void main() {\n    vec3 transformed = position.xyz;\n    float radius = aMetrics.r;\n    float myLength = aMetrics.g;\n    float speed = aMetrics.b;\n\n    transformed.xy *= radius;\n    transformed.z *= myLength;\n\n    transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);\n    transformed.xy += aOffset.xy;\n\n    float progress = abs(transformed.z / uTravelLength);\n    transformed.xyz += getDistortion(progress);\n\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n    vColor = aColor;\n    ${THREE.ShaderChunk['fog_vertex']}\n  }\n`;\n\nclass LightsSticks {\n  webgl: App;\n  options: HyperspeedOptions;\n  mesh!: THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>;\n\n  constructor(webgl: App, options: HyperspeedOptions) {\n    this.webgl = webgl;\n    this.options = options;\n  }\n\n  init() {\n    const options = this.options;\n    const geometry = new THREE.PlaneGeometry(1, 1);\n    const instanced = new THREE.InstancedBufferGeometry().copy(geometry as any) as THREE.InstancedBufferGeometry;\n    const totalSticks = options.totalSideLightSticks;\n    instanced.instanceCount = totalSticks;\n\n    const stickoffset = options.length / (totalSticks - 1);\n    const aOffset: number[] = [];\n    const aColor: number[] = [];\n    const aMetrics: number[] = [];\n\n    let colorArray: THREE.Color[];\n    if (Array.isArray(options.colors.sticks)) {\n      colorArray = options.colors.sticks.map(c => new THREE.Color(c));\n    } else {\n      colorArray = [new THREE.Color(options.colors.sticks)];\n    }\n\n    for (let i = 0; i < totalSticks; i++) {\n      const width = random(options.lightStickWidth);\n      const height = random(options.lightStickHeight);\n      aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());\n\n      const color = pickRandom<THREE.Color>(colorArray);\n      aColor.push(color.r);\n      aColor.push(color.g);\n      aColor.push(color.b);\n\n      aMetrics.push(width);\n      aMetrics.push(height);\n    }\n\n    instanced.setAttribute('aOffset', new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false));\n    instanced.setAttribute('aColor', new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false));\n    instanced.setAttribute('aMetrics', new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false));\n\n    const material = new THREE.ShaderMaterial({\n      fragmentShader: sideSticksFragment,\n      vertexShader: sideSticksVertex,\n      side: THREE.DoubleSide,\n      uniforms: Object.assign(\n        {\n          uTravelLength: { value: options.length },\n          uTime: { value: 0 }\n        },\n        this.webgl.fogUniforms,\n        (typeof options.distortion === 'object' ? options.distortion.uniforms : {}) || {}\n      )\n    });\n\n    material.onBeforeCompile = shader => {\n      shader.vertexShader = shader.vertexShader.replace(\n        '#include <getDistortion_vertex>',\n        typeof this.options.distortion === 'object' ? this.options.distortion.getDistortion : ''\n      );\n    };\n\n    const mesh = new THREE.Mesh(instanced, material);\n    mesh.frustumCulled = false;\n    this.webgl.scene.add(mesh);\n    this.mesh = mesh;\n  }\n\n  update(time: number) {\n    if (this.mesh.material.uniforms.uTime) {\n      this.mesh.material.uniforms.uTime.value = time;\n    }\n  }\n}\n\nconst sideSticksVertex = `\n  #define USE_FOG;\n  ${THREE.ShaderChunk['fog_pars_vertex']}\n  attribute float aOffset;\n  attribute vec3 aColor;\n  attribute vec2 aMetrics;\n  uniform float uTravelLength;\n  uniform float uTime;\n  varying vec3 vColor;\n  mat4 rotationY( in float angle ) {\n    return mat4(\n      cos(angle),\t\t0,\t\tsin(angle),\t0,\n      0,\t\t        1.0,\t0,\t\t\t0,\n      -sin(angle),\t    0,\t\tcos(angle),\t0,\n      0, \t\t        0,\t\t0,\t\t\t1\n    );\n  }\n  #include <getDistortion_vertex>\n  void main(){\n    vec3 transformed = position.xyz;\n    float width = aMetrics.x;\n    float height = aMetrics.y;\n\n    transformed.xy *= vec2(width, height);\n    float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);\n\n    transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\n    transformed.z += - uTravelLength + time;\n\n    float progress = abs(transformed.z / uTravelLength);\n    transformed.xyz += getDistortion(progress);\n\n    transformed.y += height / 2.;\n    transformed.x += -width / 2.;\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vColor = aColor;\n    ${THREE.ShaderChunk['fog_vertex']}\n  }\n`;\n\nconst sideSticksFragment = `\n  #define USE_FOG;\n  ${THREE.ShaderChunk['fog_pars_fragment']}\n  varying vec3 vColor;\n  void main(){\n    vec3 color = vec3(vColor);\n    gl_FragColor = vec4(color,1.);\n    ${THREE.ShaderChunk['fog_fragment']}\n  }\n`;\n\nclass Road {\n  webgl: App;\n  options: HyperspeedOptions;\n  uTime: { value: number };\n  leftRoadWay!: THREE.Mesh;\n  rightRoadWay!: THREE.Mesh;\n  island!: THREE.Mesh;\n\n  constructor(webgl: App, options: HyperspeedOptions) {\n    this.webgl = webgl;\n    this.options = options;\n    this.uTime = { value: 0 };\n  }\n\n  createPlane(side: number, width: number, isRoad: boolean) {\n    const options = this.options;\n    const segments = 100;\n    const geometry = new THREE.PlaneGeometry(\n      isRoad ? options.roadWidth : options.islandWidth,\n      options.length,\n      20,\n      segments\n    );\n\n    let uniforms: Record<string, { value: any }> = {\n      uTravelLength: { value: options.length },\n      uColor: {\n        value: new THREE.Color(isRoad ? options.colors.roadColor : options.colors.islandColor)\n      },\n      uTime: this.uTime\n    };\n\n    if (isRoad) {\n      uniforms = Object.assign(uniforms, {\n        uLanes: { value: options.lanesPerRoad },\n        uBrokenLinesColor: {\n          value: new THREE.Color(options.colors.brokenLines)\n        },\n        uShoulderLinesColor: {\n          value: new THREE.Color(options.colors.shoulderLines)\n        },\n        uShoulderLinesWidthPercentage: {\n          value: options.shoulderLinesWidthPercentage\n        },\n        uBrokenLinesLengthPercentage: {\n          value: options.brokenLinesLengthPercentage\n        },\n        uBrokenLinesWidthPercentage: {\n          value: options.brokenLinesWidthPercentage\n        }\n      });\n    }\n\n    const material = new THREE.ShaderMaterial({\n      fragmentShader: isRoad ? roadFragment : islandFragment,\n      vertexShader: roadVertex,\n      side: THREE.DoubleSide,\n      uniforms: Object.assign(\n        uniforms,\n        this.webgl.fogUniforms,\n        (typeof options.distortion === 'object' ? options.distortion.uniforms : {}) || {}\n      )\n    });\n\n    material.onBeforeCompile = shader => {\n      shader.vertexShader = shader.vertexShader.replace(\n        '#include <getDistortion_vertex>',\n        typeof this.options.distortion === 'object' ? this.options.distortion.getDistortion : ''\n      );\n    };\n\n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.rotation.x = -Math.PI / 2;\n    mesh.position.z = -options.length / 2;\n    mesh.position.x += (this.options.islandWidth / 2 + options.roadWidth / 2) * side;\n\n    this.webgl.scene.add(mesh);\n    return mesh;\n  }\n\n  init() {\n    this.leftRoadWay = this.createPlane(-1, this.options.roadWidth, true);\n    this.rightRoadWay = this.createPlane(1, this.options.roadWidth, true);\n    this.island = this.createPlane(0, this.options.islandWidth, false);\n  }\n\n  update(time: number) {\n    this.uTime.value = time;\n  }\n}\n\nconst roadBaseFragment = `\n  #define USE_FOG;\n  varying vec2 vUv; \n  uniform vec3 uColor;\n  uniform float uTime;\n  #include <roadMarkings_vars>\n  ${THREE.ShaderChunk['fog_pars_fragment']}\n  void main() {\n    vec2 uv = vUv;\n    vec3 color = vec3(uColor);\n    #include <roadMarkings_fragment>\n    gl_FragColor = vec4(color, 1.);\n    ${THREE.ShaderChunk['fog_fragment']}\n  }\n`;\n\nconst islandFragment = roadBaseFragment\n  .replace('#include <roadMarkings_fragment>', '')\n  .replace('#include <roadMarkings_vars>', '');\n\nconst roadMarkings_vars = `\n  uniform float uLanes;\n  uniform vec3 uBrokenLinesColor;\n  uniform vec3 uShoulderLinesColor;\n  uniform float uShoulderLinesWidthPercentage;\n  uniform float uBrokenLinesWidthPercentage;\n  uniform float uBrokenLinesLengthPercentage;\n  highp float random(vec2 co) {\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy, vec2(a, b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n  }\n`;\n\nconst roadMarkings_fragment = `\n  uv.y = mod(uv.y + uTime * 0.05, 1.);\n  float laneWidth = 1.0 / uLanes;\n  float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;\n  float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n  float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));\n  float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x);\n\n  brokenLines = mix(brokenLines, sideLines, uv.x);\n`;\n\nconst roadFragment = roadBaseFragment\n  .replace('#include <roadMarkings_fragment>', roadMarkings_fragment)\n  .replace('#include <roadMarkings_vars>', roadMarkings_vars);\n\nconst roadVertex = `\n  #define USE_FOG;\n  uniform float uTime;\n  ${THREE.ShaderChunk['fog_pars_vertex']}\n  uniform float uTravelLength;\n  varying vec2 vUv; \n  #include <getDistortion_vertex>\n  void main() {\n    vec3 transformed = position.xyz;\n    vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n    transformed.x += distortion.x;\n    transformed.z += distortion.y;\n    transformed.y += -1. * distortion.z;  \n    \n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n    ${THREE.ShaderChunk['fog_vertex']}\n  }\n`;\n\nfunction resizeRendererToDisplaySize(\n  renderer: THREE.WebGLRenderer,\n  setSize: (width: number, height: number, updateStyle: boolean) => void\n) {\n  const canvas = renderer.domElement;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n  const needResize = canvas.width !== width || canvas.height !== height;\n  if (needResize) {\n    setSize(width, height, false);\n  }\n  return needResize;\n}\n\nclass App {\n  container: HTMLElement;\n  options: HyperspeedOptions;\n  renderer: THREE.WebGLRenderer;\n  composer: EffectComposer;\n  camera: THREE.PerspectiveCamera;\n  scene: THREE.Scene;\n  renderPass!: RenderPass;\n  bloomPass!: EffectPass;\n  clock: THREE.Clock;\n  assets: Record<string, any>;\n  disposed: boolean;\n  road: Road;\n  leftCarLights: CarLights;\n  rightCarLights: CarLights;\n  leftSticks: LightsSticks;\n  fogUniforms: Record<string, { value: any }>;\n  fovTarget: number;\n  speedUpTarget: number;\n  speedUp: number;\n  timeOffset: number;\n\n  constructor(container: HTMLElement, options: HyperspeedOptions) {\n    this.options = options;\n    if (!this.options.distortion) {\n      this.options.distortion = {\n        uniforms: distortion_uniforms,\n        getDistortion: distortion_vertex\n      };\n    }\n    this.container = container;\n\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: false,\n      alpha: true\n    });\n    this.renderer.setSize(container.offsetWidth, container.offsetHeight, false);\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n\n    this.composer = new EffectComposer(this.renderer);\n    container.appendChild(this.renderer.domElement);\n\n    this.camera = new THREE.PerspectiveCamera(options.fov, container.offsetWidth / container.offsetHeight, 0.1, 10000);\n    this.camera.position.z = -5;\n    this.camera.position.y = 8;\n    this.camera.position.x = 0;\n\n    this.scene = new THREE.Scene();\n    this.scene.background = null;\n\n    const fog = new THREE.Fog(options.colors.background, options.length * 0.2, options.length * 500);\n    this.scene.fog = fog;\n\n    this.fogUniforms = {\n      fogColor: { value: fog.color },\n      fogNear: { value: fog.near },\n      fogFar: { value: fog.far }\n    };\n\n    this.clock = new THREE.Clock();\n    this.assets = {};\n    this.disposed = false;\n\n    this.road = new Road(this, options);\n    this.leftCarLights = new CarLights(\n      this,\n      options,\n      options.colors.leftCars,\n      options.movingAwaySpeed,\n      new THREE.Vector2(0, 1 - options.carLightsFade)\n    );\n    this.rightCarLights = new CarLights(\n      this,\n      options,\n      options.colors.rightCars,\n      options.movingCloserSpeed,\n      new THREE.Vector2(1, 0 + options.carLightsFade)\n    );\n    this.leftSticks = new LightsSticks(this, options);\n\n    this.fovTarget = options.fov;\n    this.speedUpTarget = 0;\n    this.speedUp = 0;\n    this.timeOffset = 0;\n\n    this.tick = this.tick.bind(this);\n    this.init = this.init.bind(this);\n    this.setSize = this.setSize.bind(this);\n    this.onMouseDown = this.onMouseDown.bind(this);\n    this.onMouseUp = this.onMouseUp.bind(this);\n\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onContextMenu = this.onContextMenu.bind(this);\n\n    window.addEventListener('resize', this.onWindowResize.bind(this));\n  }\n\n  onWindowResize() {\n    const width = this.container.offsetWidth;\n    const height = this.container.offsetHeight;\n\n    this.renderer.setSize(width, height);\n    this.camera.aspect = width / height;\n    this.camera.updateProjectionMatrix();\n    this.composer.setSize(width, height);\n  }\n\n  initPasses() {\n    this.renderPass = new RenderPass(this.scene, this.camera);\n    this.bloomPass = new EffectPass(\n      this.camera,\n      new BloomEffect({\n        luminanceThreshold: 0.2,\n        luminanceSmoothing: 0,\n        resolutionScale: 1\n      })\n    );\n\n    const smaaPass = new EffectPass(\n      this.camera,\n      new SMAAEffect({\n        preset: SMAAPreset.MEDIUM\n      })\n    );\n    this.renderPass.renderToScreen = false;\n    this.bloomPass.renderToScreen = false;\n    smaaPass.renderToScreen = true;\n\n    this.composer.addPass(this.renderPass);\n    this.composer.addPass(this.bloomPass);\n    this.composer.addPass(smaaPass);\n  }\n\n  loadAssets(): Promise<void> {\n    const assets = this.assets;\n    return new Promise(resolve => {\n      const manager = new THREE.LoadingManager(resolve);\n\n      const searchImage = new Image();\n      const areaImage = new Image();\n      assets.smaa = {};\n\n      searchImage.addEventListener('load', function () {\n        assets.smaa.search = this;\n        manager.itemEnd('smaa-search');\n      });\n\n      areaImage.addEventListener('load', function () {\n        assets.smaa.area = this;\n        manager.itemEnd('smaa-area');\n      });\n\n      manager.itemStart('smaa-search');\n      manager.itemStart('smaa-area');\n\n      searchImage.src = SMAAEffect.searchImageDataURL;\n      areaImage.src = SMAAEffect.areaImageDataURL;\n    });\n  }\n\n  init() {\n    this.initPasses();\n    const options = this.options;\n    this.road.init();\n    this.leftCarLights.init();\n    this.leftCarLights.mesh.position.setX(-options.roadWidth / 2 - options.islandWidth / 2);\n\n    this.rightCarLights.init();\n    this.rightCarLights.mesh.position.setX(options.roadWidth / 2 + options.islandWidth / 2);\n\n    this.leftSticks.init();\n    this.leftSticks.mesh.position.setX(-(options.roadWidth + options.islandWidth / 2));\n\n    this.container.addEventListener('mousedown', this.onMouseDown);\n    this.container.addEventListener('mouseup', this.onMouseUp);\n    this.container.addEventListener('mouseout', this.onMouseUp);\n\n    this.container.addEventListener('touchstart', this.onTouchStart, {\n      passive: true\n    });\n    this.container.addEventListener('touchend', this.onTouchEnd, {\n      passive: true\n    });\n    this.container.addEventListener('touchcancel', this.onTouchEnd, {\n      passive: true\n    });\n    this.container.addEventListener('contextmenu', this.onContextMenu);\n\n    this.tick();\n  }\n\n  onMouseDown(ev: MouseEvent) {\n    if (this.options.onSpeedUp) this.options.onSpeedUp(ev);\n    this.fovTarget = this.options.fovSpeedUp;\n    this.speedUpTarget = this.options.speedUp;\n  }\n\n  onMouseUp(ev: MouseEvent) {\n    if (this.options.onSlowDown) this.options.onSlowDown(ev);\n    this.fovTarget = this.options.fov;\n    this.speedUpTarget = 0;\n  }\n\n  onTouchStart(ev: TouchEvent) {\n    if (this.options.onSpeedUp) this.options.onSpeedUp(ev);\n    this.fovTarget = this.options.fovSpeedUp;\n    this.speedUpTarget = this.options.speedUp;\n  }\n\n  onTouchEnd(ev: TouchEvent) {\n    if (this.options.onSlowDown) this.options.onSlowDown(ev);\n    this.fovTarget = this.options.fov;\n    this.speedUpTarget = 0;\n  }\n\n  onContextMenu(ev: MouseEvent) {\n    ev.preventDefault();\n  }\n\n  update(delta: number) {\n    const lerpPercentage = Math.exp(-(-60 * Math.log2(1 - 0.1)) * delta);\n    this.speedUp += lerp(this.speedUp, this.speedUpTarget, lerpPercentage, 0.00001);\n    this.timeOffset += this.speedUp * delta;\n    const time = this.clock.elapsedTime + this.timeOffset;\n\n    this.rightCarLights.update(time);\n    this.leftCarLights.update(time);\n    this.leftSticks.update(time);\n    this.road.update(time);\n\n    let updateCamera = false;\n    const fovChange = lerp(this.camera.fov, this.fovTarget, lerpPercentage);\n    if (fovChange !== 0) {\n      this.camera.fov += fovChange * delta * 6;\n      updateCamera = true;\n    }\n\n    if (typeof this.options.distortion === 'object' && this.options.distortion.getJS) {\n      const distortion = this.options.distortion.getJS(0.025, time);\n      this.camera.lookAt(\n        new THREE.Vector3(\n          this.camera.position.x + distortion.x,\n          this.camera.position.y + distortion.y,\n          this.camera.position.z + distortion.z\n        )\n      );\n      updateCamera = true;\n    }\n\n    if (updateCamera) {\n      this.camera.updateProjectionMatrix();\n    }\n  }\n\n  render(delta: number) {\n    this.composer.render(delta);\n  }\n\n  dispose() {\n    this.disposed = true;\n\n    if (this.renderer) {\n      this.renderer.dispose();\n    }\n    if (this.composer) {\n      this.composer.dispose();\n    }\n    if (this.scene) {\n      this.scene.clear();\n    }\n\n    window.removeEventListener('resize', this.onWindowResize.bind(this));\n    if (this.container) {\n      this.container.removeEventListener('mousedown', this.onMouseDown);\n      this.container.removeEventListener('mouseup', this.onMouseUp);\n      this.container.removeEventListener('mouseout', this.onMouseUp);\n\n      this.container.removeEventListener('touchstart', this.onTouchStart);\n      this.container.removeEventListener('touchend', this.onTouchEnd);\n      this.container.removeEventListener('touchcancel', this.onTouchEnd);\n      this.container.removeEventListener('contextmenu', this.onContextMenu);\n    }\n  }\n\n  setSize(width: number, height: number, updateStyles: boolean) {\n    this.composer.setSize(width, height, updateStyles);\n  }\n\n  tick() {\n    if (this.disposed || !this) return;\n    if (resizeRendererToDisplaySize(this.renderer, this.setSize)) {\n      const canvas = this.renderer.domElement;\n      this.camera.aspect = canvas.clientWidth / canvas.clientHeight;\n      this.camera.updateProjectionMatrix();\n    }\n    const delta = this.clock.getDelta();\n    this.render(delta);\n    this.update(delta);\n    requestAnimationFrame(this.tick);\n  }\n}\n\nconst Hyperspeed: FC<HyperspeedProps> = ({ effectOptions = {} }) => {\n  const mergedOptions: HyperspeedOptions = {\n    ...defaultOptions,\n    ...effectOptions\n  };\n  const hyperspeed = useRef<HTMLDivElement>(null);\n  const appRef = useRef<App | null>(null);\n\n  useEffect(() => {\n    if (appRef.current) {\n      appRef.current.dispose();\n      const container = document.getElementById('lights');\n      if (container) {\n        while (container.firstChild) {\n          container.removeChild(container.firstChild);\n        }\n      }\n    }\n\n    const container = hyperspeed.current;\n    if (!container) return;\n\n    const options = { ...mergedOptions };\n    if (typeof options.distortion === 'string') {\n      options.distortion = distortions[options.distortion];\n    }\n\n    const myApp = new App(container, options);\n    appRef.current = myApp;\n    myApp.loadAssets().then(myApp.init);\n\n    return () => {\n      if (appRef.current) {\n        appRef.current.dispose();\n      }\n    };\n  }, [mergedOptions]);\n\n  return <div id=\"lights\" className=\"w-full h-full\" ref={hyperspeed}></div>;\n};\n\nexport default Hyperspeed;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "interactive-grid-pattern",
      "type": "component",
      "description": "A backgrounds interactive grid pattern component",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/interactive-grid-pattern.tsx",
          "content": "\"use client\"\n\nimport React, { useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\n/**\n * InteractiveGridPattern is a component that renders a grid pattern with interactive squares.\n *\n * @param width - The width of each square.\n * @param height - The height of each square.\n * @param squares - The number of squares in the grid. The first element is the number of horizontal squares, and the second element is the number of vertical squares.\n * @param className - The class name of the grid.\n * @param squaresClassName - The class name of the squares.\n */\ninterface InteractiveGridPatternProps extends React.SVGProps<SVGSVGElement> {\n  width?: number\n  height?: number\n  squares?: [number, number] // [horizontal, vertical]\n  className?: string\n  squaresClassName?: string\n}\n\n/**\n * The InteractiveGridPattern component.\n *\n * @see InteractiveGridPatternProps for the props interface.\n * @returns A React component.\n */\nexport function InteractiveGridPattern({\n  width = 40,\n  height = 40,\n  squares = [24, 24],\n  className,\n  squaresClassName,\n  ...props\n}: InteractiveGridPatternProps) {\n  const [horizontal, vertical] = squares\n  const [hoveredSquare, setHoveredSquare] = useState<number | null>(null)\n\n  return (\n    <svg\n      width={width * horizontal}\n      height={height * vertical}\n      className={cn(\n        \"absolute inset-0 h-full w-full border border-gray-400/30\",\n        className\n      )}\n      {...props}\n    >\n      {Array.from({ length: horizontal * vertical }).map((_, index) => {\n        const x = (index % horizontal) * width\n        const y = Math.floor(index / horizontal) * height\n        return (\n          <rect\n            key={index}\n            x={x}\n            y={y}\n            width={width}\n            height={height}\n            className={cn(\n              \"stroke-gray-400/30 transition-all duration-100 ease-in-out [&:not(:hover)]:duration-1000\",\n              hoveredSquare === index ? \"fill-gray-300/30\" : \"fill-transparent\",\n              squaresClassName\n            )}\n            onMouseEnter={() => setHoveredSquare(index)}\n            onMouseLeave={() => setHoveredSquare(null)}\n          />\n        )\n      })}\n    </svg>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "backgrounds"
        ]
      }
    },
    {
      "name": "iridescence",
      "type": "component",
      "description": "An iridescent shimmering background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/iridescence.tsx",
          "content": "import { Renderer, Program, Mesh, Color, Triangle } from 'ogl';\nimport { useEffect, useRef } from 'react';\n\nconst vertexShader = `\nattribute vec2 uv;\nattribute vec2 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0, 1);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\nuniform float uTime;\nuniform vec3 uColor;\nuniform vec3 uResolution;\nuniform vec2 uMouse;\nuniform float uAmplitude;\nuniform float uSpeed;\n\nvarying vec2 vUv;\n\nvoid main() {\n  float mr = min(uResolution.x, uResolution.y);\n  vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;\n\n  uv += (uMouse - vec2(0.5)) * uAmplitude;\n\n  float d = -uTime * 0.5 * uSpeed;\n  float a = 0.0;\n  for (float i = 0.0; i < 8.0; ++i) {\n    a += cos(i - d - a * uv.x);\n    d += sin(uv.y * i + a);\n  }\n  d += uTime * 0.5 * uSpeed;\n  vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);\n  col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * uColor;\n  gl_FragColor = vec4(col, 1.0);\n}\n`;\n\ninterface IridescenceProps {\n  color?: [number, number, number];\n  speed?: number;\n  amplitude?: number;\n  mouseReact?: boolean;\n}\n\nexport default function Iridescence({\n  color = [1, 1, 1],\n  speed = 1.0,\n  amplitude = 0.1,\n  mouseReact = true,\n  ...rest\n}: IridescenceProps) {\n  const ctnDom = useRef<HTMLDivElement>(null);\n  const mousePos = useRef({ x: 0.5, y: 0.5 });\n\n  useEffect(() => {\n    if (!ctnDom.current) return;\n    const ctn = ctnDom.current;\n    const renderer = new Renderer();\n    const gl = renderer.gl;\n    gl.clearColor(1, 1, 1, 1);\n\n    let program: Program;\n\n    function resize() {\n      const scale = 1;\n      renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n      if (program) {\n        program.uniforms.uResolution.value = new Color(\n          gl.canvas.width,\n          gl.canvas.height,\n          gl.canvas.width / gl.canvas.height\n        );\n      }\n    }\n    window.addEventListener('resize', resize, false);\n    resize();\n\n    const geometry = new Triangle(gl);\n    program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        uTime: { value: 0 },\n        uColor: { value: new Color(...color) },\n        uResolution: {\n          value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n        },\n        uMouse: { value: new Float32Array([mousePos.current.x, mousePos.current.y]) },\n        uAmplitude: { value: amplitude },\n        uSpeed: { value: speed }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n    let animateId: number;\n\n    function update(t: number) {\n      animateId = requestAnimationFrame(update);\n      program.uniforms.uTime.value = t * 0.001;\n      renderer.render({ scene: mesh });\n    }\n    animateId = requestAnimationFrame(update);\n    ctn.appendChild(gl.canvas);\n\n    function handleMouseMove(e: MouseEvent) {\n      const rect = ctn.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n      mousePos.current = { x, y };\n      program.uniforms.uMouse.value[0] = x;\n      program.uniforms.uMouse.value[1] = y;\n    }\n    if (mouseReact) {\n      ctn.addEventListener('mousemove', handleMouseMove);\n    }\n\n    return () => {\n      cancelAnimationFrame(animateId);\n      window.removeEventListener('resize', resize);\n      if (mouseReact) {\n        ctn.removeEventListener('mousemove', handleMouseMove);\n      }\n      ctn.removeChild(gl.canvas);\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n    };\n  }, [color, speed, amplitude, mouseReact]);\n\n  return <div ref={ctnDom} className=\"w-full h-full\" {...rest} />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "letter-glitch",
      "type": "component",
      "description": "A glitchy letter animation background effect.",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/letter-glitch.tsx",
          "content": "import { useRef, useEffect } from 'react';\n\nconst LetterGlitch = ({\n  glitchColors = ['#2b4539', '#61dca3', '#61b3dc'],\n  glitchSpeed = 50,\n  centerVignette = false,\n  outerVignette = true,\n  smooth = true,\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$&*()-_+=/[]{};:<>.,0123456789'\n}: {\n  glitchColors: string[];\n  glitchSpeed: number;\n  centerVignette: boolean;\n  outerVignette: boolean;\n  smooth: boolean;\n  characters: string;\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const animationRef = useRef<number | null>(null);\n  const letters = useRef<\n    {\n      char: string;\n      color: string;\n      targetColor: string;\n      colorProgress: number;\n    }[]\n  >([]);\n  const grid = useRef({ columns: 0, rows: 0 });\n  const context = useRef<CanvasRenderingContext2D | null>(null);\n  const lastGlitchTime = useRef(Date.now());\n\n  const lettersAndSymbols = Array.from(characters);\n\n  const fontSize = 16;\n  const charWidth = 10;\n  const charHeight = 20;\n\n  const getRandomChar = () => {\n    return lettersAndSymbols[Math.floor(Math.random() * lettersAndSymbols.length)];\n  };\n\n  const getRandomColor = () => {\n    return glitchColors[Math.floor(Math.random() * glitchColors.length)];\n  };\n\n  const hexToRgb = (hex: string) => {\n    const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    hex = hex.replace(shorthandRegex, (_m, r, g, b) => {\n      return r + r + g + g + b + b;\n    });\n\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n      ? {\n          r: parseInt(result[1], 16),\n          g: parseInt(result[2], 16),\n          b: parseInt(result[3], 16)\n        }\n      : null;\n  };\n\n  const interpolateColor = (\n    start: { r: number; g: number; b: number },\n    end: { r: number; g: number; b: number },\n    factor: number\n  ) => {\n    const result = {\n      r: Math.round(start.r + (end.r - start.r) * factor),\n      g: Math.round(start.g + (end.g - start.g) * factor),\n      b: Math.round(start.b + (end.b - start.b) * factor)\n    };\n    return `rgb(${result.r}, ${result.g}, ${result.b})`;\n  };\n\n  const calculateGrid = (width: number, height: number) => {\n    const columns = Math.ceil(width / charWidth);\n    const rows = Math.ceil(height / charHeight);\n    return { columns, rows };\n  };\n\n  const initializeLetters = (columns: number, rows: number) => {\n    grid.current = { columns, rows };\n    const totalLetters = columns * rows;\n    letters.current = Array.from({ length: totalLetters }, () => ({\n      char: getRandomChar(),\n      color: getRandomColor(),\n      targetColor: getRandomColor(),\n      colorProgress: 1\n    }));\n  };\n\n  const resizeCanvas = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const parent = canvas.parentElement;\n    if (!parent) return;\n\n    const dpr = window.devicePixelRatio || 1;\n    const rect = parent.getBoundingClientRect();\n\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n\n    canvas.style.width = `${rect.width}px`;\n    canvas.style.height = `${rect.height}px`;\n\n    if (context.current) {\n      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    const { columns, rows } = calculateGrid(rect.width, rect.height);\n    initializeLetters(columns, rows);\n    drawLetters();\n  };\n\n  const drawLetters = () => {\n    if (!context.current || letters.current.length === 0) return;\n    const ctx = context.current;\n    const { width, height } = canvasRef.current!.getBoundingClientRect();\n    ctx.clearRect(0, 0, width, height);\n    ctx.font = `${fontSize}px monospace`;\n    ctx.textBaseline = 'top';\n\n    letters.current.forEach((letter, index) => {\n      const x = (index % grid.current.columns) * charWidth;\n      const y = Math.floor(index / grid.current.columns) * charHeight;\n      ctx.fillStyle = letter.color;\n      ctx.fillText(letter.char, x, y);\n    });\n  };\n\n  const updateLetters = () => {\n    if (!letters.current || letters.current.length === 0) return;\n\n    const updateCount = Math.max(1, Math.floor(letters.current.length * 0.05));\n\n    for (let i = 0; i < updateCount; i++) {\n      const index = Math.floor(Math.random() * letters.current.length);\n      if (!letters.current[index]) continue;\n\n      letters.current[index].char = getRandomChar();\n      letters.current[index].targetColor = getRandomColor();\n\n      if (!smooth) {\n        letters.current[index].color = letters.current[index].targetColor;\n        letters.current[index].colorProgress = 1;\n      } else {\n        letters.current[index].colorProgress = 0;\n      }\n    }\n  };\n\n  const handleSmoothTransitions = () => {\n    let needsRedraw = false;\n    letters.current.forEach(letter => {\n      if (letter.colorProgress < 1) {\n        letter.colorProgress += 0.05;\n        if (letter.colorProgress > 1) letter.colorProgress = 1;\n\n        const startRgb = hexToRgb(letter.color);\n        const endRgb = hexToRgb(letter.targetColor);\n        if (startRgb && endRgb) {\n          letter.color = interpolateColor(startRgb, endRgb, letter.colorProgress);\n          needsRedraw = true;\n        }\n      }\n    });\n\n    if (needsRedraw) {\n      drawLetters();\n    }\n  };\n\n  const animate = () => {\n    const now = Date.now();\n    if (now - lastGlitchTime.current >= glitchSpeed) {\n      updateLetters();\n      drawLetters();\n      lastGlitchTime.current = now;\n    }\n\n    if (smooth) {\n      handleSmoothTransitions();\n    }\n\n    animationRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    context.current = canvas.getContext('2d');\n    resizeCanvas();\n    animate();\n\n    let resizeTimeout: ReturnType<typeof setTimeout>;\n\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        cancelAnimationFrame(animationRef.current as number);\n        resizeCanvas();\n        animate();\n      }, 100);\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      cancelAnimationFrame(animationRef.current!);\n      window.removeEventListener('resize', handleResize);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [glitchSpeed, smooth]);\n\n  return (\n    <div className=\"relative w-full h-full bg-black overflow-hidden\">\n      <canvas ref={canvasRef} className=\"block w-full h-full\" />\n      {outerVignette && (\n        <div className=\"absolute top-0 left-0 w-full h-full pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0)_60%,_rgba(0,0,0,1)_100%)]\"></div>\n      )}\n      {centerVignette && (\n        <div className=\"absolute top-0 left-0 w-full h-full pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0.8)_0%,_rgba(0,0,0,0)_60%)]\"></div>\n      )}\n    </div>\n  );\n};\n\nexport default LetterGlitch;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "light-pillar",
      "type": "component",
      "description": "An animated light pillar background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/light-pillar.tsx",
          "content": "import React, { useRef, useEffect, useState } from 'react';\nimport * as THREE from 'three';\n\ninterface LightPillarProps {\n  topColor?: string;\n  bottomColor?: string;\n  intensity?: number;\n  rotationSpeed?: number;\n  interactive?: boolean;\n  className?: string;\n  glowAmount?: number;\n  pillarWidth?: number;\n  pillarHeight?: number;\n  noiseIntensity?: number;\n  mixBlendMode?: React.CSSProperties['mixBlendMode'];\n  pillarRotation?: number;\n  quality?: 'low' | 'medium' | 'high';\n}\n\nconst LightPillar: React.FC<LightPillarProps> = ({\n  topColor = '#5227FF',\n  bottomColor = '#FF9FFC',\n  intensity = 1.0,\n  rotationSpeed = 0.3,\n  interactive = false,\n  className = '',\n  glowAmount = 0.005,\n  pillarWidth = 3.0,\n  pillarHeight = 0.4,\n  noiseIntensity = 0.5,\n  mixBlendMode = 'screen',\n  pillarRotation = 0,\n  quality = 'high'\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const rafRef = useRef<number | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const materialRef = useRef<THREE.ShaderMaterial | null>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const cameraRef = useRef<THREE.OrthographicCamera | null>(null);\n  const geometryRef = useRef<THREE.PlaneGeometry | null>(null);\n  const mouseRef = useRef<THREE.Vector2>(new THREE.Vector2(0, 0));\n  const timeRef = useRef<number>(0);\n  const [webGLSupported, setWebGLSupported] = useState<boolean>(true);\n\n  // Check WebGL support\n  useEffect(() => {\n    const canvas = document.createElement('canvas');\n    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    if (!gl) {\n      setWebGLSupported(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    if (!containerRef.current || !webGLSupported) return;\n\n    const container = containerRef.current;\n    const width = container.clientWidth;\n    const height = container.clientHeight;\n\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    const isLowEndDevice = isMobile || (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4);\n\n    let effectiveQuality = quality;\n    if (isLowEndDevice && quality === 'high') effectiveQuality = 'medium';\n    if (isMobile && quality !== 'low') effectiveQuality = 'low';\n\n    const qualitySettings = {\n      low: { iterations: 24, waveIterations: 1, pixelRatio: 0.5, precision: 'mediump', stepMultiplier: 1.5 },\n      medium: { iterations: 40, waveIterations: 2, pixelRatio: 0.65, precision: 'mediump', stepMultiplier: 1.2 },\n      high: {\n        iterations: 80,\n        waveIterations: 4,\n        pixelRatio: Math.min(window.devicePixelRatio, 2),\n        precision: 'highp',\n        stepMultiplier: 1.0\n      }\n    };\n\n    const settings = qualitySettings[effectiveQuality] || qualitySettings.medium;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    sceneRef.current = scene;\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    cameraRef.current = camera;\n\n    let renderer: THREE.WebGLRenderer;\n    try {\n      renderer = new THREE.WebGLRenderer({\n        antialias: false,\n        alpha: true,\n        powerPreference: effectiveQuality === 'low' ? 'low-power' : 'high-performance',\n        precision: settings.precision,\n        stencil: false,\n        depth: false\n      });\n    } catch (error) {\n      console.error('Failed to create WebGL renderer:', error);\n      setWebGLSupported(false);\n      return;\n    }\n\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(settings.pixelRatio);\n    container.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Convert hex colors to RGB\n    const parseColor = (hex: string): THREE.Vector3 => {\n      const color = new THREE.Color(hex);\n      return new THREE.Vector3(color.r, color.g, color.b);\n    };\n\n    // Shader material\n    const vertexShader = `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 1.0);\n      }\n    `;\n\n    const fragmentShader = `\n      uniform float uTime;\n      uniform vec2 uResolution;\n      uniform vec2 uMouse;\n      uniform vec3 uTopColor;\n      uniform vec3 uBottomColor;\n      uniform float uIntensity;\n      uniform bool uInteractive;\n      uniform float uGlowAmount;\n      uniform float uPillarWidth;\n      uniform float uPillarHeight;\n      uniform float uNoiseIntensity;\n      uniform float uPillarRotation;\n      uniform float uRotCos;\n      uniform float uRotSin;\n      uniform float uPillarRotCos;\n      uniform float uPillarRotSin;\n      uniform float uWaveSin[4];\n      uniform float uWaveCos[4];\n      varying vec2 vUv;\n\n      const float PI = 3.141592653589793;\n      const float EPSILON = 0.001;\n      const float E = 2.71828182845904523536;\n\n      float noise(vec2 coord) {\n        vec2 r = (E * sin(E * coord));\n        return fract(r.x * r.y * (1.0 + coord.x));\n      }\n\n      void main() {\n        vec2 fragCoord = vUv * uResolution;\n        vec2 uv = (fragCoord * 2.0 - uResolution) / uResolution.y;\n        \n        // Apply 2D rotation to UV coordinates using pre-computed values\n        uv = vec2(\n          uv.x * uPillarRotCos - uv.y * uPillarRotSin,\n          uv.x * uPillarRotSin + uv.y * uPillarRotCos\n        );\n\n        vec3 origin = vec3(0.0, 0.0, -10.0);\n        vec3 direction = normalize(vec3(uv, 1.0));\n\n        float maxDepth = 50.0;\n        float depth = 0.1;\n\n        // Use pre-computed rotation values (or mouse-based)\n        float rotCos = uRotCos;\n        float rotSin = uRotSin;\n        if(uInteractive && length(uMouse) > 0.0) {\n          float mouseAngle = uMouse.x * PI * 2.0;\n          rotCos = cos(mouseAngle);\n          rotSin = sin(mouseAngle);\n        }\n\n        vec3 color = vec3(0.0);\n        \n        const int ITERATIONS = ${settings.iterations};\n        const int WAVE_ITERATIONS = ${settings.waveIterations};\n        const float STEP_MULT = ${settings.stepMultiplier.toFixed(1)};\n        \n        for(int i = 0; i < ITERATIONS; i++) {\n          vec3 pos = origin + direction * depth;\n          \n          // Inline rotation: pos.xz *= rotMat\n          float newX = pos.x * rotCos - pos.z * rotSin;\n          float newZ = pos.x * rotSin + pos.z * rotCos;\n          pos.x = newX;\n          pos.z = newZ;\n\n          // Apply vertical scaling and wave deformation\n          vec3 deformed = pos;\n          deformed.y *= uPillarHeight;\n          deformed = deformed + vec3(0.0, uTime, 0.0);\n          \n          // Inlined wave deformation\n          float frequency = 1.0;\n          float amplitude = 1.0;\n          for(int j = 0; j < WAVE_ITERATIONS; j++) {\n            // Inline rotation: deformed.xz *= rot(0.4) using pre-computed\n            float wx = deformed.x * uWaveCos[j] - deformed.z * uWaveSin[j];\n            float wz = deformed.x * uWaveSin[j] + deformed.z * uWaveCos[j];\n            deformed.x = wx;\n            deformed.z = wz;\n            \n            float phase = uTime * float(j) * 2.0;\n            vec3 oscillation = cos(deformed.zxy * frequency - phase);\n            deformed += oscillation * amplitude;\n            frequency *= 2.0;\n            amplitude *= 0.5;\n          }\n          \n          // Calculate distance field using cosine pattern\n          vec2 cosinePair = cos(deformed.xz);\n          float fieldDistance = length(cosinePair) - 0.2;\n          \n          // Radial boundary constraint (inlined blendMax)\n          float radialBound = length(pos.xz) - uPillarWidth;\n          float k = 4.0;\n          float h = max(k - abs(-radialBound - (-fieldDistance)), 0.0);\n          fieldDistance = -(min(-radialBound, -fieldDistance) - h * h * 0.25 / k);\n          \n          fieldDistance = abs(fieldDistance) * 0.15 + 0.01;\n\n          vec3 gradient = mix(uBottomColor, uTopColor, smoothstep(15.0, -15.0, pos.y));\n          color += gradient / fieldDistance;\n\n          if(fieldDistance < EPSILON || depth > maxDepth) break;\n          depth += fieldDistance * STEP_MULT;\n        }\n\n        // Normalize by pillar width to maintain consistent glow regardless of size\n        float widthNormalization = uPillarWidth / 3.0;\n        color = tanh(color * uGlowAmount / widthNormalization);\n        \n        // Add noise postprocessing\n        float rnd = noise(gl_FragCoord.xy);\n        color -= rnd / 15.0 * uNoiseIntensity;\n        \n        gl_FragColor = vec4(color * uIntensity, 1.0);\n      }\n    `;\n\n    // Pre-compute wave rotation values\n    const waveAngle = 0.4;\n    const waveSinValues = new Float32Array(4);\n    const waveCosValues = new Float32Array(4);\n    for (let i = 0; i < 4; i++) {\n      waveSinValues[i] = Math.sin(waveAngle);\n      waveCosValues[i] = Math.cos(waveAngle);\n    }\n\n    // Pre-compute pillar rotation\n    const pillarRotRad = (pillarRotation * Math.PI) / 180.0;\n    const pillarRotCos = Math.cos(pillarRotRad);\n    const pillarRotSin = Math.sin(pillarRotRad);\n\n    const material = new THREE.ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        uTime: { value: 0 },\n        uResolution: { value: new THREE.Vector2(width, height) },\n        uMouse: { value: mouseRef.current },\n        uTopColor: { value: parseColor(topColor) },\n        uBottomColor: { value: parseColor(bottomColor) },\n        uIntensity: { value: intensity },\n        uInteractive: { value: interactive },\n        uGlowAmount: { value: glowAmount },\n        uPillarWidth: { value: pillarWidth },\n        uPillarHeight: { value: pillarHeight },\n        uNoiseIntensity: { value: noiseIntensity },\n        uPillarRotation: { value: pillarRotation },\n        uRotCos: { value: 1.0 },\n        uRotSin: { value: 0.0 },\n        uPillarRotCos: { value: pillarRotCos },\n        uPillarRotSin: { value: pillarRotSin },\n        uWaveSin: { value: waveSinValues },\n        uWaveCos: { value: waveCosValues }\n      },\n      transparent: true,\n      depthWrite: false,\n      depthTest: false\n    });\n    materialRef.current = material;\n\n    const geometry = new THREE.PlaneGeometry(2, 2);\n    geometryRef.current = geometry;\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    // Mouse interaction - throttled for performance\n    let mouseMoveTimeout: number | null = null;\n    const handleMouseMove = (event: MouseEvent) => {\n      if (!interactive) return;\n\n      if (mouseMoveTimeout) return;\n\n      mouseMoveTimeout = window.setTimeout(() => {\n        mouseMoveTimeout = null;\n      }, 16); // ~60fps throttle\n\n      const rect = container.getBoundingClientRect();\n      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n      mouseRef.current.set(x, y);\n    };\n\n    if (interactive) {\n      container.addEventListener('mousemove', handleMouseMove, { passive: true });\n    }\n\n    // Animation loop with fixed timestep\n    let lastTime = performance.now();\n    const targetFPS = effectiveQuality === 'low' ? 30 : 60;\n    const frameTime = 1000 / targetFPS;\n\n    const animate = (currentTime: number) => {\n      if (!materialRef.current || !rendererRef.current || !sceneRef.current || !cameraRef.current) return;\n\n      const deltaTime = currentTime - lastTime;\n\n      if (deltaTime >= frameTime) {\n        timeRef.current += 0.016 * rotationSpeed;\n        materialRef.current.uniforms.uTime.value = timeRef.current;\n\n        // Pre-compute rotation on CPU\n        const rotAngle = timeRef.current * 0.3;\n        materialRef.current.uniforms.uRotCos.value = Math.cos(rotAngle);\n        materialRef.current.uniforms.uRotSin.value = Math.sin(rotAngle);\n\n        rendererRef.current.render(sceneRef.current, cameraRef.current);\n        lastTime = currentTime - (deltaTime % frameTime);\n      }\n\n      rafRef.current = requestAnimationFrame(animate);\n    };\n    rafRef.current = requestAnimationFrame(animate);\n\n    // Handle resize with debouncing\n    let resizeTimeout: number | null = null;\n    const handleResize = () => {\n      if (resizeTimeout) {\n        clearTimeout(resizeTimeout);\n      }\n\n      resizeTimeout = window.setTimeout(() => {\n        if (!rendererRef.current || !materialRef.current || !containerRef.current) return;\n        const newWidth = containerRef.current.clientWidth;\n        const newHeight = containerRef.current.clientHeight;\n        rendererRef.current.setSize(newWidth, newHeight);\n        materialRef.current.uniforms.uResolution.value.set(newWidth, newHeight);\n      }, 150);\n    };\n\n    window.addEventListener('resize', handleResize, { passive: true });\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (interactive) {\n        container.removeEventListener('mousemove', handleMouseMove);\n      }\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      if (rendererRef.current) {\n        rendererRef.current.dispose();\n        rendererRef.current.forceContextLoss();\n        if (container.contains(rendererRef.current.domElement)) {\n          container.removeChild(rendererRef.current.domElement);\n        }\n      }\n      if (materialRef.current) {\n        materialRef.current.dispose();\n      }\n      if (geometryRef.current) {\n        geometryRef.current.dispose();\n      }\n\n      rendererRef.current = null;\n      materialRef.current = null;\n      sceneRef.current = null;\n      cameraRef.current = null;\n      geometryRef.current = null;\n      rafRef.current = null;\n    };\n  }, [\n    topColor,\n    bottomColor,\n    intensity,\n    rotationSpeed,\n    interactive,\n    glowAmount,\n    pillarWidth,\n    pillarHeight,\n    noiseIntensity,\n    pillarRotation,\n    webGLSupported,\n    quality\n  ]);\n\n  if (!webGLSupported) {\n    return (\n      <div\n        className={`w-full h-full absolute top-0 left-0 flex items-center justify-center bg-black/10 text-gray-500 text-sm ${className}`}\n        style={{ mixBlendMode }}\n      >\n        WebGL not supported\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className={`w-full h-full absolute top-0 left-0 ${className}`} style={{ mixBlendMode }} />\n  );\n};\n\nexport default LightPillar;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "light-rays",
      "type": "component",
      "description": "A backgrounds light rays component",
      "category": "backgrounds",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/light-rays.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useState, type CSSProperties } from \"react\"\nimport { motion } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface LightRaysProps extends React.HTMLAttributes<HTMLDivElement> {\n  ref?: React.Ref<HTMLDivElement>\n  count?: number\n  color?: string\n  blur?: number\n  speed?: number\n  length?: string\n}\n\ntype LightRay = {\n  id: string\n  left: number\n  rotate: number\n  width: number\n  swing: number\n  delay: number\n  duration: number\n  intensity: number\n}\n\nconst createRays = (count: number, cycle: number): LightRay[] => {\n  if (count <= 0) return []\n\n  return Array.from({ length: count }, (_, index) => {\n    const left = 8 + Math.random() * 84\n    const rotate = -28 + Math.random() * 56\n    const width = 160 + Math.random() * 160\n    const swing = 0.8 + Math.random() * 1.8\n    const delay = Math.random() * cycle\n    const duration = cycle * (0.75 + Math.random() * 0.5)\n    const intensity = 0.6 + Math.random() * 0.5\n\n    return {\n      id: `${index}-${Math.round(left * 10)}`,\n      left,\n      rotate,\n      width,\n      swing,\n      delay,\n      duration,\n      intensity,\n    }\n  })\n}\n\nconst Ray = ({\n  left,\n  rotate,\n  width,\n  swing,\n  delay,\n  duration,\n  intensity,\n}: LightRay) => {\n  return (\n    <motion.div\n      className=\"pointer-events-none absolute -top-[12%] left-[var(--ray-left)] h-[var(--light-rays-length)] w-[var(--ray-width)] origin-top -translate-x-1/2 rounded-full bg-gradient-to-b from-[color-mix(in_srgb,var(--light-rays-color)_70%,transparent)] to-transparent opacity-0 mix-blend-screen blur-[var(--light-rays-blur)]\"\n      style={\n        {\n          \"--ray-left\": `${left}%`,\n          \"--ray-width\": `${width}px`,\n        } as CSSProperties\n      }\n      initial={{ rotate: rotate }}\n      animate={{\n        opacity: [0, intensity, 0],\n        rotate: [rotate - swing, rotate + swing, rotate - swing],\n      }}\n      transition={{\n        duration: duration,\n        repeat: Infinity,\n        ease: \"easeInOut\",\n        delay: delay,\n        repeatDelay: duration * 0.1,\n      }}\n    />\n  )\n}\n\nexport function LightRays({\n  className,\n  style,\n  count = 7,\n  color = \"rgba(160, 210, 255, 0.2)\",\n  blur = 36,\n  speed = 14,\n  length = \"70vh\",\n  ref,\n  ...props\n}: LightRaysProps) {\n  const [rays, setRays] = useState<LightRay[]>([])\n  const cycleDuration = Math.max(speed, 0.1)\n\n  useEffect(() => {\n    setRays(createRays(count, cycleDuration))\n  }, [count, cycleDuration])\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"pointer-events-none absolute inset-0 isolate overflow-hidden rounded-[inherit]\",\n        className\n      )}\n      style={\n        {\n          \"--light-rays-color\": color,\n          \"--light-rays-blur\": `${blur}px`,\n          \"--light-rays-length\": length,\n          ...style,\n        } as CSSProperties\n      }\n      {...props}\n    >\n      <div className=\"absolute inset-0 overflow-hidden\">\n        <div\n          aria-hidden\n          className=\"absolute inset-0 opacity-60\"\n          style={\n            {\n              background:\n                \"radial-gradient(circle at 20% 15%, color-mix(in srgb, var(--light-rays-color) 45%, transparent), transparent 70%)\",\n            } as CSSProperties\n          }\n        />\n        <div\n          aria-hidden\n          className=\"absolute inset-0 opacity-60\"\n          style={\n            {\n              background:\n                \"radial-gradient(circle at 80% 10%, color-mix(in srgb, var(--light-rays-color) 35%, transparent), transparent 75%)\",\n            } as CSSProperties\n          }\n        />\n        {rays.map((ray) => (\n          <Ray key={ray.id} {...ray} />\n        ))}\n      </div>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "backgrounds"
        ]
      }
    },
    {
      "name": "lightning",
      "type": "component",
      "description": "An animated lightning bolt background effect.",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/lightning.tsx",
          "content": "import React, { useRef, useEffect } from 'react';\n\ninterface LightningProps {\n  hue?: number;\n  xOffset?: number;\n  speed?: number;\n  intensity?: number;\n  size?: number;\n}\n\nconst Lightning: React.FC<LightningProps> = ({ hue = 230, xOffset = 0, speed = 1, intensity = 1, size = 1 }) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const resizeCanvas = () => {\n      canvas.width = canvas.clientWidth;\n      canvas.height = canvas.clientHeight;\n    };\n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvas);\n\n    const gl = canvas.getContext('webgl');\n    if (!gl) {\n      console.error('WebGL not supported');\n      return;\n    }\n\n    const vertexShaderSource = `\n      attribute vec2 aPosition;\n      void main() {\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n      }\n    `;\n\n    const fragmentShaderSource = `\n      precision mediump float;\n      uniform vec2 iResolution;\n      uniform float iTime;\n      uniform float uHue;\n      uniform float uXOffset;\n      uniform float uSpeed;\n      uniform float uIntensity;\n      uniform float uSize;\n      \n      #define OCTAVE_COUNT 10\n\n      vec3 hsv2rgb(vec3 c) {\n          vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n          return c.z * mix(vec3(1.0), rgb, c.y);\n      }\n\n      float hash11(float p) {\n          p = fract(p * .1031);\n          p *= p + 33.33;\n          p *= p + p;\n          return fract(p);\n      }\n\n      float hash12(vec2 p) {\n          vec3 p3 = fract(vec3(p.xyx) * .1031);\n          p3 += dot(p3, p3.yzx + 33.33);\n          return fract((p3.x + p3.y) * p3.z);\n      }\n\n      mat2 rotate2d(float theta) {\n          float c = cos(theta);\n          float s = sin(theta);\n          return mat2(c, -s, s, c);\n      }\n\n      float noise(vec2 p) {\n          vec2 ip = floor(p);\n          vec2 fp = fract(p);\n          float a = hash12(ip);\n          float b = hash12(ip + vec2(1.0, 0.0));\n          float c = hash12(ip + vec2(0.0, 1.0));\n          float d = hash12(ip + vec2(1.0, 1.0));\n          \n          vec2 t = smoothstep(0.0, 1.0, fp);\n          return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n      }\n\n      float fbm(vec2 p) {\n          float value = 0.0;\n          float amplitude = 0.5;\n          for (int i = 0; i < OCTAVE_COUNT; ++i) {\n              value += amplitude * noise(p);\n              p *= rotate2d(0.45);\n              p *= 2.0;\n              amplitude *= 0.5;\n          }\n          return value;\n      }\n\n      void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n          vec2 uv = fragCoord / iResolution.xy;\n          uv = 2.0 * uv - 1.0;\n          uv.x *= iResolution.x / iResolution.y;\n          uv.x += uXOffset;\n          \n          uv += 2.0 * fbm(uv * uSize + 0.8 * iTime * uSpeed) - 1.0;\n          \n          float dist = abs(uv.x);\n          vec3 baseColor = hsv2rgb(vec3(uHue / 360.0, 0.7, 0.8));\n          vec3 col = baseColor * pow(mix(0.0, 0.07, hash11(iTime * uSpeed)) / dist, 1.0) * uIntensity;\n          col = pow(col, vec3(1.0));\n          fragColor = vec4(col, 1.0);\n      }\n\n      void main() {\n          mainImage(gl_FragColor, gl_FragCoord.xy);\n      }\n    `;\n\n    const compileShader = (source: string, type: number): WebGLShader | null => {\n      const shader = gl.createShader(type);\n      if (!shader) return null;\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error('Shader compile error:', gl.getShaderInfoLog(shader));\n        gl.deleteShader(shader);\n        return null;\n      }\n      return shader;\n    };\n\n    const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n    const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\n    if (!vertexShader || !fragmentShader) return;\n\n    const program = gl.createProgram();\n    if (!program) return;\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error('Program linking error:', gl.getProgramInfoLog(program));\n      return;\n    }\n    gl.useProgram(program);\n\n    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);\n    const vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\n    gl.enableVertexAttribArray(aPosition);\n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n\n    const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');\n    const iTimeLocation = gl.getUniformLocation(program, 'iTime');\n    const uHueLocation = gl.getUniformLocation(program, 'uHue');\n    const uXOffsetLocation = gl.getUniformLocation(program, 'uXOffset');\n    const uSpeedLocation = gl.getUniformLocation(program, 'uSpeed');\n    const uIntensityLocation = gl.getUniformLocation(program, 'uIntensity');\n    const uSizeLocation = gl.getUniformLocation(program, 'uSize');\n\n    const startTime = performance.now();\n    const render = () => {\n      resizeCanvas();\n      gl.viewport(0, 0, canvas.width, canvas.height);\n      gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);\n      const currentTime = performance.now();\n      gl.uniform1f(iTimeLocation, (currentTime - startTime) / 1000.0);\n      gl.uniform1f(uHueLocation, hue);\n      gl.uniform1f(uXOffsetLocation, xOffset);\n      gl.uniform1f(uSpeedLocation, speed);\n      gl.uniform1f(uIntensityLocation, intensity);\n      gl.uniform1f(uSizeLocation, size);\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n      requestAnimationFrame(render);\n    };\n    requestAnimationFrame(render);\n\n    return () => {\n      window.removeEventListener('resize', resizeCanvas);\n    };\n  }, [hue, xOffset, speed, intensity, size]);\n\n  return <canvas ref={canvasRef} className=\"w-full h-full relative\" />;\n};\n\nexport default Lightning;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "liquid-chrome",
      "type": "component",
      "description": "A liquid chrome metallic background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/liquid-chrome.tsx",
          "content": "import React, { useRef, useEffect } from 'react';\nimport { Renderer, Program, Mesh, Triangle } from 'ogl';\n\ninterface LiquidChromeProps extends React.HTMLAttributes<HTMLDivElement> {\n  baseColor?: [number, number, number];\n  speed?: number;\n  amplitude?: number;\n  frequencyX?: number;\n  frequencyY?: number;\n  interactive?: boolean;\n}\n\nexport const LiquidChrome: React.FC<LiquidChromeProps> = ({\n  baseColor = [0.1, 0.1, 0.1],\n  speed = 0.2,\n  amplitude = 0.5,\n  frequencyX = 3,\n  frequencyY = 2,\n  interactive = true,\n  ...props\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const container = containerRef.current;\n    const renderer = new Renderer({ antialias: true });\n    const gl = renderer.gl;\n    gl.clearColor(1, 1, 1, 1);\n\n    const vertexShader = `\n      attribute vec2 position;\n      attribute vec2 uv;\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0.0, 1.0);\n      }\n    `;\n\n    const fragmentShader = `\n      precision highp float;\n      uniform float uTime;\n      uniform vec3 uResolution;\n      uniform vec3 uBaseColor;\n      uniform float uAmplitude;\n      uniform float uFrequencyX;\n      uniform float uFrequencyY;\n      uniform vec2 uMouse;\n      varying vec2 vUv;\n\n      vec4 renderImage(vec2 uvCoord) {\n          vec2 fragCoord = uvCoord * uResolution.xy;\n          vec2 uv = (2.0 * fragCoord - uResolution.xy) / min(uResolution.x, uResolution.y);\n\n          for (float i = 1.0; i < 10.0; i++){\n              uv.x += uAmplitude / i * cos(i * uFrequencyX * uv.y + uTime + uMouse.x * 3.14159);\n              uv.y += uAmplitude / i * cos(i * uFrequencyY * uv.x + uTime + uMouse.y * 3.14159);\n          }\n\n          vec2 diff = (uvCoord - uMouse);\n          float dist = length(diff);\n          float falloff = exp(-dist * 20.0);\n          float ripple = sin(10.0 * dist - uTime * 2.0) * 0.03;\n          uv += (diff / (dist + 0.0001)) * ripple * falloff;\n\n          vec3 color = uBaseColor / abs(sin(uTime - uv.y - uv.x));\n          return vec4(color, 1.0);\n      }\n\n      void main() {\n          vec4 col = vec4(0.0);\n          int samples = 0;\n          for (int i = -1; i <= 1; i++){\n              for (int j = -1; j <= 1; j++){\n                  vec2 offset = vec2(float(i), float(j)) * (1.0 / min(uResolution.x, uResolution.y));\n                  col += renderImage(vUv + offset);\n                  samples++;\n              }\n          }\n          gl_FragColor = col / float(samples);\n      }\n    `;\n\n    const geometry = new Triangle(gl);\n    const program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        uTime: { value: 0 },\n        uResolution: {\n          value: new Float32Array([gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height])\n        },\n        uBaseColor: { value: new Float32Array(baseColor) },\n        uAmplitude: { value: amplitude },\n        uFrequencyX: { value: frequencyX },\n        uFrequencyY: { value: frequencyY },\n        uMouse: { value: new Float32Array([0, 0]) }\n      }\n    });\n    const mesh = new Mesh(gl, { geometry, program });\n\n    function resize() {\n      const scale = 1;\n      renderer.setSize(container.offsetWidth * scale, container.offsetHeight * scale);\n      const resUniform = program.uniforms.uResolution.value as Float32Array;\n      resUniform[0] = gl.canvas.width;\n      resUniform[1] = gl.canvas.height;\n      resUniform[2] = gl.canvas.width / gl.canvas.height;\n    }\n    window.addEventListener('resize', resize);\n    resize();\n\n    function handleMouseMove(event: MouseEvent) {\n      const rect = container.getBoundingClientRect();\n      const x = (event.clientX - rect.left) / rect.width;\n      const y = 1 - (event.clientY - rect.top) / rect.height;\n      const mouseUniform = program.uniforms.uMouse.value as Float32Array;\n      mouseUniform[0] = x;\n      mouseUniform[1] = y;\n    }\n\n    function handleTouchMove(event: TouchEvent) {\n      if (event.touches.length > 0) {\n        const touch = event.touches[0];\n        const rect = container.getBoundingClientRect();\n        const x = (touch.clientX - rect.left) / rect.width;\n        const y = 1 - (touch.clientY - rect.top) / rect.height;\n        const mouseUniform = program.uniforms.uMouse.value as Float32Array;\n        mouseUniform[0] = x;\n        mouseUniform[1] = y;\n      }\n    }\n\n    if (interactive) {\n      container.addEventListener('mousemove', handleMouseMove);\n      container.addEventListener('touchmove', handleTouchMove);\n    }\n\n    let animationId: number;\n    function update(t: number) {\n      animationId = requestAnimationFrame(update);\n      program.uniforms.uTime.value = t * 0.001 * speed;\n      renderer.render({ scene: mesh });\n    }\n    animationId = requestAnimationFrame(update);\n\n    container.appendChild(gl.canvas);\n\n    return () => {\n      cancelAnimationFrame(animationId);\n      window.removeEventListener('resize', resize);\n      if (interactive) {\n        container.removeEventListener('mousemove', handleMouseMove);\n        container.removeEventListener('touchmove', handleTouchMove);\n      }\n      if (gl.canvas.parentElement) {\n        gl.canvas.parentElement.removeChild(gl.canvas);\n      }\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n    };\n  }, [baseColor, speed, amplitude, frequencyX, frequencyY, interactive]);\n\n  return <div ref={containerRef} className=\"w-full h-full\" {...props} />;\n};\n\nexport default LiquidChrome;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "liquid-ether",
      "type": "component",
      "description": "A liquid ethereal fluid background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/liquid-ether.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\n\nexport interface LiquidEtherProps {\n  mouseForce?: number;\n  cursorSize?: number;\n  isViscous?: boolean;\n  viscous?: number;\n  iterationsViscous?: number;\n  iterationsPoisson?: number;\n  dt?: number;\n  BFECC?: boolean;\n  resolution?: number;\n  isBounce?: boolean;\n  colors?: string[];\n  style?: React.CSSProperties;\n  className?: string;\n  autoDemo?: boolean;\n  autoSpeed?: number;\n  autoIntensity?: number;\n  takeoverDuration?: number;\n  autoResumeDelay?: number;\n  autoRampDuration?: number;\n}\n\ninterface SimOptions {\n  iterations_poisson: number;\n  iterations_viscous: number;\n  mouse_force: number;\n  resolution: number;\n  cursor_size: number;\n  viscous: number;\n  isBounce: boolean;\n  dt: number;\n  isViscous: boolean;\n  BFECC: boolean;\n}\n\ninterface LiquidEtherWebGL {\n  output?: { simulation?: { options: SimOptions; resize: () => void } };\n  autoDriver?: {\n    enabled: boolean;\n    speed: number;\n    resumeDelay: number;\n    rampDurationMs: number;\n    mouse?: { autoIntensity: number; takeoverDuration: number };\n    forceStop: () => void;\n  };\n  resize: () => void;\n  start: () => void;\n  pause: () => void;\n  dispose: () => void;\n}\n\nconst defaultColors = ['#5227FF', '#FF9FFC', '#B19EEF'];\n\nexport default function LiquidEther({\n  mouseForce = 20,\n  cursorSize = 100,\n  isViscous = false,\n  viscous = 30,\n  iterationsViscous = 32,\n  iterationsPoisson = 32,\n  dt = 0.014,\n  BFECC = true,\n  resolution = 0.5,\n  isBounce = false,\n  colors = defaultColors,\n  style = {},\n  className = '',\n  autoDemo = true,\n  autoSpeed = 0.5,\n  autoIntensity = 2.2,\n  takeoverDuration = 0.25,\n  autoResumeDelay = 1000,\n  autoRampDuration = 0.6\n}: LiquidEtherProps): React.ReactElement {\n  const mountRef = useRef<HTMLDivElement | null>(null);\n  const webglRef = useRef<LiquidEtherWebGL | null>(null);\n  const resizeObserverRef = useRef<ResizeObserver | null>(null);\n  const rafRef = useRef<number | null>(null);\n  const intersectionObserverRef = useRef<IntersectionObserver | null>(null);\n  const isVisibleRef = useRef<boolean>(true);\n  const resizeRafRef = useRef<number | null>(null);\n\n  useEffect(() => {\n    if (!mountRef.current) return;\n\n    function makePaletteTexture(stops: string[]): THREE.DataTexture {\n      let arr: string[];\n      if (Array.isArray(stops) && stops.length > 0) {\n        arr = stops.length === 1 ? [stops[0], stops[0]] : stops;\n      } else {\n        arr = ['#ffffff', '#ffffff'];\n      }\n      const w = arr.length;\n      const data = new Uint8Array(w * 4);\n      for (let i = 0; i < w; i++) {\n        const c = new THREE.Color(arr[i]);\n        data[i * 4 + 0] = Math.round(c.r * 255);\n        data[i * 4 + 1] = Math.round(c.g * 255);\n        data[i * 4 + 2] = Math.round(c.b * 255);\n        data[i * 4 + 3] = 255;\n      }\n      const tex = new THREE.DataTexture(data, w, 1, THREE.RGBAFormat);\n      tex.magFilter = THREE.LinearFilter;\n      tex.minFilter = THREE.LinearFilter;\n      tex.wrapS = THREE.ClampToEdgeWrapping;\n      tex.wrapT = THREE.ClampToEdgeWrapping;\n      tex.generateMipmaps = false;\n      tex.needsUpdate = true;\n      return tex;\n    }\n\n    const paletteTex = makePaletteTexture(colors);\n    // Hard-code transparent background vector (alpha 0)\n    const bgVec4 = new THREE.Vector4(0, 0, 0, 0);\n\n    class CommonClass {\n      width = 0;\n      height = 0;\n      aspect = 1;\n      pixelRatio = 1;\n      isMobile = false;\n      breakpoint = 768;\n      fboWidth: number | null = null;\n      fboHeight: number | null = null;\n      time = 0;\n      delta = 0;\n      container: HTMLElement | null = null;\n      renderer: THREE.WebGLRenderer | null = null;\n      clock: THREE.Clock | null = null;\n      init(container: HTMLElement) {\n        this.container = container;\n        this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\n        this.resize();\n        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n        // Always transparent\n        this.renderer.autoClear = false;\n        this.renderer.setClearColor(new THREE.Color(0x000000), 0);\n        this.renderer.setPixelRatio(this.pixelRatio);\n        this.renderer.setSize(this.width, this.height);\n        const el = this.renderer.domElement;\n        el.style.width = '100%';\n        el.style.height = '100%';\n        el.style.display = 'block';\n        this.clock = new THREE.Clock();\n        this.clock.start();\n      }\n      resize() {\n        if (!this.container) return;\n        const rect = this.container.getBoundingClientRect();\n        this.width = Math.max(1, Math.floor(rect.width));\n        this.height = Math.max(1, Math.floor(rect.height));\n        this.aspect = this.width / this.height;\n        if (this.renderer) this.renderer.setSize(this.width, this.height, false);\n      }\n      update() {\n        if (!this.clock) return;\n        this.delta = this.clock.getDelta();\n        this.time += this.delta;\n      }\n    }\n    const Common = new CommonClass();\n\n    class MouseClass {\n      mouseMoved = false;\n      coords = new THREE.Vector2();\n      coords_old = new THREE.Vector2();\n      diff = new THREE.Vector2();\n      timer: number | null = null;\n      container: HTMLElement | null = null;\n      docTarget: Document | null = null;\n      listenerTarget: Window | null = null;\n      isHoverInside = false;\n      hasUserControl = false;\n      isAutoActive = false;\n      autoIntensity = 2.0;\n      takeoverActive = false;\n      takeoverStartTime = 0;\n      takeoverDuration = 0.25;\n      takeoverFrom = new THREE.Vector2();\n      takeoverTo = new THREE.Vector2();\n      onInteract: (() => void) | null = null;\n      private _onMouseMove = this.onDocumentMouseMove.bind(this);\n      private _onTouchStart = this.onDocumentTouchStart.bind(this);\n      private _onTouchMove = this.onDocumentTouchMove.bind(this);\n      private _onTouchEnd = this.onTouchEnd.bind(this);\n      private _onDocumentLeave = this.onDocumentLeave.bind(this);\n      init(container: HTMLElement) {\n        this.container = container;\n        this.docTarget = container.ownerDocument || null;\n        const defaultView = this.docTarget?.defaultView || (typeof window !== 'undefined' ? window : null);\n        if (!defaultView) return;\n        this.listenerTarget = defaultView;\n        this.listenerTarget.addEventListener('mousemove', this._onMouseMove);\n        this.listenerTarget.addEventListener('touchstart', this._onTouchStart, {\n          passive: true\n        });\n        this.listenerTarget.addEventListener('touchmove', this._onTouchMove, {\n          passive: true\n        });\n        this.listenerTarget.addEventListener('touchend', this._onTouchEnd);\n        this.docTarget?.addEventListener('mouseleave', this._onDocumentLeave);\n      }\n      dispose() {\n        if (this.listenerTarget) {\n          this.listenerTarget.removeEventListener('mousemove', this._onMouseMove);\n          this.listenerTarget.removeEventListener('touchstart', this._onTouchStart);\n          this.listenerTarget.removeEventListener('touchmove', this._onTouchMove);\n          this.listenerTarget.removeEventListener('touchend', this._onTouchEnd);\n        }\n        if (this.docTarget) {\n          this.docTarget.removeEventListener('mouseleave', this._onDocumentLeave);\n        }\n        this.listenerTarget = null;\n        this.docTarget = null;\n        this.container = null;\n      }\n      private isPointInside(clientX: number, clientY: number) {\n        if (!this.container) return false;\n        const rect = this.container.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return false;\n        return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n      }\n      private updateHoverState(clientX: number, clientY: number) {\n        this.isHoverInside = this.isPointInside(clientX, clientY);\n        return this.isHoverInside;\n      }\n      setCoords(x: number, y: number) {\n        if (!this.container) return;\n        if (this.timer) window.clearTimeout(this.timer);\n        const rect = this.container.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return;\n        const nx = (x - rect.left) / rect.width;\n        const ny = (y - rect.top) / rect.height;\n        this.coords.set(nx * 2 - 1, -(ny * 2 - 1));\n        this.mouseMoved = true;\n        this.timer = window.setTimeout(() => {\n          this.mouseMoved = false;\n        }, 100);\n      }\n      setNormalized(nx: number, ny: number) {\n        this.coords.set(nx, ny);\n        this.mouseMoved = true;\n      }\n      onDocumentMouseMove(event: MouseEvent) {\n        if (!this.updateHoverState(event.clientX, event.clientY)) return;\n        if (this.onInteract) this.onInteract();\n        if (this.isAutoActive && !this.hasUserControl && !this.takeoverActive) {\n          if (!this.container) return;\n          const rect = this.container.getBoundingClientRect();\n          const nx = (event.clientX - rect.left) / rect.width;\n          const ny = (event.clientY - rect.top) / rect.height;\n          this.takeoverFrom.copy(this.coords);\n          this.takeoverTo.set(nx * 2 - 1, -(ny * 2 - 1));\n          this.takeoverStartTime = performance.now();\n          this.takeoverActive = true;\n          this.hasUserControl = true;\n          this.isAutoActive = false;\n          return;\n        }\n        this.setCoords(event.clientX, event.clientY);\n        this.hasUserControl = true;\n      }\n      onDocumentTouchStart(event: TouchEvent) {\n        if (event.touches.length !== 1) return;\n        const t = event.touches[0];\n        if (!this.updateHoverState(t.clientX, t.clientY)) return;\n        if (this.onInteract) this.onInteract();\n        this.setCoords(t.clientX, t.clientY);\n        this.hasUserControl = true;\n      }\n      onDocumentTouchMove(event: TouchEvent) {\n        if (event.touches.length !== 1) return;\n        const t = event.touches[0];\n        if (!this.updateHoverState(t.clientX, t.clientY)) return;\n        if (this.onInteract) this.onInteract();\n        this.setCoords(t.clientX, t.clientY);\n      }\n      onTouchEnd() {\n        this.isHoverInside = false;\n      }\n      onDocumentLeave() {\n        this.isHoverInside = false;\n      }\n      update() {\n        if (this.takeoverActive) {\n          const t = (performance.now() - this.takeoverStartTime) / (this.takeoverDuration * 1000);\n          if (t >= 1) {\n            this.takeoverActive = false;\n            this.coords.copy(this.takeoverTo);\n            this.coords_old.copy(this.coords);\n            this.diff.set(0, 0);\n          } else {\n            const k = t * t * (3 - 2 * t);\n            this.coords.copy(this.takeoverFrom).lerp(this.takeoverTo, k);\n          }\n        }\n        this.diff.subVectors(this.coords, this.coords_old);\n        this.coords_old.copy(this.coords);\n        if (this.coords_old.x === 0 && this.coords_old.y === 0) this.diff.set(0, 0);\n        if (this.isAutoActive && !this.takeoverActive) this.diff.multiplyScalar(this.autoIntensity);\n      }\n    }\n    const Mouse = new MouseClass();\n\n    class AutoDriver {\n      mouse: MouseClass;\n      manager: WebGLManager;\n      enabled: boolean;\n      speed: number;\n      resumeDelay: number;\n      rampDurationMs: number;\n      active = false;\n      current = new THREE.Vector2(0, 0);\n      target = new THREE.Vector2();\n      lastTime = performance.now();\n      activationTime = 0;\n      margin = 0.2;\n      private _tmpDir = new THREE.Vector2();\n      constructor(\n        mouse: MouseClass,\n        manager: WebGLManager,\n        opts: { enabled: boolean; speed: number; resumeDelay: number; rampDuration: number }\n      ) {\n        this.mouse = mouse;\n        this.manager = manager;\n        this.enabled = opts.enabled;\n        this.speed = opts.speed;\n        this.resumeDelay = opts.resumeDelay || 3000;\n        this.rampDurationMs = (opts.rampDuration || 0) * 1000;\n        this.pickNewTarget();\n      }\n      pickNewTarget() {\n        const r = Math.random;\n        this.target.set((r() * 2 - 1) * (1 - this.margin), (r() * 2 - 1) * (1 - this.margin));\n      }\n      forceStop() {\n        this.active = false;\n        this.mouse.isAutoActive = false;\n      }\n      update() {\n        if (!this.enabled) return;\n        const now = performance.now();\n        const idle = now - this.manager.lastUserInteraction;\n        if (idle < this.resumeDelay) {\n          if (this.active) this.forceStop();\n          return;\n        }\n        if (this.mouse.isHoverInside) {\n          if (this.active) this.forceStop();\n          return;\n        }\n        if (!this.active) {\n          this.active = true;\n          this.current.copy(this.mouse.coords);\n          this.lastTime = now;\n          this.activationTime = now;\n        }\n        if (!this.active) return;\n        this.mouse.isAutoActive = true;\n        let dtSec = (now - this.lastTime) / 1000;\n        this.lastTime = now;\n        if (dtSec > 0.2) dtSec = 0.016;\n        const dir = this._tmpDir.subVectors(this.target, this.current);\n        const dist = dir.length();\n        if (dist < 0.01) {\n          this.pickNewTarget();\n          return;\n        }\n        dir.normalize();\n        let ramp = 1;\n        if (this.rampDurationMs > 0) {\n          const t = Math.min(1, (now - this.activationTime) / this.rampDurationMs);\n          ramp = t * t * (3 - 2 * t);\n        }\n        const step = this.speed * dtSec * ramp;\n        const move = Math.min(step, dist);\n        this.current.addScaledVector(dir, move);\n        this.mouse.setNormalized(this.current.x, this.current.y);\n      }\n    }\n\n    const face_vert = `\n  attribute vec3 position;\n  uniform vec2 px;\n  uniform vec2 boundarySpace;\n  varying vec2 uv;\n  precision highp float;\n  void main(){\n  vec3 pos = position;\n  vec2 scale = 1.0 - boundarySpace * 2.0;\n  pos.xy = pos.xy * scale;\n  uv = vec2(0.5)+(pos.xy)*0.5;\n  gl_Position = vec4(pos, 1.0);\n}\n`;\n    const line_vert = `\n  attribute vec3 position;\n  uniform vec2 px;\n  precision highp float;\n  varying vec2 uv;\n  void main(){\n  vec3 pos = position;\n  uv = 0.5 + pos.xy * 0.5;\n  vec2 n = sign(pos.xy);\n  pos.xy = abs(pos.xy) - px * 1.0;\n  pos.xy *= n;\n  gl_Position = vec4(pos, 1.0);\n}\n`;\n    const mouse_vert = `\n    precision highp float;\n    attribute vec3 position;\n    attribute vec2 uv;\n    uniform vec2 center;\n    uniform vec2 scale;\n    uniform vec2 px;\n    varying vec2 vUv;\n    void main(){\n    vec2 pos = position.xy * scale * 2.0 * px + center;\n    vUv = uv;\n    gl_Position = vec4(pos, 0.0, 1.0);\n}\n`;\n    const advection_frag = `\n    precision highp float;\n    uniform sampler2D velocity;\n    uniform float dt;\n    uniform bool isBFECC;\n    uniform vec2 fboSize;\n    uniform vec2 px;\n    varying vec2 uv;\n    void main(){\n    vec2 ratio = max(fboSize.x, fboSize.y) / fboSize;\n    if(isBFECC == false){\n        vec2 vel = texture2D(velocity, uv).xy;\n        vec2 uv2 = uv - vel * dt * ratio;\n        vec2 newVel = texture2D(velocity, uv2).xy;\n        gl_FragColor = vec4(newVel, 0.0, 0.0);\n    } else {\n        vec2 spot_new = uv;\n        vec2 vel_old = texture2D(velocity, uv).xy;\n        vec2 spot_old = spot_new - vel_old * dt * ratio;\n        vec2 vel_new1 = texture2D(velocity, spot_old).xy;\n        vec2 spot_new2 = spot_old + vel_new1 * dt * ratio;\n        vec2 error = spot_new2 - spot_new;\n        vec2 spot_new3 = spot_new - error / 2.0;\n        vec2 vel_2 = texture2D(velocity, spot_new3).xy;\n        vec2 spot_old2 = spot_new3 - vel_2 * dt * ratio;\n        vec2 newVel2 = texture2D(velocity, spot_old2).xy; \n        gl_FragColor = vec4(newVel2, 0.0, 0.0);\n    }\n}\n`;\n    const color_frag = `\n    precision highp float;\n    uniform sampler2D velocity;\n    uniform sampler2D palette;\n    uniform vec4 bgColor;\n    varying vec2 uv;\n    void main(){\n    vec2 vel = texture2D(velocity, uv).xy;\n    float lenv = clamp(length(vel), 0.0, 1.0);\n    vec3 c = texture2D(palette, vec2(lenv, 0.5)).rgb;\n    vec3 outRGB = mix(bgColor.rgb, c, lenv);\n    float outA = mix(bgColor.a, 1.0, lenv);\n    gl_FragColor = vec4(outRGB, outA);\n}\n`;\n    const divergence_frag = `\n    precision highp float;\n    uniform sampler2D velocity;\n    uniform float dt;\n    uniform vec2 px;\n    varying vec2 uv;\n    void main(){\n    float x0 = texture2D(velocity, uv-vec2(px.x, 0.0)).x;\n    float x1 = texture2D(velocity, uv+vec2(px.x, 0.0)).x;\n    float y0 = texture2D(velocity, uv-vec2(0.0, px.y)).y;\n    float y1 = texture2D(velocity, uv+vec2(0.0, px.y)).y;\n    float divergence = (x1 - x0 + y1 - y0) / 2.0;\n    gl_FragColor = vec4(divergence / dt);\n}\n`;\n    const externalForce_frag = `\n    precision highp float;\n    uniform vec2 force;\n    uniform vec2 center;\n    uniform vec2 scale;\n    uniform vec2 px;\n    varying vec2 vUv;\n    void main(){\n    vec2 circle = (vUv - 0.5) * 2.0;\n    float d = 1.0 - min(length(circle), 1.0);\n    d *= d;\n    gl_FragColor = vec4(force * d, 0.0, 1.0);\n}\n`;\n    const poisson_frag = `\n    precision highp float;\n    uniform sampler2D pressure;\n    uniform sampler2D divergence;\n    uniform vec2 px;\n    varying vec2 uv;\n    void main(){\n    float p0 = texture2D(pressure, uv + vec2(px.x * 2.0, 0.0)).r;\n    float p1 = texture2D(pressure, uv - vec2(px.x * 2.0, 0.0)).r;\n    float p2 = texture2D(pressure, uv + vec2(0.0, px.y * 2.0)).r;\n    float p3 = texture2D(pressure, uv - vec2(0.0, px.y * 2.0)).r;\n    float div = texture2D(divergence, uv).r;\n    float newP = (p0 + p1 + p2 + p3) / 4.0 - div;\n    gl_FragColor = vec4(newP);\n}\n`;\n    const pressure_frag = `\n    precision highp float;\n    uniform sampler2D pressure;\n    uniform sampler2D velocity;\n    uniform vec2 px;\n    uniform float dt;\n    varying vec2 uv;\n    void main(){\n    float step = 1.0;\n    float p0 = texture2D(pressure, uv + vec2(px.x * step, 0.0)).r;\n    float p1 = texture2D(pressure, uv - vec2(px.x * step, 0.0)).r;\n    float p2 = texture2D(pressure, uv + vec2(0.0, px.y * step)).r;\n    float p3 = texture2D(pressure, uv - vec2(0.0, px.y * step)).r;\n    vec2 v = texture2D(velocity, uv).xy;\n    vec2 gradP = vec2(p0 - p1, p2 - p3) * 0.5;\n    v = v - gradP * dt;\n    gl_FragColor = vec4(v, 0.0, 1.0);\n}\n`;\n    const viscous_frag = `\n    precision highp float;\n    uniform sampler2D velocity;\n    uniform sampler2D velocity_new;\n    uniform float v;\n    uniform vec2 px;\n    uniform float dt;\n    varying vec2 uv;\n    void main(){\n    vec2 old = texture2D(velocity, uv).xy;\n    vec2 new0 = texture2D(velocity_new, uv + vec2(px.x * 2.0, 0.0)).xy;\n    vec2 new1 = texture2D(velocity_new, uv - vec2(px.x * 2.0, 0.0)).xy;\n    vec2 new2 = texture2D(velocity_new, uv + vec2(0.0, px.y * 2.0)).xy;\n    vec2 new3 = texture2D(velocity_new, uv - vec2(0.0, px.y * 2.0)).xy;\n    vec2 newv = 4.0 * old + v * dt * (new0 + new1 + new2 + new3);\n    newv /= 4.0 * (1.0 + v * dt);\n    gl_FragColor = vec4(newv, 0.0, 0.0);\n}\n`;\n\n    type Uniforms = Record<string, { value: any }>;\n\n    class ShaderPass {\n      props: any;\n      uniforms?: Uniforms;\n      scene: THREE.Scene | null = null;\n      camera: THREE.Camera | null = null;\n      material: THREE.RawShaderMaterial | null = null;\n      geometry: THREE.BufferGeometry | null = null;\n      plane: THREE.Mesh | null = null;\n      constructor(props: any) {\n        this.props = props || {};\n        this.uniforms = this.props.material?.uniforms;\n      }\n      init(..._args: any[]) {\n        this.scene = new THREE.Scene();\n        this.camera = new THREE.Camera();\n        if (this.uniforms) {\n          this.material = new THREE.RawShaderMaterial(this.props.material);\n          this.geometry = new THREE.PlaneGeometry(2, 2);\n          this.plane = new THREE.Mesh(this.geometry, this.material);\n          this.scene.add(this.plane);\n        }\n      }\n      update(..._args: any[]) {\n        if (!Common.renderer || !this.scene || !this.camera) return;\n        Common.renderer.setRenderTarget(this.props.output || null);\n        Common.renderer.render(this.scene, this.camera);\n        Common.renderer.setRenderTarget(null);\n      }\n    }\n\n    class Advection extends ShaderPass {\n      line!: THREE.LineSegments;\n      constructor(simProps: any) {\n        super({\n          material: {\n            vertexShader: face_vert,\n            fragmentShader: advection_frag,\n            uniforms: {\n              boundarySpace: { value: simProps.cellScale },\n              px: { value: simProps.cellScale },\n              fboSize: { value: simProps.fboSize },\n              velocity: { value: simProps.src.texture },\n              dt: { value: simProps.dt },\n              isBFECC: { value: true }\n            }\n          },\n          output: simProps.dst\n        });\n        this.uniforms = this.props.material.uniforms;\n        this.init();\n      }\n      init() {\n        super.init();\n        this.createBoundary();\n      }\n      createBoundary() {\n        const boundaryG = new THREE.BufferGeometry();\n        const vertices_boundary = new Float32Array([\n          -1, -1, 0, -1, 1, 0, -1, 1, 0, 1, 1, 0, 1, 1, 0, 1, -1, 0, 1, -1, 0, -1, -1, 0\n        ]);\n        boundaryG.setAttribute('position', new THREE.BufferAttribute(vertices_boundary, 3));\n        const boundaryM = new THREE.RawShaderMaterial({\n          vertexShader: line_vert,\n          fragmentShader: advection_frag,\n          uniforms: this.uniforms!\n        });\n        this.line = new THREE.LineSegments(boundaryG, boundaryM);\n        this.scene!.add(this.line);\n      }\n      update(...args: any[]) {\n        const { dt, isBounce, BFECC } = (args[0] || {}) as { dt?: number; isBounce?: boolean; BFECC?: boolean };\n        if (!this.uniforms) return;\n        if (typeof dt === 'number') this.uniforms.dt.value = dt;\n        if (typeof isBounce === 'boolean') this.line.visible = isBounce;\n        if (typeof BFECC === 'boolean') this.uniforms.isBFECC.value = BFECC;\n        super.update();\n      }\n    }\n\n    class ExternalForce extends ShaderPass {\n      mouse!: THREE.Mesh;\n      constructor(simProps: any) {\n        super({ output: simProps.dst });\n        this.init(simProps);\n      }\n      init(simProps: any) {\n        super.init();\n        const mouseG = new THREE.PlaneGeometry(1, 1);\n        const mouseM = new THREE.RawShaderMaterial({\n          vertexShader: mouse_vert,\n          fragmentShader: externalForce_frag,\n          blending: THREE.AdditiveBlending,\n          depthWrite: false,\n          uniforms: {\n            px: { value: simProps.cellScale },\n            force: { value: new THREE.Vector2(0, 0) },\n            center: { value: new THREE.Vector2(0, 0) },\n            scale: { value: new THREE.Vector2(simProps.cursor_size, simProps.cursor_size) }\n          }\n        });\n        this.mouse = new THREE.Mesh(mouseG, mouseM);\n        this.scene!.add(this.mouse);\n      }\n      update(...args: any[]) {\n        const props = args[0] || {};\n        const forceX = (Mouse.diff.x / 2) * (props.mouse_force || 0);\n        const forceY = (Mouse.diff.y / 2) * (props.mouse_force || 0);\n        const cellScale = props.cellScale || { x: 1, y: 1 };\n        const cursorSize = props.cursor_size || 0;\n        const cursorSizeX = cursorSize * cellScale.x;\n        const cursorSizeY = cursorSize * cellScale.y;\n        const centerX = Math.min(\n          Math.max(Mouse.coords.x, -1 + cursorSizeX + cellScale.x * 2),\n          1 - cursorSizeX - cellScale.x * 2\n        );\n        const centerY = Math.min(\n          Math.max(Mouse.coords.y, -1 + cursorSizeY + cellScale.y * 2),\n          1 - cursorSizeY - cellScale.y * 2\n        );\n        const uniforms = (this.mouse.material as THREE.RawShaderMaterial).uniforms;\n        uniforms.force.value.set(forceX, forceY);\n        uniforms.center.value.set(centerX, centerY);\n        uniforms.scale.value.set(cursorSize, cursorSize);\n        super.update();\n      }\n    }\n\n    class Viscous extends ShaderPass {\n      constructor(simProps: any) {\n        super({\n          material: {\n            vertexShader: face_vert,\n            fragmentShader: viscous_frag,\n            uniforms: {\n              boundarySpace: { value: simProps.boundarySpace },\n              velocity: { value: simProps.src.texture },\n              velocity_new: { value: simProps.dst_.texture },\n              v: { value: simProps.viscous },\n              px: { value: simProps.cellScale },\n              dt: { value: simProps.dt }\n            }\n          },\n          output: simProps.dst,\n          output0: simProps.dst_,\n          output1: simProps.dst\n        });\n        this.init();\n      }\n      update(...args: any[]) {\n        const { viscous, iterations, dt } = (args[0] || {}) as { viscous?: number; iterations?: number; dt?: number };\n        if (!this.uniforms) return;\n        let fbo_in: any, fbo_out: any;\n        if (typeof viscous === 'number') this.uniforms.v.value = viscous;\n        const iter = iterations ?? 0;\n        for (let i = 0; i < iter; i++) {\n          if (i % 2 === 0) {\n            fbo_in = this.props.output0;\n            fbo_out = this.props.output1;\n          } else {\n            fbo_in = this.props.output1;\n            fbo_out = this.props.output0;\n          }\n          this.uniforms.velocity_new.value = fbo_in.texture;\n          this.props.output = fbo_out;\n          if (typeof dt === 'number') this.uniforms.dt.value = dt;\n          super.update();\n        }\n        return fbo_out;\n      }\n    }\n\n    class Divergence extends ShaderPass {\n      constructor(simProps: any) {\n        super({\n          material: {\n            vertexShader: face_vert,\n            fragmentShader: divergence_frag,\n            uniforms: {\n              boundarySpace: { value: simProps.boundarySpace },\n              velocity: { value: simProps.src.texture },\n              px: { value: simProps.cellScale },\n              dt: { value: simProps.dt }\n            }\n          },\n          output: simProps.dst\n        });\n        this.init();\n      }\n      update(...args: any[]) {\n        const { vel } = (args[0] || {}) as { vel?: any };\n        if (this.uniforms && vel) {\n          this.uniforms.velocity.value = vel.texture;\n        }\n        super.update();\n      }\n    }\n\n    class Poisson extends ShaderPass {\n      constructor(simProps: any) {\n        super({\n          material: {\n            vertexShader: face_vert,\n            fragmentShader: poisson_frag,\n            uniforms: {\n              boundarySpace: { value: simProps.boundarySpace },\n              pressure: { value: simProps.dst_.texture },\n              divergence: { value: simProps.src.texture },\n              px: { value: simProps.cellScale }\n            }\n          },\n          output: simProps.dst,\n          output0: simProps.dst_,\n          output1: simProps.dst\n        });\n        this.init();\n      }\n      update(...args: any[]) {\n        const { iterations } = (args[0] || {}) as { iterations?: number };\n        let p_in: any, p_out: any;\n        const iter = iterations ?? 0;\n        for (let i = 0; i < iter; i++) {\n          if (i % 2 === 0) {\n            p_in = this.props.output0;\n            p_out = this.props.output1;\n          } else {\n            p_in = this.props.output1;\n            p_out = this.props.output0;\n          }\n          if (this.uniforms) this.uniforms.pressure.value = p_in.texture;\n          this.props.output = p_out;\n          super.update();\n        }\n        return p_out;\n      }\n    }\n\n    class Pressure extends ShaderPass {\n      constructor(simProps: any) {\n        super({\n          material: {\n            vertexShader: face_vert,\n            fragmentShader: pressure_frag,\n            uniforms: {\n              boundarySpace: { value: simProps.boundarySpace },\n              pressure: { value: simProps.src_p.texture },\n              velocity: { value: simProps.src_v.texture },\n              px: { value: simProps.cellScale },\n              dt: { value: simProps.dt }\n            }\n          },\n          output: simProps.dst\n        });\n        this.init();\n      }\n      update(...args: any[]) {\n        const { vel, pressure } = (args[0] || {}) as { vel?: any; pressure?: any };\n        if (this.uniforms && vel && pressure) {\n          this.uniforms.velocity.value = vel.texture;\n          this.uniforms.pressure.value = pressure.texture;\n        }\n        super.update();\n      }\n    }\n\n    class Simulation {\n      options: SimOptions;\n      fbos: Record<string, THREE.WebGLRenderTarget | null> = {\n        vel_0: null,\n        vel_1: null,\n        vel_viscous0: null,\n        vel_viscous1: null,\n        div: null,\n        pressure_0: null,\n        pressure_1: null\n      };\n      fboSize = new THREE.Vector2();\n      cellScale = new THREE.Vector2();\n      boundarySpace = new THREE.Vector2();\n      advection!: Advection;\n      externalForce!: ExternalForce;\n      viscous!: Viscous;\n      divergence!: Divergence;\n      poisson!: Poisson;\n      pressure!: Pressure;\n      constructor(options?: Partial<SimOptions>) {\n        this.options = {\n          iterations_poisson: 32,\n          iterations_viscous: 32,\n          mouse_force: 20,\n          resolution: 0.5,\n          cursor_size: 100,\n          viscous: 30,\n          isBounce: false,\n          dt: 0.014,\n          isViscous: false,\n          BFECC: true,\n          ...options\n        };\n        this.init();\n      }\n      init() {\n        this.calcSize();\n        this.createAllFBO();\n        this.createShaderPass();\n      }\n      getFloatType() {\n        const isIOS = /(iPad|iPhone|iPod)/i.test(navigator.userAgent);\n        return isIOS ? THREE.HalfFloatType : THREE.FloatType;\n      }\n      createAllFBO() {\n        const type = this.getFloatType();\n        const opts = {\n          type,\n          depthBuffer: false,\n          stencilBuffer: false,\n          minFilter: THREE.LinearFilter,\n          magFilter: THREE.LinearFilter,\n          wrapS: THREE.ClampToEdgeWrapping,\n          wrapT: THREE.ClampToEdgeWrapping\n        } as const;\n        for (const key in this.fbos) {\n          this.fbos[key] = new THREE.WebGLRenderTarget(this.fboSize.x, this.fboSize.y, opts);\n        }\n      }\n      createShaderPass() {\n        this.advection = new Advection({\n          cellScale: this.cellScale,\n          fboSize: this.fboSize,\n          dt: this.options.dt,\n          src: this.fbos.vel_0,\n          dst: this.fbos.vel_1\n        });\n        this.externalForce = new ExternalForce({\n          cellScale: this.cellScale,\n          cursor_size: this.options.cursor_size,\n          dst: this.fbos.vel_1\n        });\n        this.viscous = new Viscous({\n          cellScale: this.cellScale,\n          boundarySpace: this.boundarySpace,\n          viscous: this.options.viscous,\n          src: this.fbos.vel_1,\n          dst: this.fbos.vel_viscous1,\n          dst_: this.fbos.vel_viscous0,\n          dt: this.options.dt\n        });\n        this.divergence = new Divergence({\n          cellScale: this.cellScale,\n          boundarySpace: this.boundarySpace,\n          src: this.fbos.vel_viscous0,\n          dst: this.fbos.div,\n          dt: this.options.dt\n        });\n        this.poisson = new Poisson({\n          cellScale: this.cellScale,\n          boundarySpace: this.boundarySpace,\n          src: this.fbos.div,\n          dst: this.fbos.pressure_1,\n          dst_: this.fbos.pressure_0\n        });\n        this.pressure = new Pressure({\n          cellScale: this.cellScale,\n          boundarySpace: this.boundarySpace,\n          src_p: this.fbos.pressure_0,\n          src_v: this.fbos.vel_viscous0,\n          dst: this.fbos.vel_0,\n          dt: this.options.dt\n        });\n      }\n      calcSize() {\n        const width = Math.max(1, Math.round(this.options.resolution * Common.width));\n        const height = Math.max(1, Math.round(this.options.resolution * Common.height));\n        this.cellScale.set(1 / width, 1 / height);\n        this.fboSize.set(width, height);\n      }\n      resize() {\n        this.calcSize();\n        for (const key in this.fbos) {\n          this.fbos[key]!.setSize(this.fboSize.x, this.fboSize.y);\n        }\n      }\n      update() {\n        if (this.options.isBounce) this.boundarySpace.set(0, 0);\n        else this.boundarySpace.copy(this.cellScale);\n        this.advection.update({ dt: this.options.dt, isBounce: this.options.isBounce, BFECC: this.options.BFECC });\n        this.externalForce.update({\n          cursor_size: this.options.cursor_size,\n          mouse_force: this.options.mouse_force,\n          cellScale: this.cellScale\n        });\n        let vel: any = this.fbos.vel_1;\n        if (this.options.isViscous) {\n          vel = this.viscous.update({\n            viscous: this.options.viscous,\n            iterations: this.options.iterations_viscous,\n            dt: this.options.dt\n          });\n        }\n        this.divergence.update({ vel });\n        const pressure = this.poisson.update({ iterations: this.options.iterations_poisson });\n        this.pressure.update({ vel, pressure });\n      }\n    }\n\n    class Output {\n      simulation: Simulation;\n      scene: THREE.Scene;\n      camera: THREE.Camera;\n      output: THREE.Mesh;\n      constructor() {\n        this.simulation = new Simulation();\n        this.scene = new THREE.Scene();\n        this.camera = new THREE.Camera();\n        this.output = new THREE.Mesh(\n          new THREE.PlaneGeometry(2, 2),\n          new THREE.RawShaderMaterial({\n            vertexShader: face_vert,\n            fragmentShader: color_frag,\n            transparent: true,\n            depthWrite: false,\n            uniforms: {\n              velocity: { value: this.simulation.fbos.vel_0!.texture },\n              boundarySpace: { value: new THREE.Vector2() },\n              palette: { value: paletteTex },\n              bgColor: { value: bgVec4 }\n            }\n          })\n        );\n        this.scene.add(this.output);\n      }\n      resize() {\n        this.simulation.resize();\n      }\n      render() {\n        if (!Common.renderer) return;\n        Common.renderer.setRenderTarget(null);\n        Common.renderer.render(this.scene, this.camera);\n      }\n      update() {\n        this.simulation.update();\n        this.render();\n      }\n    }\n\n    class WebGLManager implements LiquidEtherWebGL {\n      props: any;\n      output!: Output;\n      autoDriver?: AutoDriver;\n      lastUserInteraction = performance.now();\n      running = false;\n      private _loop = this.loop.bind(this);\n      private _resize = this.resize.bind(this);\n      private _onVisibility?: () => void;\n      constructor(props: any) {\n        this.props = props;\n        Common.init(props.$wrapper);\n        Mouse.init(props.$wrapper);\n        Mouse.autoIntensity = props.autoIntensity;\n        Mouse.takeoverDuration = props.takeoverDuration;\n        Mouse.onInteract = () => {\n          this.lastUserInteraction = performance.now();\n          if (this.autoDriver) this.autoDriver.forceStop();\n        };\n        this.autoDriver = new AutoDriver(Mouse, this as any, {\n          enabled: props.autoDemo,\n          speed: props.autoSpeed,\n          resumeDelay: props.autoResumeDelay,\n          rampDuration: props.autoRampDuration\n        });\n        this.init();\n        window.addEventListener('resize', this._resize);\n        this._onVisibility = () => {\n          const hidden = document.hidden;\n          if (hidden) {\n            this.pause();\n          } else if (isVisibleRef.current) {\n            this.start();\n          }\n        };\n        document.addEventListener('visibilitychange', this._onVisibility);\n      }\n      init() {\n        if (!Common.renderer) return;\n        this.props.$wrapper.prepend(Common.renderer.domElement);\n        this.output = new Output();\n      }\n      resize() {\n        Common.resize();\n        this.output.resize();\n      }\n      render() {\n        if (this.autoDriver) this.autoDriver.update();\n        Mouse.update();\n        Common.update();\n        this.output.update();\n      }\n      loop() {\n        if (!this.running) return;\n        this.render();\n        rafRef.current = requestAnimationFrame(this._loop);\n      }\n      start() {\n        if (this.running) return;\n        this.running = true;\n        this._loop();\n      }\n      pause() {\n        this.running = false;\n        if (rafRef.current) {\n          cancelAnimationFrame(rafRef.current);\n          rafRef.current = null;\n        }\n      }\n      dispose() {\n        try {\n          window.removeEventListener('resize', this._resize);\n          if (this._onVisibility) document.removeEventListener('visibilitychange', this._onVisibility);\n          Mouse.dispose();\n          if (Common.renderer) {\n            const canvas = Common.renderer.domElement;\n            if (canvas && canvas.parentNode) canvas.parentNode.removeChild(canvas);\n            Common.renderer.dispose();\n          }\n        } catch {\n          /* noop */\n        }\n      }\n    }\n\n    const container = mountRef.current;\n    container.style.position = container.style.position || 'relative';\n    container.style.overflow = container.style.overflow || 'hidden';\n\n    const webgl = new WebGLManager({\n      $wrapper: container,\n      autoDemo,\n      autoSpeed,\n      autoIntensity,\n      takeoverDuration,\n      autoResumeDelay,\n      autoRampDuration\n    });\n    webglRef.current = webgl;\n\n    const applyOptionsFromProps = () => {\n      if (!webglRef.current) return;\n      const sim = webglRef.current.output?.simulation;\n      if (!sim) return;\n      const prevRes = sim.options.resolution;\n      Object.assign(sim.options, {\n        mouse_force: mouseForce,\n        cursor_size: cursorSize,\n        isViscous,\n        viscous,\n        iterations_viscous: iterationsViscous,\n        iterations_poisson: iterationsPoisson,\n        dt,\n        BFECC,\n        resolution,\n        isBounce\n      });\n      if (resolution !== prevRes) sim.resize();\n    };\n    applyOptionsFromProps();\n    webgl.start();\n\n    const io = new IntersectionObserver(\n      entries => {\n        const entry = entries[0];\n        const isVisible = entry.isIntersecting && entry.intersectionRatio > 0;\n        isVisibleRef.current = isVisible;\n        if (!webglRef.current) return;\n        if (isVisible && !document.hidden) {\n          webglRef.current.start();\n        } else {\n          webglRef.current.pause();\n        }\n      },\n      { threshold: [0, 0.01, 0.1] }\n    );\n    io.observe(container);\n    intersectionObserverRef.current = io;\n\n    const ro = new ResizeObserver(() => {\n      if (!webglRef.current) return;\n      if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current);\n      resizeRafRef.current = requestAnimationFrame(() => {\n        if (!webglRef.current) return;\n        webglRef.current.resize();\n      });\n    });\n    ro.observe(container);\n    resizeObserverRef.current = ro;\n\n    return () => {\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      if (resizeObserverRef.current) {\n        try {\n          resizeObserverRef.current.disconnect();\n        } catch {\n          /* noop */\n        }\n      }\n      if (intersectionObserverRef.current) {\n        try {\n          intersectionObserverRef.current.disconnect();\n        } catch {\n          /* noop */\n        }\n      }\n      if (webglRef.current) {\n        webglRef.current.dispose();\n      }\n      webglRef.current = null;\n    };\n  }, [\n    BFECC,\n    cursorSize,\n    dt,\n    isBounce,\n    isViscous,\n    iterationsPoisson,\n    iterationsViscous,\n    mouseForce,\n    resolution,\n    viscous,\n    colors,\n    autoDemo,\n    autoSpeed,\n    autoIntensity,\n    takeoverDuration,\n    autoResumeDelay,\n    autoRampDuration\n  ]);\n\n  useEffect(() => {\n    const webgl = webglRef.current;\n    if (!webgl) return;\n    const sim = webgl.output?.simulation;\n    if (!sim) return;\n    const prevRes = sim.options.resolution;\n    Object.assign(sim.options, {\n      mouse_force: mouseForce,\n      cursor_size: cursorSize,\n      isViscous,\n      viscous,\n      iterations_viscous: iterationsViscous,\n      iterations_poisson: iterationsPoisson,\n      dt,\n      BFECC,\n      resolution,\n      isBounce\n    });\n    if (webgl.autoDriver) {\n      webgl.autoDriver.enabled = autoDemo;\n      webgl.autoDriver.speed = autoSpeed;\n      webgl.autoDriver.resumeDelay = autoResumeDelay;\n      webgl.autoDriver.rampDurationMs = autoRampDuration * 1000;\n      if (webgl.autoDriver.mouse) {\n        webgl.autoDriver.mouse.autoIntensity = autoIntensity;\n        webgl.autoDriver.mouse.takeoverDuration = takeoverDuration;\n      }\n    }\n    if (resolution !== prevRes) sim.resize();\n  }, [\n    mouseForce,\n    cursorSize,\n    isViscous,\n    viscous,\n    iterationsViscous,\n    iterationsPoisson,\n    dt,\n    BFECC,\n    resolution,\n    isBounce,\n    autoDemo,\n    autoSpeed,\n    autoIntensity,\n    takeoverDuration,\n    autoResumeDelay,\n    autoRampDuration\n  ]);\n\n  return (\n    <div\n      ref={mountRef}\n      className={`w-full h-full relative overflow-hidden pointer-events-none touch-none ${className || ''}`}\n      style={style}\n    />\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "orb",
      "type": "component",
      "description": "An animated glowing orb background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/orb.tsx",
          "content": "import { Mesh, Program, Renderer, Triangle, Vec3 } from 'ogl';\nimport { useEffect, useRef } from 'react';\n\ninterface OrbProps {\n  hue?: number;\n  hoverIntensity?: number;\n  rotateOnHover?: boolean;\n  forceHoverState?: boolean;\n  backgroundColor?: string;\n}\n\nexport default function Orb({\n  hue = 0,\n  hoverIntensity = 0.2,\n  rotateOnHover = true,\n  forceHoverState = false,\n  backgroundColor = '#000000'\n}: OrbProps) {\n  const ctnDom = useRef<HTMLDivElement>(null);\n\n  const vert = /* glsl */ `\n    precision highp float;\n    attribute vec2 position;\n    attribute vec2 uv;\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n\n  const frag = /* glsl */ `\n    precision highp float;\n\n    uniform float iTime;\n    uniform vec3 iResolution;\n    uniform float hue;\n    uniform float hover;\n    uniform float rot;\n    uniform float hoverIntensity;\n    uniform vec3 backgroundColor;\n    varying vec2 vUv;\n\n    vec3 rgb2yiq(vec3 c) {\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\n      return vec3(y, i, q);\n    }\n    \n    vec3 yiq2rgb(vec3 c) {\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\n      return vec3(r, g, b);\n    }\n    \n    vec3 adjustHue(vec3 color, float hueDeg) {\n      float hueRad = hueDeg * 3.14159265 / 180.0;\n      vec3 yiq = rgb2yiq(color);\n      float cosA = cos(hueRad);\n      float sinA = sin(hueRad);\n      float i = yiq.y * cosA - yiq.z * sinA;\n      float q = yiq.y * sinA + yiq.z * cosA;\n      yiq.y = i;\n      yiq.z = q;\n      return yiq2rgb(yiq);\n    }\n    \n    vec3 hash33(vec3 p3) {\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n      p3 += dot(p3, p3.yxz + 19.19);\n      return -1.0 + 2.0 * fract(vec3(\n        p3.x + p3.y,\n        p3.x + p3.z,\n        p3.y + p3.z\n      ) * p3.zyx);\n    }\n    \n    float snoise3(vec3 p) {\n      const float K1 = 0.333333333;\n      const float K2 = 0.166666667;\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\n      vec3 i1 = e * (1.0 - e.zxy);\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n      vec3 d1 = d0 - (i1 - K2);\n      vec3 d2 = d0 - (i2 - K1);\n      vec3 d3 = d0 - 0.5;\n      vec4 h = max(0.6 - vec4(\n        dot(d0, d0),\n        dot(d1, d1),\n        dot(d2, d2),\n        dot(d3, d3)\n      ), 0.0);\n      vec4 n = h * h * h * h * vec4(\n        dot(d0, hash33(i)),\n        dot(d1, hash33(i + i1)),\n        dot(d2, hash33(i + i2)),\n        dot(d3, hash33(i + 1.0))\n      );\n      return dot(vec4(31.316), n);\n    }\n    \n    vec4 extractAlpha(vec3 colorIn) {\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\n      return vec4(colorIn.rgb / (a + 1e-5), a);\n    }\n    \n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\n    const float innerRadius = 0.6;\n    const float noiseScale = 0.65;\n    \n    float light1(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * attenuation);\n    }\n    \n    float light2(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * dist * attenuation);\n    }\n    \n    vec4 draw(vec2 uv) {\n      vec3 color1 = adjustHue(baseColor1, hue);\n      vec3 color2 = adjustHue(baseColor2, hue);\n      vec3 color3 = adjustHue(baseColor3, hue);\n      \n      float ang = atan(uv.y, uv.x);\n      float len = length(uv);\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\n      \n      float bgLuminance = dot(backgroundColor, vec3(0.299, 0.587, 0.114));\n      \n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n      float d0 = distance(uv, (r0 * invLen) * uv);\n      float v0 = light1(1.0, 10.0, d0);\n\n      v0 *= smoothstep(r0 * 1.05, r0, len);\n      float innerFade = smoothstep(r0 * 0.8, r0 * 0.95, len);\n      v0 *= mix(innerFade, 1.0, bgLuminance * 0.7);\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\n      \n      float a = iTime * -1.0;\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\n      float d = distance(uv, pos);\n      float v1 = light2(1.5, 5.0, d);\n      v1 *= light1(1.0, 50.0, d0);\n      \n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\n      \n      vec3 colBase = mix(color1, color2, cl);\n      float fadeAmount = mix(1.0, 0.1, bgLuminance);\n      \n      vec3 darkCol = mix(color3, colBase, v0);\n      darkCol = (darkCol + v1) * v2 * v3;\n      darkCol = clamp(darkCol, 0.0, 1.0);\n      \n      vec3 lightCol = (colBase + v1) * mix(1.0, v2 * v3, fadeAmount);\n      lightCol = mix(backgroundColor, lightCol, v0);\n      lightCol = clamp(lightCol, 0.0, 1.0);\n      \n      vec3 finalCol = mix(darkCol, lightCol, bgLuminance);\n      \n      return extractAlpha(finalCol);\n    }\n    \n    vec4 mainImage(vec2 fragCoord) {\n      vec2 center = iResolution.xy * 0.5;\n      float size = min(iResolution.x, iResolution.y);\n      vec2 uv = (fragCoord - center) / size * 2.0;\n      \n      float angle = rot;\n      float s = sin(angle);\n      float c = cos(angle);\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n      \n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\n      \n      return draw(uv);\n    }\n    \n    void main() {\n      vec2 fragCoord = vUv * iResolution.xy;\n      vec4 col = mainImage(fragCoord);\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\n    }\n  `;\n\n  useEffect(() => {\n    const container = ctnDom.current;\n    if (!container) return;\n\n    const renderer = new Renderer({ alpha: true, premultipliedAlpha: false });\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    container.appendChild(gl.canvas);\n\n    const geometry = new Triangle(gl);\n    const program = new Program(gl, {\n      vertex: vert,\n      fragment: frag,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: {\n          value: new Vec3(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n        },\n        hue: { value: hue },\n        hover: { value: 0 },\n        rot: { value: 0 },\n        hoverIntensity: { value: hoverIntensity },\n        backgroundColor: { value: hexToVec3(backgroundColor) }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    function resize() {\n      if (!container) return;\n      const dpr = window.devicePixelRatio || 1;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n      renderer.setSize(width * dpr, height * dpr);\n      gl.canvas.style.width = width + 'px';\n      gl.canvas.style.height = height + 'px';\n      program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height);\n    }\n    window.addEventListener('resize', resize);\n    resize();\n\n    let targetHover = 0;\n    let lastTime = 0;\n    let currentRot = 0;\n    const rotationSpeed = 0.3;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = container.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const width = rect.width;\n      const height = rect.height;\n      const size = Math.min(width, height);\n      const centerX = width / 2;\n      const centerY = height / 2;\n      const uvX = ((x - centerX) / size) * 2.0;\n      const uvY = ((y - centerY) / size) * 2.0;\n\n      if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n        targetHover = 1;\n      } else {\n        targetHover = 0;\n      }\n    };\n\n    const handleMouseLeave = () => {\n      targetHover = 0;\n    };\n\n    container.addEventListener('mousemove', handleMouseMove);\n    container.addEventListener('mouseleave', handleMouseLeave);\n\n    let rafId: number;\n    const update = (t: number) => {\n      rafId = requestAnimationFrame(update);\n      const dt = (t - lastTime) * 0.001;\n      lastTime = t;\n      program.uniforms.iTime.value = t * 0.001;\n      program.uniforms.hue.value = hue;\n      program.uniforms.hoverIntensity.value = hoverIntensity;\n\n      const effectiveHover = forceHoverState ? 1 : targetHover;\n      program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n\n      if (rotateOnHover && effectiveHover > 0.5) {\n        currentRot += dt * rotationSpeed;\n      }\n      program.uniforms.rot.value = currentRot;\n      program.uniforms.backgroundColor.value = hexToVec3(backgroundColor);\n\n      renderer.render({ scene: mesh });\n    };\n    rafId = requestAnimationFrame(update);\n\n    return () => {\n      cancelAnimationFrame(rafId);\n      window.removeEventListener('resize', resize);\n      container.removeEventListener('mousemove', handleMouseMove);\n      container.removeEventListener('mouseleave', handleMouseLeave);\n      container.removeChild(gl.canvas);\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n    };\n  }, [hue, hoverIntensity, rotateOnHover, forceHoverState, backgroundColor]);\n\n  return <div ref={ctnDom} className=\"w-full h-full\" />;\n}\n\nfunction hslToRgb(h: number, s: number, l: number) {\n  let r, g, b;\n\n  if (s === 0) {\n    r = g = b = l;\n  } else {\n    const hue2rgb = (p: number, q: number, t: number) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n\n  return new Vec3(r, g, b);\n}\n\nfunction hexToVec3(color: string) {\n  if (color.startsWith('#')) {\n    const r = parseInt(color.slice(1, 3), 16) / 255;\n    const g = parseInt(color.slice(3, 5), 16) / 255;\n    const b = parseInt(color.slice(5, 7), 16) / 255;\n    return new Vec3(r, g, b);\n  }\n\n  const rgbMatch = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/);\n  if (rgbMatch) {\n    return new Vec3(parseInt(rgbMatch[1]) / 255, parseInt(rgbMatch[2]) / 255, parseInt(rgbMatch[3]) / 255);\n  }\n\n  const hslMatch = color.match(/hsla?\\((\\d+),\\s*(\\d+)%,\\s*(\\d+)%/);\n  if (hslMatch) {\n    const h = parseInt(hslMatch[1]) / 360;\n    const s = parseInt(hslMatch[2]) / 100;\n    const l = parseInt(hslMatch[3]) / 100;\n    return hslToRgb(h, s, l);\n  }\n\n  return new Vec3(0, 0, 0);\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "pixel-blast",
      "type": "component",
      "description": "A pixelated blast particle background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three",
        "postprocessing"
      ],
      "files": [
        {
          "path": "components/ui/pixel-blast.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\nimport { EffectComposer, EffectPass, RenderPass, Effect } from 'postprocessing';\n\ntype PixelBlastVariant = 'square' | 'circle' | 'triangle' | 'diamond';\n\ninterface TouchPoint {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  force: number;\n  age: number;\n}\n\ninterface TouchTexture {\n  canvas: HTMLCanvasElement;\n  texture: THREE.Texture;\n  addTouch: (norm: { x: number; y: number }) => void;\n  update: () => void;\n  radiusScale: number;\n  size: number;\n}\n\ninterface ReinitConfig {\n  antialias: boolean;\n  liquid: boolean;\n  noiseAmount: number;\n}\n\ntype PixelBlastProps = {\n  variant?: PixelBlastVariant;\n  pixelSize?: number;\n  color?: string;\n  className?: string;\n  style?: React.CSSProperties;\n  antialias?: boolean;\n  patternScale?: number;\n  patternDensity?: number;\n  liquid?: boolean;\n  liquidStrength?: number;\n  liquidRadius?: number;\n  pixelSizeJitter?: number;\n  enableRipples?: boolean;\n  rippleIntensityScale?: number;\n  rippleThickness?: number;\n  rippleSpeed?: number;\n  liquidWobbleSpeed?: number;\n  autoPauseOffscreen?: boolean;\n  speed?: number;\n  transparent?: boolean;\n  edgeFade?: number;\n  noiseAmount?: number;\n};\n\nconst createTouchTexture = (): TouchTexture => {\n  const size = 64;\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new Error('2D context not available');\n  ctx.fillStyle = 'black';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n  const texture = new THREE.Texture(canvas);\n  texture.minFilter = THREE.LinearFilter;\n  texture.magFilter = THREE.LinearFilter;\n  texture.generateMipmaps = false;\n  const trail: TouchPoint[] = [];\n  let last: { x: number; y: number } | null = null;\n  const maxAge = 64;\n  let radius = 0.1 * size;\n  const speed = 1 / maxAge;\n  const clear = () => {\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n  };\n  const drawPoint = (p: TouchPoint) => {\n    const pos = { x: p.x * size, y: (1 - p.y) * size };\n    let intensity = 1;\n    const easeOutSine = (t: number) => Math.sin((t * Math.PI) / 2);\n    const easeOutQuad = (t: number) => -t * (t - 2);\n    if (p.age < maxAge * 0.3) intensity = easeOutSine(p.age / (maxAge * 0.3));\n    else intensity = easeOutQuad(1 - (p.age - maxAge * 0.3) / (maxAge * 0.7)) || 0;\n    intensity *= p.force;\n    const color = `${((p.vx + 1) / 2) * 255}, ${((p.vy + 1) / 2) * 255}, ${intensity * 255}`;\n    const offset = size * 5;\n    ctx.shadowOffsetX = offset;\n    ctx.shadowOffsetY = offset;\n    ctx.shadowBlur = radius;\n    ctx.shadowColor = `rgba(${color},${0.22 * intensity})`;\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(255,0,0,1)';\n    ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);\n    ctx.fill();\n  };\n  const addTouch = (norm: { x: number; y: number }) => {\n    let force = 0;\n    let vx = 0;\n    let vy = 0;\n    if (last) {\n      const dx = norm.x - last.x;\n      const dy = norm.y - last.y;\n      if (dx === 0 && dy === 0) return;\n      const dd = dx * dx + dy * dy;\n      const d = Math.sqrt(dd);\n      vx = dx / (d || 1);\n      vy = dy / (d || 1);\n      force = Math.min(dd * 10000, 1);\n    }\n    last = { x: norm.x, y: norm.y };\n    trail.push({ x: norm.x, y: norm.y, age: 0, force, vx, vy });\n  };\n  const update = () => {\n    clear();\n    for (let i = trail.length - 1; i >= 0; i--) {\n      const point = trail[i];\n      const f = point.force * speed * (1 - point.age / maxAge);\n      point.x += point.vx * f;\n      point.y += point.vy * f;\n      point.age++;\n      if (point.age > maxAge) trail.splice(i, 1);\n    }\n    for (let i = 0; i < trail.length; i++) drawPoint(trail[i]);\n    texture.needsUpdate = true;\n  };\n  return {\n    canvas,\n    texture,\n    addTouch,\n    update,\n    set radiusScale(v: number) {\n      radius = 0.1 * size * v;\n    },\n    get radiusScale() {\n      return radius / (0.1 * size);\n    },\n    size\n  };\n};\n\nconst createLiquidEffect = (texture: THREE.Texture, opts?: { strength?: number; freq?: number }) => {\n  const fragment = `\n    uniform sampler2D uTexture;\n    uniform float uStrength;\n    uniform float uTime;\n    uniform float uFreq;\n\n    void mainUv(inout vec2 uv) {\n      vec4 tex = texture2D(uTexture, uv);\n      float vx = tex.r * 2.0 - 1.0;\n      float vy = tex.g * 2.0 - 1.0;\n      float intensity = tex.b;\n\n      float wave = 0.5 + 0.5 * sin(uTime * uFreq + intensity * 6.2831853);\n\n      float amt = uStrength * intensity * wave;\n\n      uv += vec2(vx, vy) * amt;\n    }\n    `;\n  return new Effect('LiquidEffect', fragment, {\n    uniforms: new Map<string, THREE.Uniform>([\n      ['uTexture', new THREE.Uniform(texture)],\n      ['uStrength', new THREE.Uniform(opts?.strength ?? 0.025)],\n      ['uTime', new THREE.Uniform(0)],\n      ['uFreq', new THREE.Uniform(opts?.freq ?? 4.5)]\n    ])\n  });\n};\n\nconst SHAPE_MAP: Record<PixelBlastVariant, number> = {\n  square: 0,\n  circle: 1,\n  triangle: 2,\n  diamond: 3\n};\n\nconst VERTEX_SRC = `\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n`;\nconst FRAGMENT_SRC = `\nprecision highp float;\n\nuniform vec3  uColor;\nuniform vec2  uResolution;\nuniform float uTime;\nuniform float uPixelSize;\nuniform float uScale;\nuniform float uDensity;\nuniform float uPixelJitter;\nuniform int   uEnableRipples;\nuniform float uRippleSpeed;\nuniform float uRippleThickness;\nuniform float uRippleIntensity;\nuniform float uEdgeFade;\n\nuniform int   uShapeType;\nconst int SHAPE_SQUARE   = 0;\nconst int SHAPE_CIRCLE   = 1;\nconst int SHAPE_TRIANGLE = 2;\nconst int SHAPE_DIAMOND  = 3;\n\nconst int   MAX_CLICKS = 10;\n\nuniform vec2  uClickPos  [MAX_CLICKS];\nuniform float uClickTimes[MAX_CLICKS];\n\nout vec4 fragColor;\n\nfloat Bayer2(vec2 a) {\n  a = floor(a);\n  return fract(a.x / 2. + a.y * a.y * .75);\n}\n#define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))\n#define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))\n\n#define FBM_OCTAVES     5\n#define FBM_LACUNARITY  1.25\n#define FBM_GAIN        1.0\n\nfloat hash11(float n){ return fract(sin(n)*43758.5453); }\n\nfloat vnoise(vec3 p){\n  vec3 ip = floor(p);\n  vec3 fp = fract(p);\n  float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));\n  float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));\n  float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));\n  float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));\n  float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));\n  float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));\n  float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));\n  float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));\n  vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);\n  float x00 = mix(n000, n100, w.x);\n  float x10 = mix(n010, n110, w.x);\n  float x01 = mix(n001, n101, w.x);\n  float x11 = mix(n011, n111, w.x);\n  float y0  = mix(x00, x10, w.y);\n  float y1  = mix(x01, x11, w.y);\n  return mix(y0, y1, w.z) * 2.0 - 1.0;\n}\n\nfloat fbm2(vec2 uv, float t){\n  vec3 p = vec3(uv * uScale, t);\n  float amp = 1.0;\n  float freq = 1.0;\n  float sum = 1.0;\n  for (int i = 0; i < FBM_OCTAVES; ++i){\n    sum  += amp * vnoise(p * freq);\n    freq *= FBM_LACUNARITY;\n    amp  *= FBM_GAIN;\n  }\n  return sum * 0.5 + 0.5;\n}\n\nfloat maskCircle(vec2 p, float cov){\n  float r = sqrt(cov) * .25;\n  float d = length(p - 0.5) - r;\n  float aa = 0.5 * fwidth(d);\n  return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));\n}\n\nfloat maskTriangle(vec2 p, vec2 id, float cov){\n  bool flip = mod(id.x + id.y, 2.0) > 0.5;\n  if (flip) p.x = 1.0 - p.x;\n  float r = sqrt(cov);\n  float d  = p.y - r*(1.0 - p.x);\n  float aa = fwidth(d);\n  return cov * clamp(0.5 - d/aa, 0.0, 1.0);\n}\n\nfloat maskDiamond(vec2 p, float cov){\n  float r = sqrt(cov) * 0.564;\n  return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);\n}\n\nvoid main(){\n  float pixelSize = uPixelSize;\n  vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;\n  float aspectRatio = uResolution.x / uResolution.y;\n\n  vec2 pixelId = floor(fragCoord / pixelSize);\n  vec2 pixelUV = fract(fragCoord / pixelSize);\n\n  float cellPixelSize = 8.0 * pixelSize;\n  vec2 cellId = floor(fragCoord / cellPixelSize);\n  vec2 cellCoord = cellId * cellPixelSize;\n  vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);\n\n  float base = fbm2(uv, uTime * 0.05);\n  base = base * 0.5 - 0.65;\n\n  float feed = base + (uDensity - 0.5) * 0.3;\n\n  float speed     = uRippleSpeed;\n  float thickness = uRippleThickness;\n  const float dampT     = 1.0;\n  const float dampR     = 10.0;\n\n  if (uEnableRipples == 1) {\n    for (int i = 0; i < MAX_CLICKS; ++i){\n      vec2 pos = uClickPos[i];\n      if (pos.x < 0.0) continue;\n      float cellPixelSize = 8.0 * pixelSize;\n      vec2 cuv = (((pos - uResolution * .5 - cellPixelSize * .5) / (uResolution))) * vec2(aspectRatio, 1.0);\n      float t = max(uTime - uClickTimes[i], 0.0);\n      float r = distance(uv, cuv);\n      float waveR = speed * t;\n      float ring  = exp(-pow((r - waveR) / thickness, 2.0));\n      float atten = exp(-dampT * t) * exp(-dampR * r);\n      feed = max(feed, ring * atten * uRippleIntensity);\n    }\n  }\n\n  float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;\n  float bw = step(0.5, feed + bayer);\n\n  float h = fract(sin(dot(floor(fragCoord / uPixelSize), vec2(127.1, 311.7))) * 43758.5453);\n  float jitterScale = 1.0 + (h - 0.5) * uPixelJitter;\n  float coverage = bw * jitterScale;\n  float M;\n  if      (uShapeType == SHAPE_CIRCLE)   M = maskCircle (pixelUV, coverage);\n  else if (uShapeType == SHAPE_TRIANGLE) M = maskTriangle(pixelUV, pixelId, coverage);\n  else if (uShapeType == SHAPE_DIAMOND)  M = maskDiamond(pixelUV, coverage);\n  else                                   M = coverage;\n\n  if (uEdgeFade > 0.0) {\n    vec2 norm = gl_FragCoord.xy / uResolution;\n    float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));\n    float fade = smoothstep(0.0, uEdgeFade, edge);\n    M *= fade;\n  }\n\n  vec3 color = uColor;\n\n  // sRGB gamma correction - convert linear to sRGB for accurate color output\n  vec3 srgbColor = mix(\n    color * 12.92,\n    1.055 * pow(color, vec3(1.0 / 2.4)) - 0.055,\n    step(0.0031308, color)\n  );\n\n  fragColor = vec4(srgbColor, M);\n}\n`;\n\nconst MAX_CLICKS = 10;\n\nconst PixelBlast: React.FC<PixelBlastProps> = ({\n  variant = 'square',\n  pixelSize = 3,\n  color = '#B19EEF',\n  className,\n  style,\n  antialias = true,\n  patternScale = 2,\n  patternDensity = 1,\n  liquid = false,\n  liquidStrength = 0.1,\n  liquidRadius = 1,\n  pixelSizeJitter = 0,\n  enableRipples = true,\n  rippleIntensityScale = 1,\n  rippleThickness = 0.1,\n  rippleSpeed = 0.3,\n  liquidWobbleSpeed = 4.5,\n  autoPauseOffscreen = true,\n  speed = 0.5,\n  transparent = true,\n  edgeFade = 0.5,\n  noiseAmount = 0\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const visibilityRef = useRef({ visible: true });\n  const speedRef = useRef(speed);\n\n  const threeRef = useRef<{\n    renderer: THREE.WebGLRenderer;\n    scene: THREE.Scene;\n    camera: THREE.OrthographicCamera;\n    material: THREE.ShaderMaterial;\n    clock: THREE.Clock;\n    clickIx: number;\n    uniforms: {\n      uResolution: { value: THREE.Vector2 };\n      uTime: { value: number };\n      uColor: { value: THREE.Color };\n      uClickPos: { value: THREE.Vector2[] };\n      uClickTimes: { value: Float32Array };\n      uShapeType: { value: number };\n      uPixelSize: { value: number };\n      uScale: { value: number };\n      uDensity: { value: number };\n      uPixelJitter: { value: number };\n      uEnableRipples: { value: number };\n      uRippleSpeed: { value: number };\n      uRippleThickness: { value: number };\n      uRippleIntensity: { value: number };\n      uEdgeFade: { value: number };\n    };\n    resizeObserver?: ResizeObserver;\n    raf?: number;\n    quad?: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>;\n    timeOffset?: number;\n    composer?: EffectComposer;\n    touch?: ReturnType<typeof createTouchTexture>;\n    liquidEffect?: Effect;\n  } | null>(null);\n  const prevConfigRef = useRef<ReinitConfig | null>(null);\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    speedRef.current = speed;\n    const needsReinitKeys: (keyof ReinitConfig)[] = ['antialias', 'liquid', 'noiseAmount'];\n    const cfg: ReinitConfig = { antialias, liquid, noiseAmount };\n    let mustReinit = false;\n    if (!threeRef.current) mustReinit = true;\n    else if (prevConfigRef.current) {\n      for (const k of needsReinitKeys)\n        if (prevConfigRef.current[k] !== cfg[k]) {\n          mustReinit = true;\n          break;\n        }\n    }\n    if (mustReinit) {\n      if (threeRef.current) {\n        const t = threeRef.current;\n        t.resizeObserver?.disconnect();\n        cancelAnimationFrame(t.raf!);\n        t.quad?.geometry.dispose();\n        t.material.dispose();\n        t.composer?.dispose();\n        t.renderer.dispose();\n        if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);\n        threeRef.current = null;\n      }\n      const canvas = document.createElement('canvas');\n      const renderer = new THREE.WebGLRenderer({\n        canvas,\n        antialias,\n        alpha: true,\n        powerPreference: 'high-performance'\n      });\n      renderer.domElement.style.width = '100%';\n      renderer.domElement.style.height = '100%';\n      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n      container.appendChild(renderer.domElement);\n      if (transparent) renderer.setClearAlpha(0);\n      else renderer.setClearColor(0x000000, 1);\n      const uniforms = {\n        uResolution: { value: new THREE.Vector2(0, 0) },\n        uTime: { value: 0 },\n        uColor: { value: new THREE.Color(color) },\n        uClickPos: {\n          value: Array.from({ length: MAX_CLICKS }, () => new THREE.Vector2(-1, -1))\n        },\n        uClickTimes: { value: new Float32Array(MAX_CLICKS) },\n        uShapeType: { value: SHAPE_MAP[variant] ?? 0 },\n        uPixelSize: { value: pixelSize * renderer.getPixelRatio() },\n        uScale: { value: patternScale },\n        uDensity: { value: patternDensity },\n        uPixelJitter: { value: pixelSizeJitter },\n        uEnableRipples: { value: enableRipples ? 1 : 0 },\n        uRippleSpeed: { value: rippleSpeed },\n        uRippleThickness: { value: rippleThickness },\n        uRippleIntensity: { value: rippleIntensityScale },\n        uEdgeFade: { value: edgeFade }\n      };\n      const scene = new THREE.Scene();\n      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: VERTEX_SRC,\n        fragmentShader: FRAGMENT_SRC,\n        uniforms,\n        transparent: true,\n        depthTest: false,\n        depthWrite: false,\n        glslVersion: THREE.GLSL3\n      });\n      const quadGeom = new THREE.PlaneGeometry(2, 2);\n      const quad = new THREE.Mesh(quadGeom, material);\n      scene.add(quad);\n      const clock = new THREE.Clock();\n      const setSize = () => {\n        const w = container.clientWidth || 1;\n        const h = container.clientHeight || 1;\n        renderer.setSize(w, h, false);\n        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);\n        if (threeRef.current?.composer)\n          threeRef.current.composer.setSize(renderer.domElement.width, renderer.domElement.height);\n        uniforms.uPixelSize.value = pixelSize * renderer.getPixelRatio();\n      };\n      setSize();\n      const ro = new ResizeObserver(setSize);\n      ro.observe(container);\n      const randomFloat = (): number => {\n        if (typeof window !== 'undefined' && window.crypto?.getRandomValues) {\n          const u32 = new Uint32Array(1);\n          window.crypto.getRandomValues(u32);\n          return u32[0] / 0xffffffff;\n        }\n        return Math.random();\n      };\n      const timeOffset = randomFloat() * 1000;\n      let composer: EffectComposer | undefined;\n      let touch: ReturnType<typeof createTouchTexture> | undefined;\n      let liquidEffect: Effect | undefined;\n      if (liquid) {\n        touch = createTouchTexture();\n        touch.radiusScale = liquidRadius;\n        composer = new EffectComposer(renderer);\n        const renderPass = new RenderPass(scene, camera);\n        liquidEffect = createLiquidEffect(touch.texture, {\n          strength: liquidStrength,\n          freq: liquidWobbleSpeed\n        });\n        const effectPass = new EffectPass(camera, liquidEffect);\n        effectPass.renderToScreen = true;\n        composer.addPass(renderPass);\n        composer.addPass(effectPass);\n      }\n      if (noiseAmount > 0) {\n        if (!composer) {\n          composer = new EffectComposer(renderer);\n          composer.addPass(new RenderPass(scene, camera));\n        }\n        const noiseEffect = new Effect(\n          'NoiseEffect',\n          `uniform float uTime; uniform float uAmount; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);} void mainUv(inout vec2 uv){} void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){ float n=hash(floor(uv*vec2(1920.0,1080.0))+floor(uTime*60.0)); float g=(n-0.5)*uAmount; outputColor=inputColor+vec4(vec3(g),0.0);} `,\n          {\n            uniforms: new Map<string, THREE.Uniform>([\n              ['uTime', new THREE.Uniform(0)],\n              ['uAmount', new THREE.Uniform(noiseAmount)]\n            ])\n          }\n        );\n        const noisePass = new EffectPass(camera, noiseEffect);\n        noisePass.renderToScreen = true;\n        if (composer && composer.passes.length > 0) {\n          composer.passes.forEach((p: any) => {\n            const pass = p as { renderToScreen?: boolean };\n            pass.renderToScreen = false;\n          });\n        }\n        composer.addPass(noisePass);\n      }\n      if (composer) composer.setSize(renderer.domElement.width, renderer.domElement.height);\n      const mapToPixels = (e: PointerEvent) => {\n        const rect = renderer.domElement.getBoundingClientRect();\n        const scaleX = renderer.domElement.width / rect.width;\n        const scaleY = renderer.domElement.height / rect.height;\n        const fx = (e.clientX - rect.left) * scaleX;\n        const fy = (rect.height - (e.clientY - rect.top)) * scaleY;\n        return {\n          fx,\n          fy,\n          w: renderer.domElement.width,\n          h: renderer.domElement.height\n        };\n      };\n      const onPointerDown = (e: PointerEvent) => {\n        const { fx, fy } = mapToPixels(e);\n        const ix = threeRef.current?.clickIx ?? 0;\n        uniforms.uClickPos.value[ix].set(fx, fy);\n        uniforms.uClickTimes.value[ix] = uniforms.uTime.value;\n        if (threeRef.current) threeRef.current.clickIx = (ix + 1) % MAX_CLICKS;\n      };\n      const onPointerMove = (e: PointerEvent) => {\n        if (!touch) return;\n        const { fx, fy, w, h } = mapToPixels(e);\n        touch.addTouch({ x: fx / w, y: fy / h });\n      };\n      renderer.domElement.addEventListener('pointerdown', onPointerDown, {\n        passive: true\n      });\n      renderer.domElement.addEventListener('pointermove', onPointerMove, {\n        passive: true\n      });\n      let raf = 0;\n      const animate = () => {\n        if (autoPauseOffscreen && !visibilityRef.current.visible) {\n          raf = requestAnimationFrame(animate);\n          return;\n        }\n        uniforms.uTime.value = timeOffset + clock.getElapsedTime() * speedRef.current;\n        if (liquidEffect) {\n          const liqEffect = liquidEffect as Effect & { uniforms: Map<string, THREE.Uniform> };\n          const timeUniform = liqEffect.uniforms.get('uTime');\n          if (timeUniform) timeUniform.value = uniforms.uTime.value;\n        }\n        if (composer) {\n          if (touch) touch.update();\n          composer.passes.forEach((p: any) => {\n            const pass = p as { effects?: Array<Effect & { uniforms: Map<string, THREE.Uniform> }> };\n            if (pass.effects) {\n              pass.effects.forEach(eff => {\n                const timeUniform = eff.uniforms?.get('uTime');\n                if (timeUniform) timeUniform.value = uniforms.uTime.value;\n              });\n            }\n          });\n          composer.render();\n        } else renderer.render(scene, camera);\n        raf = requestAnimationFrame(animate);\n      };\n      raf = requestAnimationFrame(animate);\n      threeRef.current = {\n        renderer,\n        scene,\n        camera,\n        material,\n        clock,\n        clickIx: 0,\n        uniforms,\n        resizeObserver: ro,\n        raf,\n        quad,\n        timeOffset,\n        composer,\n        touch,\n        liquidEffect\n      };\n    } else {\n      const t = threeRef.current!;\n      t.uniforms.uShapeType.value = SHAPE_MAP[variant] ?? 0;\n      t.uniforms.uPixelSize.value = pixelSize * t.renderer.getPixelRatio();\n      t.uniforms.uColor.value.set(color);\n      t.uniforms.uScale.value = patternScale;\n      t.uniforms.uDensity.value = patternDensity;\n      t.uniforms.uPixelJitter.value = pixelSizeJitter;\n      t.uniforms.uEnableRipples.value = enableRipples ? 1 : 0;\n      t.uniforms.uRippleIntensity.value = rippleIntensityScale;\n      t.uniforms.uRippleThickness.value = rippleThickness;\n      t.uniforms.uRippleSpeed.value = rippleSpeed;\n      t.uniforms.uEdgeFade.value = edgeFade;\n      if (transparent) t.renderer.setClearAlpha(0);\n      else t.renderer.setClearColor(0x000000, 1);\n      if (t.liquidEffect) {\n        const liqEffect = t.liquidEffect as Effect & { uniforms: Map<string, THREE.Uniform> };\n        const uStrength = liqEffect.uniforms.get('uStrength');\n        if (uStrength) uStrength.value = liquidStrength;\n        const uFreq = liqEffect.uniforms.get('uFreq');\n        if (uFreq) uFreq.value = liquidWobbleSpeed;\n      }\n      if (t.touch) t.touch.radiusScale = liquidRadius;\n    }\n    prevConfigRef.current = cfg;\n    return () => {\n      if (threeRef.current && mustReinit) return;\n      if (!threeRef.current) return;\n      const t = threeRef.current;\n      t.resizeObserver?.disconnect();\n      cancelAnimationFrame(t.raf!);\n      t.quad?.geometry.dispose();\n      t.material.dispose();\n      t.composer?.dispose();\n      t.renderer.dispose();\n      if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);\n      threeRef.current = null;\n    };\n  }, [\n    antialias,\n    liquid,\n    noiseAmount,\n    pixelSize,\n    patternScale,\n    patternDensity,\n    enableRipples,\n    rippleIntensityScale,\n    rippleThickness,\n    rippleSpeed,\n    pixelSizeJitter,\n    edgeFade,\n    transparent,\n    liquidStrength,\n    liquidRadius,\n    liquidWobbleSpeed,\n    autoPauseOffscreen,\n    variant,\n    color,\n    speed\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`w-full h-full relative overflow-hidden ${className ?? ''}`}\n      style={style}\n      aria-label=\"PixelBlast interactive background\"\n    />\n  );\n};\n\nexport default PixelBlast;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "pixel-snow",
      "type": "component",
      "description": "An animated pixel snow falling background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/pixel-snow.tsx",
          "content": "import { useEffect, useRef, useMemo, useCallback } from 'react';\nimport {\n  Scene,\n  OrthographicCamera,\n  WebGLRenderer,\n  PlaneGeometry,\n  ShaderMaterial,\n  Mesh,\n  Vector2,\n  Vector3,\n  Color\n} from 'three';\n\nconst vertexShader = `\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision mediump float;\n\nuniform float uTime;\nuniform vec2 uResolution;\nuniform float uFlakeSize;\nuniform float uMinFlakeSize;\nuniform float uPixelResolution;\nuniform float uSpeed;\nuniform float uDepthFade;\nuniform float uFarPlane;\nuniform vec3 uColor;\nuniform float uBrightness;\nuniform float uGamma;\nuniform float uDensity;\nuniform float uVariant;\nuniform float uDirection;\n\n// Precomputed constants\n#define PI 3.14159265\n#define PI_OVER_6 0.5235988\n#define PI_OVER_3 1.0471976\n#define INV_SQRT3 0.57735027\n#define M1 1597334677U\n#define M2 3812015801U\n#define M3 3299493293U\n#define F0 2.3283064e-10\n\n// Optimized hash - inline multiplication\n#define hash(n) (n * (n ^ (n >> 15)))\n#define coord3(p) (uvec3(p).x * M1 ^ uvec3(p).y * M2 ^ uvec3(p).z * M3)\n\n// Precomputed camera basis vectors (normalized vec3(1,1,1), vec3(1,0,-1))\nconst vec3 camK = vec3(0.57735027, 0.57735027, 0.57735027);\nconst vec3 camI = vec3(0.70710678, 0.0, -0.70710678);\nconst vec3 camJ = vec3(-0.40824829, 0.81649658, -0.40824829);\n\n// Precomputed branch direction\nconst vec2 b1d = vec2(0.574, 0.819);\n\nvec3 hash3(uint n) {\n  uvec3 hashed = hash(n) * uvec3(1U, 511U, 262143U);\n  return vec3(hashed) * F0;\n}\n\nfloat snowflakeDist(vec2 p) {\n  float r = length(p);\n  float a = atan(p.y, p.x);\n  a = abs(mod(a + PI_OVER_6, PI_OVER_3) - PI_OVER_6);\n  vec2 q = r * vec2(cos(a), sin(a));\n  float dMain = max(abs(q.y), max(-q.x, q.x - 1.0));\n  float b1t = clamp(dot(q - vec2(0.4, 0.0), b1d), 0.0, 0.4);\n  float dB1 = length(q - vec2(0.4, 0.0) - b1t * b1d);\n  float b2t = clamp(dot(q - vec2(0.7, 0.0), b1d), 0.0, 0.25);\n  float dB2 = length(q - vec2(0.7, 0.0) - b2t * b1d);\n  return min(dMain, min(dB1, dB2)) * 10.0;\n}\n\nvoid main() {\n  // Precompute reciprocals to avoid division\n  float invPixelRes = 1.0 / uPixelResolution;\n  float pixelSize = max(1.0, floor(0.5 + uResolution.x * invPixelRes));\n  float invPixelSize = 1.0 / pixelSize;\n  \n  vec2 fragCoord = floor(gl_FragCoord.xy * invPixelSize);\n  vec2 res = uResolution * invPixelSize;\n  float invResX = 1.0 / res.x;\n\n  vec3 ray = normalize(vec3((fragCoord - res * 0.5) * invResX, 1.0));\n  ray = ray.x * camI + ray.y * camJ + ray.z * camK;\n\n  // Precompute time-based values\n  float timeSpeed = uTime * uSpeed;\n  float windX = cos(uDirection) * 0.4;\n  float windY = sin(uDirection) * 0.4;\n  vec3 camPos = (windX * camI + windY * camJ + 0.1 * camK) * timeSpeed;\n  vec3 pos = camPos;\n\n  // Precompute ray reciprocal for strides\n  vec3 absRay = max(abs(ray), vec3(0.001));\n  vec3 strides = 1.0 / absRay;\n  vec3 raySign = step(ray, vec3(0.0));\n  vec3 phase = fract(pos) * strides;\n  phase = mix(strides - phase, phase, raySign);\n\n  // Precompute for intersection test\n  float rayDotCamK = dot(ray, camK);\n  float invRayDotCamK = 1.0 / rayDotCamK;\n  float invDepthFade = 1.0 / uDepthFade;\n  float halfInvResX = 0.5 * invResX;\n  vec3 timeAnim = timeSpeed * 0.1 * vec3(7.0, 8.0, 5.0);\n\n  float t = 0.0;\n  for (int i = 0; i < 128; i++) {\n    if (t >= uFarPlane) break;\n    \n    vec3 fpos = floor(pos);\n    uint cellCoord = coord3(fpos);\n    float cellHash = hash3(cellCoord).x;\n\n    if (cellHash < uDensity) {\n      vec3 h = hash3(cellCoord);\n      \n      // Optimized flake position calculation\n      vec3 sinArg1 = fpos.yzx * 0.073;\n      vec3 sinArg2 = fpos.zxy * 0.27;\n      vec3 flakePos = 0.5 - 0.5 * cos(4.0 * sin(sinArg1) + 4.0 * sin(sinArg2) + 2.0 * h + timeAnim);\n      flakePos = flakePos * 0.8 + 0.1 + fpos;\n\n      float toIntersection = dot(flakePos - pos, camK) * invRayDotCamK;\n      \n      if (toIntersection > 0.0) {\n        vec3 testPos = pos + ray * toIntersection - flakePos;\n        float testX = dot(testPos, camI);\n        float testY = dot(testPos, camJ);\n        vec2 testUV = abs(vec2(testX, testY));\n        \n        float depth = dot(flakePos - camPos, camK);\n        float flakeSize = max(uFlakeSize, uMinFlakeSize * depth * halfInvResX);\n        \n        // Avoid branching with step functions where possible\n        float dist;\n        if (uVariant < 0.5) {\n          dist = max(testUV.x, testUV.y);\n        } else if (uVariant < 1.5) {\n          dist = length(testUV);\n        } else {\n          float invFlakeSize = 1.0 / flakeSize;\n          dist = snowflakeDist(vec2(testX, testY) * invFlakeSize) * flakeSize;\n        }\n\n        if (dist < flakeSize) {\n          float flakeSizeRatio = uFlakeSize / flakeSize;\n          float intensity = exp2(-(t + toIntersection) * invDepthFade) *\n                           min(1.0, flakeSizeRatio * flakeSizeRatio) * uBrightness;\n          gl_FragColor = vec4(uColor * pow(vec3(intensity), vec3(uGamma)), 1.0);\n          return;\n        }\n      }\n    }\n\n    float nextStep = min(min(phase.x, phase.y), phase.z);\n    vec3 sel = step(phase, vec3(nextStep));\n    phase = phase - nextStep + strides * sel;\n    t += nextStep;\n    pos = mix(pos + ray * nextStep, floor(pos + ray * nextStep + 0.5), sel);\n  }\n\n  gl_FragColor = vec4(0.0);\n}\n`;\n\ninterface PixelSnowProps {\n  color?: string;\n  flakeSize?: number;\n  minFlakeSize?: number;\n  pixelResolution?: number;\n  speed?: number;\n  depthFade?: number;\n  farPlane?: number;\n  brightness?: number;\n  gamma?: number;\n  density?: number;\n  variant?: 'square' | 'round' | 'snowflake';\n  direction?: number;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport default function PixelSnow({\n  color = '#ffffff',\n  flakeSize = 0.01,\n  minFlakeSize = 1.25,\n  pixelResolution = 200,\n  speed = 1.25,\n  depthFade = 8,\n  farPlane = 20,\n  brightness = 1,\n  gamma = 0.4545,\n  density = 0.3,\n  variant = 'square',\n  direction = 125,\n  className = '',\n  style = {}\n}: PixelSnowProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const animationRef = useRef<number>(0);\n  const isVisibleRef = useRef(true);\n  const rendererRef = useRef<WebGLRenderer | null>(null);\n  const materialRef = useRef<ShaderMaterial | null>(null);\n  const resizeTimeoutRef = useRef<number | null>(null);\n\n  // Memoize shader variant value\n  const variantValue = useMemo(() => {\n    return variant === 'round' ? 1.0 : variant === 'snowflake' ? 2.0 : 0.0;\n  }, [variant]);\n\n  // Memoize color conversion\n  const colorVector = useMemo(() => {\n    const threeColor = new Color(color);\n    return new Vector3(threeColor.r, threeColor.g, threeColor.b);\n  }, [color]);\n\n  // Debounced resize handler\n  const handleResize = useCallback(() => {\n    if (resizeTimeoutRef.current) {\n      clearTimeout(resizeTimeoutRef.current);\n    }\n    resizeTimeoutRef.current = window.setTimeout(() => {\n      const container = containerRef.current;\n      const renderer = rendererRef.current;\n      const material = materialRef.current;\n      if (!container || !renderer || !material) return;\n\n      const w = container.offsetWidth;\n      const h = container.offsetHeight;\n      renderer.setSize(w, h);\n      material.uniforms.uResolution.value.set(w, h);\n    }, 100);\n  }, []);\n\n  // Visibility observer\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        isVisibleRef.current = entry.isIntersecting;\n      },\n      { threshold: 0 }\n    );\n\n    observer.observe(container);\n    return () => observer.disconnect();\n  }, []);\n\n  // Main Three.js setup - only runs once\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const scene = new Scene();\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const renderer = new WebGLRenderer({\n      antialias: false,\n      alpha: true,\n      premultipliedAlpha: false,\n      powerPreference: 'high-performance',\n      stencil: false,\n      depth: false\n    });\n\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.setSize(container.offsetWidth, container.offsetHeight);\n    renderer.setClearColor(0x000000, 0);\n    container.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    const material = new ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        uTime: { value: 0 },\n        uResolution: { value: new Vector2(container.offsetWidth, container.offsetHeight) },\n        uFlakeSize: { value: flakeSize },\n        uMinFlakeSize: { value: minFlakeSize },\n        uPixelResolution: { value: pixelResolution },\n        uSpeed: { value: speed },\n        uDepthFade: { value: depthFade },\n        uFarPlane: { value: farPlane },\n        uColor: { value: colorVector.clone() },\n        uBrightness: { value: brightness },\n        uGamma: { value: gamma },\n        uDensity: { value: density },\n        uVariant: { value: variantValue },\n        uDirection: { value: (direction * Math.PI) / 180 }\n      },\n      transparent: true\n    });\n    materialRef.current = material;\n\n    const geometry = new PlaneGeometry(2, 2);\n    scene.add(new Mesh(geometry, material));\n\n    window.addEventListener('resize', handleResize);\n\n    const startTime = performance.now();\n    const animate = () => {\n      animationRef.current = requestAnimationFrame(animate);\n\n      // Only render if visible\n      if (isVisibleRef.current) {\n        material.uniforms.uTime.value = (performance.now() - startTime) * 0.001;\n        renderer.render(scene, camera);\n      }\n    };\n    animate();\n\n    return () => {\n      cancelAnimationFrame(animationRef.current);\n      window.removeEventListener('resize', handleResize);\n      if (resizeTimeoutRef.current) {\n        clearTimeout(resizeTimeoutRef.current);\n      }\n      if (container.contains(renderer.domElement)) {\n        container.removeChild(renderer.domElement);\n      }\n      renderer.dispose();\n      geometry.dispose();\n      material.dispose();\n      rendererRef.current = null;\n      materialRef.current = null;\n    };\n  }, [handleResize]); // Only recreate scene when handleResize changes\n\n  // Update material uniforms when props change\n  useEffect(() => {\n    const material = materialRef.current;\n    if (!material) return;\n\n    material.uniforms.uFlakeSize.value = flakeSize;\n    material.uniforms.uMinFlakeSize.value = minFlakeSize;\n    material.uniforms.uPixelResolution.value = pixelResolution;\n    material.uniforms.uSpeed.value = speed;\n    material.uniforms.uDepthFade.value = depthFade;\n    material.uniforms.uFarPlane.value = farPlane;\n    material.uniforms.uBrightness.value = brightness;\n    material.uniforms.uGamma.value = gamma;\n    material.uniforms.uDensity.value = density;\n    material.uniforms.uVariant.value = variantValue;\n    material.uniforms.uDirection.value = (direction * Math.PI) / 180;\n    material.uniforms.uColor.value.copy(colorVector);\n  }, [\n    flakeSize,\n    minFlakeSize,\n    pixelResolution,\n    speed,\n    depthFade,\n    farPlane,\n    brightness,\n    gamma,\n    density,\n    variantValue,\n    direction,\n    colorVector\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`absolute inset-0 w-full h-full transform-gpu will-change-transform backface-hidden ${className}`}\n      style={style}\n    />\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "plasma",
      "type": "component",
      "description": "An animated plasma fluid background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/plasma.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { Renderer, Program, Mesh, Triangle } from 'ogl';\n\ninterface PlasmaProps {\n  color?: string;\n  speed?: number;\n  direction?: 'forward' | 'reverse' | 'pingpong';\n  scale?: number;\n  opacity?: number;\n  mouseInteractive?: boolean;\n}\n\nconst hexToRgb = (hex: string): [number, number, number] => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  if (!result) return [1, 0.5, 0.2];\n  return [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255];\n};\n\nconst vertex = `#version 300 es\nprecision highp float;\nin vec2 position;\nin vec2 uv;\nout vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst fragment = `#version 300 es\nprecision highp float;\nuniform vec2 iResolution;\nuniform float iTime;\nuniform vec3 uCustomColor;\nuniform float uUseCustomColor;\nuniform float uSpeed;\nuniform float uDirection;\nuniform float uScale;\nuniform float uOpacity;\nuniform vec2 uMouse;\nuniform float uMouseInteractive;\nout vec4 fragColor;\n\nvoid mainImage(out vec4 o, vec2 C) {\n  vec2 center = iResolution.xy * 0.5;\n  C = (C - center) / uScale + center;\n  \n  vec2 mouseOffset = (uMouse - center) * 0.0002;\n  C += mouseOffset * length(C - center) * step(0.5, uMouseInteractive);\n  \n  float i, d, z, T = iTime * uSpeed * uDirection;\n  vec3 O, p, S;\n\n  for (vec2 r = iResolution.xy, Q; ++i < 60.; O += o.w/d*o.xyz) {\n    p = z*normalize(vec3(C-.5*r,r.y)); \n    p.z -= 4.; \n    S = p;\n    d = p.y-T;\n    \n    p.x += .4*(1.+p.y)*sin(d + p.x*0.1)*cos(.34*d + p.x*0.05); \n    Q = p.xz *= mat2(cos(p.y+vec4(0,11,33,0)-T)); \n    z+= d = abs(sqrt(length(Q*Q)) - .25*(5.+S.y))/3.+8e-4; \n    o = 1.+sin(S.y+p.z*.5+S.z-length(S-p)+vec4(2,1,0,8));\n  }\n  \n  o.xyz = tanh(O/1e4);\n}\n\nbool finite1(float x){ return !(isnan(x) || isinf(x)); }\nvec3 sanitize(vec3 c){\n  return vec3(\n    finite1(c.r) ? c.r : 0.0,\n    finite1(c.g) ? c.g : 0.0,\n    finite1(c.b) ? c.b : 0.0\n  );\n}\n\nvoid main() {\n  vec4 o = vec4(0.0);\n  mainImage(o, gl_FragCoord.xy);\n  vec3 rgb = sanitize(o.rgb);\n  \n  float intensity = (rgb.r + rgb.g + rgb.b) / 3.0;\n  vec3 customColor = intensity * uCustomColor;\n  vec3 finalColor = mix(rgb, customColor, step(0.5, uUseCustomColor));\n  \n  float alpha = length(rgb) * uOpacity;\n  fragColor = vec4(finalColor, alpha);\n}`;\n\nexport const Plasma: React.FC<PlasmaProps> = ({\n  color = '#ffffff',\n  speed = 1,\n  direction = 'forward',\n  scale = 1,\n  opacity = 1,\n  mouseInteractive = true\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const mousePos = useRef({ x: 0, y: 0 });\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const useCustomColor = color ? 1.0 : 0.0;\n    const customColorRgb = color ? hexToRgb(color) : [1, 1, 1];\n\n    const directionMultiplier = direction === 'reverse' ? -1.0 : 1.0;\n\n    const renderer = new Renderer({\n      webgl: 2,\n      alpha: true,\n      antialias: false,\n      dpr: Math.min(window.devicePixelRatio || 1, 2)\n    });\n    const gl = renderer.gl;\n    const canvas = gl.canvas as HTMLCanvasElement;\n    canvas.style.display = 'block';\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    containerRef.current.appendChild(canvas);\n\n    const geometry = new Triangle(gl);\n\n    const program = new Program(gl, {\n      vertex: vertex,\n      fragment: fragment,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: { value: new Float32Array([1, 1]) },\n        uCustomColor: { value: new Float32Array(customColorRgb) },\n        uUseCustomColor: { value: useCustomColor },\n        uSpeed: { value: speed * 0.4 },\n        uDirection: { value: directionMultiplier },\n        uScale: { value: scale },\n        uOpacity: { value: opacity },\n        uMouse: { value: new Float32Array([0, 0]) },\n        uMouseInteractive: { value: mouseInteractive ? 1.0 : 0.0 }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!mouseInteractive) return;\n      const rect = containerRef.current!.getBoundingClientRect();\n      mousePos.current.x = e.clientX - rect.left;\n      mousePos.current.y = e.clientY - rect.top;\n      const mouseUniform = program.uniforms.uMouse.value as Float32Array;\n      mouseUniform[0] = mousePos.current.x;\n      mouseUniform[1] = mousePos.current.y;\n    };\n\n    if (mouseInteractive) {\n      containerRef.current.addEventListener('mousemove', handleMouseMove);\n    }\n\n    const setSize = () => {\n      const rect = containerRef.current!.getBoundingClientRect();\n      const width = Math.max(1, Math.floor(rect.width));\n      const height = Math.max(1, Math.floor(rect.height));\n      renderer.setSize(width, height);\n      const res = program.uniforms.iResolution.value as Float32Array;\n      res[0] = gl.drawingBufferWidth;\n      res[1] = gl.drawingBufferHeight;\n    };\n\n    const ro = new ResizeObserver(setSize);\n    ro.observe(containerRef.current);\n    setSize();\n\n    let raf = 0;\n    const t0 = performance.now();\n    const loop = (t: number) => {\n      let timeValue = (t - t0) * 0.001;\n      if (direction === 'pingpong') {\n        const pingpongDuration = 10;\n        const segmentTime = timeValue % pingpongDuration;\n        const isForward = Math.floor(timeValue / pingpongDuration) % 2 === 0;\n        const u = segmentTime / pingpongDuration;\n        const smooth = u * u * (3 - 2 * u);\n        const pingpongTime = isForward ? smooth * pingpongDuration : (1 - smooth) * pingpongDuration;\n        (program.uniforms.uDirection as any).value = 1.0;\n        (program.uniforms.iTime as any).value = pingpongTime;\n      } else {\n        (program.uniforms.iTime as any).value = timeValue;\n      }\n      renderer.render({ scene: mesh });\n      raf = requestAnimationFrame(loop);\n    };\n    raf = requestAnimationFrame(loop);\n\n    return () => {\n      cancelAnimationFrame(raf);\n      ro.disconnect();\n      if (mouseInteractive && containerRef.current) {\n        containerRef.current.removeEventListener('mousemove', handleMouseMove);\n      }\n      try {\n        containerRef.current?.removeChild(canvas);\n      } catch {}\n    };\n  }, [color, speed, direction, scale, opacity, mouseInteractive]);\n\n  return <div ref={containerRef} className=\"w-full h-full relative overflow-hidden\" />;\n};\n\nexport default Plasma;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "prism",
      "type": "component",
      "description": "A prismatic light refraction background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/prism.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { Renderer, Triangle, Program, Mesh } from 'ogl';\n\ntype PrismProps = {\n  height?: number;\n  baseWidth?: number;\n  animationType?: 'rotate' | 'hover' | '3drotate';\n  glow?: number;\n  offset?: { x?: number; y?: number };\n  noise?: number;\n  transparent?: boolean;\n  scale?: number;\n  hueShift?: number;\n  colorFrequency?: number;\n  hoverStrength?: number;\n  inertia?: number;\n  bloom?: number;\n  suspendWhenOffscreen?: boolean;\n  timeScale?: number;\n};\n\nconst Prism: React.FC<PrismProps> = ({\n  height = 3.5,\n  baseWidth = 5.5,\n  animationType = 'rotate',\n  glow = 1,\n  offset = { x: 0, y: 0 },\n  noise = 0.5,\n  transparent = true,\n  scale = 3.6,\n  hueShift = 0,\n  colorFrequency = 1,\n  hoverStrength = 2,\n  inertia = 0.05,\n  bloom = 1,\n  suspendWhenOffscreen = false,\n  timeScale = 0.5\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const H = Math.max(0.001, height);\n    const BW = Math.max(0.001, baseWidth);\n    const BASE_HALF = BW * 0.5;\n    const GLOW = Math.max(0.0, glow);\n    const NOISE = Math.max(0.0, noise);\n    const offX = offset?.x ?? 0;\n    const offY = offset?.y ?? 0;\n    const SAT = transparent ? 1.5 : 1;\n    const SCALE = Math.max(0.001, scale);\n    const HUE = hueShift || 0;\n    const CFREQ = Math.max(0.0, colorFrequency || 1);\n    const BLOOM = Math.max(0.0, bloom || 1);\n    const RSX = 1;\n    const RSY = 1;\n    const RSZ = 1;\n    const TS = Math.max(0, timeScale || 1);\n    const HOVSTR = Math.max(0, hoverStrength || 1);\n    const INERT = Math.max(0, Math.min(1, inertia || 0.12));\n\n    const dpr = Math.min(2, window.devicePixelRatio || 1);\n    const renderer = new Renderer({\n      dpr,\n      alpha: transparent,\n      antialias: false\n    });\n    const gl = renderer.gl;\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.disable(gl.BLEND);\n\n    Object.assign(gl.canvas.style, {\n      position: 'absolute',\n      inset: '0',\n      width: '100%',\n      height: '100%',\n      display: 'block'\n    } as Partial<CSSStyleDeclaration>);\n    container.appendChild(gl.canvas);\n\n    const vertex = /* glsl */ `\n      attribute vec2 position;\n      void main() {\n        gl_Position = vec4(position, 0.0, 1.0);\n      }\n    `;\n\n    const fragment = /* glsl */ `\n      precision highp float;\n\n      uniform vec2  iResolution;\n      uniform float iTime;\n\n      uniform float uHeight;\n      uniform float uBaseHalf;\n      uniform mat3  uRot;\n      uniform int   uUseBaseWobble;\n      uniform float uGlow;\n      uniform vec2  uOffsetPx;\n      uniform float uNoise;\n      uniform float uSaturation;\n      uniform float uScale;\n      uniform float uHueShift;\n      uniform float uColorFreq;\n      uniform float uBloom;\n      uniform float uCenterShift;\n      uniform float uInvBaseHalf;\n      uniform float uInvHeight;\n      uniform float uMinAxis;\n      uniform float uPxScale;\n      uniform float uTimeScale;\n\n      vec4 tanh4(vec4 x){\n        vec4 e2x = exp(2.0*x);\n        return (e2x - 1.0) / (e2x + 1.0);\n      }\n\n      float rand(vec2 co){\n        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);\n      }\n\n      float sdOctaAnisoInv(vec3 p){\n        vec3 q = vec3(abs(p.x) * uInvBaseHalf, abs(p.y) * uInvHeight, abs(p.z) * uInvBaseHalf);\n        float m = q.x + q.y + q.z - 1.0;\n        return m * uMinAxis * 0.5773502691896258;\n      }\n\n      float sdPyramidUpInv(vec3 p){\n        float oct = sdOctaAnisoInv(p);\n        float halfSpace = -p.y;\n        return max(oct, halfSpace);\n      }\n\n      mat3 hueRotation(float a){\n        float c = cos(a), s = sin(a);\n        mat3 W = mat3(\n          0.299, 0.587, 0.114,\n          0.299, 0.587, 0.114,\n          0.299, 0.587, 0.114\n        );\n        mat3 U = mat3(\n           0.701, -0.587, -0.114,\n          -0.299,  0.413, -0.114,\n          -0.300, -0.588,  0.886\n        );\n        mat3 V = mat3(\n           0.168, -0.331,  0.500,\n           0.328,  0.035, -0.500,\n          -0.497,  0.296,  0.201\n        );\n        return W + U * c + V * s;\n      }\n\n      void main(){\n        vec2 f = (gl_FragCoord.xy - 0.5 * iResolution.xy - uOffsetPx) * uPxScale;\n\n        float z = 5.0;\n        float d = 0.0;\n\n        vec3 p;\n        vec4 o = vec4(0.0);\n\n        float centerShift = uCenterShift;\n        float cf = uColorFreq;\n\n        mat2 wob = mat2(1.0);\n        if (uUseBaseWobble == 1) {\n          float t = iTime * uTimeScale;\n          float c0 = cos(t + 0.0);\n          float c1 = cos(t + 33.0);\n          float c2 = cos(t + 11.0);\n          wob = mat2(c0, c1, c2, c0);\n        }\n\n        const int STEPS = 100;\n        for (int i = 0; i < STEPS; i++) {\n          p = vec3(f, z);\n          p.xz = p.xz * wob;\n          p = uRot * p;\n          vec3 q = p;\n          q.y += centerShift;\n          d = 0.1 + 0.2 * abs(sdPyramidUpInv(q));\n          z -= d;\n          o += (sin((p.y + z) * cf + vec4(0.0, 1.0, 2.0, 3.0)) + 1.0) / d;\n        }\n\n        o = tanh4(o * o * (uGlow * uBloom) / 1e5);\n\n        vec3 col = o.rgb;\n        float n = rand(gl_FragCoord.xy + vec2(iTime));\n        col += (n - 0.5) * uNoise;\n        col = clamp(col, 0.0, 1.0);\n\n        float L = dot(col, vec3(0.2126, 0.7152, 0.0722));\n        col = clamp(mix(vec3(L), col, uSaturation), 0.0, 1.0);\n\n        if(abs(uHueShift) > 0.0001){\n          col = clamp(hueRotation(uHueShift) * col, 0.0, 1.0);\n        }\n\n        gl_FragColor = vec4(col, o.a);\n      }\n    `;\n\n    const geometry = new Triangle(gl);\n    const iResBuf = new Float32Array(2);\n    const offsetPxBuf = new Float32Array(2);\n\n    const program = new Program(gl, {\n      vertex,\n      fragment,\n      uniforms: {\n        iResolution: { value: iResBuf },\n        iTime: { value: 0 },\n        uHeight: { value: H },\n        uBaseHalf: { value: BASE_HALF },\n        uUseBaseWobble: { value: 1 },\n        uRot: { value: new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]) },\n        uGlow: { value: GLOW },\n        uOffsetPx: { value: offsetPxBuf },\n        uNoise: { value: NOISE },\n        uSaturation: { value: SAT },\n        uScale: { value: SCALE },\n        uHueShift: { value: HUE },\n        uColorFreq: { value: CFREQ },\n        uBloom: { value: BLOOM },\n        uCenterShift: { value: H * 0.25 },\n        uInvBaseHalf: { value: 1 / BASE_HALF },\n        uInvHeight: { value: 1 / H },\n        uMinAxis: { value: Math.min(BASE_HALF, H) },\n        uPxScale: {\n          value: 1 / ((gl.drawingBufferHeight || 1) * 0.1 * SCALE)\n        },\n        uTimeScale: { value: TS }\n      }\n    });\n    const mesh = new Mesh(gl, { geometry, program });\n\n    const resize = () => {\n      const w = container.clientWidth || 1;\n      const h = container.clientHeight || 1;\n      renderer.setSize(w, h);\n      iResBuf[0] = gl.drawingBufferWidth;\n      iResBuf[1] = gl.drawingBufferHeight;\n      offsetPxBuf[0] = offX * dpr;\n      offsetPxBuf[1] = offY * dpr;\n      program.uniforms.uPxScale.value = 1 / ((gl.drawingBufferHeight || 1) * 0.1 * SCALE);\n    };\n    const ro = new ResizeObserver(resize);\n    ro.observe(container);\n    resize();\n\n    const rotBuf = new Float32Array(9);\n    const setMat3FromEuler = (yawY: number, pitchX: number, rollZ: number, out: Float32Array) => {\n      const cy = Math.cos(yawY),\n        sy = Math.sin(yawY);\n      const cx = Math.cos(pitchX),\n        sx = Math.sin(pitchX);\n      const cz = Math.cos(rollZ),\n        sz = Math.sin(rollZ);\n      const r00 = cy * cz + sy * sx * sz;\n      const r01 = -cy * sz + sy * sx * cz;\n      const r02 = sy * cx;\n\n      const r10 = cx * sz;\n      const r11 = cx * cz;\n      const r12 = -sx;\n\n      const r20 = -sy * cz + cy * sx * sz;\n      const r21 = sy * sz + cy * sx * cz;\n      const r22 = cy * cx;\n\n      out[0] = r00;\n      out[1] = r10;\n      out[2] = r20;\n      out[3] = r01;\n      out[4] = r11;\n      out[5] = r21;\n      out[6] = r02;\n      out[7] = r12;\n      out[8] = r22;\n      return out;\n    };\n\n    const NOISE_IS_ZERO = NOISE < 1e-6;\n    let raf = 0;\n    const t0 = performance.now();\n    const startRAF = () => {\n      if (raf) return;\n      raf = requestAnimationFrame(render);\n    };\n    const stopRAF = () => {\n      if (!raf) return;\n      cancelAnimationFrame(raf);\n      raf = 0;\n    };\n\n    const rnd = () => Math.random();\n    const wX = (0.3 + rnd() * 0.6) * RSX;\n    const wY = (0.2 + rnd() * 0.7) * RSY;\n    const wZ = (0.1 + rnd() * 0.5) * RSZ;\n    const phX = rnd() * Math.PI * 2;\n    const phZ = rnd() * Math.PI * 2;\n\n    let yaw = 0,\n      pitch = 0,\n      roll = 0;\n    let targetYaw = 0,\n      targetPitch = 0;\n    const lerp = (a: number, b: number, t: number) => a + (b - a) * t;\n\n    const pointer = { x: 0, y: 0, inside: true };\n    const onMove = (e: PointerEvent) => {\n      const ww = Math.max(1, window.innerWidth);\n      const wh = Math.max(1, window.innerHeight);\n      const cx = ww * 0.5;\n      const cy = wh * 0.5;\n      const nx = (e.clientX - cx) / (ww * 0.5);\n      const ny = (e.clientY - cy) / (wh * 0.5);\n      pointer.x = Math.max(-1, Math.min(1, nx));\n      pointer.y = Math.max(-1, Math.min(1, ny));\n      pointer.inside = true;\n    };\n    const onLeave = () => {\n      pointer.inside = false;\n    };\n    const onBlur = () => {\n      pointer.inside = false;\n    };\n\n    let onPointerMove: ((e: PointerEvent) => void) | null = null;\n    if (animationType === 'hover') {\n      onPointerMove = (e: PointerEvent) => {\n        onMove(e);\n        startRAF();\n      };\n      window.addEventListener('pointermove', onPointerMove, { passive: true });\n      window.addEventListener('mouseleave', onLeave);\n      window.addEventListener('blur', onBlur);\n      program.uniforms.uUseBaseWobble.value = 0;\n    } else if (animationType === '3drotate') {\n      program.uniforms.uUseBaseWobble.value = 0;\n    } else {\n      program.uniforms.uUseBaseWobble.value = 1;\n    }\n\n    const render = (t: number) => {\n      const time = (t - t0) * 0.001;\n      program.uniforms.iTime.value = time;\n\n      let continueRAF = true;\n\n      if (animationType === 'hover') {\n        const maxPitch = 0.6 * HOVSTR;\n        const maxYaw = 0.6 * HOVSTR;\n        targetYaw = (pointer.inside ? -pointer.x : 0) * maxYaw;\n        targetPitch = (pointer.inside ? pointer.y : 0) * maxPitch;\n        const prevYaw = yaw;\n        const prevPitch = pitch;\n        const prevRoll = roll;\n        yaw = lerp(prevYaw, targetYaw, INERT);\n        pitch = lerp(prevPitch, targetPitch, INERT);\n        roll = lerp(prevRoll, 0, 0.1);\n        program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n\n        if (NOISE_IS_ZERO) {\n          const settled =\n            Math.abs(yaw - targetYaw) < 1e-4 && Math.abs(pitch - targetPitch) < 1e-4 && Math.abs(roll) < 1e-4;\n          if (settled) continueRAF = false;\n        }\n      } else if (animationType === '3drotate') {\n        const tScaled = time * TS;\n        yaw = tScaled * wY;\n        pitch = Math.sin(tScaled * wX + phX) * 0.6;\n        roll = Math.sin(tScaled * wZ + phZ) * 0.5;\n        program.uniforms.uRot.value = setMat3FromEuler(yaw, pitch, roll, rotBuf);\n        if (TS < 1e-6) continueRAF = false;\n      } else {\n        rotBuf[0] = 1;\n        rotBuf[1] = 0;\n        rotBuf[2] = 0;\n        rotBuf[3] = 0;\n        rotBuf[4] = 1;\n        rotBuf[5] = 0;\n        rotBuf[6] = 0;\n        rotBuf[7] = 0;\n        rotBuf[8] = 1;\n        program.uniforms.uRot.value = rotBuf;\n        if (TS < 1e-6) continueRAF = false;\n      }\n\n      renderer.render({ scene: mesh });\n      if (continueRAF) {\n        raf = requestAnimationFrame(render);\n      } else {\n        raf = 0;\n      }\n    };\n\n    interface PrismContainer extends HTMLElement {\n      __prismIO?: IntersectionObserver;\n    }\n\n    if (suspendWhenOffscreen) {\n      const io = new IntersectionObserver(entries => {\n        const vis = entries.some(e => e.isIntersecting);\n        if (vis) startRAF();\n        else stopRAF();\n      });\n      io.observe(container);\n      startRAF();\n      (container as PrismContainer).__prismIO = io;\n    } else {\n      startRAF();\n    }\n\n    return () => {\n      stopRAF();\n      ro.disconnect();\n      if (animationType === 'hover') {\n        if (onPointerMove) window.removeEventListener('pointermove', onPointerMove as EventListener);\n        window.removeEventListener('mouseleave', onLeave);\n        window.removeEventListener('blur', onBlur);\n      }\n      if (suspendWhenOffscreen) {\n        const io = (container as PrismContainer).__prismIO as IntersectionObserver | undefined;\n        if (io) io.disconnect();\n        delete (container as PrismContainer).__prismIO;\n      }\n      if (gl.canvas.parentElement === container) container.removeChild(gl.canvas);\n    };\n  }, [\n    height,\n    baseWidth,\n    animationType,\n    glow,\n    noise,\n    offset?.x,\n    offset?.y,\n    scale,\n    transparent,\n    hueShift,\n    colorFrequency,\n    timeScale,\n    hoverStrength,\n    inertia,\n    bloom,\n    suspendWhenOffscreen\n  ]);\n\n  return <div className=\"w-full h-full relative\" ref={containerRef} />;\n};\n\nexport default Prism;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "prismatic-burst",
      "type": "component",
      "description": "A prismatic burst of colorful light rays background.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/prismatic-burst.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { Renderer, Program, Mesh, Triangle, Texture } from 'ogl';\n\ntype Offset = { x?: number | string; y?: number | string };\ntype AnimationType = 'rotate' | 'rotate3d' | 'hover';\n\nexport type PrismaticBurstProps = {\n  intensity?: number;\n  speed?: number;\n  animationType?: AnimationType;\n  colors?: string[];\n  distort?: number;\n  paused?: boolean;\n  offset?: Offset;\n  hoverDampness?: number;\n  rayCount?: number;\n  mixBlendMode?: React.CSSProperties['mixBlendMode'] | 'none';\n};\n\nconst vertexShader = `#version 300 es\nin vec2 position;\nin vec2 uv;\nout vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst fragmentShader = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nout vec4 fragColor;\n\nuniform vec2  uResolution;\nuniform float uTime;\n\nuniform float uIntensity;\nuniform float uSpeed;\nuniform int   uAnimType;\nuniform vec2  uMouse;\nuniform int   uColorCount;\nuniform float uDistort;\nuniform vec2  uOffset;\nuniform sampler2D uGradient;\nuniform float uNoiseAmount;\nuniform int   uRayCount;\n\nfloat hash21(vec2 p){\n    p = floor(p);\n    float f = 52.9829189 * fract(dot(p, vec2(0.065, 0.005)));\n    return fract(f);\n}\n\nmat2 rot30(){ return mat2(0.8, -0.5, 0.5, 0.8); }\n\nfloat layeredNoise(vec2 fragPx){\n    vec2 p = mod(fragPx + vec2(uTime * 30.0, -uTime * 21.0), 1024.0);\n    vec2 q = rot30() * p;\n    float n = 0.0;\n    n += 0.40 * hash21(q);\n    n += 0.25 * hash21(q * 2.0 + 17.0);\n    n += 0.20 * hash21(q * 4.0 + 47.0);\n    n += 0.10 * hash21(q * 8.0 + 113.0);\n    n += 0.05 * hash21(q * 16.0 + 191.0);\n    return n;\n}\n\nvec3 rayDir(vec2 frag, vec2 res, vec2 offset, float dist){\n    float focal = res.y * max(dist, 1e-3);\n    return normalize(vec3(2.0 * (frag - offset) - res, focal));\n}\n\nfloat edgeFade(vec2 frag, vec2 res, vec2 offset){\n    vec2 toC = frag - 0.5 * res - offset;\n    float r = length(toC) / (0.5 * min(res.x, res.y));\n    float x = clamp(r, 0.0, 1.0);\n    float q = x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n    float s = q * 0.5;\n    s = pow(s, 1.5);\n    float tail = 1.0 - pow(1.0 - s, 2.0);\n    s = mix(s, tail, 0.2);\n    float dn = (layeredNoise(frag * 0.15) - 0.5) * 0.0015 * s;\n    return clamp(s + dn, 0.0, 1.0);\n}\n\nmat3 rotX(float a){ float c = cos(a), s = sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }\nmat3 rotY(float a){ float c = cos(a), s = sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }\nmat3 rotZ(float a){ float c = cos(a), s = sin(a); return mat3(c,-s,0.0, s,c,0.0, 0.0,0.0,1.0); }\n\nvec3 sampleGradient(float t){\n    t = clamp(t, 0.0, 1.0);\n    return texture(uGradient, vec2(t, 0.5)).rgb;\n}\n\nvec2 rot2(vec2 v, float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c) * v;\n}\n\nfloat bendAngle(vec3 q, float t){\n    float a = 0.8 * sin(q.x * 0.55 + t * 0.6)\n            + 0.7 * sin(q.y * 0.50 - t * 0.5)\n            + 0.6 * sin(q.z * 0.60 + t * 0.7);\n    return a;\n}\n\nvoid main(){\n    vec2 frag = gl_FragCoord.xy;\n    float t = uTime * uSpeed;\n    float jitterAmp = 0.1 * clamp(uNoiseAmount, 0.0, 1.0);\n    vec3 dir = rayDir(frag, uResolution, uOffset, 1.0);\n    float marchT = 0.0;\n    vec3 col = vec3(0.0);\n    float n = layeredNoise(frag);\n    vec4 c = cos(t * 0.2 + vec4(0.0, 33.0, 11.0, 0.0));\n    mat2 M2 = mat2(c.x, c.y, c.z, c.w);\n    float amp = clamp(uDistort, 0.0, 50.0) * 0.15;\n\n    mat3 rot3dMat = mat3(1.0);\n    if(uAnimType == 1){\n      vec3 ang = vec3(t * 0.31, t * 0.21, t * 0.17);\n      rot3dMat = rotZ(ang.z) * rotY(ang.y) * rotX(ang.x);\n    }\n    mat3 hoverMat = mat3(1.0);\n    if(uAnimType == 2){\n      vec2 m = uMouse * 2.0 - 1.0;\n      vec3 ang = vec3(m.y * 0.6, m.x * 0.6, 0.0);\n      hoverMat = rotY(ang.y) * rotX(ang.x);\n    }\n\n    for (int i = 0; i < 44; ++i) {\n        vec3 P = marchT * dir;\n        P.z -= 2.0;\n        float rad = length(P);\n        vec3 Pl = P * (10.0 / max(rad, 1e-6));\n\n        if(uAnimType == 0){\n            Pl.xz *= M2;\n        } else if(uAnimType == 1){\n      Pl = rot3dMat * Pl;\n        } else {\n      Pl = hoverMat * Pl;\n        }\n\n        float stepLen = min(rad - 0.3, n * jitterAmp) + 0.1;\n\n        float grow = smoothstep(0.35, 3.0, marchT);\n        float a1 = amp * grow * bendAngle(Pl * 0.6, t);\n        float a2 = 0.5 * amp * grow * bendAngle(Pl.zyx * 0.5 + 3.1, t * 0.9);\n        vec3 Pb = Pl;\n        Pb.xz = rot2(Pb.xz, a1);\n        Pb.xy = rot2(Pb.xy, a2);\n\n        float rayPattern = smoothstep(\n            0.5, 0.7,\n            sin(Pb.x + cos(Pb.y) * cos(Pb.z)) *\n            sin(Pb.z + sin(Pb.y) * cos(Pb.x + t))\n        );\n\n        if (uRayCount > 0) {\n            float ang = atan(Pb.y, Pb.x);\n            float comb = 0.5 + 0.5 * cos(float(uRayCount) * ang);\n            comb = pow(comb, 3.0);\n            rayPattern *= smoothstep(0.15, 0.95, comb);\n        }\n\n        vec3 spectralDefault = 1.0 + vec3(\n            cos(marchT * 3.0 + 0.0),\n            cos(marchT * 3.0 + 1.0),\n            cos(marchT * 3.0 + 2.0)\n        );\n\n        float saw = fract(marchT * 0.25);\n        float tRay = saw * saw * (3.0 - 2.0 * saw);\n        vec3 userGradient = 2.0 * sampleGradient(tRay);\n        vec3 spectral = (uColorCount > 0) ? userGradient : spectralDefault;\n        vec3 base = (0.05 / (0.4 + stepLen))\n                  * smoothstep(5.0, 0.0, rad)\n                  * spectral;\n\n        col += base * rayPattern;\n        marchT += stepLen;\n    }\n\n    col *= edgeFade(frag, uResolution, uOffset);\n    col *= uIntensity;\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n}`;\n\nconst hexToRgb01 = (hex: string): [number, number, number] => {\n  let h = hex.trim();\n  if (h.startsWith('#')) h = h.slice(1);\n  if (h.length === 3) {\n    const r = h[0],\n      g = h[1],\n      b = h[2];\n    h = r + r + g + g + b + b;\n  }\n  const intVal = parseInt(h, 16);\n  if (isNaN(intVal) || (h.length !== 6 && h.length !== 8)) return [1, 1, 1];\n  const r = ((intVal >> 16) & 255) / 255;\n  const g = ((intVal >> 8) & 255) / 255;\n  const b = (intVal & 255) / 255;\n  return [r, g, b];\n};\n\nconst toPx = (v: number | string | undefined): number => {\n  if (v == null) return 0;\n  if (typeof v === 'number') return v;\n  const s = String(v).trim();\n  const num = parseFloat(s.replace('px', ''));\n  return isNaN(num) ? 0 : num;\n};\n\nconst PrismaticBurst = ({\n  intensity = 2,\n  speed = 0.5,\n  animationType = 'rotate3d',\n  colors,\n  distort = 0,\n  paused = false,\n  offset = { x: 0, y: 0 },\n  hoverDampness = 0,\n  rayCount,\n  mixBlendMode = 'lighten'\n}: PrismaticBurstProps) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const programRef = useRef<Program | null>(null);\n  const rendererRef = useRef<Renderer | null>(null);\n  const mouseTargetRef = useRef<[number, number]>([0.5, 0.5]);\n  const mouseSmoothRef = useRef<[number, number]>([0.5, 0.5]);\n  const pausedRef = useRef<boolean>(paused);\n  const gradTexRef = useRef<Texture | null>(null);\n  const hoverDampRef = useRef<number>(hoverDampness);\n  const isVisibleRef = useRef<boolean>(true);\n  const meshRef = useRef<Mesh | null>(null);\n  const triRef = useRef<Triangle | null>(null);\n\n  useEffect(() => {\n    pausedRef.current = paused;\n  }, [paused]);\n  useEffect(() => {\n    hoverDampRef.current = hoverDampness;\n  }, [hoverDampness]);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\n    const renderer = new Renderer({ dpr, alpha: false, antialias: false });\n    rendererRef.current = renderer;\n\n    const gl = renderer.gl;\n    gl.canvas.style.position = 'absolute';\n    gl.canvas.style.inset = '0';\n    gl.canvas.style.width = '100%';\n    gl.canvas.style.height = '100%';\n    gl.canvas.style.mixBlendMode = mixBlendMode && mixBlendMode !== 'none' ? mixBlendMode : '';\n    container.appendChild(gl.canvas);\n\n    const white = new Uint8Array([255, 255, 255, 255]);\n    const gradientTex = new Texture(gl, {\n      image: white,\n      width: 1,\n      height: 1,\n      generateMipmaps: false,\n      flipY: false\n    });\n\n    gradientTex.minFilter = gl.LINEAR;\n    gradientTex.magFilter = gl.LINEAR;\n    gradientTex.wrapS = gl.CLAMP_TO_EDGE;\n    gradientTex.wrapT = gl.CLAMP_TO_EDGE;\n    gradTexRef.current = gradientTex;\n\n    const program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        uResolution: { value: [1, 1] as [number, number] },\n        uTime: { value: 0 },\n\n        uIntensity: { value: 1 },\n        uSpeed: { value: 1 },\n        uAnimType: { value: 0 },\n        uMouse: { value: [0.5, 0.5] as [number, number] },\n        uColorCount: { value: 0 },\n        uDistort: { value: 0 },\n        uOffset: { value: [0, 0] as [number, number] },\n        uGradient: { value: gradientTex },\n        uNoiseAmount: { value: 0.8 },\n        uRayCount: { value: 0 }\n      }\n    });\n\n    programRef.current = program;\n\n    const triangle = new Triangle(gl);\n    const mesh = new Mesh(gl, { geometry: triangle, program });\n    triRef.current = triangle;\n    meshRef.current = mesh;\n\n    const resize = () => {\n      const w = container.clientWidth || 1;\n      const h = container.clientHeight || 1;\n      renderer.setSize(w, h);\n      program.uniforms.uResolution.value = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n    };\n\n    let ro: ResizeObserver | null = null;\n    if ('ResizeObserver' in window) {\n      ro = new ResizeObserver(resize);\n      ro.observe(container);\n    } else {\n      (window as Window).addEventListener('resize', resize);\n    }\n    resize();\n\n    const onPointer = (e: PointerEvent) => {\n      const rect = container.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / Math.max(rect.width, 1);\n      const y = (e.clientY - rect.top) / Math.max(rect.height, 1);\n      mouseTargetRef.current = [Math.min(Math.max(x, 0), 1), Math.min(Math.max(y, 0), 1)];\n    };\n    container.addEventListener('pointermove', onPointer, { passive: true });\n\n    let io: IntersectionObserver | null = null;\n    if ('IntersectionObserver' in window) {\n      io = new IntersectionObserver(\n        entries => {\n          if (entries[0]) isVisibleRef.current = entries[0].isIntersecting;\n        },\n        { root: null, threshold: 0.01 }\n      );\n      io.observe(container);\n    }\n    const onVis = () => {};\n    document.addEventListener('visibilitychange', onVis);\n\n    let raf = 0;\n    let last = performance.now();\n    let accumTime = 0;\n\n    const update = (now: number) => {\n      const dt = Math.max(0, now - last) * 0.001;\n      last = now;\n      const visible = isVisibleRef.current && !document.hidden;\n      if (!pausedRef.current) accumTime += dt;\n      if (!visible) {\n        raf = requestAnimationFrame(update);\n        return;\n      }\n      const tau = 0.02 + Math.max(0, Math.min(1, hoverDampRef.current)) * 0.5;\n      const alpha = 1 - Math.exp(-dt / tau);\n      const tgt = mouseTargetRef.current;\n      const sm = mouseSmoothRef.current;\n      sm[0] += (tgt[0] - sm[0]) * alpha;\n      sm[1] += (tgt[1] - sm[1]) * alpha;\n      program.uniforms.uMouse.value = sm as any;\n      program.uniforms.uTime.value = accumTime;\n      renderer.render({ scene: meshRef.current! });\n      raf = requestAnimationFrame(update);\n    };\n    raf = requestAnimationFrame(update);\n\n    return () => {\n      cancelAnimationFrame(raf);\n      container.removeEventListener('pointermove', onPointer);\n      ro?.disconnect();\n      if (!ro) window.removeEventListener('resize', resize);\n      io?.disconnect();\n      document.removeEventListener('visibilitychange', onVis);\n      try {\n        container.removeChild(gl.canvas);\n      } catch (e) {\n        void e;\n      }\n      meshRef.current = null;\n      triRef.current = null;\n      programRef.current = null;\n      try {\n        const glCtx = rendererRef.current?.gl;\n        if (glCtx && gradTexRef.current?.texture) glCtx.deleteTexture(gradTexRef.current.texture);\n      } catch (e) {\n        void e;\n      }\n      rendererRef.current = null;\n      gradTexRef.current = null;\n    };\n  }, []);\n\n  useEffect(() => {\n    const canvas = rendererRef.current?.gl?.canvas as HTMLCanvasElement | undefined;\n    if (canvas) {\n      canvas.style.mixBlendMode = mixBlendMode && mixBlendMode !== 'none' ? mixBlendMode : '';\n    }\n  }, [mixBlendMode]);\n\n  useEffect(() => {\n    const program = programRef.current;\n    const renderer = rendererRef.current;\n    const gradTex = gradTexRef.current;\n    if (!program || !renderer || !gradTex) return;\n\n    program.uniforms.uIntensity.value = intensity ?? 1;\n    program.uniforms.uSpeed.value = speed ?? 1;\n\n    const animTypeMap: Record<AnimationType, number> = {\n      rotate: 0,\n      rotate3d: 1,\n      hover: 2\n    };\n    program.uniforms.uAnimType.value = animTypeMap[animationType ?? 'rotate'];\n\n    program.uniforms.uDistort.value = typeof distort === 'number' ? distort : 0;\n\n    const ox = toPx(offset?.x);\n    const oy = toPx(offset?.y);\n    program.uniforms.uOffset.value = [ox, oy];\n    program.uniforms.uRayCount.value = Math.max(0, Math.floor(rayCount ?? 0));\n\n    let count = 0;\n    if (Array.isArray(colors) && colors.length > 0) {\n      const gl = renderer.gl;\n      const capped = colors.slice(0, 64);\n      count = capped.length;\n      const data = new Uint8Array(count * 4);\n      for (let i = 0; i < count; i++) {\n        const [r, g, b] = hexToRgb01(capped[i]);\n        data[i * 4 + 0] = Math.round(r * 255);\n        data[i * 4 + 1] = Math.round(g * 255);\n        data[i * 4 + 2] = Math.round(b * 255);\n        data[i * 4 + 3] = 255;\n      }\n      gradTex.image = data;\n      gradTex.width = count;\n      gradTex.height = 1;\n      gradTex.minFilter = gl.LINEAR;\n      gradTex.magFilter = gl.LINEAR;\n      gradTex.wrapS = gl.CLAMP_TO_EDGE;\n      gradTex.wrapT = gl.CLAMP_TO_EDGE;\n      gradTex.flipY = false;\n      gradTex.generateMipmaps = false;\n      gradTex.format = gl.RGBA;\n      gradTex.type = gl.UNSIGNED_BYTE;\n      gradTex.needsUpdate = true;\n    } else {\n      count = 0;\n    }\n    program.uniforms.uColorCount.value = count;\n  }, [intensity, speed, animationType, colors, distort, offset, rayCount]);\n\n  return <div className=\"w-full h-full relative overflow-hidden\" ref={containerRef} />;\n};\n\nexport default PrismaticBurst;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "retro-grid",
      "type": "component",
      "description": "A backgrounds retro grid component",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/retro-grid.tsx",
          "content": "import { cn } from \"@/lib/utils\"\n\ninterface RetroGridProps extends React.HTMLAttributes<HTMLDivElement> {\n  /**\n   * Additional CSS classes to apply to the grid container\n   */\n  className?: string\n  /**\n   * Rotation angle of the grid in degrees\n   * @default 65\n   */\n  angle?: number\n  /**\n   * Grid cell size in pixels\n   * @default 60\n   */\n  cellSize?: number\n  /**\n   * Grid opacity value between 0 and 1\n   * @default 0.5\n   */\n  opacity?: number\n  /**\n   * Grid line color in light mode\n   * @default \"gray\"\n   */\n  lightLineColor?: string\n  /**\n   * Grid line color in dark mode\n   * @default \"gray\"\n   */\n  darkLineColor?: string\n}\n\nexport function RetroGrid({\n  className,\n  angle = 65,\n  cellSize = 60,\n  opacity = 0.5,\n  lightLineColor = \"gray\",\n  darkLineColor = \"gray\",\n  ...props\n}: RetroGridProps) {\n  const gridStyles = {\n    \"--grid-angle\": `${angle}deg`,\n    \"--cell-size\": `${cellSize}px`,\n    \"--opacity\": opacity,\n    \"--light-line\": lightLineColor,\n    \"--dark-line\": darkLineColor,\n  } as React.CSSProperties\n\n  return (\n    <div\n      className={cn(\n        \"pointer-events-none absolute size-full overflow-hidden [perspective:200px]\",\n        `opacity-[var(--opacity)]`,\n        className\n      )}\n      style={gridStyles}\n      {...props}\n    >\n      <div className=\"absolute inset-0 [transform:rotateX(var(--grid-angle))]\">\n        <div className=\"animate-grid [inset:0%_0px] [margin-left:-200%] [height:300vh] [width:600vw] [transform-origin:100%_0_0] [background-image:linear-gradient(to_right,var(--light-line)_1px,transparent_0),linear-gradient(to_bottom,var(--light-line)_1px,transparent_0)] [background-size:var(--cell-size)_var(--cell-size)] [background-repeat:repeat] dark:[background-image:linear-gradient(to_right,var(--dark-line)_1px,transparent_0),linear-gradient(to_bottom,var(--dark-line)_1px,transparent_0)]\" />\n      </div>\n\n      <div className=\"absolute inset-0 bg-gradient-to-t from-white to-transparent to-90% dark:from-black\" />\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "backgrounds"
        ]
      }
    },
    {
      "name": "ripple",
      "type": "component",
      "description": "A backgrounds ripple component",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/ripple.tsx",
          "content": "import React, { ComponentPropsWithoutRef, CSSProperties } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface RippleProps extends ComponentPropsWithoutRef<\"div\"> {\n  mainCircleSize?: number\n  mainCircleOpacity?: number\n  numCircles?: number\n}\n\nexport const Ripple = React.memo(function Ripple({\n  mainCircleSize = 210,\n  mainCircleOpacity = 0.24,\n  numCircles = 8,\n  className,\n  ...props\n}: RippleProps) {\n  return (\n    <div\n      className={cn(\n        \"pointer-events-none absolute inset-0 [mask-image:linear-gradient(to_bottom,white,transparent)] select-none\",\n        className\n      )}\n      {...props}\n    >\n      {Array.from({ length: numCircles }, (_, i) => {\n        const size = mainCircleSize + i * 70\n        const opacity = mainCircleOpacity - i * 0.03\n        const animationDelay = `${i * 0.06}s`\n        const borderStyle = \"solid\"\n\n        return (\n          <div\n            key={i}\n            className={`animate-ripple bg-foreground/25 absolute rounded-full border shadow-xl`}\n            style={\n              {\n                \"--i\": i,\n                width: `${size}px`,\n                height: `${size}px`,\n                opacity,\n                animationDelay,\n                borderStyle,\n                borderWidth: \"1px\",\n                borderColor: `var(--foreground)`,\n                top: \"50%\",\n                left: \"50%\",\n                transform: \"translate(-50%, -50%) scale(1)\",\n              } as CSSProperties\n            }\n          />\n        )\n      })}\n    </div>\n  )\n})\n\nRipple.displayName = \"Ripple\"\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "backgrounds"
        ]
      }
    },
    {
      "name": "ripple-grid",
      "type": "component",
      "description": "An animated ripple grid background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/ripple-grid.tsx",
          "content": "import { useRef, useEffect } from 'react';\nimport { Renderer, Program, Triangle, Mesh } from 'ogl';\n\ntype Props = {\n  enableRainbow?: boolean;\n  gridColor?: string;\n  rippleIntensity?: number;\n  gridSize?: number;\n  gridThickness?: number;\n  fadeDistance?: number;\n  vignetteStrength?: number;\n  glowIntensity?: number;\n  opacity?: number;\n  gridRotation?: number;\n  mouseInteraction?: boolean;\n  mouseInteractionRadius?: number;\n};\n\nconst RippleGrid: React.FC<Props> = ({\n  enableRainbow = false,\n  gridColor = '#ffffff',\n  rippleIntensity = 0.05,\n  gridSize = 10.0,\n  gridThickness = 15.0,\n  fadeDistance = 1.5,\n  vignetteStrength = 2.0,\n  glowIntensity = 0.1,\n  opacity = 1.0,\n  gridRotation = 0,\n  mouseInteraction = true,\n  mouseInteractionRadius = 1\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const mousePositionRef = useRef({ x: 0.5, y: 0.5 });\n  const targetMouseRef = useRef({ x: 0.5, y: 0.5 });\n  const mouseInfluenceRef = useRef(0);\n  const uniformsRef = useRef<any>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const hexToRgb = (hex: string): [number, number, number] => {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result\n        ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255]\n        : [1, 1, 1];\n    };\n\n    const renderer = new Renderer({\n      dpr: Math.min(window.devicePixelRatio, 2),\n      alpha: true\n    });\n    const gl = renderer.gl;\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    gl.canvas.style.width = '100%';\n    gl.canvas.style.height = '100%';\n    containerRef.current.appendChild(gl.canvas);\n\n    const vert = `\nattribute vec2 position;\nvarying vec2 vUv;\nvoid main() {\n    vUv = position * 0.5 + 0.5;\n    gl_Position = vec4(position, 0.0, 1.0);\n}`;\n\n    const frag = `precision highp float;\nuniform float iTime;\nuniform vec2 iResolution;\nuniform bool enableRainbow;\nuniform vec3 gridColor;\nuniform float rippleIntensity;\nuniform float gridSize;\nuniform float gridThickness;\nuniform float fadeDistance;\nuniform float vignetteStrength;\nuniform float glowIntensity;\nuniform float opacity;\nuniform float gridRotation;\nuniform bool mouseInteraction;\nuniform vec2 mousePosition;\nuniform float mouseInfluence;\nuniform float mouseInteractionRadius;\nvarying vec2 vUv;\n\nfloat pi = 3.141592;\n\nmat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid main() {\n    vec2 uv = vUv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    if (gridRotation != 0.0) {\n        uv = rotate(gridRotation * pi / 180.0) * uv;\n    }\n\n    float dist = length(uv);\n    float func = sin(pi * (iTime - dist));\n    vec2 rippleUv = uv + uv * func * rippleIntensity;\n\n    if (mouseInteraction && mouseInfluence > 0.0) {\n        vec2 mouseUv = (mousePosition * 2.0 - 1.0);\n        mouseUv.x *= iResolution.x / iResolution.y;\n        float mouseDist = length(uv - mouseUv);\n        \n        float influence = mouseInfluence * exp(-mouseDist * mouseDist / (mouseInteractionRadius * mouseInteractionRadius));\n        \n        float mouseWave = sin(pi * (iTime * 2.0 - mouseDist * 3.0)) * influence;\n        rippleUv += normalize(uv - mouseUv) * mouseWave * rippleIntensity * 0.3;\n    }\n\n    vec2 a = sin(gridSize * 0.5 * pi * rippleUv - pi / 2.0);\n    vec2 b = abs(a);\n\n    float aaWidth = 0.5;\n    vec2 smoothB = vec2(\n        smoothstep(0.0, aaWidth, b.x),\n        smoothstep(0.0, aaWidth, b.y)\n    );\n\n    vec3 color = vec3(0.0);\n    color += exp(-gridThickness * smoothB.x * (0.8 + 0.5 * sin(pi * iTime)));\n    color += exp(-gridThickness * smoothB.y);\n    color += 0.5 * exp(-(gridThickness / 4.0) * sin(smoothB.x));\n    color += 0.5 * exp(-(gridThickness / 3.0) * smoothB.y);\n\n    if (glowIntensity > 0.0) {\n        color += glowIntensity * exp(-gridThickness * 0.5 * smoothB.x);\n        color += glowIntensity * exp(-gridThickness * 0.5 * smoothB.y);\n    }\n\n    float ddd = exp(-2.0 * clamp(pow(dist, fadeDistance), 0.0, 1.0));\n    \n    vec2 vignetteCoords = vUv - 0.5;\n    float vignetteDistance = length(vignetteCoords);\n    float vignette = 1.0 - pow(vignetteDistance * 2.0, vignetteStrength);\n    vignette = clamp(vignette, 0.0, 1.0);\n    \n    vec3 t;\n    if (enableRainbow) {\n        t = vec3(\n            uv.x * 0.5 + 0.5 * sin(iTime),\n            uv.y * 0.5 + 0.5 * cos(iTime),\n            pow(cos(iTime), 4.0)\n        ) + 0.5;\n    } else {\n        t = gridColor;\n    }\n\n    float finalFade = ddd * vignette;\n    float alpha = length(color) * finalFade * opacity;\n    gl_FragColor = vec4(color * t * finalFade * opacity, alpha);\n}`;\n\n    const uniforms = {\n      iTime: { value: 0 },\n      iResolution: { value: [1, 1] },\n      enableRainbow: { value: enableRainbow },\n      gridColor: { value: hexToRgb(gridColor) },\n      rippleIntensity: { value: rippleIntensity },\n      gridSize: { value: gridSize },\n      gridThickness: { value: gridThickness },\n      fadeDistance: { value: fadeDistance },\n      vignetteStrength: { value: vignetteStrength },\n      glowIntensity: { value: glowIntensity },\n      opacity: { value: opacity },\n      gridRotation: { value: gridRotation },\n      mouseInteraction: { value: mouseInteraction },\n      mousePosition: { value: [0.5, 0.5] },\n      mouseInfluence: { value: 0 },\n      mouseInteractionRadius: { value: mouseInteractionRadius }\n    };\n\n    uniformsRef.current = uniforms;\n\n    const geometry = new Triangle(gl);\n    const program = new Program(gl, { vertex: vert, fragment: frag, uniforms });\n    const mesh = new Mesh(gl, { geometry, program });\n\n    const resize = () => {\n      const { clientWidth: w, clientHeight: h } = containerRef.current!;\n      renderer.setSize(w, h);\n      uniforms.iResolution.value = [w, h];\n    };\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!mouseInteraction || !containerRef.current) return;\n      const rect = containerRef.current.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n      targetMouseRef.current = { x, y };\n    };\n\n    const handleMouseEnter = () => {\n      if (!mouseInteraction) return;\n      mouseInfluenceRef.current = 1.0;\n    };\n\n    const handleMouseLeave = () => {\n      if (!mouseInteraction) return;\n      mouseInfluenceRef.current = 0.0;\n    };\n\n    window.addEventListener('resize', resize);\n    if (mouseInteraction) {\n      containerRef.current.addEventListener('mousemove', handleMouseMove);\n      containerRef.current.addEventListener('mouseenter', handleMouseEnter);\n      containerRef.current.addEventListener('mouseleave', handleMouseLeave);\n    }\n    resize();\n\n    const render = (t: number) => {\n      uniforms.iTime.value = t * 0.001;\n\n      const lerpFactor = 0.1;\n      mousePositionRef.current.x += (targetMouseRef.current.x - mousePositionRef.current.x) * lerpFactor;\n      mousePositionRef.current.y += (targetMouseRef.current.y - mousePositionRef.current.y) * lerpFactor;\n\n      const currentInfluence = uniforms.mouseInfluence.value;\n      const targetInfluence = mouseInfluenceRef.current;\n      uniforms.mouseInfluence.value += (targetInfluence - currentInfluence) * 0.05;\n\n      uniforms.mousePosition.value = [mousePositionRef.current.x, mousePositionRef.current.y];\n\n      renderer.render({ scene: mesh });\n      requestAnimationFrame(render);\n    };\n\n    requestAnimationFrame(render);\n\n    return () => {\n      window.removeEventListener('resize', resize);\n      if (mouseInteraction && containerRef.current) {\n        containerRef.current.removeEventListener('mousemove', handleMouseMove);\n        containerRef.current.removeEventListener('mouseenter', handleMouseEnter);\n        containerRef.current.removeEventListener('mouseleave', handleMouseLeave);\n      }\n      renderer.gl.getExtension('WEBGL_lose_context')?.loseContext();\n      containerRef.current?.removeChild(gl.canvas);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!uniformsRef.current) return;\n\n    const hexToRgb = (hex: string): [number, number, number] => {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result\n        ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255]\n        : [1, 1, 1];\n    };\n\n    uniformsRef.current.enableRainbow.value = enableRainbow;\n    uniformsRef.current.gridColor.value = hexToRgb(gridColor);\n    uniformsRef.current.rippleIntensity.value = rippleIntensity;\n    uniformsRef.current.gridSize.value = gridSize;\n    uniformsRef.current.gridThickness.value = gridThickness;\n    uniformsRef.current.fadeDistance.value = fadeDistance;\n    uniformsRef.current.vignetteStrength.value = vignetteStrength;\n    uniformsRef.current.glowIntensity.value = glowIntensity;\n    uniformsRef.current.opacity.value = opacity;\n    uniformsRef.current.gridRotation.value = gridRotation;\n    uniformsRef.current.mouseInteraction.value = mouseInteraction;\n    uniformsRef.current.mouseInteractionRadius.value = mouseInteractionRadius;\n  }, [\n    enableRainbow,\n    gridColor,\n    rippleIntensity,\n    gridSize,\n    gridThickness,\n    fadeDistance,\n    vignetteStrength,\n    glowIntensity,\n    opacity,\n    gridRotation,\n    mouseInteraction,\n    mouseInteractionRadius\n  ]);\n\n  return <div ref={containerRef} className=\"w-full h-full relative overflow-hidden [&_canvas]:block\" />;\n};\n\nexport default RippleGrid;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "silk",
      "type": "component",
      "description": "A flowing silk fabric background effect.",
      "category": "backgrounds",
      "dependencies": [
        "three",
        "@react-three/fiber"
      ],
      "files": [
        {
          "path": "components/ui/silk.tsx",
          "content": "/* eslint-disable react/no-unknown-property */\nimport React, { forwardRef, useMemo, useRef, useLayoutEffect } from 'react';\nimport { Canvas, useFrame, useThree, RootState } from '@react-three/fiber';\nimport { Color, Mesh, ShaderMaterial } from 'three';\nimport { IUniform } from 'three';\n\ntype NormalizedRGB = [number, number, number];\n\nconst hexToNormalizedRGB = (hex: string): NormalizedRGB => {\n  const clean = hex.replace('#', '');\n  const r = parseInt(clean.slice(0, 2), 16) / 255;\n  const g = parseInt(clean.slice(2, 4), 16) / 255;\n  const b = parseInt(clean.slice(4, 6), 16) / 255;\n  return [r, g, b];\n};\n\ninterface UniformValue<T = number | Color> {\n  value: T;\n}\n\ninterface SilkUniforms {\n  uSpeed: UniformValue<number>;\n  uScale: UniformValue<number>;\n  uNoiseIntensity: UniformValue<number>;\n  uColor: UniformValue<Color>;\n  uRotation: UniformValue<number>;\n  uTime: UniformValue<number>;\n  [uniform: string]: IUniform;\n}\n\nconst vertexShader = `\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvoid main() {\n  vPosition = position;\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nuniform float uTime;\nuniform vec3  uColor;\nuniform float uSpeed;\nuniform float uScale;\nuniform float uRotation;\nuniform float uNoiseIntensity;\n\nconst float e = 2.71828182845904523536;\n\nfloat noise(vec2 texCoord) {\n  float G = e;\n  vec2  r = (G * sin(G * texCoord));\n  return fract(r.x * r.y * (1.0 + texCoord.x));\n}\n\nvec2 rotateUvs(vec2 uv, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2  rot = mat2(c, -s, s, c);\n  return rot * uv;\n}\n\nvoid main() {\n  float rnd        = noise(gl_FragCoord.xy);\n  vec2  uv         = rotateUvs(vUv * uScale, uRotation);\n  vec2  tex        = uv * uScale;\n  float tOffset    = uSpeed * uTime;\n\n  tex.y += 0.03 * sin(8.0 * tex.x - tOffset);\n\n  float pattern = 0.6 +\n                  0.4 * sin(5.0 * (tex.x + tex.y +\n                                   cos(3.0 * tex.x + 5.0 * tex.y) +\n                                   0.02 * tOffset) +\n                           sin(20.0 * (tex.x + tex.y - 0.1 * tOffset)));\n\n  vec4 col = vec4(uColor, 1.0) * vec4(pattern) - rnd / 15.0 * uNoiseIntensity;\n  col.a = 1.0;\n  gl_FragColor = col;\n}\n`;\n\ninterface SilkPlaneProps {\n  uniforms: SilkUniforms;\n}\n\nconst SilkPlane = forwardRef<Mesh, SilkPlaneProps>(function SilkPlane({ uniforms }, ref) {\n  const { viewport } = useThree();\n\n  useLayoutEffect(() => {\n    const mesh = ref as React.MutableRefObject<Mesh | null>;\n    if (mesh.current) {\n      mesh.current.scale.set(viewport.width, viewport.height, 1);\n    }\n  }, [ref, viewport]);\n\n  useFrame((_state: RootState, delta: number) => {\n    const mesh = ref as React.MutableRefObject<Mesh | null>;\n    if (mesh.current) {\n      const material = mesh.current.material as ShaderMaterial & {\n        uniforms: SilkUniforms;\n      };\n      material.uniforms.uTime.value += 0.1 * delta;\n    }\n  });\n\n  return (\n    <mesh ref={ref}>\n      <planeGeometry args={[1, 1, 1, 1]} />\n      <shaderMaterial uniforms={uniforms} vertexShader={vertexShader} fragmentShader={fragmentShader} />\n    </mesh>\n  );\n});\nSilkPlane.displayName = 'SilkPlane';\n\nexport interface SilkProps {\n  speed?: number;\n  scale?: number;\n  color?: string;\n  noiseIntensity?: number;\n  rotation?: number;\n}\n\nconst Silk: React.FC<SilkProps> = ({ speed = 5, scale = 1, color = '#7B7481', noiseIntensity = 1.5, rotation = 0 }) => {\n  const meshRef = useRef<Mesh>(null);\n\n  const uniforms = useMemo<SilkUniforms>(\n    () => ({\n      uSpeed: { value: speed },\n      uScale: { value: scale },\n      uNoiseIntensity: { value: noiseIntensity },\n      uColor: { value: new Color(...hexToNormalizedRGB(color)) },\n      uRotation: { value: rotation },\n      uTime: { value: 0 }\n    }),\n    [speed, scale, noiseIntensity, color, rotation]\n  );\n\n  return (\n    <Canvas dpr={[1, 2]} frameloop=\"always\">\n      <SilkPlane ref={meshRef} uniforms={uniforms} />\n    </Canvas>\n  );\n};\n\nexport default Silk;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "squares",
      "type": "component",
      "description": "An animated squares pattern background effect.",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/squares.tsx",
          "content": "import React, { useRef, useEffect } from 'react';\n\ntype CanvasStrokeStyle = string | CanvasGradient | CanvasPattern;\n\ninterface GridOffset {\n  x: number;\n  y: number;\n}\n\ninterface SquaresProps {\n  direction?: 'diagonal' | 'up' | 'right' | 'down' | 'left';\n  speed?: number;\n  borderColor?: CanvasStrokeStyle;\n  squareSize?: number;\n  hoverFillColor?: CanvasStrokeStyle;\n}\n\nconst Squares: React.FC<SquaresProps> = ({\n  direction = 'right',\n  speed = 1,\n  borderColor = '#999',\n  squareSize = 40,\n  hoverFillColor = '#222'\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const requestRef = useRef<number | null>(null);\n  const numSquaresX = useRef<number>(0);\n  const numSquaresY = useRef<number>(0);\n  const gridOffset = useRef<GridOffset>({ x: 0, y: 0 });\n  const hoveredSquareRef = useRef<GridOffset | null>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n\n    const resizeCanvas = () => {\n      canvas.width = canvas.offsetWidth;\n      canvas.height = canvas.offsetHeight;\n      numSquaresX.current = Math.ceil(canvas.width / squareSize) + 1;\n      numSquaresY.current = Math.ceil(canvas.height / squareSize) + 1;\n    };\n\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n\n    const drawGrid = () => {\n      if (!ctx) return;\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      const startX = Math.floor(gridOffset.current.x / squareSize) * squareSize;\n      const startY = Math.floor(gridOffset.current.y / squareSize) * squareSize;\n\n      for (let x = startX; x < canvas.width + squareSize; x += squareSize) {\n        for (let y = startY; y < canvas.height + squareSize; y += squareSize) {\n          const squareX = x - (gridOffset.current.x % squareSize);\n          const squareY = y - (gridOffset.current.y % squareSize);\n\n          if (\n            hoveredSquareRef.current &&\n            Math.floor((x - startX) / squareSize) === hoveredSquareRef.current.x &&\n            Math.floor((y - startY) / squareSize) === hoveredSquareRef.current.y\n          ) {\n            ctx.fillStyle = hoverFillColor;\n            ctx.fillRect(squareX, squareY, squareSize, squareSize);\n          }\n\n          ctx.strokeStyle = borderColor;\n          ctx.strokeRect(squareX, squareY, squareSize, squareSize);\n        }\n      }\n\n      const gradient = ctx.createRadialGradient(\n        canvas.width / 2,\n        canvas.height / 2,\n        0,\n        canvas.width / 2,\n        canvas.height / 2,\n        Math.sqrt(canvas.width ** 2 + canvas.height ** 2) / 2\n      );\n      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n      gradient.addColorStop(1, '#060010');\n\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    };\n\n    const updateAnimation = () => {\n      const effectiveSpeed = Math.max(speed, 0.1);\n      switch (direction) {\n        case 'right':\n          gridOffset.current.x = (gridOffset.current.x - effectiveSpeed + squareSize) % squareSize;\n          break;\n        case 'left':\n          gridOffset.current.x = (gridOffset.current.x + effectiveSpeed + squareSize) % squareSize;\n          break;\n        case 'up':\n          gridOffset.current.y = (gridOffset.current.y + effectiveSpeed + squareSize) % squareSize;\n          break;\n        case 'down':\n          gridOffset.current.y = (gridOffset.current.y - effectiveSpeed + squareSize) % squareSize;\n          break;\n        case 'diagonal':\n          gridOffset.current.x = (gridOffset.current.x - effectiveSpeed + squareSize) % squareSize;\n          gridOffset.current.y = (gridOffset.current.y - effectiveSpeed + squareSize) % squareSize;\n          break;\n        default:\n          break;\n      }\n\n      drawGrid();\n      requestRef.current = requestAnimationFrame(updateAnimation);\n    };\n\n    const handleMouseMove = (event: MouseEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      const mouseX = event.clientX - rect.left;\n      const mouseY = event.clientY - rect.top;\n\n      const startX = Math.floor(gridOffset.current.x / squareSize) * squareSize;\n      const startY = Math.floor(gridOffset.current.y / squareSize) * squareSize;\n\n      const hoveredSquareX = Math.floor((mouseX + gridOffset.current.x - startX) / squareSize);\n      const hoveredSquareY = Math.floor((mouseY + gridOffset.current.y - startY) / squareSize);\n\n      if (\n        !hoveredSquareRef.current ||\n        hoveredSquareRef.current.x !== hoveredSquareX ||\n        hoveredSquareRef.current.y !== hoveredSquareY\n      ) {\n        hoveredSquareRef.current = { x: hoveredSquareX, y: hoveredSquareY };\n      }\n    };\n\n    const handleMouseLeave = () => {\n      hoveredSquareRef.current = null;\n    };\n\n    canvas.addEventListener('mousemove', handleMouseMove);\n    canvas.addEventListener('mouseleave', handleMouseLeave);\n    requestRef.current = requestAnimationFrame(updateAnimation);\n\n    return () => {\n      window.removeEventListener('resize', resizeCanvas);\n      if (requestRef.current) cancelAnimationFrame(requestRef.current);\n      canvas.removeEventListener('mousemove', handleMouseMove);\n      canvas.removeEventListener('mouseleave', handleMouseLeave);\n    };\n  }, [direction, speed, borderColor, hoverFillColor, squareSize]);\n\n  return <canvas ref={canvasRef} className=\"w-full h-full border-none block\"></canvas>;\n};\n\nexport default Squares;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "striped-pattern",
      "type": "component",
      "description": "A backgrounds striped pattern component",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/striped-pattern.tsx",
          "content": "import React, { useId } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface StripedPatternProps extends React.SVGProps<SVGSVGElement> {\n  direction?: \"left\" | \"right\"\n}\n\nexport function StripedPattern({\n  direction = \"left\",\n  className,\n  width = 10,\n  height = 10,\n  ...props\n}: StripedPatternProps) {\n  const id = useId()\n  const w = Number(width)\n  const h = Number(height)\n\n  return (\n    <svg\n      aria-hidden=\"true\"\n      className={cn(\n        \"pointer-events-none absolute inset-0 z-10 h-full w-full stroke-[0.5]\",\n        className\n      )}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      {...props}\n    >\n      <defs>\n        <pattern id={id} width={w} height={h} patternUnits=\"userSpaceOnUse\">\n          {direction === \"left\" ? (\n            <>\n              <line x1=\"0\" y1={h} x2={w} y2=\"0\" stroke=\"currentColor\" />\n              <line x1={-w} y1={h} x2=\"0\" y2=\"0\" stroke=\"currentColor\" />\n              <line x1={w} y1={h} x2={w * 2} y2=\"0\" stroke=\"currentColor\" />\n            </>\n          ) : (\n            <>\n              <line x1=\"0\" y1=\"0\" x2={w} y2={h} stroke=\"currentColor\" />\n              <line x1={-w} y1=\"0\" x2=\"0\" y2={h} stroke=\"currentColor\" />\n              <line x1={w} y1=\"0\" x2={w * 2} y2={h} stroke=\"currentColor\" />\n            </>\n          )}\n        </pattern>\n      </defs>\n      <rect width=\"100%\" height=\"100%\" fill={`url(#${id})`} />\n    </svg>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "backgrounds"
        ]
      }
    },
    {
      "name": "threads",
      "type": "component",
      "description": "Animated flowing threads background effect.",
      "category": "backgrounds",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/threads.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { Renderer, Program, Mesh, Triangle, Color } from 'ogl';\n\ninterface ThreadsProps {\n  color?: [number, number, number];\n  amplitude?: number;\n  distance?: number;\n  enableMouseInteraction?: boolean;\n}\n\nconst vertexShader = `\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\nuniform float iTime;\nuniform vec3 iResolution;\nuniform vec3 uColor;\nuniform float uAmplitude;\nuniform float uDistance;\nuniform vec2 uMouse;\n\n#define PI 3.1415926538\n\nconst int u_line_count = 40;\nconst float u_line_width = 7.0;\nconst float u_line_blur = 10.0;\n\nfloat Perlin2D(vec2 P) {\n    vec2 Pi = floor(P);\n    vec4 Pf_Pfmin1 = P.xyxy - vec4(Pi, Pi + 1.0);\n    vec4 Pt = vec4(Pi.xy, Pi.xy + 1.0);\n    Pt = Pt - floor(Pt * (1.0 / 71.0)) * 71.0;\n    Pt += vec2(26.0, 161.0).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec4 hash_x = fract(Pt * (1.0 / 951.135664));\n    vec4 hash_y = fract(Pt * (1.0 / 642.949883));\n    vec4 grad_x = hash_x - 0.49999;\n    vec4 grad_y = hash_y - 0.49999;\n    vec4 grad_results = inversesqrt(grad_x * grad_x + grad_y * grad_y)\n        * (grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww);\n    grad_results *= 1.4142135623730950;\n    vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy\n               * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n    vec4 blend2 = vec4(blend, vec2(1.0 - blend));\n    return dot(grad_results, blend2.zxzx * blend2.wwyy);\n}\n\nfloat pixel(float count, vec2 resolution) {\n    return (1.0 / max(resolution.x, resolution.y)) * count;\n}\n\nfloat lineFn(vec2 st, float width, float perc, float offset, vec2 mouse, float time, float amplitude, float distance) {\n    float split_offset = (perc * 0.4);\n    float split_point = 0.1 + split_offset;\n\n    float amplitude_normal = smoothstep(split_point, 0.7, st.x);\n    float amplitude_strength = 0.5;\n    float finalAmplitude = amplitude_normal * amplitude_strength\n                           * amplitude * (1.0 + (mouse.y - 0.5) * 0.2);\n\n    float time_scaled = time / 10.0 + (mouse.x - 0.5) * 1.0;\n    float blur = smoothstep(split_point, split_point + 0.05, st.x) * perc;\n\n    float xnoise = mix(\n        Perlin2D(vec2(time_scaled, st.x + perc) * 2.5),\n        Perlin2D(vec2(time_scaled, st.x + time_scaled) * 3.5) / 1.5,\n        st.x * 0.3\n    );\n\n    float y = 0.5 + (perc - 0.5) * distance + xnoise / 2.0 * finalAmplitude;\n\n    float line_start = smoothstep(\n        y + (width / 2.0) + (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n        y,\n        st.y\n    );\n\n    float line_end = smoothstep(\n        y,\n        y - (width / 2.0) - (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n        st.y\n    );\n\n    return clamp(\n        (line_start - line_end) * (1.0 - smoothstep(0.0, 1.0, pow(perc, 0.3))),\n        0.0,\n        1.0\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float line_strength = 1.0;\n    for (int i = 0; i < u_line_count; i++) {\n        float p = float(i) / float(u_line_count);\n        line_strength *= (1.0 - lineFn(\n            uv,\n            u_line_width * pixel(1.0, iResolution.xy) * (1.0 - p),\n            p,\n            (PI * 1.0) * p,\n            uMouse,\n            iTime,\n            uAmplitude,\n            uDistance\n        ));\n    }\n\n    float colorVal = 1.0 - line_strength;\n    fragColor = vec4(uColor * colorVal, colorVal);\n}\n\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n`;\n\nconst Threads: React.FC<ThreadsProps> = ({\n  color = [1, 1, 1],\n  amplitude = 1,\n  distance = 0,\n  enableMouseInteraction = false,\n  ...rest\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const animationFrameId = useRef<number>(0);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const container = containerRef.current;\n\n    const renderer = new Renderer({ alpha: true });\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    container.appendChild(gl.canvas);\n\n    const geometry = new Triangle(gl);\n    const program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: {\n          value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n        },\n        uColor: { value: new Color(...color) },\n        uAmplitude: { value: amplitude },\n        uDistance: { value: distance },\n        uMouse: { value: new Float32Array([0.5, 0.5]) }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    function resize() {\n      const { clientWidth, clientHeight } = container;\n      renderer.setSize(clientWidth, clientHeight);\n      program.uniforms.iResolution.value.r = clientWidth;\n      program.uniforms.iResolution.value.g = clientHeight;\n      program.uniforms.iResolution.value.b = clientWidth / clientHeight;\n    }\n    window.addEventListener('resize', resize);\n    resize();\n\n    let currentMouse = [0.5, 0.5];\n    let targetMouse = [0.5, 0.5];\n\n    function handleMouseMove(e: MouseEvent) {\n      const rect = container.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n      targetMouse = [x, y];\n    }\n    function handleMouseLeave() {\n      targetMouse = [0.5, 0.5];\n    }\n    if (enableMouseInteraction) {\n      container.addEventListener('mousemove', handleMouseMove);\n      container.addEventListener('mouseleave', handleMouseLeave);\n    }\n\n    function update(t: number) {\n      if (enableMouseInteraction) {\n        const smoothing = 0.05;\n        currentMouse[0] += smoothing * (targetMouse[0] - currentMouse[0]);\n        currentMouse[1] += smoothing * (targetMouse[1] - currentMouse[1]);\n        program.uniforms.uMouse.value[0] = currentMouse[0];\n        program.uniforms.uMouse.value[1] = currentMouse[1];\n      } else {\n        program.uniforms.uMouse.value[0] = 0.5;\n        program.uniforms.uMouse.value[1] = 0.5;\n      }\n      program.uniforms.iTime.value = t * 0.001;\n\n      renderer.render({ scene: mesh });\n      animationFrameId.current = requestAnimationFrame(update);\n    }\n    animationFrameId.current = requestAnimationFrame(update);\n\n    return () => {\n      if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);\n      window.removeEventListener('resize', resize);\n\n      if (enableMouseInteraction) {\n        container.removeEventListener('mousemove', handleMouseMove);\n        container.removeEventListener('mouseleave', handleMouseLeave);\n      }\n      if (container.contains(gl.canvas)) container.removeChild(gl.canvas);\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n    };\n  }, [color, amplitude, distance, enableMouseInteraction]);\n\n  return <div ref={containerRef} className=\"w-full h-full relative\" {...rest} />;\n};\n\nexport default Threads;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "warp-background",
      "type": "component",
      "description": "A backgrounds warp background component",
      "category": "backgrounds",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/warp-background.tsx",
          "content": "\"use client\"\n\nimport React, { HTMLAttributes, useCallback, useMemo } from \"react\"\nimport { motion } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface WarpBackgroundProps extends HTMLAttributes<HTMLDivElement> {\n  children: React.ReactNode\n  perspective?: number\n  beamsPerSide?: number\n  beamSize?: number\n  beamDelayMax?: number\n  beamDelayMin?: number\n  beamDuration?: number\n  gridColor?: string\n}\n\nconst Beam = ({\n  width,\n  x,\n  delay,\n  duration,\n}: {\n  width: string | number\n  x: string | number\n  delay: number\n  duration: number\n}) => {\n  const hue = Math.floor(Math.random() * 360)\n  const ar = Math.floor(Math.random() * 10) + 1\n\n  return (\n    <motion.div\n      style={\n        {\n          \"--x\": `${x}`,\n          \"--width\": `${width}`,\n          \"--aspect-ratio\": `${ar}`,\n          \"--background\": `linear-gradient(hsl(${hue} 80% 60%), transparent)`,\n        } as React.CSSProperties\n      }\n      className={`absolute top-0 left-[var(--x)] [aspect-ratio:1/var(--aspect-ratio)] [width:var(--width)] [background:var(--background)]`}\n      initial={{ y: \"100cqmax\", x: \"-50%\" }}\n      animate={{ y: \"-100%\", x: \"-50%\" }}\n      transition={{\n        duration,\n        delay,\n        repeat: Infinity,\n        ease: \"linear\",\n      }}\n    />\n  )\n}\n\nexport const WarpBackground: React.FC<WarpBackgroundProps> = ({\n  children,\n  perspective = 100,\n  className,\n  beamsPerSide = 3,\n  beamSize = 5,\n  beamDelayMax = 3,\n  beamDelayMin = 0,\n  beamDuration = 3,\n  gridColor = \"var(--border)\",\n  ...props\n}) => {\n  const generateBeams = useCallback(() => {\n    const beams = []\n    const cellsPerSide = Math.floor(100 / beamSize)\n    const step = cellsPerSide / beamsPerSide\n\n    for (let i = 0; i < beamsPerSide; i++) {\n      const x = Math.floor(i * step)\n      const delay = Math.random() * (beamDelayMax - beamDelayMin) + beamDelayMin\n      beams.push({ x, delay })\n    }\n    return beams\n  }, [beamsPerSide, beamSize, beamDelayMax, beamDelayMin])\n\n  const topBeams = useMemo(() => generateBeams(), [generateBeams])\n  const rightBeams = useMemo(() => generateBeams(), [generateBeams])\n  const bottomBeams = useMemo(() => generateBeams(), [generateBeams])\n  const leftBeams = useMemo(() => generateBeams(), [generateBeams])\n\n  return (\n    <div className={cn(\"relative rounded border p-20\", className)} {...props}>\n      <div\n        style={\n          {\n            \"--perspective\": `${perspective}px`,\n            \"--grid-color\": gridColor,\n            \"--beam-size\": `${beamSize}%`,\n          } as React.CSSProperties\n        }\n        className={\n          \"[container-type:size] pointer-events-none absolute top-0 left-0 size-full overflow-hidden [clipPath:inset(0)] [perspective:var(--perspective)] [transform-style:preserve-3d]\"\n        }\n      >\n        {/* top side */}\n        <div className=\"[container-type:inline-size] absolute z-20 [height:100cqmax] [width:100cqi] [transform-origin:50%_0%] [transform:rotateX(-90deg)] [background-size:var(--beam-size)_var(--beam-size)] [background:linear-gradient(var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_-0.5px_/var(--beam-size)_var(--beam-size),linear-gradient(90deg,_var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_50%_/var(--beam-size)_var(--beam-size)] [transform-style:preserve-3d]\">\n          {topBeams.map((beam, index) => (\n            <Beam\n              key={`top-${index}`}\n              width={`${beamSize}%`}\n              x={`${beam.x * beamSize}%`}\n              delay={beam.delay}\n              duration={beamDuration}\n            />\n          ))}\n        </div>\n        {/* bottom side */}\n        <div className=\"[container-type:inline-size] absolute top-full [height:100cqmax] [width:100cqi] [transform-origin:50%_0%] [transform:rotateX(-90deg)] [background-size:var(--beam-size)_var(--beam-size)] [background:linear-gradient(var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_-0.5px_/var(--beam-size)_var(--beam-size),linear-gradient(90deg,_var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_50%_/var(--beam-size)_var(--beam-size)] [transform-style:preserve-3d]\">\n          {bottomBeams.map((beam, index) => (\n            <Beam\n              key={`bottom-${index}`}\n              width={`${beamSize}%`}\n              x={`${beam.x * beamSize}%`}\n              delay={beam.delay}\n              duration={beamDuration}\n            />\n          ))}\n        </div>\n        {/* left side */}\n        <div className=\"[container-type:inline-size] absolute top-0 left-0 [height:100cqmax] [width:100cqh] [transform-origin:0%_0%] [transform:rotate(90deg)_rotateX(-90deg)] [background-size:var(--beam-size)_var(--beam-size)] [background:linear-gradient(var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_-0.5px_/var(--beam-size)_var(--beam-size),linear-gradient(90deg,_var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_50%_/var(--beam-size)_var(--beam-size)] [transform-style:preserve-3d]\">\n          {leftBeams.map((beam, index) => (\n            <Beam\n              key={`left-${index}`}\n              width={`${beamSize}%`}\n              x={`${beam.x * beamSize}%`}\n              delay={beam.delay}\n              duration={beamDuration}\n            />\n          ))}\n        </div>\n        {/* right side */}\n        <div className=\"[container-type:inline-size] absolute top-0 right-0 [height:100cqmax] [width:100cqh] [transform-origin:100%_0%] [transform:rotate(-90deg)_rotateX(-90deg)] [background-size:var(--beam-size)_var(--beam-size)] [background:linear-gradient(var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_-0.5px_/var(--beam-size)_var(--beam-size),linear-gradient(90deg,_var(--grid-color)_0_1px,_transparent_1px_var(--beam-size))_50%_50%_/var(--beam-size)_var(--beam-size)] [transform-style:preserve-3d]\">\n          {rightBeams.map((beam, index) => (\n            <Beam\n              key={`right-${index}`}\n              width={`${beamSize}%`}\n              x={`${beam.x * beamSize}%`}\n              delay={beam.delay}\n              duration={beamDuration}\n            />\n          ))}\n        </div>\n      </div>\n      <div className=\"relative\">{children}</div>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "backgrounds"
        ]
      }
    },
    {
      "name": "waves",
      "type": "component",
      "description": "An animated waves background effect.",
      "category": "backgrounds",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/waves.tsx",
          "content": "import React, { useRef, useEffect, CSSProperties } from 'react';\n\nclass Grad {\n  x: number;\n  y: number;\n  z: number;\n  constructor(x: number, y: number, z: number) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  dot2(x: number, y: number): number {\n    return this.x * x + this.y * y;\n  }\n}\n\nclass Noise {\n  grad3: Grad[];\n  p: number[];\n  perm: number[];\n  gradP: Grad[];\n\n  constructor(seed = 0) {\n    this.grad3 = [\n      new Grad(1, 1, 0),\n      new Grad(-1, 1, 0),\n      new Grad(1, -1, 0),\n      new Grad(-1, -1, 0),\n      new Grad(1, 0, 1),\n      new Grad(-1, 0, 1),\n      new Grad(1, 0, -1),\n      new Grad(-1, 0, -1),\n      new Grad(0, 1, 1),\n      new Grad(0, -1, 1),\n      new Grad(0, 1, -1),\n      new Grad(0, -1, -1)\n    ];\n    this.p = [\n      151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240,\n      21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88,\n      237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83,\n      111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216,\n      80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186,\n      3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58,\n      17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n      129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193,\n      238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157,\n      184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128,\n      195, 78, 66, 215, 61, 156, 180\n    ];\n    this.perm = new Array(512);\n    this.gradP = new Array(512);\n    this.seed(seed);\n  }\n  seed(seed: number) {\n    if (seed > 0 && seed < 1) seed *= 65536;\n    seed = Math.floor(seed);\n    if (seed < 256) seed |= seed << 8;\n    for (let i = 0; i < 256; i++) {\n      let v = i & 1 ? this.p[i] ^ (seed & 255) : this.p[i] ^ ((seed >> 8) & 255);\n      this.perm[i] = this.perm[i + 256] = v;\n      this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 12];\n    }\n  }\n  fade(t: number): number {\n    return t * t * t * (t * (t * 6 - 15) + 10);\n  }\n  lerp(a: number, b: number, t: number): number {\n    return (1 - t) * a + t * b;\n  }\n  perlin2(x: number, y: number): number {\n    let X = Math.floor(x),\n      Y = Math.floor(y);\n    x -= X;\n    y -= Y;\n    X &= 255;\n    Y &= 255;\n    const n00 = this.gradP[X + this.perm[Y]].dot2(x, y);\n    const n01 = this.gradP[X + this.perm[Y + 1]].dot2(x, y - 1);\n    const n10 = this.gradP[X + 1 + this.perm[Y]].dot2(x - 1, y);\n    const n11 = this.gradP[X + 1 + this.perm[Y + 1]].dot2(x - 1, y - 1);\n    const u = this.fade(x);\n    return this.lerp(this.lerp(n00, n10, u), this.lerp(n01, n11, u), this.fade(y));\n  }\n}\n\ninterface Point {\n  x: number;\n  y: number;\n  wave: { x: number; y: number };\n  cursor: { x: number; y: number; vx: number; vy: number };\n}\n\ninterface Mouse {\n  x: number;\n  y: number;\n  lx: number;\n  ly: number;\n  sx: number;\n  sy: number;\n  v: number;\n  vs: number;\n  a: number;\n  set: boolean;\n}\n\ninterface Config {\n  lineColor: string;\n  waveSpeedX: number;\n  waveSpeedY: number;\n  waveAmpX: number;\n  waveAmpY: number;\n  friction: number;\n  tension: number;\n  maxCursorMove: number;\n  xGap: number;\n  yGap: number;\n}\n\ninterface WavesProps {\n  lineColor?: string;\n  backgroundColor?: string;\n  waveSpeedX?: number;\n  waveSpeedY?: number;\n  waveAmpX?: number;\n  waveAmpY?: number;\n  xGap?: number;\n  yGap?: number;\n  friction?: number;\n  tension?: number;\n  maxCursorMove?: number;\n  style?: CSSProperties;\n  className?: string;\n}\n\nconst Waves: React.FC<WavesProps> = ({\n  lineColor = 'black',\n  backgroundColor = 'transparent',\n  waveSpeedX = 0.0125,\n  waveSpeedY = 0.005,\n  waveAmpX = 32,\n  waveAmpY = 16,\n  xGap = 10,\n  yGap = 32,\n  friction = 0.925,\n  tension = 0.005,\n  maxCursorMove = 100,\n  style = {},\n  className = ''\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const ctxRef = useRef<CanvasRenderingContext2D | null>(null);\n  const boundingRef = useRef<{\n    width: number;\n    height: number;\n    left: number;\n    top: number;\n  }>({\n    width: 0,\n    height: 0,\n    left: 0,\n    top: 0\n  });\n  const noiseRef = useRef(new Noise(Math.random()));\n  const linesRef = useRef<Point[][]>([]);\n  const mouseRef = useRef<Mouse>({\n    x: -10,\n    y: 0,\n    lx: 0,\n    ly: 0,\n    sx: 0,\n    sy: 0,\n    v: 0,\n    vs: 0,\n    a: 0,\n    set: false\n  });\n\n  const configRef = useRef<Config>({\n    lineColor,\n    waveSpeedX,\n    waveSpeedY,\n    waveAmpX,\n    waveAmpY,\n    friction,\n    tension,\n    maxCursorMove,\n    xGap,\n    yGap\n  });\n\n  const frameIdRef = useRef<number | null>(null);\n\n  useEffect(() => {\n    configRef.current = {\n      lineColor,\n      waveSpeedX,\n      waveSpeedY,\n      waveAmpX,\n      waveAmpY,\n      friction,\n      tension,\n      maxCursorMove,\n      xGap,\n      yGap\n    };\n  }, [lineColor, waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove, xGap, yGap]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    if (!canvas || !container) return;\n    ctxRef.current = canvas.getContext('2d');\n\n    function setSize() {\n      if (!container || !canvas) return;\n      const rect = container.getBoundingClientRect();\n      boundingRef.current = {\n        width: rect.width,\n        height: rect.height,\n        left: rect.left,\n        top: rect.top\n      };\n      canvas.width = rect.width;\n      canvas.height = rect.height;\n    }\n\n    function setLines() {\n      const { width, height } = boundingRef.current;\n      linesRef.current = [];\n      const oWidth = width + 200,\n        oHeight = height + 30;\n      const { xGap, yGap } = configRef.current;\n      const totalLines = Math.ceil(oWidth / xGap);\n      const totalPoints = Math.ceil(oHeight / yGap);\n      const xStart = (width - xGap * totalLines) / 2;\n      const yStart = (height - yGap * totalPoints) / 2;\n      for (let i = 0; i <= totalLines; i++) {\n        const pts: Point[] = [];\n        for (let j = 0; j <= totalPoints; j++) {\n          pts.push({\n            x: xStart + xGap * i,\n            y: yStart + yGap * j,\n            wave: { x: 0, y: 0 },\n            cursor: { x: 0, y: 0, vx: 0, vy: 0 }\n          });\n        }\n        linesRef.current.push(pts);\n      }\n    }\n\n    function movePoints(time: number) {\n      const lines = linesRef.current;\n      const mouse = mouseRef.current;\n      const noise = noiseRef.current;\n      const { waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove } = configRef.current;\n      lines.forEach(pts => {\n        pts.forEach(p => {\n          const move = noise.perlin2((p.x + time * waveSpeedX) * 0.002, (p.y + time * waveSpeedY) * 0.0015) * 12;\n          p.wave.x = Math.cos(move) * waveAmpX;\n          p.wave.y = Math.sin(move) * waveAmpY;\n\n          const dx = p.x - mouse.sx,\n            dy = p.y - mouse.sy;\n          const dist = Math.hypot(dx, dy);\n          const l = Math.max(175, mouse.vs);\n          if (dist < l) {\n            const s = 1 - dist / l;\n            const f = Math.cos(dist * 0.001) * s;\n            p.cursor.vx += Math.cos(mouse.a) * f * l * mouse.vs * 0.00065;\n            p.cursor.vy += Math.sin(mouse.a) * f * l * mouse.vs * 0.00065;\n          }\n\n          p.cursor.vx += (0 - p.cursor.x) * tension;\n          p.cursor.vy += (0 - p.cursor.y) * tension;\n          p.cursor.vx *= friction;\n          p.cursor.vy *= friction;\n          p.cursor.x += p.cursor.vx * 2;\n          p.cursor.y += p.cursor.vy * 2;\n          p.cursor.x = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.x));\n          p.cursor.y = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.y));\n        });\n      });\n    }\n\n    function moved(point: Point, withCursor = true): { x: number; y: number } {\n      const x = point.x + point.wave.x + (withCursor ? point.cursor.x : 0);\n      const y = point.y + point.wave.y + (withCursor ? point.cursor.y : 0);\n      return { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };\n    }\n\n    function drawLines() {\n      const { width, height } = boundingRef.current;\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n      ctx.clearRect(0, 0, width, height);\n      ctx.beginPath();\n      ctx.strokeStyle = configRef.current.lineColor;\n      linesRef.current.forEach(points => {\n        let p1 = moved(points[0], false);\n        ctx.moveTo(p1.x, p1.y);\n        points.forEach((p, idx) => {\n          const isLast = idx === points.length - 1;\n          p1 = moved(p, !isLast);\n          const p2 = moved(points[idx + 1] || points[points.length - 1], !isLast);\n          ctx.lineTo(p1.x, p1.y);\n          if (isLast) ctx.moveTo(p2.x, p2.y);\n        });\n      });\n      ctx.stroke();\n    }\n\n    function tick(t: number) {\n      if (!container) return;\n      const mouse = mouseRef.current;\n      mouse.sx += (mouse.x - mouse.sx) * 0.1;\n      mouse.sy += (mouse.y - mouse.sy) * 0.1;\n      const dx = mouse.x - mouse.lx,\n        dy = mouse.y - mouse.ly;\n      const d = Math.hypot(dx, dy);\n      mouse.v = d;\n      mouse.vs += (d - mouse.vs) * 0.1;\n      mouse.vs = Math.min(100, mouse.vs);\n      mouse.lx = mouse.x;\n      mouse.ly = mouse.y;\n      mouse.a = Math.atan2(dy, dx);\n      container.style.setProperty('--x', `${mouse.sx}px`);\n      container.style.setProperty('--y', `${mouse.sy}px`);\n\n      movePoints(t);\n      drawLines();\n      frameIdRef.current = requestAnimationFrame(tick);\n    }\n\n    function onResize() {\n      setSize();\n      setLines();\n    }\n    function onMouseMove(e: MouseEvent) {\n      updateMouse(e.clientX, e.clientY);\n    }\n    function onTouchMove(e: TouchEvent) {\n      const touch = e.touches[0];\n      updateMouse(touch.clientX, touch.clientY);\n    }\n    function updateMouse(x: number, y: number) {\n      const mouse = mouseRef.current;\n      const b = boundingRef.current;\n      mouse.x = x - b.left;\n      mouse.y = y - b.top;\n      if (!mouse.set) {\n        mouse.sx = mouse.x;\n        mouse.sy = mouse.y;\n        mouse.lx = mouse.x;\n        mouse.ly = mouse.y;\n        mouse.set = true;\n      }\n    }\n\n    setSize();\n    setLines();\n    frameIdRef.current = requestAnimationFrame(tick);\n    window.addEventListener('resize', onResize);\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('touchmove', onTouchMove, { passive: false });\n\n    return () => {\n      window.removeEventListener('resize', onResize);\n      window.removeEventListener('mousemove', onMouseMove);\n      window.removeEventListener('touchmove', onTouchMove);\n      if (frameIdRef.current !== null) {\n        cancelAnimationFrame(frameIdRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        backgroundColor,\n        ...style\n      }}\n      className={`absolute top-0 left-0 w-full h-full overflow-hidden ${className}`}\n    >\n      <div\n        className=\"absolute top-0 left-0 bg-[#160000] rounded-full w-[0.5rem] h-[0.5rem]\"\n        style={{\n          transform: 'translate3d(calc(var(--x) - 50%), calc(var(--y) - 50%), 0)',\n          willChange: 'transform'\n        }}\n      />\n      <canvas ref={canvasRef} className=\"block w-full h-full\" />\n    </div>\n  );\n};\n\nexport default Waves;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "background"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "animated-beam",
      "type": "component",
      "description": "An animated beam of light which travels along a path.",
      "category": "animations",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/animated-beam.tsx",
          "content": "\"use client\"\n\nimport { RefObject, useEffect, useId, useState } from \"react\"\nimport { motion } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface AnimatedBeamProps {\n  className?: string\n  containerRef: RefObject<HTMLElement | null> // Container ref\n  fromRef: RefObject<HTMLElement | null>\n  toRef: RefObject<HTMLElement | null>\n  curvature?: number\n  reverse?: boolean\n  pathColor?: string\n  pathWidth?: number\n  pathOpacity?: number\n  gradientStartColor?: string\n  gradientStopColor?: string\n  delay?: number\n  duration?: number\n  startXOffset?: number\n  startYOffset?: number\n  endXOffset?: number\n  endYOffset?: number\n}\n\nexport const AnimatedBeam: React.FC<AnimatedBeamProps> = ({\n  className,\n  containerRef,\n  fromRef,\n  toRef,\n  curvature = 0,\n  reverse = false, // Include the reverse prop\n  duration = Math.random() * 3 + 4,\n  delay = 0,\n  pathColor = \"gray\",\n  pathWidth = 2,\n  pathOpacity = 0.2,\n  gradientStartColor = \"#ffaa40\",\n  gradientStopColor = \"#9c40ff\",\n  startXOffset = 0,\n  startYOffset = 0,\n  endXOffset = 0,\n  endYOffset = 0,\n}) => {\n  const id = useId()\n  const [pathD, setPathD] = useState(\"\")\n  const [svgDimensions, setSvgDimensions] = useState({ width: 0, height: 0 })\n\n  // Calculate the gradient coordinates based on the reverse prop\n  const gradientCoordinates = reverse\n    ? {\n        x1: [\"90%\", \"-10%\"],\n        x2: [\"100%\", \"0%\"],\n        y1: [\"0%\", \"0%\"],\n        y2: [\"0%\", \"0%\"],\n      }\n    : {\n        x1: [\"10%\", \"110%\"],\n        x2: [\"0%\", \"100%\"],\n        y1: [\"0%\", \"0%\"],\n        y2: [\"0%\", \"0%\"],\n      }\n\n  useEffect(() => {\n    const updatePath = () => {\n      if (containerRef.current && fromRef.current && toRef.current) {\n        const containerRect = containerRef.current.getBoundingClientRect()\n        const rectA = fromRef.current.getBoundingClientRect()\n        const rectB = toRef.current.getBoundingClientRect()\n\n        const svgWidth = containerRect.width\n        const svgHeight = containerRect.height\n        setSvgDimensions({ width: svgWidth, height: svgHeight })\n\n        const startX =\n          rectA.left - containerRect.left + rectA.width / 2 + startXOffset\n        const startY =\n          rectA.top - containerRect.top + rectA.height / 2 + startYOffset\n        const endX =\n          rectB.left - containerRect.left + rectB.width / 2 + endXOffset\n        const endY =\n          rectB.top - containerRect.top + rectB.height / 2 + endYOffset\n\n        const controlY = startY - curvature\n        const d = `M ${startX},${startY} Q ${\n          (startX + endX) / 2\n        },${controlY} ${endX},${endY}`\n        setPathD(d)\n      }\n    }\n\n    // Initialize ResizeObserver\n    const resizeObserver = new ResizeObserver(() => {\n      updatePath()\n    })\n\n    // Observe the container element\n    if (containerRef.current) {\n      resizeObserver.observe(containerRef.current)\n    }\n\n    // Call the updatePath initially to set the initial path\n    updatePath()\n\n    // Clean up the observer on component unmount\n    return () => {\n      resizeObserver.disconnect()\n    }\n  }, [\n    containerRef,\n    fromRef,\n    toRef,\n    curvature,\n    startXOffset,\n    startYOffset,\n    endXOffset,\n    endYOffset,\n  ])\n\n  return (\n    <svg\n      fill=\"none\"\n      width={svgDimensions.width}\n      height={svgDimensions.height}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(\n        \"pointer-events-none absolute top-0 left-0 transform-gpu stroke-2\",\n        className\n      )}\n      viewBox={`0 0 ${svgDimensions.width} ${svgDimensions.height}`}\n    >\n      <path\n        d={pathD}\n        stroke={pathColor}\n        strokeWidth={pathWidth}\n        strokeOpacity={pathOpacity}\n        strokeLinecap=\"round\"\n      />\n      <path\n        d={pathD}\n        strokeWidth={pathWidth}\n        stroke={`url(#${id})`}\n        strokeOpacity=\"1\"\n        strokeLinecap=\"round\"\n      />\n      <defs>\n        <motion.linearGradient\n          className=\"transform-gpu\"\n          id={id}\n          gradientUnits={\"userSpaceOnUse\"}\n          initial={{\n            x1: \"0%\",\n            x2: \"0%\",\n            y1: \"0%\",\n            y2: \"0%\",\n          }}\n          animate={{\n            x1: gradientCoordinates.x1,\n            x2: gradientCoordinates.x2,\n            y1: gradientCoordinates.y1,\n            y2: gradientCoordinates.y2,\n          }}\n          transition={{\n            delay,\n            duration,\n            ease: [0.16, 1, 0.3, 1], // https://easings.net/#easeOutExpo\n            repeat: Infinity,\n            repeatDelay: 0,\n          }}\n        >\n          <stop stopColor={gradientStartColor} stopOpacity=\"0\"></stop>\n          <stop stopColor={gradientStartColor}></stop>\n          <stop offset=\"32.5%\" stopColor={gradientStopColor}></stop>\n          <stop\n            offset=\"100%\"\n            stopColor={gradientStopColor}\n            stopOpacity=\"0\"\n          ></stop>\n        </motion.linearGradient>\n      </defs>\n    </svg>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "animated-circular-progress-bar",
      "type": "component",
      "description": "Animated Circular Progress Bar with a percentage value.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/animated-circular-progress-bar.tsx",
          "content": "import { cn } from \"@/lib/utils\"\n\ninterface AnimatedCircularProgressBarProps {\n  max?: number\n  min?: number\n  value: number\n  gaugePrimaryColor: string\n  gaugeSecondaryColor: string\n  className?: string\n}\n\nexport function AnimatedCircularProgressBar({\n  max = 100,\n  min = 0,\n  value = 0,\n  gaugePrimaryColor,\n  gaugeSecondaryColor,\n  className,\n}: AnimatedCircularProgressBarProps) {\n  const circumference = 2 * Math.PI * 45\n  const percentPx = circumference / 100\n  const currentPercent = Math.round(((value - min) / (max - min)) * 100)\n\n  return (\n    <div\n      className={cn(\"relative size-40 text-2xl font-semibold\", className)}\n      style={\n        {\n          \"--circle-size\": \"100px\",\n          \"--circumference\": circumference,\n          \"--percent-to-px\": `${percentPx}px`,\n          \"--gap-percent\": \"5\",\n          \"--offset-factor\": \"0\",\n          \"--transition-length\": \"1s\",\n          \"--transition-step\": \"200ms\",\n          \"--delay\": \"0s\",\n          \"--percent-to-deg\": \"3.6deg\",\n          transform: \"translateZ(0)\",\n        } as React.CSSProperties\n      }\n    >\n      <svg\n        fill=\"none\"\n        className=\"size-full\"\n        strokeWidth=\"2\"\n        viewBox=\"0 0 100 100\"\n      >\n        {currentPercent <= 90 && currentPercent >= 0 && (\n          <circle\n            cx=\"50\"\n            cy=\"50\"\n            r=\"45\"\n            strokeWidth=\"10\"\n            strokeDashoffset=\"0\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            className=\"opacity-100\"\n            style={\n              {\n                stroke: gaugeSecondaryColor,\n                \"--stroke-percent\": 90 - currentPercent,\n                \"--offset-factor-secondary\": \"calc(1 - var(--offset-factor))\",\n                strokeDasharray:\n                  \"calc(var(--stroke-percent) * var(--percent-to-px)) var(--circumference)\",\n                transform:\n                  \"rotate(calc(1turn - 90deg - (var(--gap-percent) * var(--percent-to-deg) * var(--offset-factor-secondary)))) scaleY(-1)\",\n                transition: \"all var(--transition-length) ease var(--delay)\",\n                transformOrigin:\n                  \"calc(var(--circle-size) / 2) calc(var(--circle-size) / 2)\",\n              } as React.CSSProperties\n            }\n          />\n        )}\n        <circle\n          cx=\"50\"\n          cy=\"50\"\n          r=\"45\"\n          strokeWidth=\"10\"\n          strokeDashoffset=\"0\"\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n          className=\"opacity-100\"\n          style={\n            {\n              stroke: gaugePrimaryColor,\n              \"--stroke-percent\": currentPercent,\n              strokeDasharray:\n                \"calc(var(--stroke-percent) * var(--percent-to-px)) var(--circumference)\",\n              transition:\n                \"var(--transition-length) ease var(--delay),stroke var(--transition-length) ease var(--delay)\",\n              transitionProperty: \"stroke-dasharray,transform\",\n              transform:\n                \"rotate(calc(-90deg + var(--gap-percent) * var(--offset-factor) * var(--percent-to-deg)))\",\n              transformOrigin:\n                \"calc(var(--circle-size) / 2) calc(var(--circle-size) / 2)\",\n            } as React.CSSProperties\n          }\n        />\n      </svg>\n      <span\n        data-current-value={currentPercent}\n        className=\"animate-in fade-in absolute inset-0 m-auto size-fit delay-[var(--delay)] duration-[var(--transition-length)] ease-linear\"\n      >\n        {currentPercent}\n      </span>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "animated-content",
      "type": "component",
      "description": "Animates content with entrance effects.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/animated-content.tsx",
          "content": "import React, { useRef, useEffect } from 'react';\nimport { gsap } from 'gsap';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\n\ngsap.registerPlugin(ScrollTrigger);\n\ninterface AnimatedContentProps extends React.HTMLAttributes<HTMLDivElement> {\n  children: React.ReactNode;\n  container?: Element | string | null;\n  distance?: number;\n  direction?: 'vertical' | 'horizontal';\n  reverse?: boolean;\n  duration?: number;\n  ease?: string;\n  initialOpacity?: number;\n  animateOpacity?: boolean;\n  scale?: number;\n  threshold?: number;\n  delay?: number;\n  disappearAfter?: number;\n  disappearDuration?: number;\n  disappearEase?: string;\n  onComplete?: () => void;\n  onDisappearanceComplete?: () => void;\n}\n\nconst AnimatedContent: React.FC<AnimatedContentProps> = ({\n  children,\n  container,\n  distance = 100,\n  direction = 'vertical',\n  reverse = false,\n  duration = 0.8,\n  ease = 'power3.out',\n  initialOpacity = 0,\n  animateOpacity = true,\n  scale = 1,\n  threshold = 0.1,\n  delay = 0,\n  disappearAfter = 0,\n  disappearDuration = 0.5,\n  disappearEase = 'power3.in',\n  onComplete,\n  onDisappearanceComplete,\n  className = '',\n  ...props\n}) => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) return;\n\n    let scrollerTarget: Element | string | null = container || document.getElementById('snap-main-container') || null;\n\n    if (typeof scrollerTarget === 'string') {\n      scrollerTarget = document.querySelector(scrollerTarget);\n    }\n\n    const axis = direction === 'horizontal' ? 'x' : 'y';\n    const offset = reverse ? -distance : distance;\n    const startPct = (1 - threshold) * 100;\n\n    gsap.set(el, {\n      [axis]: offset,\n      scale,\n      opacity: animateOpacity ? initialOpacity : 1,\n      visibility: 'visible'\n    });\n\n    const tl = gsap.timeline({\n      paused: true,\n      delay,\n      onComplete: () => {\n        if (onComplete) onComplete();\n        if (disappearAfter > 0) {\n          gsap.to(el, {\n            [axis]: reverse ? distance : -distance,\n            scale: 0.8,\n            opacity: animateOpacity ? initialOpacity : 0,\n            delay: disappearAfter,\n            duration: disappearDuration,\n            ease: disappearEase,\n            onComplete: () => onDisappearanceComplete?.()\n          });\n        }\n      }\n    });\n\n    tl.to(el, {\n      [axis]: 0,\n      scale: 1,\n      opacity: 1,\n      duration,\n      ease\n    });\n\n    const st = ScrollTrigger.create({\n      trigger: el,\n      scroller: scrollerTarget || window,\n      start: `top ${startPct}%`,\n      once: true,\n      onEnter: () => tl.play()\n    });\n\n    return () => {\n      st.kill();\n      tl.kill();\n    };\n  }, [\n    container,\n    distance,\n    direction,\n    reverse,\n    duration,\n    ease,\n    initialOpacity,\n    animateOpacity,\n    scale,\n    threshold,\n    delay,\n    disappearAfter,\n    disappearDuration,\n    disappearEase,\n    onComplete,\n    onDisappearanceComplete\n  ]);\n\n  return (\n    <div ref={ref} className={`invisible ${className}`} {...props}>\n      {children}\n    </div>\n  );\n};\n\nexport default AnimatedContent;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "animated-list",
      "type": "component",
      "description": "A list that animates each item in sequence with a delay.",
      "category": "animations",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/animated-list.tsx",
          "content": "\"use client\"\n\nimport React, {\n  ComponentPropsWithoutRef,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\"\nimport { AnimatePresence, motion, MotionProps } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport function AnimatedListItem({ children }: { children: React.ReactNode }) {\n  const animations: MotionProps = {\n    initial: { scale: 0, opacity: 0 },\n    animate: { scale: 1, opacity: 1, originY: 0 },\n    exit: { scale: 0, opacity: 0 },\n    transition: { type: \"spring\", stiffness: 350, damping: 40 },\n  }\n\n  return (\n    <motion.div {...animations} layout className=\"mx-auto w-full\">\n      {children}\n    </motion.div>\n  )\n}\n\nexport interface AnimatedListProps extends ComponentPropsWithoutRef<\"div\"> {\n  children: React.ReactNode\n  delay?: number\n}\n\nexport const AnimatedList = React.memo(\n  ({ children, className, delay = 1000, ...props }: AnimatedListProps) => {\n    const [index, setIndex] = useState(0)\n    const childrenArray = useMemo(\n      () => React.Children.toArray(children),\n      [children]\n    )\n\n    useEffect(() => {\n      if (index < childrenArray.length - 1) {\n        const timeout = setTimeout(() => {\n          setIndex((prevIndex) => (prevIndex + 1) % childrenArray.length)\n        }, delay)\n\n        return () => clearTimeout(timeout)\n      }\n    }, [index, delay, childrenArray.length])\n\n    const itemsToShow = useMemo(() => {\n      const result = childrenArray.slice(0, index + 1).reverse()\n      return result\n    }, [index, childrenArray])\n\n    return (\n      <div\n        className={cn(`flex flex-col items-center gap-4`, className)}\n        {...props}\n      >\n        <AnimatePresence>\n          {itemsToShow.map((item) => (\n            <AnimatedListItem key={(item as React.ReactElement).key}>\n              {item}\n            </AnimatedListItem>\n          ))}\n        </AnimatePresence>\n      </div>\n    )\n  }\n)\n\nAnimatedList.displayName = \"AnimatedList\"\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "animated-theme-toggler",
      "type": "component",
      "description": "A component for theme changing animation.",
      "category": "animations",
      "dependencies": [
        "lucide-react"
      ],
      "files": [
        {
          "path": "components/ui/animated-theme-toggler.tsx",
          "content": "\"use client\"\n\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport { Moon, Sun } from \"lucide-react\"\nimport { flushSync } from \"react-dom\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface AnimatedThemeTogglerProps extends React.ComponentPropsWithoutRef<\"button\"> {\n  duration?: number\n}\n\nexport const AnimatedThemeToggler = ({\n  className,\n  duration = 400,\n  ...props\n}: AnimatedThemeTogglerProps) => {\n  const [isDark, setIsDark] = useState(false)\n  const buttonRef = useRef<HTMLButtonElement>(null)\n\n  useEffect(() => {\n    const updateTheme = () => {\n      setIsDark(document.documentElement.classList.contains(\"dark\"))\n    }\n\n    updateTheme()\n\n    const observer = new MutationObserver(updateTheme)\n    observer.observe(document.documentElement, {\n      attributes: true,\n      attributeFilter: [\"class\"],\n    })\n\n    return () => observer.disconnect()\n  }, [])\n\n  const toggleTheme = useCallback(async () => {\n    if (!buttonRef.current) return\n\n    await document.startViewTransition(() => {\n      flushSync(() => {\n        const newTheme = !isDark\n        setIsDark(newTheme)\n        document.documentElement.classList.toggle(\"dark\")\n        localStorage.setItem(\"theme\", newTheme ? \"dark\" : \"light\")\n      })\n    }).ready\n\n    const { top, left, width, height } =\n      buttonRef.current.getBoundingClientRect()\n    const x = left + width / 2\n    const y = top + height / 2\n    const maxRadius = Math.hypot(\n      Math.max(left, window.innerWidth - left),\n      Math.max(top, window.innerHeight - top)\n    )\n\n    document.documentElement.animate(\n      {\n        clipPath: [\n          `circle(0px at ${x}px ${y}px)`,\n          `circle(${maxRadius}px at ${x}px ${y}px)`,\n        ],\n      },\n      {\n        duration,\n        easing: \"ease-in-out\",\n        pseudoElement: \"::view-transition-new(root)\",\n      }\n    )\n  }, [isDark, duration])\n\n  return (\n    <button\n      ref={buttonRef}\n      onClick={toggleTheme}\n      className={cn(className)}\n      {...props}\n    >\n      {isDark ? <Sun /> : <Moon />}\n      <span className=\"sr-only\">Toggle theme</span>\n    </button>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "antigravity",
      "type": "component",
      "description": "Anti-gravity floating animation.",
      "category": "animations",
      "dependencies": [
        "three",
        "@react-three/fiber"
      ],
      "files": [
        {
          "path": "components/ui/antigravity.tsx",
          "content": "import { Canvas, useFrame, useThree } from '@react-three/fiber';\nimport React, { useMemo, useRef } from 'react';\nimport * as THREE from 'three';\n\ninterface AntigravityProps {\n  count?: number;\n  magnetRadius?: number;\n  ringRadius?: number;\n  waveSpeed?: number;\n  waveAmplitude?: number;\n  particleSize?: number;\n  lerpSpeed?: number;\n  color?: string;\n  autoAnimate?: boolean;\n  particleVariance?: number;\n  rotationSpeed?: number;\n  depthFactor?: number;\n  pulseSpeed?: number;\n  particleShape?: 'capsule' | 'sphere' | 'box' | 'tetrahedron';\n  fieldStrength?: number;\n}\n\nconst AntigravityInner: React.FC<AntigravityProps> = ({\n  count = 300,\n  magnetRadius = 10,\n  ringRadius = 10,\n  waveSpeed = 0.4,\n  waveAmplitude = 1,\n  particleSize = 2,\n  lerpSpeed = 0.1,\n  color = '#FF9FFC',\n  autoAnimate = false,\n  particleVariance = 1,\n  rotationSpeed = 0,\n  depthFactor = 1,\n  pulseSpeed = 3,\n  particleShape = 'capsule',\n  fieldStrength = 10\n}) => {\n  const meshRef = useRef<THREE.InstancedMesh>(null);\n  const { viewport } = useThree();\n  const dummy = useMemo(() => new THREE.Object3D(), []);\n\n  const lastMousePos = useRef({ x: 0, y: 0 });\n  const lastMouseMoveTime = useRef(0);\n  const virtualMouse = useRef({ x: 0, y: 0 });\n\n  const particles = useMemo(() => {\n    const temp = [];\n    const width = viewport.width || 100;\n    const height = viewport.height || 100;\n\n    for (let i = 0; i < count; i++) {\n      const t = Math.random() * 100;\n      const factor = 20 + Math.random() * 100;\n      const speed = 0.01 + Math.random() / 200;\n      const xFactor = -50 + Math.random() * 100;\n      const yFactor = -50 + Math.random() * 100;\n      const zFactor = -50 + Math.random() * 100;\n\n      const x = (Math.random() - 0.5) * width;\n      const y = (Math.random() - 0.5) * height;\n      const z = (Math.random() - 0.5) * 20;\n\n      const randomRadiusOffset = (Math.random() - 0.5) * 2;\n\n      temp.push({\n        t,\n        factor,\n        speed,\n        xFactor,\n        yFactor,\n        zFactor,\n        mx: x,\n        my: y,\n        mz: z,\n        cx: x,\n        cy: y,\n        cz: z,\n        vx: 0,\n        vy: 0,\n        vz: 0,\n        randomRadiusOffset\n      });\n    }\n    return temp;\n  }, [count, viewport.width, viewport.height]);\n\n  useFrame(state => {\n    const mesh = meshRef.current;\n    if (!mesh) return;\n\n    const { viewport: v, pointer: m } = state;\n\n    const mouseDist = Math.sqrt(Math.pow(m.x - lastMousePos.current.x, 2) + Math.pow(m.y - lastMousePos.current.y, 2));\n\n    if (mouseDist > 0.001) {\n      lastMouseMoveTime.current = Date.now();\n      lastMousePos.current = { x: m.x, y: m.y };\n    }\n\n    let destX = (m.x * v.width) / 2;\n    let destY = (m.y * v.height) / 2;\n\n    if (autoAnimate && Date.now() - lastMouseMoveTime.current > 2000) {\n      const time = state.clock.getElapsedTime();\n      destX = Math.sin(time * 0.5) * (v.width / 4);\n      destY = Math.cos(time * 0.5 * 2) * (v.height / 4);\n    }\n\n    const smoothFactor = 0.05;\n    virtualMouse.current.x += (destX - virtualMouse.current.x) * smoothFactor;\n    virtualMouse.current.y += (destY - virtualMouse.current.y) * smoothFactor;\n\n    const targetX = virtualMouse.current.x;\n    const targetY = virtualMouse.current.y;\n\n    const globalRotation = state.clock.getElapsedTime() * rotationSpeed;\n\n    particles.forEach((particle, i) => {\n      let { t, speed, mx, my, mz, cz, randomRadiusOffset } = particle;\n\n      t = particle.t += speed / 2;\n\n      const projectionFactor = 1 - cz / 50;\n      const projectedTargetX = targetX * projectionFactor;\n      const projectedTargetY = targetY * projectionFactor;\n\n      const dx = mx - projectedTargetX;\n      const dy = my - projectedTargetY;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      let targetPos = { x: mx, y: my, z: mz * depthFactor };\n\n      if (dist < magnetRadius) {\n        const angle = Math.atan2(dy, dx) + globalRotation;\n\n        const wave = Math.sin(t * waveSpeed + angle) * (0.5 * waveAmplitude);\n        const deviation = randomRadiusOffset * (5 / (fieldStrength + 0.1));\n\n        const currentRingRadius = ringRadius + wave + deviation;\n\n        targetPos.x = projectedTargetX + currentRingRadius * Math.cos(angle);\n        targetPos.y = projectedTargetY + currentRingRadius * Math.sin(angle);\n        targetPos.z = mz * depthFactor + Math.sin(t) * (1 * waveAmplitude * depthFactor);\n      }\n\n      particle.cx += (targetPos.x - particle.cx) * lerpSpeed;\n      particle.cy += (targetPos.y - particle.cy) * lerpSpeed;\n      particle.cz += (targetPos.z - particle.cz) * lerpSpeed;\n\n      dummy.position.set(particle.cx, particle.cy, particle.cz);\n\n      dummy.lookAt(projectedTargetX, projectedTargetY, particle.cz);\n      dummy.rotateX(Math.PI / 2);\n\n      const currentDistToMouse = Math.sqrt(\n        Math.pow(particle.cx - projectedTargetX, 2) + Math.pow(particle.cy - projectedTargetY, 2)\n      );\n\n      const distFromRing = Math.abs(currentDistToMouse - ringRadius);\n      let scaleFactor = 1 - distFromRing / 10;\n\n      scaleFactor = Math.max(0, Math.min(1, scaleFactor));\n\n      const finalScale = scaleFactor * (0.8 + Math.sin(t * pulseSpeed) * 0.2 * particleVariance) * particleSize;\n      dummy.scale.set(finalScale, finalScale, finalScale);\n\n      dummy.updateMatrix();\n\n      mesh.setMatrixAt(i, dummy.matrix);\n    });\n\n    mesh.instanceMatrix.needsUpdate = true;\n  });\n\n  return (\n    <instancedMesh ref={meshRef} args={[undefined, undefined, count]}>\n      {particleShape === 'capsule' && <capsuleGeometry args={[0.1, 0.4, 4, 8]} />}\n      {particleShape === 'sphere' && <sphereGeometry args={[0.2, 16, 16]} />}\n      {particleShape === 'box' && <boxGeometry args={[0.3, 0.3, 0.3]} />}\n      {particleShape === 'tetrahedron' && <tetrahedronGeometry args={[0.3]} />}\n      <meshBasicMaterial color={color} />\n    </instancedMesh>\n  );\n};\n\nconst Antigravity: React.FC<AntigravityProps> = props => {\n  return (\n    <Canvas camera={{ position: [0, 0, 50], fov: 35 }}>\n      <AntigravityInner {...props} />\n    </Canvas>\n  );\n};\n\nexport default Antigravity;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "blob-cursor",
      "type": "component",
      "description": "An organic blob cursor that follows the pointer.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/blob-cursor.tsx",
          "content": "'use client';\n\nimport React, { useRef, useEffect, useCallback } from 'react';\nimport gsap from 'gsap';\n\nexport interface BlobCursorProps {\n  blobType?: 'circle' | 'square';\n  fillColor?: string;\n  trailCount?: number;\n  sizes?: number[];\n  innerSizes?: number[];\n  innerColor?: string;\n  opacities?: number[];\n  shadowColor?: string;\n  shadowBlur?: number;\n  shadowOffsetX?: number;\n  shadowOffsetY?: number;\n  filterId?: string;\n  filterStdDeviation?: number;\n  filterColorMatrixValues?: string;\n  useFilter?: boolean;\n  fastDuration?: number;\n  slowDuration?: number;\n  fastEase?: string;\n  slowEase?: string;\n  zIndex?: number;\n}\n\nexport default function BlobCursor({\n  blobType = 'circle',\n  fillColor = '#5227FF',\n  trailCount = 3,\n  sizes = [60, 125, 75],\n  innerSizes = [20, 35, 25],\n  innerColor = 'rgba(255,255,255,0.8)',\n  opacities = [0.6, 0.6, 0.6],\n  shadowColor = 'rgba(0,0,0,0.75)',\n  shadowBlur = 5,\n  shadowOffsetX = 10,\n  shadowOffsetY = 10,\n  filterId = 'blob',\n  filterStdDeviation = 30,\n  filterColorMatrixValues = '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 35 -10',\n  useFilter = true,\n  fastDuration = 0.1,\n  slowDuration = 0.5,\n  fastEase = 'power3.out',\n  slowEase = 'power1.out',\n  zIndex = 100\n}: BlobCursorProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const blobsRef = useRef<(HTMLDivElement | null)[]>([]);\n\n  const updateOffset = useCallback(() => {\n    if (!containerRef.current) return { left: 0, top: 0 };\n    const rect = containerRef.current.getBoundingClientRect();\n    return { left: rect.left, top: rect.top };\n  }, []);\n\n  const handleMove = useCallback(\n    (e: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n      const { left, top } = updateOffset();\n      const x = 'clientX' in e ? e.clientX : e.touches[0].clientX;\n      const y = 'clientY' in e ? e.clientY : e.touches[0].clientY;\n\n      blobsRef.current.forEach((el, i) => {\n        if (!el) return;\n        const isLead = i === 0;\n        gsap.to(el, {\n          x: x - left,\n          y: y - top,\n          duration: isLead ? fastDuration : slowDuration,\n          ease: isLead ? fastEase : slowEase\n        });\n      });\n    },\n    [updateOffset, fastDuration, slowDuration, fastEase, slowEase]\n  );\n\n  useEffect(() => {\n    const onResize = () => updateOffset();\n    window.addEventListener('resize', onResize);\n    return () => window.removeEventListener('resize', onResize);\n  }, [updateOffset]);\n\n  return (\n    <div\n      ref={containerRef}\n      onMouseMove={handleMove}\n      onTouchMove={handleMove}\n      className=\"relative top-0 left-0 w-full h-full\"\n      style={{ zIndex }}\n    >\n      {useFilter && (\n        <svg className=\"absolute w-0 h-0\">\n          <filter id={filterId}>\n            <feGaussianBlur in=\"SourceGraphic\" result=\"blur\" stdDeviation={filterStdDeviation} />\n            <feColorMatrix in=\"blur\" values={filterColorMatrixValues} />\n          </filter>\n        </svg>\n      )}\n\n      <div\n        className=\"pointer-events-none absolute inset-0 overflow-hidden select-none cursor-default\"\n        style={{ filter: useFilter ? `url(#${filterId})` : undefined }}\n      >\n        {Array.from({ length: trailCount }).map((_, i) => (\n          <div\n            key={i}\n            ref={el => {\n              blobsRef.current[i] = el;\n            }}\n            className=\"absolute will-change-transform transform -translate-x-1/2 -translate-y-1/2\"\n            style={{\n              width: sizes[i],\n              height: sizes[i],\n              borderRadius: blobType === 'circle' ? '50%' : '0',\n              backgroundColor: fillColor,\n              opacity: opacities[i],\n              boxShadow: `${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px 0 ${shadowColor}`\n            }}\n          >\n            <div\n              className=\"absolute\"\n              style={{\n                width: innerSizes[i],\n                height: innerSizes[i],\n                top: (sizes[i] - innerSizes[i]) / 2,\n                left: (sizes[i] - innerSizes[i]) / 2,\n                backgroundColor: innerColor,\n                borderRadius: blobType === 'circle' ? '50%' : '0'\n              }}\n            />\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "blur-fade",
      "type": "component",
      "description": "Blur fade in and out animation.",
      "category": "animations",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/blur-fade.tsx",
          "content": "\"use client\"\n\nimport { useRef } from \"react\"\nimport {\n  AnimatePresence,\n  motion,\n  MotionProps,\n  useInView,\n  UseInViewOptions,\n  Variants,\n} from \"motion/react\"\n\ntype MarginType = UseInViewOptions[\"margin\"]\n\ninterface BlurFadeProps extends MotionProps {\n  children: React.ReactNode\n  className?: string\n  variant?: {\n    hidden: { y: number }\n    visible: { y: number }\n  }\n  duration?: number\n  delay?: number\n  offset?: number\n  direction?: \"up\" | \"down\" | \"left\" | \"right\"\n  inView?: boolean\n  inViewMargin?: MarginType\n  blur?: string\n}\n\nexport function BlurFade({\n  children,\n  className,\n  variant,\n  duration = 0.4,\n  delay = 0,\n  offset = 6,\n  direction = \"down\",\n  inView = false,\n  inViewMargin = \"-50px\",\n  blur = \"6px\",\n  ...props\n}: BlurFadeProps) {\n  const ref = useRef(null)\n  const inViewResult = useInView(ref, { once: true, margin: inViewMargin })\n  const isInView = !inView || inViewResult\n  const defaultVariants: Variants = {\n    hidden: {\n      [direction === \"left\" || direction === \"right\" ? \"x\" : \"y\"]:\n        direction === \"right\" || direction === \"down\" ? -offset : offset,\n      opacity: 0,\n      filter: `blur(${blur})`,\n    },\n    visible: {\n      [direction === \"left\" || direction === \"right\" ? \"x\" : \"y\"]: 0,\n      opacity: 1,\n      filter: `blur(0px)`,\n    },\n  }\n  const combinedVariants = variant || defaultVariants\n  return (\n    <AnimatePresence>\n      <motion.div\n        ref={ref}\n        initial=\"hidden\"\n        animate={isInView ? \"visible\" : \"hidden\"}\n        exit=\"hidden\"\n        variants={combinedVariants}\n        transition={{\n          delay: 0.04 + delay,\n          duration,\n          ease: \"easeOut\",\n        }}\n        className={className}\n        {...props}\n      >\n        {children}\n      </motion.div>\n    </AnimatePresence>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "border-beam",
      "type": "component",
      "description": "An animated beam of light which travels along the border of its container.",
      "category": "animations",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/border-beam.tsx",
          "content": "\"use client\"\n\nimport { motion, MotionStyle, Transition } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface BorderBeamProps {\n  /**\n   * The size of the border beam.\n   */\n  size?: number\n  /**\n   * The duration of the border beam.\n   */\n  duration?: number\n  /**\n   * The delay of the border beam.\n   */\n  delay?: number\n  /**\n   * The color of the border beam from.\n   */\n  colorFrom?: string\n  /**\n   * The color of the border beam to.\n   */\n  colorTo?: string\n  /**\n   * The motion transition of the border beam.\n   */\n  transition?: Transition\n  /**\n   * The class name of the border beam.\n   */\n  className?: string\n  /**\n   * The style of the border beam.\n   */\n  style?: React.CSSProperties\n  /**\n   * Whether to reverse the animation direction.\n   */\n  reverse?: boolean\n  /**\n   * The initial offset position (0-100).\n   */\n  initialOffset?: number\n  /**\n   * The border width of the beam.\n   */\n  borderWidth?: number\n}\n\nexport const BorderBeam = ({\n  className,\n  size = 50,\n  delay = 0,\n  duration = 6,\n  colorFrom = \"#ffaa40\",\n  colorTo = \"#9c40ff\",\n  transition,\n  style,\n  reverse = false,\n  initialOffset = 0,\n  borderWidth = 1,\n}: BorderBeamProps) => {\n  return (\n    <div\n      className=\"pointer-events-none absolute inset-0 rounded-[inherit] border-(length:--border-beam-width) border-transparent mask-[linear-gradient(transparent,transparent),linear-gradient(#000,#000)] mask-intersect [mask-clip:padding-box,border-box]\"\n      style={\n        {\n          \"--border-beam-width\": `${borderWidth}px`,\n        } as React.CSSProperties\n      }\n    >\n      <motion.div\n        className={cn(\n          \"absolute aspect-square\",\n          \"bg-linear-to-l from-(--color-from) via-(--color-to) to-transparent\",\n          className\n        )}\n        style={\n          {\n            width: size,\n            offsetPath: `rect(0 auto auto 0 round ${size}px)`,\n            \"--color-from\": colorFrom,\n            \"--color-to\": colorTo,\n            ...style,\n          } as MotionStyle\n        }\n        initial={{ offsetDistance: `${initialOffset}%` }}\n        animate={{\n          offsetDistance: reverse\n            ? [`${100 - initialOffset}%`, `${-initialOffset}%`]\n            : [`${initialOffset}%`, `${100 + initialOffset}%`],\n        }}\n        transition={{\n          repeat: Infinity,\n          ease: \"linear\",\n          duration,\n          delay: -delay,\n          ...transition,\n        }}\n      />\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "click-spark",
      "type": "component",
      "description": "Spark effect on click events.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/click-spark.tsx",
          "content": "import React, { useRef, useEffect, useCallback } from 'react';\n\ninterface ClickSparkProps {\n  sparkColor?: string;\n  sparkSize?: number;\n  sparkRadius?: number;\n  sparkCount?: number;\n  duration?: number;\n  easing?: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out';\n  extraScale?: number;\n  children?: React.ReactNode;\n}\n\ninterface Spark {\n  x: number;\n  y: number;\n  angle: number;\n  startTime: number;\n}\n\nconst ClickSpark: React.FC<ClickSparkProps> = ({\n  sparkColor = '#fff',\n  sparkSize = 10,\n  sparkRadius = 15,\n  sparkCount = 8,\n  duration = 400,\n  easing = 'ease-out',\n  extraScale = 1.0,\n  children\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const sparksRef = useRef<Spark[]>([]);\n  const startTimeRef = useRef<number | null>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const parent = canvas.parentElement;\n    if (!parent) return;\n\n    let resizeTimeout: ReturnType<typeof setTimeout>;\n\n    const resizeCanvas = () => {\n      const { width, height } = parent.getBoundingClientRect();\n      if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n      }\n    };\n\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(resizeCanvas, 100);\n    };\n\n    const ro = new ResizeObserver(handleResize);\n    ro.observe(parent);\n\n    resizeCanvas();\n\n    return () => {\n      ro.disconnect();\n      clearTimeout(resizeTimeout);\n    };\n  }, []);\n\n  const easeFunc = useCallback(\n    (t: number) => {\n      switch (easing) {\n        case 'linear':\n          return t;\n        case 'ease-in':\n          return t * t;\n        case 'ease-in-out':\n          return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        default:\n          return t * (2 - t);\n      }\n    },\n    [easing]\n  );\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    let animationId: number;\n\n    const draw = (timestamp: number) => {\n      if (!startTimeRef.current) {\n        startTimeRef.current = timestamp;\n      }\n      ctx?.clearRect(0, 0, canvas.width, canvas.height);\n\n      sparksRef.current = sparksRef.current.filter((spark: Spark) => {\n        const elapsed = timestamp - spark.startTime;\n        if (elapsed >= duration) {\n          return false;\n        }\n\n        const progress = elapsed / duration;\n        const eased = easeFunc(progress);\n\n        const distance = eased * sparkRadius * extraScale;\n        const lineLength = sparkSize * (1 - eased);\n\n        const x1 = spark.x + distance * Math.cos(spark.angle);\n        const y1 = spark.y + distance * Math.sin(spark.angle);\n        const x2 = spark.x + (distance + lineLength) * Math.cos(spark.angle);\n        const y2 = spark.y + (distance + lineLength) * Math.sin(spark.angle);\n\n        ctx.strokeStyle = sparkColor;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n\n        return true;\n      });\n\n      animationId = requestAnimationFrame(draw);\n    };\n\n    animationId = requestAnimationFrame(draw);\n\n    return () => {\n      cancelAnimationFrame(animationId);\n    };\n  }, [sparkColor, sparkSize, sparkRadius, sparkCount, duration, easeFunc, extraScale]);\n\n  const handleClick = (e: React.MouseEvent<HTMLDivElement>): void => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const now = performance.now();\n    const newSparks: Spark[] = Array.from({ length: sparkCount }, (_, i) => ({\n      x,\n      y,\n      angle: (2 * Math.PI * i) / sparkCount,\n      startTime: now\n    }));\n\n    sparksRef.current.push(...newSparks);\n  };\n\n  return (\n    <div className=\"relative w-full h-full\" onClick={handleClick}>\n      <canvas ref={canvasRef} className=\"absolute inset-0 pointer-events-none\" />\n      {children}\n    </div>\n  );\n};\n\nexport default ClickSpark;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "confetti",
      "type": "component",
      "description": "Confetti animations for delightful user experiences",
      "category": "animations",
      "dependencies": [
        "canvas-confetti"
      ],
      "files": [
        {
          "path": "components/ui/confetti.tsx",
          "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport React, {\n  createContext,\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n} from \"react\"\nimport type {\n  GlobalOptions as ConfettiGlobalOptions,\n  CreateTypes as ConfettiInstance,\n  Options as ConfettiOptions,\n} from \"canvas-confetti\"\nimport confetti from \"canvas-confetti\"\n\n\n\ntype Api = {\n  fire: (options?: ConfettiOptions) => void\n}\n\ntype Props = React.ComponentPropsWithRef<\"canvas\"> & {\n  options?: ConfettiOptions\n  globalOptions?: ConfettiGlobalOptions\n  manualstart?: boolean\n  children?: ReactNode\n}\n\nexport type ConfettiRef = Api | null\n\nconst ConfettiContext = createContext<Api>({} as Api)\n\n// Define component first\nconst ConfettiComponent = forwardRef<ConfettiRef, Props>((props, ref) => {\n  const {\n    options,\n    globalOptions = { resize: true, useWorker: true },\n    manualstart = false,\n    children,\n    ...rest\n  } = props\n  const instanceRef = useRef<ConfettiInstance | null>(null)\n\n  const canvasRef = useCallback(\n    (node: HTMLCanvasElement) => {\n      if (node !== null) {\n        if (instanceRef.current) return\n        instanceRef.current = confetti.create(node, {\n          ...globalOptions,\n          resize: true,\n        })\n      } else {\n        if (instanceRef.current) {\n          instanceRef.current.reset()\n          instanceRef.current = null\n        }\n      }\n    },\n    [globalOptions]\n  )\n\n  const fire = useCallback(\n    async (opts = {}) => {\n      try {\n        await instanceRef.current?.({ ...options, ...opts })\n      } catch (error) {\n        console.error(\"Confetti error:\", error)\n      }\n    },\n    [options]\n  )\n\n  const api = useMemo(\n    () => ({\n      fire,\n    }),\n    [fire]\n  )\n\n  useImperativeHandle(ref, () => api, [api])\n\n  useEffect(() => {\n    if (!manualstart) {\n      ;(async () => {\n        try {\n          await fire()\n        } catch (error) {\n          console.error(\"Confetti effect error:\", error)\n        }\n      })()\n    }\n  }, [manualstart, fire])\n\n  return (\n    <ConfettiContext.Provider value={api}>\n      <canvas ref={canvasRef} {...rest} />\n      {children}\n    </ConfettiContext.Provider>\n  )\n})\n\n// Set display name immediately\nConfettiComponent.displayName = \"Confetti\"\n\n// Export as Confetti\nexport const Confetti = ConfettiComponent\n\ninterface ConfettiButtonProps extends React.ComponentProps<\"button\"> {\n  options?: ConfettiOptions &\n    ConfettiGlobalOptions & { canvas?: HTMLCanvasElement }\n}\n\nconst ConfettiButtonComponent = ({\n  options,\n  children,\n  ...props\n}: ConfettiButtonProps) => {\n  const handleClick = async (event: React.MouseEvent<HTMLButtonElement>) => {\n    try {\n      const rect = event.currentTarget.getBoundingClientRect()\n      const x = rect.left + rect.width / 2\n      const y = rect.top + rect.height / 2\n      await confetti({\n        ...options,\n        origin: {\n          x: x / window.innerWidth,\n          y: y / window.innerHeight,\n        },\n      })\n    } catch (error) {\n      console.error(\"Confetti button error:\", error)\n    }\n  }\n\n  return (\n    <button onClick={handleClick} {...props}>\n      {children}\n    </button>\n  )\n}\n\nConfettiButtonComponent.displayName = \"ConfettiButton\"\n\nexport const ConfettiButton = ConfettiButtonComponent\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "cool-mode",
      "type": "component",
      "description": "Cool mode effect for buttons, links, and other DOMs",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/cool-mode.tsx",
          "content": "\"use client\"\n\nimport React, { ReactNode, useEffect, useRef } from \"react\"\n\nexport interface BaseParticle {\n  element: HTMLElement | SVGSVGElement\n  left: number\n  size: number\n  top: number\n}\n\nexport interface BaseParticleOptions {\n  particle?: string\n  size?: number\n}\n\nexport interface CoolParticle extends BaseParticle {\n  direction: number\n  speedHorz: number\n  speedUp: number\n  spinSpeed: number\n  spinVal: number\n}\n\nexport interface CoolParticleOptions extends BaseParticleOptions {\n  particleCount?: number\n  speedHorz?: number\n  speedUp?: number\n}\n\nconst getContainer = () => {\n  const id = \"_coolMode_effect\"\n  const existingContainer = document.getElementById(id)\n\n  if (existingContainer) {\n    return existingContainer\n  }\n\n  const container = document.createElement(\"div\")\n  container.setAttribute(\"id\", id)\n  container.setAttribute(\n    \"style\",\n    \"overflow:hidden; position:fixed; height:100%; top:0; left:0; right:0; bottom:0; pointer-events:none; z-index:2147483647\"\n  )\n\n  document.body.appendChild(container)\n\n  return container\n}\n\nlet instanceCounter = 0\n\nconst applyParticleEffect = (\n  element: HTMLElement,\n  options?: CoolParticleOptions\n): (() => void) => {\n  instanceCounter++\n\n  const defaultParticle = \"circle\"\n  const particleType = options?.particle || defaultParticle\n  const sizes = [15, 20, 25, 35, 45]\n  const limit = 45\n\n  let particles: CoolParticle[] = []\n  let autoAddParticle = false\n  let mouseX = 0\n  let mouseY = 0\n\n  const container = getContainer()\n\n  function generateParticle() {\n    const size =\n      options?.size || sizes[Math.floor(Math.random() * sizes.length)]\n    const speedHorz = options?.speedHorz || Math.random() * 10\n    const speedUp = options?.speedUp || Math.random() * 25\n    const spinVal = Math.random() * 360\n    const spinSpeed = Math.random() * 35 * (Math.random() <= 0.5 ? -1 : 1)\n    const top = mouseY - size / 2\n    const left = mouseX - size / 2\n    const direction = Math.random() <= 0.5 ? -1 : 1\n\n    const particle = document.createElement(\"div\")\n\n    if (particleType === \"circle\") {\n      const svgNS = \"http://www.w3.org/2000/svg\"\n      const circleSVG = document.createElementNS(svgNS, \"svg\")\n      const circle = document.createElementNS(svgNS, \"circle\")\n      circle.setAttributeNS(null, \"cx\", (size / 2).toString())\n      circle.setAttributeNS(null, \"cy\", (size / 2).toString())\n      circle.setAttributeNS(null, \"r\", (size / 2).toString())\n      circle.setAttributeNS(\n        null,\n        \"fill\",\n        `hsl(${Math.random() * 360}, 70%, 50%)`\n      )\n\n      circleSVG.appendChild(circle)\n      circleSVG.setAttribute(\"width\", size.toString())\n      circleSVG.setAttribute(\"height\", size.toString())\n\n      particle.appendChild(circleSVG)\n    } else if (\n      particleType.startsWith(\"http\") ||\n      particleType.startsWith(\"/\")\n    ) {\n      // Handle URL-based images\n      particle.innerHTML = `<img src=\"${particleType}\" width=\"${size}\" height=\"${size}\" style=\"border-radius: 50%\">`\n    } else {\n      // Handle emoji or text characters\n      const fontSizeMultiplier = 3 // Make emojis 3x bigger\n      const emojiSize = size * fontSizeMultiplier\n      particle.innerHTML = `<div style=\"font-size: ${emojiSize}px; line-height: 1; text-align: center; width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center; transform: scale(${fontSizeMultiplier}); transform-origin: center;\">${particleType}</div>`\n    }\n\n    particle.style.position = \"absolute\"\n    particle.style.transform = `translate3d(${left}px, ${top}px, 0px) rotate(${spinVal}deg)`\n\n    container.appendChild(particle)\n\n    particles.push({\n      direction,\n      element: particle,\n      left,\n      size,\n      speedHorz,\n      speedUp,\n      spinSpeed,\n      spinVal,\n      top,\n    })\n  }\n\n  function refreshParticles() {\n    particles.forEach((p) => {\n      p.left = p.left - p.speedHorz * p.direction\n      p.top = p.top - p.speedUp\n      p.speedUp = Math.min(p.size, p.speedUp - 1)\n      p.spinVal = p.spinVal + p.spinSpeed\n\n      if (\n        p.top >=\n        Math.max(window.innerHeight, document.body.clientHeight) + p.size\n      ) {\n        particles = particles.filter((o) => o !== p)\n        p.element.remove()\n      }\n\n      p.element.setAttribute(\n        \"style\",\n        [\n          \"position:absolute\",\n          \"will-change:transform\",\n          `top:${p.top}px`,\n          `left:${p.left}px`,\n          `transform:rotate(${p.spinVal}deg)`,\n        ].join(\";\")\n      )\n    })\n  }\n\n  let animationFrame: number | undefined\n\n  let lastParticleTimestamp = 0\n  const particleGenerationDelay = 30\n\n  function loop() {\n    const currentTime = performance.now()\n    if (\n      autoAddParticle &&\n      particles.length < limit &&\n      currentTime - lastParticleTimestamp > particleGenerationDelay\n    ) {\n      generateParticle()\n      lastParticleTimestamp = currentTime\n    }\n\n    refreshParticles()\n    animationFrame = requestAnimationFrame(loop)\n  }\n\n  loop()\n\n  const isTouchInteraction = \"ontouchstart\" in window\n\n  const tap = isTouchInteraction ? \"touchstart\" : \"mousedown\"\n  const tapEnd = isTouchInteraction ? \"touchend\" : \"mouseup\"\n  const move = isTouchInteraction ? \"touchmove\" : \"mousemove\"\n\n  const updateMousePosition = (e: MouseEvent | TouchEvent) => {\n    if (\"touches\" in e) {\n      mouseX = e.touches?.[0].clientX\n      mouseY = e.touches?.[0].clientY\n    } else {\n      mouseX = e.clientX\n      mouseY = e.clientY\n    }\n  }\n\n  const tapHandler = (e: MouseEvent | TouchEvent) => {\n    updateMousePosition(e)\n    autoAddParticle = true\n  }\n\n  const disableAutoAddParticle = () => {\n    autoAddParticle = false\n  }\n\n  element.addEventListener(move, updateMousePosition, { passive: true })\n  element.addEventListener(tap, tapHandler, { passive: true })\n  element.addEventListener(tapEnd, disableAutoAddParticle, { passive: true })\n  element.addEventListener(\"mouseleave\", disableAutoAddParticle, {\n    passive: true,\n  })\n\n  return () => {\n    element.removeEventListener(move, updateMousePosition)\n    element.removeEventListener(tap, tapHandler)\n    element.removeEventListener(tapEnd, disableAutoAddParticle)\n    element.removeEventListener(\"mouseleave\", disableAutoAddParticle)\n\n    const interval = setInterval(() => {\n      if (animationFrame && particles.length === 0) {\n        cancelAnimationFrame(animationFrame)\n        clearInterval(interval)\n\n        if (--instanceCounter === 0) {\n          container.remove()\n        }\n      }\n    }, 500)\n  }\n}\n\ninterface CoolModeProps {\n  children: ReactNode\n  options?: CoolParticleOptions\n}\n\nexport const CoolMode: React.FC<CoolModeProps> = ({ children, options }) => {\n  const ref = useRef<HTMLSpanElement>(null)\n\n  useEffect(() => {\n    if (ref.current) {\n      return applyParticleEffect(ref.current, options)\n    }\n  }, [options])\n\n  return <span ref={ref}>{children}</span>\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "crosshair",
      "type": "component",
      "description": "A crosshair cursor effect.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/crosshair.tsx",
          "content": "import React, { useEffect, useRef, RefObject } from 'react';\nimport { gsap } from 'gsap';\n\nconst lerp = (a: number, b: number, n: number): number => (1 - n) * a + n * b;\n\nconst getMousePos = (e: Event, container?: HTMLElement | null): { x: number; y: number } => {\n  const mouseEvent = e as MouseEvent;\n  if (container) {\n    const bounds = container.getBoundingClientRect();\n    return {\n      x: mouseEvent.clientX - bounds.left,\n      y: mouseEvent.clientY - bounds.top\n    };\n  }\n  return { x: mouseEvent.clientX, y: mouseEvent.clientY };\n};\n\ninterface CrosshairProps {\n  color?: string;\n  containerRef?: RefObject<HTMLElement>;\n}\n\nconst Crosshair: React.FC<CrosshairProps> = ({ color = 'white', containerRef = null }) => {\n  const cursorRef = useRef<HTMLDivElement>(null);\n  const lineHorizontalRef = useRef<HTMLDivElement>(null);\n  const lineVerticalRef = useRef<HTMLDivElement>(null);\n  const filterXRef = useRef<SVGFETurbulenceElement>(null);\n  const filterYRef = useRef<SVGFETurbulenceElement>(null);\n\n  let mouse = { x: 0, y: 0 };\n\n  useEffect(() => {\n    const handleMouseMove = (ev: Event) => {\n      const mouseEvent = ev as MouseEvent;\n      mouse = getMousePos(mouseEvent, containerRef?.current);\n      if (containerRef?.current) {\n        const bounds = containerRef.current.getBoundingClientRect();\n        if (\n          mouseEvent.clientX < bounds.left ||\n          mouseEvent.clientX > bounds.right ||\n          mouseEvent.clientY < bounds.top ||\n          mouseEvent.clientY > bounds.bottom\n        ) {\n          gsap.to([lineHorizontalRef.current, lineVerticalRef.current].filter(Boolean), { opacity: 0 });\n        } else {\n          gsap.to([lineHorizontalRef.current, lineVerticalRef.current].filter(Boolean), { opacity: 1 });\n        }\n      }\n    };\n\n    const target: HTMLElement | Window = containerRef?.current || window;\n    target.addEventListener('mousemove', handleMouseMove);\n\n    const renderedStyles: {\n      [key: string]: { previous: number; current: number; amt: number };\n    } = {\n      tx: { previous: 0, current: 0, amt: 0.15 },\n      ty: { previous: 0, current: 0, amt: 0.15 }\n    };\n\n    gsap.set([lineHorizontalRef.current, lineVerticalRef.current].filter(Boolean), { opacity: 0 });\n\n    const onMouseMove = (_ev: Event) => {\n      renderedStyles.tx.previous = renderedStyles.tx.current = mouse.x;\n      renderedStyles.ty.previous = renderedStyles.ty.current = mouse.y;\n\n      gsap.to([lineHorizontalRef.current, lineVerticalRef.current].filter(Boolean), {\n        duration: 0.9,\n        ease: 'Power3.easeOut',\n        opacity: 1\n      });\n\n      requestAnimationFrame(render);\n\n      target.removeEventListener('mousemove', onMouseMove);\n    };\n\n    target.addEventListener('mousemove', onMouseMove);\n\n    const primitiveValues = { turbulence: 0 };\n\n    const tl = gsap\n      .timeline({\n        paused: true,\n        onStart: () => {\n          if (lineHorizontalRef.current) {\n            lineHorizontalRef.current.style.filter = 'url(#filter-noise-x)';\n          }\n          if (lineVerticalRef.current) {\n            lineVerticalRef.current.style.filter = 'url(#filter-noise-y)';\n          }\n        },\n        onUpdate: () => {\n          if (filterXRef.current && filterYRef.current) {\n            filterXRef.current.setAttribute('baseFrequency', primitiveValues.turbulence.toString());\n            filterYRef.current.setAttribute('baseFrequency', primitiveValues.turbulence.toString());\n          }\n        },\n        onComplete: () => {\n          if (lineHorizontalRef.current && lineVerticalRef.current) {\n            lineHorizontalRef.current.style.filter = 'none';\n            lineVerticalRef.current.style.filter = 'none';\n          }\n        }\n      })\n      .to(primitiveValues, {\n        duration: 0.5,\n        ease: 'power1',\n        startAt: { turbulence: 1 },\n        turbulence: 0\n      });\n\n    const enter = () => tl.restart();\n    const leave = () => {\n      tl.progress(1).kill();\n    };\n\n    const render = () => {\n      renderedStyles.tx.current = mouse.x;\n      renderedStyles.ty.current = mouse.y;\n\n      for (const key in renderedStyles) {\n        const style = renderedStyles[key];\n        style.previous = lerp(style.previous, style.current, style.amt);\n      }\n\n      if (lineHorizontalRef.current && lineVerticalRef.current) {\n        gsap.set(lineVerticalRef.current, { x: renderedStyles.tx.previous });\n        gsap.set(lineHorizontalRef.current, { y: renderedStyles.ty.previous });\n      }\n\n      requestAnimationFrame(render);\n    };\n\n    const links: NodeListOf<HTMLAnchorElement> = containerRef?.current\n      ? containerRef.current.querySelectorAll('a')\n      : document.querySelectorAll('a');\n\n    links.forEach(link => {\n      link.addEventListener('mouseenter', enter);\n      link.addEventListener('mouseleave', leave);\n    });\n\n    return () => {\n      target.removeEventListener('mousemove', handleMouseMove);\n      target.removeEventListener('mousemove', onMouseMove);\n      links.forEach(link => {\n        link.removeEventListener('mouseenter', enter);\n        link.removeEventListener('mouseleave', leave);\n      });\n    };\n  }, [containerRef]);\n\n  return (\n    <div\n      ref={cursorRef}\n      className={`${containerRef ? 'absolute' : 'fixed'} top-0 left-0 w-full h-full pointer-events-none z-[10000]`}\n    >\n      <svg className=\"absolute top-0 left-0 w-full h-full\">\n        <defs>\n          <filter id=\"filter-noise-x\">\n            <feTurbulence type=\"fractalNoise\" baseFrequency=\"0.000001\" numOctaves=\"1\" ref={filterXRef} />\n            <feDisplacementMap in=\"SourceGraphic\" scale=\"40\" />\n          </filter>\n          <filter id=\"filter-noise-y\">\n            <feTurbulence type=\"fractalNoise\" baseFrequency=\"0.000001\" numOctaves=\"1\" ref={filterYRef} />\n            <feDisplacementMap in=\"SourceGraphic\" scale=\"40\" />\n          </filter>\n        </defs>\n      </svg>\n      <div\n        ref={lineHorizontalRef}\n        className={`absolute w-full h-px pointer-events-none opacity-0 transform translate-y-1/2`}\n        style={{ background: color }}\n      ></div>\n      <div\n        ref={lineVerticalRef}\n        className={`absolute h-full w-px pointer-events-none opacity-0 transform translate-x-1/2`}\n        style={{ background: color }}\n      ></div>\n    </div>\n  );\n};\n\nexport default Crosshair;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "cubes",
      "type": "component",
      "description": "3D cube animation effect.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/cubes.tsx",
          "content": "import React, { useCallback, useEffect, useRef } from 'react';\nimport gsap from 'gsap';\n\ninterface Gap {\n  row: number;\n  col: number;\n}\ninterface Duration {\n  enter: number;\n  leave: number;\n}\n\nexport interface CubesProps {\n  gridSize?: number;\n  cubeSize?: number;\n  maxAngle?: number;\n  radius?: number;\n  easing?: gsap.EaseString;\n  duration?: Duration;\n  cellGap?: number | Gap;\n  borderStyle?: string;\n  faceColor?: string;\n  shadow?: boolean | string;\n  autoAnimate?: boolean;\n  rippleOnClick?: boolean;\n  rippleColor?: string;\n  rippleSpeed?: number;\n}\n\nconst Cubes: React.FC<CubesProps> = ({\n  gridSize = 10,\n  cubeSize,\n  maxAngle = 45,\n  radius = 3,\n  easing = 'power3.out',\n  duration = { enter: 0.3, leave: 0.6 },\n  cellGap,\n  borderStyle = '1px solid #fff',\n  faceColor = '#060010',\n  shadow = false,\n  autoAnimate = true,\n  rippleOnClick = true,\n  rippleColor = '#fff',\n  rippleSpeed = 2\n}) => {\n  const sceneRef = useRef<HTMLDivElement | null>(null);\n  const rafRef = useRef<number | null>(null);\n  const idleTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const userActiveRef = useRef(false);\n  const simPosRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });\n  const simTargetRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });\n  const simRAFRef = useRef<number | null>(null);\n\n  const colGap =\n    typeof cellGap === 'number'\n      ? `${cellGap}px`\n      : (cellGap as Gap)?.col !== undefined\n        ? `${(cellGap as Gap).col}px`\n        : '5%';\n  const rowGap =\n    typeof cellGap === 'number'\n      ? `${cellGap}px`\n      : (cellGap as Gap)?.row !== undefined\n        ? `${(cellGap as Gap).row}px`\n        : '5%';\n\n  const enterDur = duration.enter;\n  const leaveDur = duration.leave;\n\n  const tiltAt = useCallback(\n    (rowCenter: number, colCenter: number) => {\n      if (!sceneRef.current) return;\n      sceneRef.current.querySelectorAll<HTMLDivElement>('.cube').forEach(cube => {\n        const r = +cube.dataset.row!;\n        const c = +cube.dataset.col!;\n        const dist = Math.hypot(r - rowCenter, c - colCenter);\n        if (dist <= radius) {\n          const pct = 1 - dist / radius;\n          const angle = pct * maxAngle;\n          gsap.to(cube, {\n            duration: enterDur,\n            ease: easing,\n            overwrite: true,\n            rotateX: -angle,\n            rotateY: angle\n          });\n        } else {\n          gsap.to(cube, {\n            duration: leaveDur,\n            ease: 'power3.out',\n            overwrite: true,\n            rotateX: 0,\n            rotateY: 0\n          });\n        }\n      });\n    },\n    [radius, maxAngle, enterDur, leaveDur, easing]\n  );\n\n  const onPointerMove = useCallback(\n    (e: PointerEvent) => {\n      userActiveRef.current = true;\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\n\n      const rect = sceneRef.current!.getBoundingClientRect();\n      const cellW = rect.width / gridSize;\n      const cellH = rect.height / gridSize;\n      const colCenter = (e.clientX - rect.left) / cellW;\n      const rowCenter = (e.clientY - rect.top) / cellH;\n\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      rafRef.current = requestAnimationFrame(() => tiltAt(rowCenter, colCenter));\n\n      idleTimerRef.current = setTimeout(() => {\n        userActiveRef.current = false;\n      }, 3000);\n    },\n    [gridSize, tiltAt]\n  );\n\n  const resetAll = useCallback(() => {\n    if (!sceneRef.current) return;\n    sceneRef.current.querySelectorAll<HTMLDivElement>('.cube').forEach(cube =>\n      gsap.to(cube, {\n        duration: leaveDur,\n        rotateX: 0,\n        rotateY: 0,\n        ease: 'power3.out'\n      })\n    );\n  }, [leaveDur]);\n\n  const onTouchMove = useCallback(\n    (e: TouchEvent) => {\n      e.preventDefault();\n      userActiveRef.current = true;\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\n\n      const rect = sceneRef.current!.getBoundingClientRect();\n      const cellW = rect.width / gridSize;\n      const cellH = rect.height / gridSize;\n\n      const touch = e.touches[0];\n      const colCenter = (touch.clientX - rect.left) / cellW;\n      const rowCenter = (touch.clientY - rect.top) / cellH;\n\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      rafRef.current = requestAnimationFrame(() => tiltAt(rowCenter, colCenter));\n\n      idleTimerRef.current = setTimeout(() => {\n        userActiveRef.current = false;\n      }, 3000);\n    },\n    [gridSize, tiltAt]\n  );\n\n  const onTouchStart = useCallback(() => {\n    userActiveRef.current = true;\n  }, []);\n\n  const onTouchEnd = useCallback(() => {\n    if (!sceneRef.current) return;\n    resetAll();\n  }, [resetAll]);\n\n  const onClick = useCallback(\n    (e: MouseEvent | TouchEvent) => {\n      if (!rippleOnClick || !sceneRef.current) return;\n      const rect = sceneRef.current.getBoundingClientRect();\n      const cellW = rect.width / gridSize;\n      const cellH = rect.height / gridSize;\n\n      const clientX = (e as MouseEvent).clientX || ((e as TouchEvent).touches && (e as TouchEvent).touches[0].clientX);\n      const clientY = (e as MouseEvent).clientY || ((e as TouchEvent).touches && (e as TouchEvent).touches[0].clientY);\n\n      const colHit = Math.floor((clientX - rect.left) / cellW);\n      const rowHit = Math.floor((clientY - rect.top) / cellH);\n\n      const baseRingDelay = 0.15;\n      const baseAnimDur = 0.3;\n      const baseHold = 0.6;\n\n      const spreadDelay = baseRingDelay / rippleSpeed;\n      const animDuration = baseAnimDur / rippleSpeed;\n      const holdTime = baseHold / rippleSpeed;\n\n      const rings: Record<number, HTMLDivElement[]> = {};\n      sceneRef.current.querySelectorAll<HTMLDivElement>('.cube').forEach(cube => {\n        const r = +cube.dataset.row!;\n        const c = +cube.dataset.col!;\n        const dist = Math.hypot(r - rowHit, c - colHit);\n        const ring = Math.round(dist);\n        if (!rings[ring]) rings[ring] = [];\n        rings[ring].push(cube);\n      });\n\n      Object.keys(rings)\n        .map(Number)\n        .sort((a, b) => a - b)\n        .forEach(ring => {\n          const delay = ring * spreadDelay;\n          const faces = rings[ring].flatMap(cube => Array.from(cube.querySelectorAll<HTMLElement>('.cube-face')));\n\n          gsap.to(faces, {\n            backgroundColor: rippleColor,\n            duration: animDuration,\n            delay,\n            ease: 'power3.out'\n          });\n          gsap.to(faces, {\n            backgroundColor: faceColor,\n            duration: animDuration,\n            delay: delay + animDuration + holdTime,\n            ease: 'power3.out'\n          });\n        });\n    },\n    [rippleOnClick, gridSize, faceColor, rippleColor, rippleSpeed]\n  );\n\n  useEffect(() => {\n    if (!autoAnimate || !sceneRef.current) return;\n    simPosRef.current = {\n      x: Math.random() * gridSize,\n      y: Math.random() * gridSize\n    };\n    simTargetRef.current = {\n      x: Math.random() * gridSize,\n      y: Math.random() * gridSize\n    };\n    const speed = 0.02;\n    const loop = () => {\n      if (!userActiveRef.current) {\n        const pos = simPosRef.current;\n        const tgt = simTargetRef.current;\n        pos.x += (tgt.x - pos.x) * speed;\n        pos.y += (tgt.y - pos.y) * speed;\n        tiltAt(pos.y, pos.x);\n        if (Math.hypot(pos.x - tgt.x, pos.y - tgt.y) < 0.1) {\n          simTargetRef.current = {\n            x: Math.random() * gridSize,\n            y: Math.random() * gridSize\n          };\n        }\n      }\n      simRAFRef.current = requestAnimationFrame(loop);\n    };\n    simRAFRef.current = requestAnimationFrame(loop);\n    return () => {\n      if (simRAFRef.current != null) cancelAnimationFrame(simRAFRef.current);\n    };\n  }, [autoAnimate, gridSize, tiltAt]);\n\n  useEffect(() => {\n    const el = sceneRef.current;\n    if (!el) return;\n    el.addEventListener('pointermove', onPointerMove);\n    el.addEventListener('pointerleave', resetAll);\n    el.addEventListener('click', onClick);\n\n    el.addEventListener('touchmove', onTouchMove, { passive: false });\n    el.addEventListener('touchstart', onTouchStart, { passive: true });\n    el.addEventListener('touchend', onTouchEnd, { passive: true });\n\n    return () => {\n      el.removeEventListener('pointermove', onPointerMove);\n      el.removeEventListener('pointerleave', resetAll);\n      el.removeEventListener('click', onClick);\n\n      el.removeEventListener('touchmove', onTouchMove);\n      el.removeEventListener('touchstart', onTouchStart);\n      el.removeEventListener('touchend', onTouchEnd);\n\n      if (rafRef.current != null) cancelAnimationFrame(rafRef.current);\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\n    };\n  }, [onPointerMove, resetAll, onClick, onTouchMove, onTouchStart, onTouchEnd]);\n\n  const cells = Array.from({ length: gridSize });\n  const sceneStyle: React.CSSProperties = {\n    gridTemplateColumns: cubeSize ? `repeat(${gridSize}, ${cubeSize}px)` : `repeat(${gridSize}, 1fr)`,\n    gridTemplateRows: cubeSize ? `repeat(${gridSize}, ${cubeSize}px)` : `repeat(${gridSize}, 1fr)`,\n    columnGap: colGap,\n    rowGap: rowGap,\n    perspective: '99999999px',\n    gridAutoRows: '1fr'\n  };\n  const wrapperStyle = {\n    '--cube-face-border': borderStyle,\n    '--cube-face-bg': faceColor,\n    '--cube-face-shadow': shadow === true ? '0 0 6px rgba(0,0,0,.5)' : shadow || 'none',\n    ...(cubeSize\n      ? {\n          width: `${gridSize * cubeSize}px`,\n          height: `${gridSize * cubeSize}px`\n        }\n      : {})\n  } as React.CSSProperties;\n\n  return (\n    <div className=\"relative w-1/2 max-md:w-11/12 aspect-square\" style={wrapperStyle}>\n      <div ref={sceneRef} className=\"grid w-full h-full\" style={sceneStyle}>\n        {cells.map((_, r) =>\n          cells.map((__, c) => (\n            <div\n              key={`${r}-${c}`}\n              className=\"cube relative w-full h-full aspect-square [transform-style:preserve-3d]\"\n              data-row={r}\n              data-col={c}\n            >\n              <span className=\"absolute pointer-events-none -inset-9\" />\n\n              <div\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\n                style={{\n                  background: 'var(--cube-face-bg)',\n                  border: 'var(--cube-face-border)',\n                  boxShadow: 'var(--cube-face-shadow)',\n                  transform: 'translateY(-50%) rotateX(90deg)'\n                }}\n              />\n              <div\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\n                style={{\n                  background: 'var(--cube-face-bg)',\n                  border: 'var(--cube-face-border)',\n                  boxShadow: 'var(--cube-face-shadow)',\n                  transform: 'translateY(50%) rotateX(-90deg)'\n                }}\n              />\n              <div\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\n                style={{\n                  background: 'var(--cube-face-bg)',\n                  border: 'var(--cube-face-border)',\n                  boxShadow: 'var(--cube-face-shadow)',\n                  transform: 'translateX(-50%) rotateY(-90deg)'\n                }}\n              />\n              <div\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\n                style={{\n                  background: 'var(--cube-face-bg)',\n                  border: 'var(--cube-face-border)',\n                  boxShadow: 'var(--cube-face-shadow)',\n                  transform: 'translateX(50%) rotateY(90deg)'\n                }}\n              />\n              <div\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\n                style={{\n                  background: 'var(--cube-face-bg)',\n                  border: 'var(--cube-face-border)',\n                  boxShadow: 'var(--cube-face-shadow)',\n                  transform: 'rotateY(-90deg) translateX(50%) rotateY(90deg)'\n                }}\n              />\n              <div\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\n                style={{\n                  background: 'var(--cube-face-bg)',\n                  border: 'var(--cube-face-border)',\n                  boxShadow: 'var(--cube-face-shadow)',\n                  transform: 'rotateY(90deg) translateX(-50%) rotateY(-90deg)'\n                }}\n              />\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default Cubes;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "electric-border",
      "type": "component",
      "description": "An electric border animation effect.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/electric-border.tsx",
          "content": "import React, { useEffect, useRef, useCallback, CSSProperties, ReactNode } from 'react';\n\nfunction hexToRgba(hex: string, alpha: number = 1): string {\n  if (!hex) return `rgba(0,0,0,${alpha})`;\n  let h = hex.replace('#', '');\n  if (h.length === 3) {\n    h = h\n      .split('')\n      .map(c => c + c)\n      .join('');\n  }\n  const int = parseInt(h, 16);\n  const r = (int >> 16) & 255;\n  const g = (int >> 8) & 255;\n  const b = int & 255;\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\ninterface ElectricBorderProps {\n  children?: ReactNode;\n  color?: string;\n  speed?: number;\n  chaos?: number;\n  borderRadius?: number;\n  className?: string;\n  style?: CSSProperties;\n}\n\nconst ElectricBorder: React.FC<ElectricBorderProps> = ({\n  children,\n  color = '#5227FF',\n  speed = 1,\n  chaos = 0.12,\n  borderRadius = 24,\n  className,\n  style\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const animationRef = useRef<number | null>(null);\n  const timeRef = useRef(0);\n  const lastFrameTimeRef = useRef(0);\n\n  const random = useCallback((x: number): number => {\n    return (Math.sin(x * 12.9898) * 43758.5453) % 1;\n  }, []);\n\n  const noise2D = useCallback(\n    (x: number, y: number): number => {\n      const i = Math.floor(x);\n      const j = Math.floor(y);\n      const fx = x - i;\n      const fy = y - j;\n\n      const a = random(i + j * 57);\n      const b = random(i + 1 + j * 57);\n      const c = random(i + (j + 1) * 57);\n      const d = random(i + 1 + (j + 1) * 57);\n\n      const ux = fx * fx * (3.0 - 2.0 * fx);\n      const uy = fy * fy * (3.0 - 2.0 * fy);\n\n      return a * (1 - ux) * (1 - uy) + b * ux * (1 - uy) + c * (1 - ux) * uy + d * ux * uy;\n    },\n    [random]\n  );\n\n  const octavedNoise = useCallback(\n    (\n      x: number,\n      octaves: number,\n      lacunarity: number,\n      gain: number,\n      baseAmplitude: number,\n      baseFrequency: number,\n      time: number,\n      seed: number,\n      baseFlatness: number\n    ): number => {\n      let y = 0;\n      let amplitude = baseAmplitude;\n      let frequency = baseFrequency;\n\n      for (let i = 0; i < octaves; i++) {\n        let octaveAmplitude = amplitude;\n        if (i === 0) {\n          octaveAmplitude *= baseFlatness;\n        }\n        y += octaveAmplitude * noise2D(frequency * x + seed * 100, time * frequency * 0.3);\n        frequency *= lacunarity;\n        amplitude *= gain;\n      }\n\n      return y;\n    },\n    [noise2D]\n  );\n\n  const getCornerPoint = useCallback(\n    (\n      centerX: number,\n      centerY: number,\n      radius: number,\n      startAngle: number,\n      arcLength: number,\n      progress: number\n    ): { x: number; y: number } => {\n      const angle = startAngle + progress * arcLength;\n      return {\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle)\n      };\n    },\n    []\n  );\n\n  const getRoundedRectPoint = useCallback(\n    (t: number, left: number, top: number, width: number, height: number, radius: number): { x: number; y: number } => {\n      const straightWidth = width - 2 * radius;\n      const straightHeight = height - 2 * radius;\n      const cornerArc = (Math.PI * radius) / 2;\n      const totalPerimeter = 2 * straightWidth + 2 * straightHeight + 4 * cornerArc;\n      const distance = t * totalPerimeter;\n\n      let accumulated = 0;\n\n      if (distance <= accumulated + straightWidth) {\n        const progress = (distance - accumulated) / straightWidth;\n        return { x: left + radius + progress * straightWidth, y: top };\n      }\n      accumulated += straightWidth;\n\n      if (distance <= accumulated + cornerArc) {\n        const progress = (distance - accumulated) / cornerArc;\n        return getCornerPoint(left + width - radius, top + radius, radius, -Math.PI / 2, Math.PI / 2, progress);\n      }\n      accumulated += cornerArc;\n\n      if (distance <= accumulated + straightHeight) {\n        const progress = (distance - accumulated) / straightHeight;\n        return { x: left + width, y: top + radius + progress * straightHeight };\n      }\n      accumulated += straightHeight;\n\n      if (distance <= accumulated + cornerArc) {\n        const progress = (distance - accumulated) / cornerArc;\n        return getCornerPoint(left + width - radius, top + height - radius, radius, 0, Math.PI / 2, progress);\n      }\n      accumulated += cornerArc;\n\n      if (distance <= accumulated + straightWidth) {\n        const progress = (distance - accumulated) / straightWidth;\n        return { x: left + width - radius - progress * straightWidth, y: top + height };\n      }\n      accumulated += straightWidth;\n\n      if (distance <= accumulated + cornerArc) {\n        const progress = (distance - accumulated) / cornerArc;\n        return getCornerPoint(left + radius, top + height - radius, radius, Math.PI / 2, Math.PI / 2, progress);\n      }\n      accumulated += cornerArc;\n\n      if (distance <= accumulated + straightHeight) {\n        const progress = (distance - accumulated) / straightHeight;\n        return { x: left, y: top + height - radius - progress * straightHeight };\n      }\n      accumulated += straightHeight;\n\n      const progress = (distance - accumulated) / cornerArc;\n      return getCornerPoint(left + radius, top + radius, radius, Math.PI, Math.PI / 2, progress);\n    },\n    [getCornerPoint]\n  );\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    if (!canvas || !container) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    const octaves = 10;\n    const lacunarity = 1.6;\n    const gain = 0.7;\n    const amplitude = chaos;\n    const frequency = 10;\n    const baseFlatness = 0;\n    const displacement = 60;\n    const borderOffset = 60;\n\n    const updateSize = () => {\n      const rect = container.getBoundingClientRect();\n      const width = rect.width + borderOffset * 2;\n      const height = rect.height + borderOffset * 2;\n\n      const dpr = Math.min(window.devicePixelRatio || 1, 2);\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n      canvas.style.width = `${width}px`;\n      canvas.style.height = `${height}px`;\n      ctx.scale(dpr, dpr);\n\n      return { width, height };\n    };\n\n    let { width, height } = updateSize();\n\n    const drawElectricBorder = (currentTime: number) => {\n      if (!canvas || !ctx) return;\n\n      const deltaTime = (currentTime - lastFrameTimeRef.current) / 1000;\n      timeRef.current += deltaTime * speed;\n      lastFrameTimeRef.current = currentTime;\n\n      const dpr = Math.min(window.devicePixelRatio || 1, 2);\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.scale(dpr, dpr);\n\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 1;\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n\n      const scale = displacement;\n      const left = borderOffset;\n      const top = borderOffset;\n      const borderWidth = width - 2 * borderOffset;\n      const borderHeight = height - 2 * borderOffset;\n      const maxRadius = Math.min(borderWidth, borderHeight) / 2;\n      const radius = Math.min(borderRadius, maxRadius);\n\n      const approximatePerimeter = 2 * (borderWidth + borderHeight) + 2 * Math.PI * radius;\n      const sampleCount = Math.floor(approximatePerimeter / 2);\n\n      ctx.beginPath();\n\n      for (let i = 0; i <= sampleCount; i++) {\n        const progress = i / sampleCount;\n\n        const point = getRoundedRectPoint(progress, left, top, borderWidth, borderHeight, radius);\n\n        const xNoise = octavedNoise(\n          progress * 8,\n          octaves,\n          lacunarity,\n          gain,\n          amplitude,\n          frequency,\n          timeRef.current,\n          0,\n          baseFlatness\n        );\n        const yNoise = octavedNoise(\n          progress * 8,\n          octaves,\n          lacunarity,\n          gain,\n          amplitude,\n          frequency,\n          timeRef.current,\n          1,\n          baseFlatness\n        );\n\n        const displacedX = point.x + xNoise * scale;\n        const displacedY = point.y + yNoise * scale;\n\n        if (i === 0) {\n          ctx.moveTo(displacedX, displacedY);\n        } else {\n          ctx.lineTo(displacedX, displacedY);\n        }\n      }\n\n      ctx.closePath();\n      ctx.stroke();\n\n      animationRef.current = requestAnimationFrame(drawElectricBorder);\n    };\n\n    const resizeObserver = new ResizeObserver(() => {\n      const newSize = updateSize();\n      width = newSize.width;\n      height = newSize.height;\n    });\n    resizeObserver.observe(container);\n\n    animationRef.current = requestAnimationFrame(drawElectricBorder);\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n      resizeObserver.disconnect();\n    };\n  }, [color, speed, chaos, borderRadius, octavedNoise, getRoundedRectPoint]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`relative overflow-visible isolate ${className ?? ''}`}\n      style={{ '--electric-border-color': color, borderRadius, ...style } as CSSProperties}\n    >\n      <div className=\"absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none z-[2]\">\n        <canvas ref={canvasRef} className=\"block\" />\n      </div>\n      <div className=\"absolute inset-0 rounded-[inherit] pointer-events-none z-0\">\n        <div\n          className=\"absolute inset-0 rounded-[inherit] pointer-events-none\"\n          style={{ border: `2px solid ${hexToRgba(color, 0.6)}`, filter: 'blur(1px)' }}\n        />\n        <div\n          className=\"absolute inset-0 rounded-[inherit] pointer-events-none\"\n          style={{ border: `2px solid ${color}`, filter: 'blur(4px)' }}\n        />\n        <div\n          className=\"absolute inset-0 rounded-[inherit] pointer-events-none -z-[1] scale-110 opacity-30\"\n          style={{\n            filter: 'blur(32px)',\n            background: `linear-gradient(-30deg, ${color}, transparent, ${color})`\n          }}\n        />\n      </div>\n      <div className=\"relative rounded-[inherit] z-[1]\">{children}</div>\n    </div>\n  );\n};\n\nexport default ElectricBorder;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "fade-content",
      "type": "component",
      "description": "Content with fade animation.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/fade-content.tsx",
          "content": "import * as React from 'react';\nimport { useRef, useEffect } from 'react';\nimport { gsap } from 'gsap';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\n\ngsap.registerPlugin(ScrollTrigger);\n\ninterface FadeContentProps extends React.HTMLAttributes<HTMLDivElement> {\n  children: React.ReactNode;\n  container?: Element | string | null;\n  blur?: boolean;\n  duration?: number;\n  ease?: string;\n  delay?: number;\n  threshold?: number;\n  initialOpacity?: number;\n  disappearAfter?: number;\n  disappearDuration?: number;\n  disappearEase?: string;\n  onComplete?: () => void;\n  onDisappearanceComplete?: () => void;\n}\n\nconst FadeContent: React.FC<FadeContentProps> = ({\n  children,\n  container,\n  blur = false,\n  duration = 1000,\n  ease = 'power2.out',\n  delay = 0,\n  threshold = 0.1,\n  initialOpacity = 0,\n  disappearAfter = 0,\n  disappearDuration = 0.5,\n  disappearEase = 'power2.in',\n  onComplete,\n  onDisappearanceComplete,\n  className = '',\n  ...props\n}) => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) return;\n\n    let scrollerTarget: Element | string | null = container || document.getElementById('snap-main-container') || null;\n\n    if (typeof scrollerTarget === 'string') {\n      scrollerTarget = document.querySelector(scrollerTarget);\n    }\n\n    const startPct = (1 - threshold) * 100;\n    const getSeconds = (val: number) => (val > 10 ? val / 1000 : val);\n\n    gsap.set(el, {\n      autoAlpha: initialOpacity,\n      filter: blur ? 'blur(10px)' : 'blur(0px)',\n      willChange: 'opacity, filter, transform'\n    });\n\n    const tl = gsap.timeline({\n      paused: true,\n      delay: getSeconds(delay),\n      onComplete: () => {\n        if (onComplete) onComplete();\n        if (disappearAfter > 0) {\n          gsap.to(el, {\n            autoAlpha: initialOpacity,\n            filter: blur ? 'blur(10px)' : 'blur(0px)',\n            delay: getSeconds(disappearAfter),\n            duration: getSeconds(disappearDuration),\n            ease: disappearEase,\n            onComplete: () => onDisappearanceComplete?.()\n          });\n        }\n      }\n    });\n\n    tl.to(el, {\n      autoAlpha: 1,\n      filter: 'blur(0px)',\n      duration: getSeconds(duration),\n      ease: ease\n    });\n\n    const st = ScrollTrigger.create({\n      trigger: el,\n      scroller: scrollerTarget || window,\n      start: `top ${startPct}%`,\n      once: true,\n      onEnter: () => tl.play()\n    });\n\n    return () => {\n      st.kill();\n      tl.kill();\n      gsap.killTweensOf(el);\n    };\n  }, []);\n\n  return (\n    <div ref={ref} className={className} {...props}>\n      {children}\n    </div>\n  );\n};\n\nexport default FadeContent;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "ghost-cursor",
      "type": "component",
      "description": "A ghost trail cursor effect.",
      "category": "animations",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/ghost-cursor.tsx",
          "content": "import React, { useEffect, useMemo, useRef } from 'react';\nimport * as THREE from 'three';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';\n\ntype GhostCursorProps = {\n  className?: string;\n  style?: React.CSSProperties;\n\n  trailLength?: number;\n  inertia?: number;\n  grainIntensity?: number;\n  bloomStrength?: number;\n  bloomRadius?: number;\n  bloomThreshold?: number;\n\n  brightness?: number;\n  color?: string;\n  mixBlendMode?: React.CSSProperties['mixBlendMode'];\n  edgeIntensity?: number;\n\n  maxDevicePixelRatio?: number;\n  targetPixels?: number;\n  fadeDelayMs?: number;\n  fadeDurationMs?: number;\n  zIndex?: number;\n};\n\nconst GhostCursor: React.FC<GhostCursorProps> = ({\n  className,\n  style,\n  trailLength = 50,\n  inertia = 0.5,\n  grainIntensity = 0.05,\n  bloomStrength = 0.1,\n  bloomRadius = 1.0,\n  bloomThreshold = 0.025,\n\n  brightness = 1,\n  color = '#B19EEF',\n  mixBlendMode = 'screen',\n  edgeIntensity = 0,\n\n  maxDevicePixelRatio = 0.5,\n  targetPixels,\n\n  fadeDelayMs,\n  fadeDurationMs,\n  zIndex = 10\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const composerRef = useRef<EffectComposer | null>(null);\n  const materialRef = useRef<THREE.ShaderMaterial | null>(null);\n  const bloomPassRef = useRef<UnrealBloomPass | null>(null);\n  const filmPassRef = useRef<ShaderPass | null>(null);\n\n  // Trail circular buffer\n  const trailBufRef = useRef<THREE.Vector2[]>([]);\n  const headRef = useRef(0);\n\n  const rafRef = useRef<number | null>(null);\n  const resizeObsRef = useRef<ResizeObserver | null>(null);\n  const currentMouseRef = useRef(new THREE.Vector2(0.5, 0.5));\n  const velocityRef = useRef(new THREE.Vector2(0, 0));\n  const fadeOpacityRef = useRef(1.0);\n  const lastMoveTimeRef = useRef(typeof performance !== 'undefined' ? performance.now() : Date.now());\n  const pointerActiveRef = useRef(false);\n  const runningRef = useRef(false);\n\n  const isTouch = useMemo(\n    () => typeof window !== 'undefined' && ('ontouchstart' in window || navigator.maxTouchPoints > 0),\n    []\n  );\n\n  const pixelBudget = targetPixels ?? (isTouch ? 0.9e6 : 1.3e6);\n  const fadeDelay = fadeDelayMs ?? (isTouch ? 500 : 1000);\n  const fadeDuration = fadeDurationMs ?? (isTouch ? 1000 : 1500);\n\n  const baseVertexShader = `\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 1.0);\n    }\n  `;\n\n  const fragmentShader = `\n    uniform float iTime;\n    uniform vec3  iResolution;\n    uniform vec2  iMouse;\n    uniform vec2  iPrevMouse[MAX_TRAIL_LENGTH];\n    uniform float iOpacity;\n    uniform float iScale;\n    uniform vec3  iBaseColor;\n    uniform float iBrightness;\n    uniform float iEdgeIntensity;\n    varying vec2  vUv;\n\n    float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123); }\n    float noise(vec2 p){\n      vec2 i = floor(p), f = fract(p);\n      f *= f * (3. - 2. * f);\n      return mix(mix(hash(i + vec2(0.,0.)), hash(i + vec2(1.,0.)), f.x),\n                 mix(hash(i + vec2(0.,1.)), hash(i + vec2(1.,1.)), f.x), f.y);\n    }\n    float fbm(vec2 p){\n      float v = 0.0;\n      float a = 0.5;\n      mat2 m = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n      for(int i=0;i<5;i++){\n        v += a * noise(p);\n        p = m * p * 2.0;\n        a *= 0.5;\n      }\n      return v;\n    }\n    vec3 tint1(vec3 base){ return mix(base, vec3(1.0), 0.15); }\n    vec3 tint2(vec3 base){ return mix(base, vec3(0.8, 0.9, 1.0), 0.25); }\n\n    vec4 blob(vec2 p, vec2 mousePos, float intensity, float activity) {\n      vec2 q = vec2(fbm(p * iScale + iTime * 0.1), fbm(p * iScale + vec2(5.2,1.3) + iTime * 0.1));\n      vec2 r = vec2(fbm(p * iScale + q * 1.5 + iTime * 0.15), fbm(p * iScale + q * 1.5 + vec2(8.3,2.8) + iTime * 0.15));\n\n      float smoke = fbm(p * iScale + r * 0.8);\n      float radius = 0.5 + 0.3 * (1.0 / iScale);\n      float distFactor = 1.0 - smoothstep(0.0, radius * activity, length(p - mousePos));\n      float alpha = pow(smoke, 2.5) * distFactor;\n\n      vec3 c1 = tint1(iBaseColor);\n      vec3 c2 = tint2(iBaseColor);\n      vec3 color = mix(c1, c2, sin(iTime * 0.5) * 0.5 + 0.5);\n\n      return vec4(color * alpha * intensity, alpha * intensity);\n    }\n\n    void main() {\n      vec2 uv = (gl_FragCoord.xy / iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n      vec2 mouse = (iMouse * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\n      vec3 colorAcc = vec3(0.0);\n      float alphaAcc = 0.0;\n\n      vec4 b = blob(uv, mouse, 1.0, iOpacity);\n      colorAcc += b.rgb;\n      alphaAcc += b.a;\n\n      for (int i = 0; i < MAX_TRAIL_LENGTH; i++) {\n        vec2 pm = (iPrevMouse[i] * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n        float t = 1.0 - float(i) / float(MAX_TRAIL_LENGTH);\n        t = pow(t, 2.0);\n        if (t > 0.01) {\n          vec4 bt = blob(uv, pm, t * 0.8, iOpacity);\n          colorAcc += bt.rgb;\n          alphaAcc += bt.a;\n        }\n      }\n\n      colorAcc *= iBrightness;\n\n      vec2 uv01 = gl_FragCoord.xy / iResolution.xy;\n      float edgeDist = min(min(uv01.x, 1.0 - uv01.x), min(uv01.y, 1.0 - uv01.y));\n      float distFromEdge = clamp(edgeDist * 2.0, 0.0, 1.0);\n      float k = clamp(iEdgeIntensity, 0.0, 1.0);\n      float edgeMask = mix(1.0 - k, 1.0, distFromEdge);\n\n      float outAlpha = clamp(alphaAcc * iOpacity * edgeMask, 0.0, 1.0);\n      gl_FragColor = vec4(colorAcc, outAlpha);\n    }\n  `;\n\n  const FilmGrainShader = useMemo(() => {\n    return {\n      uniforms: {\n        tDiffuse: { value: null },\n        iTime: { value: 0 },\n        intensity: { value: grainIntensity }\n      },\n      vertexShader: `\n        varying vec2 vUv;\n        void main(){\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform sampler2D tDiffuse;\n        uniform float iTime;\n        uniform float intensity;\n        varying vec2 vUv;\n\n        float hash1(float n){ return fract(sin(n)*43758.5453); }\n\n        void main(){\n          vec4 color = texture2D(tDiffuse, vUv);\n          float n = hash1(vUv.x*1000.0 + vUv.y*2000.0 + iTime) * 2.0 - 1.0;\n          color.rgb += n * intensity * color.rgb;\n          gl_FragColor = color;\n        }\n      `\n    };\n  }, [grainIntensity]);\n\n  const UnpremultiplyPass = useMemo(\n    () =>\n      new ShaderPass({\n        uniforms: { tDiffuse: { value: null } },\n        vertexShader: `\n          varying vec2 vUv;\n          void main(){\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          }\n        `,\n        fragmentShader: `\n          uniform sampler2D tDiffuse;\n          varying vec2 vUv;\n          void main(){\n            vec4 c = texture2D(tDiffuse, vUv);\n            float a = max(c.a, 1e-5);\n            vec3 straight = c.rgb / a;\n            gl_FragColor = vec4(clamp(straight, 0.0, 1.0), c.a);\n          }\n        `\n      }),\n    []\n  );\n\n  function calculateScale(el: HTMLElement) {\n    const r = el.getBoundingClientRect();\n    const base = 600;\n    const current = Math.min(Math.max(1, r.width), Math.max(1, r.height));\n    return Math.max(0.5, Math.min(2.0, current / base));\n  }\n\n  useEffect(() => {\n    const host = containerRef.current;\n    const parent = host?.parentElement;\n    if (!host || !parent) return;\n\n    const prevParentPos = parent.style.position;\n    if (!prevParentPos || prevParentPos === 'static') {\n      parent.style.position = 'relative';\n    }\n\n    const renderer = new THREE.WebGLRenderer({\n      antialias: !isTouch,\n      alpha: true,\n      depth: false,\n      stencil: false,\n      powerPreference: isTouch ? 'low-power' : 'high-performance',\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: false\n    });\n    renderer.setClearColor(0x000000, 0);\n    rendererRef.current = renderer;\n\n    renderer.domElement.style.pointerEvents = 'none';\n    if (mixBlendMode) {\n      renderer.domElement.style.mixBlendMode = String(mixBlendMode);\n    } else {\n      renderer.domElement.style.removeProperty('mix-blend-mode');\n    }\n\n    renderer.domElement.style.display = 'block';\n    renderer.domElement.style.width = '100%';\n    renderer.domElement.style.height = '100%';\n    renderer.domElement.style.background = 'transparent';\n\n    host.appendChild(renderer.domElement);\n\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n    const geom = new THREE.PlaneGeometry(2, 2);\n\n    const maxTrail = Math.max(1, Math.floor(trailLength));\n    trailBufRef.current = Array.from({ length: maxTrail }, () => new THREE.Vector2(0.5, 0.5));\n    headRef.current = 0;\n\n    const baseColor = new THREE.Color(color);\n\n    const material = new THREE.ShaderMaterial({\n      defines: { MAX_TRAIL_LENGTH: maxTrail },\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: { value: new THREE.Vector3(1, 1, 1) },\n        iMouse: { value: new THREE.Vector2(0.5, 0.5) },\n        iPrevMouse: { value: trailBufRef.current.map(v => v.clone()) },\n        iOpacity: { value: 1.0 },\n        iScale: { value: 1.0 },\n        iBaseColor: { value: new THREE.Vector3(baseColor.r, baseColor.g, baseColor.b) },\n        iBrightness: { value: brightness },\n        iEdgeIntensity: { value: edgeIntensity }\n      },\n      vertexShader: baseVertexShader,\n      fragmentShader,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false\n    });\n    materialRef.current = material;\n\n    const mesh = new THREE.Mesh(geom, material);\n    scene.add(mesh);\n\n    const composer = new EffectComposer(renderer);\n    composerRef.current = composer;\n\n    const renderPass = new RenderPass(scene, camera);\n    composer.addPass(renderPass);\n\n    const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), bloomStrength, bloomRadius, bloomThreshold);\n    bloomPassRef.current = bloomPass;\n    composer.addPass(bloomPass);\n\n    const filmPass = new ShaderPass(FilmGrainShader as any);\n    filmPassRef.current = filmPass;\n    composer.addPass(filmPass);\n\n    composer.addPass(UnpremultiplyPass);\n\n    const resize = () => {\n      const rect = host.getBoundingClientRect();\n      const cssW = Math.max(1, Math.floor(rect.width));\n      const cssH = Math.max(1, Math.floor(rect.height));\n\n      const currentDPR = Math.min(\n        typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n        maxDevicePixelRatio\n      );\n      const need = cssW * cssH * currentDPR * currentDPR;\n      const scale = need <= pixelBudget ? 1 : Math.max(0.5, Math.min(1, Math.sqrt(pixelBudget / Math.max(1, need))));\n      const pixelRatio = currentDPR * scale;\n\n      renderer.setPixelRatio(pixelRatio);\n      renderer.setSize(cssW, cssH, false);\n\n      composer.setPixelRatio?.(pixelRatio);\n      composer.setSize(cssW, cssH);\n\n      const wpx = Math.max(1, Math.floor(cssW * pixelRatio));\n      const hpx = Math.max(1, Math.floor(cssH * pixelRatio));\n      material.uniforms.iResolution.value.set(wpx, hpx, 1);\n      material.uniforms.iScale.value = calculateScale(host);\n      bloomPass.setSize(wpx, hpx);\n    };\n\n    resize();\n    const ro = new ResizeObserver(resize);\n    resizeObsRef.current = ro;\n    ro.observe(parent);\n    ro.observe(host);\n\n    const start = typeof performance !== 'undefined' ? performance.now() : Date.now();\n    const animate = () => {\n      const now = performance.now();\n      const t = (now - start) / 1000;\n\n      const mat = materialRef.current!;\n      const comp = composerRef.current!;\n\n      if (pointerActiveRef.current) {\n        velocityRef.current.set(\n          currentMouseRef.current.x - mat.uniforms.iMouse.value.x,\n          currentMouseRef.current.y - mat.uniforms.iMouse.value.y\n        );\n        mat.uniforms.iMouse.value.copy(currentMouseRef.current);\n        fadeOpacityRef.current = 1.0;\n      } else {\n        velocityRef.current.multiplyScalar(inertia);\n        if (velocityRef.current.lengthSq() > 1e-6) {\n          mat.uniforms.iMouse.value.add(velocityRef.current);\n        }\n        const dt = now - lastMoveTimeRef.current;\n        if (dt > fadeDelay) {\n          const k = Math.min(1, (dt - fadeDelay) / fadeDuration);\n          fadeOpacityRef.current = Math.max(0, 1 - k);\n        }\n      }\n\n      const N = trailBufRef.current.length;\n      headRef.current = (headRef.current + 1) % N;\n      trailBufRef.current[headRef.current].copy(mat.uniforms.iMouse.value);\n      const arr = mat.uniforms.iPrevMouse.value as THREE.Vector2[];\n      for (let i = 0; i < N; i++) {\n        const srcIdx = (headRef.current - i + N) % N;\n        arr[i].copy(trailBufRef.current[srcIdx]);\n      }\n\n      mat.uniforms.iOpacity.value = fadeOpacityRef.current;\n      mat.uniforms.iTime.value = t;\n\n      if (filmPassRef.current?.uniforms?.iTime) {\n        filmPassRef.current.uniforms.iTime.value = t;\n      }\n\n      comp.render();\n\n      if (!pointerActiveRef.current && fadeOpacityRef.current <= 0.001) {\n        runningRef.current = false;\n        rafRef.current = null;\n        return;\n      }\n\n      rafRef.current = requestAnimationFrame(animate);\n    };\n\n    const ensureLoop = () => {\n      if (!runningRef.current) {\n        runningRef.current = true;\n        rafRef.current = requestAnimationFrame(animate);\n      }\n    };\n\n    const onPointerMove = (e: PointerEvent) => {\n      const rect = parent.getBoundingClientRect();\n      const x = THREE.MathUtils.clamp((e.clientX - rect.left) / Math.max(1, rect.width), 0, 1);\n      const y = THREE.MathUtils.clamp(1 - (e.clientY - rect.top) / Math.max(1, rect.height), 0, 1);\n      currentMouseRef.current.set(x, y);\n      pointerActiveRef.current = true;\n      lastMoveTimeRef.current = performance.now();\n      ensureLoop();\n    };\n    const onPointerEnter = () => {\n      pointerActiveRef.current = true;\n      ensureLoop();\n    };\n    const onPointerLeave = () => {\n      pointerActiveRef.current = false;\n      lastMoveTimeRef.current = performance.now();\n      ensureLoop();\n    };\n\n    parent.addEventListener('pointermove', onPointerMove, { passive: true });\n    parent.addEventListener('pointerenter', onPointerEnter, { passive: true });\n    parent.addEventListener('pointerleave', onPointerLeave, { passive: true });\n\n    ensureLoop();\n\n    return () => {\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      runningRef.current = false;\n      rafRef.current = null;\n\n      parent.removeEventListener('pointermove', onPointerMove);\n      parent.removeEventListener('pointerenter', onPointerEnter);\n      parent.removeEventListener('pointerleave', onPointerLeave);\n      resizeObsRef.current?.disconnect();\n\n      scene.clear();\n      geom.dispose();\n      material.dispose();\n      composer.dispose();\n      renderer.dispose();\n\n      if (renderer.domElement && renderer.domElement.parentElement) {\n        renderer.domElement.parentElement.removeChild(renderer.domElement);\n      }\n      if (!prevParentPos || prevParentPos === 'static') {\n        parent.style.position = prevParentPos;\n      }\n    };\n  }, [\n    trailLength,\n    inertia,\n    grainIntensity,\n    bloomStrength,\n    bloomRadius,\n    bloomThreshold,\n    pixelBudget,\n    fadeDelay,\n    fadeDuration,\n    isTouch,\n    color,\n    brightness,\n    mixBlendMode,\n    edgeIntensity\n  ]);\n\n  useEffect(() => {\n    if (materialRef.current) {\n      const c = new THREE.Color(color);\n      (materialRef.current.uniforms.iBaseColor.value as THREE.Vector3).set(c.r, c.g, c.b);\n    }\n  }, [color]);\n\n  useEffect(() => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.iBrightness.value = brightness;\n    }\n  }, [brightness]);\n\n  useEffect(() => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.iEdgeIntensity.value = edgeIntensity;\n    }\n  }, [edgeIntensity]);\n\n  useEffect(() => {\n    if (filmPassRef.current?.uniforms?.intensity) {\n      filmPassRef.current.uniforms.intensity.value = grainIntensity;\n    }\n  }, [grainIntensity]);\n\n  useEffect(() => {\n    const el = rendererRef.current?.domElement;\n    if (!el) return;\n    if (mixBlendMode) {\n      el.style.mixBlendMode = String(mixBlendMode);\n    } else {\n      el.style.removeProperty('mix-blend-mode');\n    }\n  }, [mixBlendMode]);\n\n  const mergedStyle = useMemo<React.CSSProperties>(() => ({ zIndex, ...style }), [zIndex, style]);\n\n  return (\n    <div ref={containerRef} className={`pointer-events-none absolute inset-0 ${className ?? ''}`} style={mergedStyle} />\n  );\n};\n\nexport default GhostCursor;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "glare-hover",
      "type": "component",
      "description": "A glare effect on hover.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/glare-hover.tsx",
          "content": "import React, { useRef } from 'react';\n\ninterface GlareHoverProps {\n  width?: string;\n  height?: string;\n  background?: string;\n  borderRadius?: string;\n  borderColor?: string;\n  children?: React.ReactNode;\n  glareColor?: string;\n  glareOpacity?: number;\n  glareAngle?: number;\n  glareSize?: number;\n  transitionDuration?: number;\n  playOnce?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst GlareHover: React.FC<GlareHoverProps> = ({\n  width = '500px',\n  height = '500px',\n  background = '#000',\n  borderRadius = '10px',\n  borderColor = '#333',\n  children,\n  glareColor = '#ffffff',\n  glareOpacity = 0.5,\n  glareAngle = -45,\n  glareSize = 250,\n  transitionDuration = 650,\n  playOnce = false,\n  className = '',\n  style = {}\n}) => {\n  const hex = glareColor.replace('#', '');\n  let rgba = glareColor;\n  if (/^[\\dA-Fa-f]{6}$/.test(hex)) {\n    const r = parseInt(hex.slice(0, 2), 16);\n    const g = parseInt(hex.slice(2, 4), 16);\n    const b = parseInt(hex.slice(4, 6), 16);\n    rgba = `rgba(${r}, ${g}, ${b}, ${glareOpacity})`;\n  } else if (/^[\\dA-Fa-f]{3}$/.test(hex)) {\n    const r = parseInt(hex[0] + hex[0], 16);\n    const g = parseInt(hex[1] + hex[1], 16);\n    const b = parseInt(hex[2] + hex[2], 16);\n    rgba = `rgba(${r}, ${g}, ${b}, ${glareOpacity})`;\n  }\n\n  const overlayRef = useRef<HTMLDivElement | null>(null);\n\n  const animateIn = () => {\n    const el = overlayRef.current;\n    if (!el) return;\n\n    el.style.transition = 'none';\n    el.style.backgroundPosition = '-100% -100%, 0 0';\n    el.style.transition = `${transitionDuration}ms ease`;\n    el.style.backgroundPosition = '100% 100%, 0 0';\n  };\n\n  const animateOut = () => {\n    const el = overlayRef.current;\n    if (!el) return;\n\n    if (playOnce) {\n      el.style.transition = 'none';\n      el.style.backgroundPosition = '-100% -100%, 0 0';\n    } else {\n      el.style.transition = `${transitionDuration}ms ease`;\n      el.style.backgroundPosition = '-100% -100%, 0 0';\n    }\n  };\n\n  const overlayStyle: React.CSSProperties = {\n    position: 'absolute',\n    inset: 0,\n    background: `linear-gradient(${glareAngle}deg,\n        hsla(0,0%,0%,0) 60%,\n        ${rgba} 70%,\n        hsla(0,0%,0%,0) 100%)`,\n    backgroundSize: `${glareSize}% ${glareSize}%, 100% 100%`,\n    backgroundRepeat: 'no-repeat',\n    backgroundPosition: '-100% -100%, 0 0',\n    pointerEvents: 'none'\n  };\n\n  return (\n    <div\n      className={`relative grid place-items-center overflow-hidden border cursor-pointer ${className}`}\n      style={{\n        width,\n        height,\n        background,\n        borderRadius,\n        borderColor,\n        ...style\n      }}\n      onMouseEnter={animateIn}\n      onMouseLeave={animateOut}\n    >\n      <div ref={overlayRef} style={overlayStyle} />\n      {children}\n    </div>\n  );\n};\n\nexport default GlareHover;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "gradual-blur",
      "type": "component",
      "description": "Gradual blur animation effect.",
      "category": "animations",
      "dependencies": [
        "mathjs"
      ],
      "files": [
        {
          "path": "components/ui/gradual-blur.tsx",
          "content": "import React, { CSSProperties, useEffect, useRef, useState, useMemo, PropsWithChildren } from 'react';\nimport * as math from 'mathjs';\n\ntype GradualBlurProps = PropsWithChildren<{\n  position?: 'top' | 'bottom' | 'left' | 'right';\n  strength?: number;\n  height?: string;\n  width?: string;\n  divCount?: number;\n  exponential?: boolean;\n  zIndex?: number;\n  animated?: boolean | 'scroll';\n  duration?: string;\n  easing?: string;\n  opacity?: number;\n  curve?: 'linear' | 'bezier' | 'ease-in' | 'ease-out' | 'ease-in-out';\n  responsive?: boolean;\n  mobileHeight?: string;\n  tabletHeight?: string;\n  desktopHeight?: string;\n  mobileWidth?: string;\n  tabletWidth?: string;\n  desktopWidth?: string;\n\n  preset?:\n    | 'top'\n    | 'bottom'\n    | 'left'\n    | 'right'\n    | 'subtle'\n    | 'intense'\n    | 'smooth'\n    | 'sharp'\n    | 'header'\n    | 'footer'\n    | 'sidebar'\n    | 'page-header'\n    | 'page-footer';\n  gpuOptimized?: boolean;\n  hoverIntensity?: number;\n  target?: 'parent' | 'page';\n\n  onAnimationComplete?: () => void;\n  className?: string;\n  style?: CSSProperties;\n}>;\n\nconst DEFAULT_CONFIG: Partial<GradualBlurProps> = {\n  position: 'bottom',\n  strength: 2,\n  height: '6rem',\n  divCount: 5,\n  exponential: false,\n  zIndex: 1000,\n  animated: false,\n  duration: '0.3s',\n  easing: 'ease-out',\n  opacity: 1,\n  curve: 'linear',\n  responsive: false,\n  target: 'parent',\n  className: '',\n  style: {}\n};\n\nconst PRESETS: Record<string, Partial<GradualBlurProps>> = {\n  top: { position: 'top', height: '6rem' },\n  bottom: { position: 'bottom', height: '6rem' },\n  left: { position: 'left', height: '6rem' },\n  right: { position: 'right', height: '6rem' },\n\n  subtle: { height: '4rem', strength: 1, opacity: 0.8, divCount: 3 },\n  intense: { height: '10rem', strength: 4, divCount: 8, exponential: true },\n\n  smooth: { height: '8rem', curve: 'bezier', divCount: 10 },\n  sharp: { height: '5rem', curve: 'linear', divCount: 4 },\n\n  header: { position: 'top', height: '8rem', curve: 'ease-out' },\n  footer: { position: 'bottom', height: '8rem', curve: 'ease-out' },\n  sidebar: { position: 'left', height: '6rem', strength: 2.5 },\n\n  'page-header': {\n    position: 'top',\n    height: '10rem',\n    target: 'page',\n    strength: 3\n  },\n  'page-footer': {\n    position: 'bottom',\n    height: '10rem',\n    target: 'page',\n    strength: 3\n  }\n};\n\nconst CURVE_FUNCTIONS: Record<string, (p: number) => number> = {\n  linear: p => p,\n  bezier: p => p * p * (3 - 2 * p),\n  'ease-in': p => p * p,\n  'ease-out': p => 1 - Math.pow(1 - p, 2),\n  'ease-in-out': p => (p < 0.5 ? 2 * p * p : 1 - Math.pow(-2 * p + 2, 2) / 2)\n};\n\nconst mergeConfigs = (...configs: Partial<GradualBlurProps>[]): Partial<GradualBlurProps> => {\n  return configs.reduce((acc, config) => ({ ...acc, ...config }), {});\n};\n\nconst getGradientDirection = (position: string): string => {\n  const directions: Record<string, string> = {\n    top: 'to top',\n    bottom: 'to bottom',\n    left: 'to left',\n    right: 'to right'\n  };\n  return directions[position] || 'to bottom';\n};\n\nconst debounce = <T extends (...a: any[]) => void>(fn: T, wait: number) => {\n  let t: ReturnType<typeof setTimeout>;\n  return (...a: Parameters<T>) => {\n    clearTimeout(t);\n    t = setTimeout(() => fn(...a), wait);\n  };\n};\nconst useResponsiveDimension = (\n  responsive: boolean | undefined,\n  config: Partial<GradualBlurProps>,\n  key: keyof GradualBlurProps\n) => {\n  const [val, setVal] = useState<any>(config[key]);\n  useEffect(() => {\n    if (!responsive) return;\n    const calc = () => {\n      const w = window.innerWidth;\n      let v: any = config[key];\n      const cap = (s: string) => s.charAt(0).toUpperCase() + s.slice(1);\n      const k = cap(key as string);\n      if (w <= 480 && (config as any)['mobile' + k]) v = (config as any)['mobile' + k];\n      else if (w <= 768 && (config as any)['tablet' + k]) v = (config as any)['tablet' + k];\n      else if (w <= 1024 && (config as any)['desktop' + k]) v = (config as any)['desktop' + k];\n      setVal(v);\n    };\n    const deb = debounce(calc, 100);\n    calc();\n    window.addEventListener('resize', deb);\n    return () => window.removeEventListener('resize', deb);\n  }, [responsive, config, key]);\n  return responsive ? val : (config as any)[key];\n};\n\nconst useIntersectionObserver = (ref: React.RefObject<HTMLDivElement>, shouldObserve: boolean = false) => {\n  const [isVisible, setIsVisible] = useState(!shouldObserve);\n\n  useEffect(() => {\n    if (!shouldObserve || !ref.current) return;\n\n    const observer = new IntersectionObserver(([entry]) => setIsVisible(entry.isIntersecting), { threshold: 0.1 });\n\n    observer.observe(ref.current);\n    return () => observer.disconnect();\n  }, [ref, shouldObserve]);\n\n  return isVisible;\n};\n\nconst GradualBlur: React.FC<GradualBlurProps> = props => {\n  const containerRef = useRef<HTMLDivElement>(null) as React.RefObject<HTMLDivElement>;\n  const [isHovered, setIsHovered] = useState(false);\n\n  const config = useMemo(() => {\n    const presetConfig = props.preset && PRESETS[props.preset] ? PRESETS[props.preset] : {};\n    return mergeConfigs(DEFAULT_CONFIG, presetConfig, props) as Required<GradualBlurProps>;\n  }, [props]);\n\n  const responsiveHeight = useResponsiveDimension(config.responsive, config, 'height');\n  const responsiveWidth = useResponsiveDimension(config.responsive, config, 'width');\n\n  const isVisible = useIntersectionObserver(containerRef, config.animated === 'scroll');\n\n  const blurDivs = useMemo(() => {\n    const divs: React.ReactNode[] = [];\n    const increment = 100 / config.divCount;\n    const currentStrength =\n      isHovered && config.hoverIntensity ? config.strength * config.hoverIntensity : config.strength;\n\n    const curveFunc = CURVE_FUNCTIONS[config.curve] || CURVE_FUNCTIONS.linear;\n\n    for (let i = 1; i <= config.divCount; i++) {\n      let progress = i / config.divCount;\n      progress = curveFunc(progress);\n\n      let blurValue: number;\n      if (config.exponential) {\n        blurValue = Number(math.pow(2, progress * 4)) * 0.0625 * currentStrength;\n      } else {\n        blurValue = 0.0625 * (progress * config.divCount + 1) * currentStrength;\n      }\n\n      const p1 = math.round((increment * i - increment) * 10) / 10;\n      const p2 = math.round(increment * i * 10) / 10;\n      const p3 = math.round((increment * i + increment) * 10) / 10;\n      const p4 = math.round((increment * i + increment * 2) * 10) / 10;\n\n      let gradient = `transparent ${p1}%, black ${p2}%`;\n      if (p3 <= 100) gradient += `, black ${p3}%`;\n      if (p4 <= 100) gradient += `, transparent ${p4}%`;\n\n      const direction = getGradientDirection(config.position);\n\n      const divStyle: CSSProperties = {\n        maskImage: `linear-gradient(${direction}, ${gradient})`,\n        WebkitMaskImage: `linear-gradient(${direction}, ${gradient})`,\n        backdropFilter: `blur(${blurValue.toFixed(3)}rem)`,\n        opacity: config.opacity,\n        transition:\n          config.animated && config.animated !== 'scroll'\n            ? `backdrop-filter ${config.duration} ${config.easing}`\n            : undefined\n      };\n\n      divs.push(<div key={i} className=\"absolute inset-0\" style={divStyle} />);\n    }\n\n    return divs;\n  }, [config, isHovered]);\n\n  const containerStyle: CSSProperties = useMemo(() => {\n    const isVertical = ['top', 'bottom'].includes(config.position);\n    const isHorizontal = ['left', 'right'].includes(config.position);\n    const isPageTarget = config.target === 'page';\n\n    const baseStyle: CSSProperties = {\n      position: isPageTarget ? 'fixed' : 'absolute',\n      pointerEvents: config.hoverIntensity ? 'auto' : 'none',\n      opacity: isVisible ? 1 : 0,\n      transition: config.animated ? `opacity ${config.duration} ${config.easing}` : undefined,\n      zIndex: isPageTarget ? config.zIndex + 100 : config.zIndex,\n      ...config.style\n    };\n\n    if (isVertical) {\n      baseStyle.height = responsiveHeight;\n      baseStyle.width = responsiveWidth || '100%';\n      baseStyle[config.position] = 0;\n      baseStyle.left = 0;\n      baseStyle.right = 0;\n    } else if (isHorizontal) {\n      baseStyle.width = responsiveWidth || responsiveHeight;\n      baseStyle.height = '100%';\n      baseStyle[config.position] = 0;\n      baseStyle.top = 0;\n      baseStyle.bottom = 0;\n    }\n\n    return baseStyle;\n  }, [config, responsiveHeight, responsiveWidth, isVisible]);\n\n  const { hoverIntensity, animated, onAnimationComplete, duration } = config as any;\n  useEffect(() => {\n    if (isVisible && animated === 'scroll' && onAnimationComplete) {\n      const t = setTimeout(() => onAnimationComplete(), parseFloat(duration) * 1000);\n      return () => clearTimeout(t);\n    }\n  }, [isVisible, animated, onAnimationComplete, duration]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`gradual-blur relative isolate ${config.target === 'page' ? 'gradual-blur-page' : 'gradual-blur-parent'} ${config.className}`}\n      style={containerStyle}\n      onMouseEnter={hoverIntensity ? () => setIsHovered(true) : undefined}\n      onMouseLeave={hoverIntensity ? () => setIsHovered(false) : undefined}\n    >\n      <div className=\"relative w-full h-full\">{blurDivs}</div>\n      {props.children && <div className=\"relative\">{props.children}</div>}\n    </div>\n  );\n};\n\nconst GradualBlurMemo = React.memo(GradualBlur);\nGradualBlurMemo.displayName = 'GradualBlur';\n(GradualBlurMemo as any).PRESETS = PRESETS;\n(GradualBlurMemo as any).CURVE_FUNCTIONS = CURVE_FUNCTIONS;\nexport default GradualBlurMemo;\n\nconst injectStyles = () => {\n  if (typeof document === 'undefined') return;\n  const id = 'gradual-blur-styles';\n  if (document.getElementById(id)) return;\n  const el = document.createElement('style');\n  el.id = id;\n  el.textContent = `.gradual-blur{pointer-events:none;transition:opacity .3s ease-out}.gradual-blur-inner{pointer-events:none}`;\n  document.head.appendChild(el);\n};\nif (typeof document !== 'undefined') {\n  injectStyles();\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "hero-video-dialog",
      "type": "component",
      "description": "A hero video dialog component.",
      "category": "animations",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/hero-video-dialog.tsx",
          "content": "/* eslint-disable @next/next/no-img-element */\n\"use client\"\n\nimport { useState } from \"react\"\nimport { Play, XIcon } from \"lucide-react\"\nimport { AnimatePresence, motion } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ntype AnimationStyle =\n  | \"from-bottom\"\n  | \"from-center\"\n  | \"from-top\"\n  | \"from-left\"\n  | \"from-right\"\n  | \"fade\"\n  | \"top-in-bottom-out\"\n  | \"left-in-right-out\"\n\ninterface HeroVideoProps {\n  animationStyle?: AnimationStyle\n  videoSrc: string\n  thumbnailSrc: string\n  thumbnailAlt?: string\n  className?: string\n}\n\nconst animationVariants = {\n  \"from-bottom\": {\n    initial: { y: \"100%\", opacity: 0 },\n    animate: { y: 0, opacity: 1 },\n    exit: { y: \"100%\", opacity: 0 },\n  },\n  \"from-center\": {\n    initial: { scale: 0.5, opacity: 0 },\n    animate: { scale: 1, opacity: 1 },\n    exit: { scale: 0.5, opacity: 0 },\n  },\n  \"from-top\": {\n    initial: { y: \"-100%\", opacity: 0 },\n    animate: { y: 0, opacity: 1 },\n    exit: { y: \"-100%\", opacity: 0 },\n  },\n  \"from-left\": {\n    initial: { x: \"-100%\", opacity: 0 },\n    animate: { x: 0, opacity: 1 },\n    exit: { x: \"-100%\", opacity: 0 },\n  },\n  \"from-right\": {\n    initial: { x: \"100%\", opacity: 0 },\n    animate: { x: 0, opacity: 1 },\n    exit: { x: \"100%\", opacity: 0 },\n  },\n  fade: {\n    initial: { opacity: 0 },\n    animate: { opacity: 1 },\n    exit: { opacity: 0 },\n  },\n  \"top-in-bottom-out\": {\n    initial: { y: \"-100%\", opacity: 0 },\n    animate: { y: 0, opacity: 1 },\n    exit: { y: \"100%\", opacity: 0 },\n  },\n  \"left-in-right-out\": {\n    initial: { x: \"-100%\", opacity: 0 },\n    animate: { x: 0, opacity: 1 },\n    exit: { x: \"100%\", opacity: 0 },\n  },\n}\n\nexport function HeroVideoDialog({\n  animationStyle = \"from-center\",\n  videoSrc,\n  thumbnailSrc,\n  thumbnailAlt = \"Video thumbnail\",\n  className,\n}: HeroVideoProps) {\n  const [isVideoOpen, setIsVideoOpen] = useState(false)\n  const selectedAnimation = animationVariants[animationStyle]\n\n  return (\n    <div className={cn(\"relative\", className)}>\n      <button\n        type=\"button\"\n        aria-label=\"Play video\"\n        className=\"group relative cursor-pointer border-0 bg-transparent p-0\"\n        onClick={() => setIsVideoOpen(true)}\n      >\n        <img\n          src={thumbnailSrc}\n          alt={thumbnailAlt}\n          width={1920}\n          height={1080}\n          className=\"w-full rounded-md border shadow-lg transition-all duration-200 ease-out group-hover:brightness-[0.8]\"\n        />\n        <div className=\"absolute inset-0 flex scale-[0.9] items-center justify-center rounded-2xl transition-all duration-200 ease-out group-hover:scale-100\">\n          <div className=\"bg-primary/10 flex size-28 items-center justify-center rounded-full backdrop-blur-md\">\n            <div\n              className={`from-primary/30 to-primary relative flex size-20 scale-100 items-center justify-center rounded-full bg-gradient-to-b shadow-md transition-all duration-200 ease-out group-hover:scale-[1.2]`}\n            >\n              <Play\n                className=\"size-8 scale-100 fill-white text-white transition-transform duration-200 ease-out group-hover:scale-105\"\n                style={{\n                  filter:\n                    \"drop-shadow(0 4px 3px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 2px rgb(0 0 0 / 0.06))\",\n                }}\n              />\n            </div>\n          </div>\n        </div>\n      </button>\n      <AnimatePresence>\n        {isVideoOpen && (\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => {\n              if (e.key === \"Escape\" || e.key === \"Enter\" || e.key === \" \") {\n                setIsVideoOpen(false)\n              }\n            }}\n            onClick={() => setIsVideoOpen(false)}\n            exit={{ opacity: 0 }}\n            className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-md\"\n          >\n            <motion.div\n              {...selectedAnimation}\n              transition={{ type: \"spring\", damping: 30, stiffness: 300 }}\n              className=\"relative mx-4 aspect-video w-full max-w-4xl md:mx-0\"\n            >\n              <motion.button className=\"absolute -top-16 right-0 rounded-full bg-neutral-900/50 p-2 text-xl text-white ring-1 backdrop-blur-md dark:bg-neutral-100/50 dark:text-black\">\n                <XIcon className=\"size-5\" />\n              </motion.button>\n              <div className=\"relative isolate z-[1] size-full overflow-hidden rounded-2xl border-2 border-white\">\n                <iframe\n                  src={videoSrc}\n                  title=\"Hero Video player\"\n                  className=\"size-full rounded-2xl\"\n                  allowFullScreen\n                  allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n                ></iframe>\n              </div>\n            </motion.div>\n          </motion.div>\n        )}\n      </AnimatePresence>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "icon-cloud",
      "type": "component",
      "description": "An interactive 3D tag cloud component",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/icon-cloud.tsx",
          "content": "\"use client\"\n\nimport React, { useEffect, useRef, useState } from \"react\"\nimport { renderToString } from \"react-dom/server\"\n\ninterface Icon {\n  x: number\n  y: number\n  z: number\n  scale: number\n  opacity: number\n  id: number\n}\n\ninterface IconCloudProps {\n  icons?: React.ReactNode[]\n  images?: string[]\n}\n\nfunction easeOutCubic(t: number): number {\n  return 1 - Math.pow(1 - t, 3)\n}\n\nexport function IconCloud({ icons, images }: IconCloudProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const [iconPositions, setIconPositions] = useState<Icon[]>([])\n  const [rotation, setRotation] = useState({ x: 0, y: 0 })\n  const [isDragging, setIsDragging] = useState(false)\n  const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 })\n  const [mousePos, setMousePos] = useState({ x: 0, y: 0 })\n  const [targetRotation, setTargetRotation] = useState<{\n    x: number\n    y: number\n    startX: number\n    startY: number\n    distance: number\n    startTime: number\n    duration: number\n  } | null>(null)\n  const animationFrameRef = useRef<number>(0)\n  const rotationRef = useRef(rotation)\n  const iconCanvasesRef = useRef<HTMLCanvasElement[]>([])\n  const imagesLoadedRef = useRef<boolean[]>([])\n\n  // Create icon canvases once when icons/images change\n  useEffect(() => {\n    if (!icons && !images) return\n\n    const items = icons || images || []\n    imagesLoadedRef.current = new Array(items.length).fill(false)\n\n    const newIconCanvases = items.map((item, index) => {\n      const offscreen = document.createElement(\"canvas\")\n      offscreen.width = 40\n      offscreen.height = 40\n      const offCtx = offscreen.getContext(\"2d\")\n\n      if (offCtx) {\n        if (images) {\n          // Handle image URLs directly\n          const img = new Image()\n          img.crossOrigin = \"anonymous\"\n          img.src = items[index] as string\n          img.onload = () => {\n            offCtx.clearRect(0, 0, offscreen.width, offscreen.height)\n\n            // Create circular clipping path\n            offCtx.beginPath()\n            offCtx.arc(20, 20, 20, 0, Math.PI * 2)\n            offCtx.closePath()\n            offCtx.clip()\n\n            // Draw the image\n            offCtx.drawImage(img, 0, 0, 40, 40)\n\n            imagesLoadedRef.current[index] = true\n          }\n        } else {\n          // Handle SVG icons\n          offCtx.scale(0.4, 0.4)\n          const svgString = renderToString(item as React.ReactElement)\n          const img = new Image()\n          img.src = \"data:image/svg+xml;base64,\" + btoa(svgString)\n          img.onload = () => {\n            offCtx.clearRect(0, 0, offscreen.width, offscreen.height)\n            offCtx.drawImage(img, 0, 0)\n            imagesLoadedRef.current[index] = true\n          }\n        }\n      }\n      return offscreen\n    })\n\n    iconCanvasesRef.current = newIconCanvases\n  }, [icons, images])\n\n  // Generate initial icon positions on a sphere\n  useEffect(() => {\n    const items = icons || images || []\n    const newIcons: Icon[] = []\n    const numIcons = items.length || 20\n\n    // Fibonacci sphere parameters\n    const offset = 2 / numIcons\n    const increment = Math.PI * (3 - Math.sqrt(5))\n\n    for (let i = 0; i < numIcons; i++) {\n      const y = i * offset - 1 + offset / 2\n      const r = Math.sqrt(1 - y * y)\n      const phi = i * increment\n\n      const x = Math.cos(phi) * r\n      const z = Math.sin(phi) * r\n\n      newIcons.push({\n        x: x * 100,\n        y: y * 100,\n        z: z * 100,\n        scale: 1,\n        opacity: 1,\n        id: i,\n      })\n    }\n    setIconPositions(newIcons)\n  }, [icons, images])\n\n  // Handle mouse events\n  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    const rect = canvasRef.current?.getBoundingClientRect()\n    if (!rect || !canvasRef.current) return\n\n    const x = e.clientX - rect.left\n    const y = e.clientY - rect.top\n\n    const ctx = canvasRef.current.getContext(\"2d\")\n    if (!ctx) return\n\n    iconPositions.forEach((icon) => {\n      const cosX = Math.cos(rotationRef.current.x)\n      const sinX = Math.sin(rotationRef.current.x)\n      const cosY = Math.cos(rotationRef.current.y)\n      const sinY = Math.sin(rotationRef.current.y)\n\n      const rotatedX = icon.x * cosY - icon.z * sinY\n      const rotatedZ = icon.x * sinY + icon.z * cosY\n      const rotatedY = icon.y * cosX + rotatedZ * sinX\n\n      const screenX = canvasRef.current!.width / 2 + rotatedX\n      const screenY = canvasRef.current!.height / 2 + rotatedY\n\n      const scale = (rotatedZ + 200) / 300\n      const radius = 20 * scale\n      const dx = x - screenX\n      const dy = y - screenY\n\n      if (dx * dx + dy * dy < radius * radius) {\n        const targetX = -Math.atan2(\n          icon.y,\n          Math.sqrt(icon.x * icon.x + icon.z * icon.z)\n        )\n        const targetY = Math.atan2(icon.x, icon.z)\n\n        const currentX = rotationRef.current.x\n        const currentY = rotationRef.current.y\n        const distance = Math.sqrt(\n          Math.pow(targetX - currentX, 2) + Math.pow(targetY - currentY, 2)\n        )\n\n        const duration = Math.min(2000, Math.max(800, distance * 1000))\n\n        setTargetRotation({\n          x: targetX,\n          y: targetY,\n          startX: currentX,\n          startY: currentY,\n          distance,\n          startTime: performance.now(),\n          duration,\n        })\n        return\n      }\n    })\n\n    setIsDragging(true)\n    setLastMousePos({ x: e.clientX, y: e.clientY })\n  }\n\n  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    const rect = canvasRef.current?.getBoundingClientRect()\n    if (rect) {\n      const x = e.clientX - rect.left\n      const y = e.clientY - rect.top\n      setMousePos({ x, y })\n    }\n\n    if (isDragging) {\n      const deltaX = e.clientX - lastMousePos.x\n      const deltaY = e.clientY - lastMousePos.y\n\n      rotationRef.current = {\n        x: rotationRef.current.x + deltaY * 0.002,\n        y: rotationRef.current.y + deltaX * 0.002,\n      }\n\n      setLastMousePos({ x: e.clientX, y: e.clientY })\n    }\n  }\n\n  const handleMouseUp = () => {\n    setIsDragging(false)\n  }\n\n  // Animation and rendering\n  useEffect(() => {\n    const canvas = canvasRef.current\n    const ctx = canvas?.getContext(\"2d\")\n    if (!canvas || !ctx) return\n\n    const animate = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n      const centerX = canvas.width / 2\n      const centerY = canvas.height / 2\n      const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY)\n      const dx = mousePos.x - centerX\n      const dy = mousePos.y - centerY\n      const distance = Math.sqrt(dx * dx + dy * dy)\n      const speed = 0.003 + (distance / maxDistance) * 0.01\n\n      if (targetRotation) {\n        const elapsed = performance.now() - targetRotation.startTime\n        const progress = Math.min(1, elapsed / targetRotation.duration)\n        const easedProgress = easeOutCubic(progress)\n\n        rotationRef.current = {\n          x:\n            targetRotation.startX +\n            (targetRotation.x - targetRotation.startX) * easedProgress,\n          y:\n            targetRotation.startY +\n            (targetRotation.y - targetRotation.startY) * easedProgress,\n        }\n\n        if (progress >= 1) {\n          setTargetRotation(null)\n        }\n      } else if (!isDragging) {\n        rotationRef.current = {\n          x: rotationRef.current.x + (dy / canvas.height) * speed,\n          y: rotationRef.current.y + (dx / canvas.width) * speed,\n        }\n      }\n\n      iconPositions.forEach((icon, index) => {\n        const cosX = Math.cos(rotationRef.current.x)\n        const sinX = Math.sin(rotationRef.current.x)\n        const cosY = Math.cos(rotationRef.current.y)\n        const sinY = Math.sin(rotationRef.current.y)\n\n        const rotatedX = icon.x * cosY - icon.z * sinY\n        const rotatedZ = icon.x * sinY + icon.z * cosY\n        const rotatedY = icon.y * cosX + rotatedZ * sinX\n\n        const scale = (rotatedZ + 200) / 300\n        const opacity = Math.max(0.2, Math.min(1, (rotatedZ + 150) / 200))\n\n        ctx.save()\n        ctx.translate(canvas.width / 2 + rotatedX, canvas.height / 2 + rotatedY)\n        ctx.scale(scale, scale)\n        ctx.globalAlpha = opacity\n\n        if (icons || images) {\n          // Only try to render icons/images if they exist\n          if (\n            iconCanvasesRef.current[index] &&\n            imagesLoadedRef.current[index]\n          ) {\n            ctx.drawImage(iconCanvasesRef.current[index], -20, -20, 40, 40)\n          }\n        } else {\n          // Show numbered circles if no icons/images are provided\n          ctx.beginPath()\n          ctx.arc(0, 0, 20, 0, Math.PI * 2)\n          ctx.fillStyle = \"#4444ff\"\n          ctx.fill()\n          ctx.fillStyle = \"white\"\n          ctx.textAlign = \"center\"\n          ctx.textBaseline = \"middle\"\n          ctx.font = \"16px Arial\"\n          ctx.fillText(`${icon.id + 1}`, 0, 0)\n        }\n\n        ctx.restore()\n      })\n      animationFrameRef.current = requestAnimationFrame(animate)\n    }\n\n    animate()\n\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n      }\n    }\n  }, [icons, images, iconPositions, isDragging, mousePos, targetRotation])\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={400}\n      height={400}\n      onMouseDown={handleMouseDown}\n      onMouseMove={handleMouseMove}\n      onMouseUp={handleMouseUp}\n      onMouseLeave={handleMouseUp}\n      className=\"rounded-lg\"\n      aria-label=\"Interactive 3D Icon Cloud\"\n      role=\"img\"\n    />\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "image-trail",
      "type": "component",
      "description": "Trail of images following the cursor.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/image-trail.tsx",
          "content": "import { gsap } from 'gsap';\nimport { JSX, useEffect, useRef } from 'react';\n\nfunction lerp(a: number, b: number, n: number): number {\n  return (1 - n) * a + n * b;\n}\n\nfunction getLocalPointerPos(e: MouseEvent | TouchEvent, rect: DOMRect): { x: number; y: number } {\n  let clientX = 0,\n    clientY = 0;\n  if ('touches' in e && e.touches.length > 0) {\n    clientX = e.touches[0].clientX;\n    clientY = e.touches[0].clientY;\n  } else if ('clientX' in e) {\n    clientX = e.clientX;\n    clientY = e.clientY;\n  }\n  return {\n    x: clientX - rect.left,\n    y: clientY - rect.top\n  };\n}\n\nfunction getMouseDistance(p1: { x: number; y: number }, p2: { x: number; y: number }): number {\n  const dx = p1.x - p2.x;\n  const dy = p1.y - p2.y;\n  return Math.hypot(dx, dy);\n}\n\nclass ImageItem {\n  public DOM: { el: HTMLDivElement; inner: HTMLDivElement | null } = {\n    el: null as unknown as HTMLDivElement,\n    inner: null\n  };\n  public defaultStyle: gsap.TweenVars = { scale: 1, x: 0, y: 0, opacity: 0 };\n  public rect: DOMRect | null = null;\n  private resize!: () => void;\n\n  constructor(DOM_el: HTMLDivElement) {\n    this.DOM.el = DOM_el;\n    this.DOM.inner = this.DOM.el.querySelector('.content__img-inner');\n    this.getRect();\n    this.initEvents();\n  }\n\n  private initEvents() {\n    this.resize = () => {\n      gsap.set(this.DOM.el, this.defaultStyle);\n      this.getRect();\n    };\n    window.addEventListener('resize', this.resize);\n  }\n\n  private getRect() {\n    this.rect = this.DOM.el.getBoundingClientRect();\n  }\n}\n\nclass ImageTrailVariant1 {\n  private container: HTMLDivElement;\n  private DOM: { el: HTMLDivElement };\n  private images: ImageItem[];\n  private imagesTotal: number;\n  private imgPosition: number;\n  private zIndexVal: number;\n  private activeImagesCount: number;\n  private isIdle: boolean;\n  private threshold: number;\n  private mousePos: { x: number; y: number };\n  private lastMousePos: { x: number; y: number };\n  private cacheMousePos: { x: number; y: number };\n\n  constructor(container: HTMLDivElement) {\n    this.container = container;\n    this.DOM = { el: container };\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img as HTMLDivElement));\n    this.imagesTotal = this.images.length;\n    this.imgPosition = 0;\n    this.zIndexVal = 1;\n    this.activeImagesCount = 0;\n    this.isIdle = true;\n    this.threshold = 80;\n    this.mousePos = { x: 0, y: 0 };\n    this.lastMousePos = { x: 0, y: 0 };\n    this.cacheMousePos = { x: 0, y: 0 };\n\n    const handlePointerMove = (ev: MouseEvent | TouchEvent) => {\n      const rect = this.container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n    };\n    container.addEventListener('mousemove', handlePointerMove);\n    container.addEventListener('touchmove', handlePointerMove);\n\n    const initRender = (ev: MouseEvent | TouchEvent) => {\n      const rect = this.container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n      this.cacheMousePos = { ...this.mousePos };\n      requestAnimationFrame(() => this.render());\n      container.removeEventListener('mousemove', initRender as EventListener);\n      container.removeEventListener('touchmove', initRender as EventListener);\n    };\n    container.addEventListener('mousemove', initRender as EventListener);\n    container.addEventListener('touchmove', initRender as EventListener);\n  }\n\n  private render() {\n    const distance = getMouseDistance(this.mousePos, this.lastMousePos);\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\n\n    if (distance > this.threshold) {\n      this.showNextImage();\n      this.lastMousePos = { ...this.mousePos };\n    }\n    if (this.isIdle && this.zIndexVal !== 1) {\n      this.zIndexVal = 1;\n    }\n    requestAnimationFrame(() => this.render());\n  }\n\n  private showNextImage() {\n    ++this.zIndexVal;\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\n    const img = this.images[this.imgPosition];\n\n    gsap.killTweensOf(img.DOM.el);\n    gsap\n      .timeline({\n        onStart: () => this.onImageActivated(),\n        onComplete: () => this.onImageDeactivated()\n      })\n      .fromTo(\n        img.DOM.el,\n        {\n          opacity: 1,\n          scale: 1,\n          zIndex: this.zIndexVal,\n          x: this.cacheMousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.cacheMousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        {\n          duration: 0.4,\n          ease: 'power1',\n          x: this.mousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.mousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        0\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 0.4,\n          ease: 'power3',\n          opacity: 0,\n          scale: 0.2\n        },\n        0.4\n      );\n  }\n\n  private onImageActivated() {\n    this.activeImagesCount++;\n    this.isIdle = false;\n  }\n\n  private onImageDeactivated() {\n    this.activeImagesCount--;\n    if (this.activeImagesCount === 0) {\n      this.isIdle = true;\n    }\n  }\n}\n\nclass ImageTrailVariant2 {\n  private container: HTMLDivElement;\n  private DOM: { el: HTMLDivElement };\n  private images: ImageItem[];\n  private imagesTotal: number;\n  private imgPosition: number;\n  private zIndexVal: number;\n  private activeImagesCount: number;\n  private isIdle: boolean;\n  private threshold: number;\n  private mousePos: { x: number; y: number };\n  private lastMousePos: { x: number; y: number };\n  private cacheMousePos: { x: number; y: number };\n\n  constructor(container: HTMLDivElement) {\n    this.container = container;\n    this.DOM = { el: container };\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img as HTMLDivElement));\n    this.imagesTotal = this.images.length;\n    this.imgPosition = 0;\n    this.zIndexVal = 1;\n    this.activeImagesCount = 0;\n    this.isIdle = true;\n    this.threshold = 80;\n    this.mousePos = { x: 0, y: 0 };\n    this.lastMousePos = { x: 0, y: 0 };\n    this.cacheMousePos = { x: 0, y: 0 };\n\n    const handlePointerMove = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n    };\n    container.addEventListener('mousemove', handlePointerMove);\n    container.addEventListener('touchmove', handlePointerMove);\n\n    const initRender = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n      this.cacheMousePos = { ...this.mousePos };\n      requestAnimationFrame(() => this.render());\n      container.removeEventListener('mousemove', initRender as EventListener);\n      container.removeEventListener('touchmove', initRender as EventListener);\n    };\n    container.addEventListener('mousemove', initRender as EventListener);\n    container.addEventListener('touchmove', initRender as EventListener);\n  }\n\n  private render() {\n    const distance = getMouseDistance(this.mousePos, this.lastMousePos);\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\n\n    if (distance > this.threshold) {\n      this.showNextImage();\n      this.lastMousePos = { ...this.mousePos };\n    }\n    if (this.isIdle && this.zIndexVal !== 1) {\n      this.zIndexVal = 1;\n    }\n    requestAnimationFrame(() => this.render());\n  }\n\n  private showNextImage() {\n    ++this.zIndexVal;\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\n    const img = this.images[this.imgPosition];\n\n    gsap.killTweensOf(img.DOM.el);\n    gsap\n      .timeline({\n        onStart: () => this.onImageActivated(),\n        onComplete: () => this.onImageDeactivated()\n      })\n      .fromTo(\n        img.DOM.el,\n        {\n          opacity: 1,\n          scale: 0,\n          zIndex: this.zIndexVal,\n          x: this.cacheMousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.cacheMousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        {\n          duration: 0.4,\n          ease: 'power1',\n          scale: 1,\n          x: this.mousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.mousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        0\n      )\n      .fromTo(\n        img.DOM.inner,\n        { scale: 2.8, filter: 'brightness(250%)' },\n        {\n          duration: 0.4,\n          ease: 'power1',\n          scale: 1,\n          filter: 'brightness(100%)'\n        },\n        0\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 0.4,\n          ease: 'power2',\n          opacity: 0,\n          scale: 0.2\n        },\n        0.45\n      );\n  }\n\n  private onImageActivated() {\n    this.activeImagesCount++;\n    this.isIdle = false;\n  }\n\n  private onImageDeactivated() {\n    this.activeImagesCount--;\n    if (this.activeImagesCount === 0) {\n      this.isIdle = true;\n    }\n  }\n}\n\nclass ImageTrailVariant3 {\n  private container: HTMLDivElement;\n  private DOM: { el: HTMLDivElement };\n  private images: ImageItem[];\n  private imagesTotal: number;\n  private imgPosition: number;\n  private zIndexVal: number;\n  private activeImagesCount: number;\n  private isIdle: boolean;\n  private threshold: number;\n  private mousePos: { x: number; y: number };\n  private lastMousePos: { x: number; y: number };\n  private cacheMousePos: { x: number; y: number };\n\n  constructor(container: HTMLDivElement) {\n    this.container = container;\n    this.DOM = { el: container };\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img as HTMLDivElement));\n    this.imagesTotal = this.images.length;\n    this.imgPosition = 0;\n    this.zIndexVal = 1;\n    this.activeImagesCount = 0;\n    this.isIdle = true;\n    this.threshold = 80;\n    this.mousePos = { x: 0, y: 0 };\n    this.lastMousePos = { x: 0, y: 0 };\n    this.cacheMousePos = { x: 0, y: 0 };\n\n    const handlePointerMove = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n    };\n    container.addEventListener('mousemove', handlePointerMove);\n    container.addEventListener('touchmove', handlePointerMove);\n\n    const initRender = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n      this.cacheMousePos = { ...this.mousePos };\n      requestAnimationFrame(() => this.render());\n      container.removeEventListener('mousemove', initRender as EventListener);\n      container.removeEventListener('touchmove', initRender as EventListener);\n    };\n    container.addEventListener('mousemove', initRender as EventListener);\n    container.addEventListener('touchmove', initRender as EventListener);\n  }\n\n  private render() {\n    const distance = getMouseDistance(this.mousePos, this.lastMousePos);\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\n\n    if (distance > this.threshold) {\n      this.showNextImage();\n      this.lastMousePos = { ...this.mousePos };\n    }\n    if (this.isIdle && this.zIndexVal !== 1) {\n      this.zIndexVal = 1;\n    }\n    requestAnimationFrame(() => this.render());\n  }\n\n  private showNextImage() {\n    ++this.zIndexVal;\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\n    const img = this.images[this.imgPosition];\n\n    gsap.killTweensOf(img.DOM.el);\n    gsap\n      .timeline({\n        onStart: () => this.onImageActivated(),\n        onComplete: () => this.onImageDeactivated()\n      })\n      .fromTo(\n        img.DOM.el,\n        {\n          opacity: 1,\n          scale: 0,\n          zIndex: this.zIndexVal,\n          xPercent: 0,\n          yPercent: 0,\n          x: this.cacheMousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.cacheMousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        {\n          duration: 0.4,\n          ease: 'power1',\n          scale: 1,\n          x: this.mousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.mousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        0\n      )\n      .fromTo(\n        img.DOM.inner,\n        { scale: 1.2 },\n        {\n          duration: 0.4,\n          ease: 'power1',\n          scale: 1\n        },\n        0\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 0.6,\n          ease: 'power2',\n          opacity: 0,\n          scale: 0.2,\n          xPercent: () => gsap.utils.random(-30, 30),\n          yPercent: -200\n        },\n        0.6\n      );\n  }\n\n  private onImageActivated() {\n    this.activeImagesCount++;\n    this.isIdle = false;\n  }\n\n  private onImageDeactivated() {\n    this.activeImagesCount--;\n    if (this.activeImagesCount === 0) {\n      this.isIdle = true;\n    }\n  }\n}\n\nclass ImageTrailVariant4 {\n  private container: HTMLDivElement;\n  private DOM: { el: HTMLDivElement };\n  private images: ImageItem[];\n  private imagesTotal: number;\n  private imgPosition: number;\n  private zIndexVal: number;\n  private activeImagesCount: number;\n  private isIdle: boolean;\n  private threshold: number;\n  private mousePos: { x: number; y: number };\n  private lastMousePos: { x: number; y: number };\n  private cacheMousePos: { x: number; y: number };\n\n  constructor(container: HTMLDivElement) {\n    this.container = container;\n    this.DOM = { el: container };\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img as HTMLDivElement));\n    this.imagesTotal = this.images.length;\n    this.imgPosition = 0;\n    this.zIndexVal = 1;\n    this.activeImagesCount = 0;\n    this.isIdle = true;\n    this.threshold = 80;\n    this.mousePos = { x: 0, y: 0 };\n    this.lastMousePos = { x: 0, y: 0 };\n    this.cacheMousePos = { x: 0, y: 0 };\n\n    const handlePointerMove = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n    };\n    container.addEventListener('mousemove', handlePointerMove);\n    container.addEventListener('touchmove', handlePointerMove);\n\n    const initRender = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n      this.cacheMousePos = { ...this.mousePos };\n      requestAnimationFrame(() => this.render());\n      container.removeEventListener('mousemove', initRender as EventListener);\n      container.removeEventListener('touchmove', initRender as EventListener);\n    };\n    container.addEventListener('mousemove', initRender as EventListener);\n    container.addEventListener('touchmove', initRender as EventListener);\n  }\n\n  private render() {\n    const distance = getMouseDistance(this.mousePos, this.lastMousePos);\n    if (distance > this.threshold) {\n      this.showNextImage();\n      this.lastMousePos = { ...this.mousePos };\n    }\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\n\n    if (this.isIdle && this.zIndexVal !== 1) this.zIndexVal = 1;\n    requestAnimationFrame(() => this.render());\n  }\n\n  private showNextImage() {\n    ++this.zIndexVal;\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\n    const img = this.images[this.imgPosition];\n    gsap.killTweensOf(img.DOM.el);\n\n    let dx = this.mousePos.x - this.cacheMousePos.x;\n    let dy = this.mousePos.y - this.cacheMousePos.y;\n    let distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance !== 0) {\n      dx /= distance;\n      dy /= distance;\n    }\n    dx *= distance / 100;\n    dy *= distance / 100;\n\n    gsap\n      .timeline({\n        onStart: () => this.onImageActivated(),\n        onComplete: () => this.onImageDeactivated()\n      })\n      .fromTo(\n        img.DOM.el,\n        {\n          opacity: 1,\n          scale: 0,\n          zIndex: this.zIndexVal,\n          x: this.cacheMousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.cacheMousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        {\n          duration: 0.4,\n          ease: 'power1',\n          scale: 1,\n          x: this.mousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.mousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        0\n      )\n      .fromTo(\n        img.DOM.inner,\n        {\n          scale: 2,\n          filter: `brightness(${Math.max((400 * distance) / 100, 100)}%) contrast(${Math.max(\n            (400 * distance) / 100,\n            100\n          )}%)`\n        },\n        {\n          duration: 0.4,\n          ease: 'power1',\n          scale: 1,\n          filter: 'brightness(100%) contrast(100%)'\n        },\n        0\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 0.4,\n          ease: 'power3',\n          opacity: 0\n        },\n        0.4\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 1.5,\n          ease: 'power4',\n          x: `+=${dx * 110}`,\n          y: `+=${dy * 110}`\n        },\n        0.05\n      );\n  }\n\n  private onImageActivated() {\n    this.activeImagesCount++;\n    this.isIdle = false;\n  }\n\n  private onImageDeactivated() {\n    this.activeImagesCount--;\n    if (this.activeImagesCount === 0) {\n      this.isIdle = true;\n    }\n  }\n}\n\nclass ImageTrailVariant5 {\n  private container: HTMLDivElement;\n  private DOM: { el: HTMLDivElement };\n  private images: ImageItem[];\n  private imagesTotal: number;\n  private imgPosition: number;\n  private zIndexVal: number;\n  private activeImagesCount: number;\n  private isIdle: boolean;\n  private threshold: number;\n  private mousePos: { x: number; y: number };\n  private lastMousePos: { x: number; y: number };\n  private cacheMousePos: { x: number; y: number };\n  private lastAngle: number;\n\n  constructor(container: HTMLDivElement) {\n    this.container = container;\n    this.DOM = { el: container };\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img as HTMLDivElement));\n    this.imagesTotal = this.images.length;\n    this.imgPosition = 0;\n    this.zIndexVal = 1;\n    this.activeImagesCount = 0;\n    this.isIdle = true;\n    this.threshold = 80;\n    this.mousePos = { x: 0, y: 0 };\n    this.lastMousePos = { x: 0, y: 0 };\n    this.cacheMousePos = { x: 0, y: 0 };\n    this.lastAngle = 0;\n\n    const handlePointerMove = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n    };\n    container.addEventListener('mousemove', handlePointerMove);\n    container.addEventListener('touchmove', handlePointerMove);\n\n    const initRender = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n      this.cacheMousePos = { ...this.mousePos };\n      requestAnimationFrame(() => this.render());\n      container.removeEventListener('mousemove', initRender as EventListener);\n      container.removeEventListener('touchmove', initRender as EventListener);\n    };\n    container.addEventListener('mousemove', initRender as EventListener);\n    container.addEventListener('touchmove', initRender as EventListener);\n  }\n\n  private render() {\n    const distance = getMouseDistance(this.mousePos, this.lastMousePos);\n    if (distance > this.threshold) {\n      this.showNextImage();\n      this.lastMousePos = { ...this.mousePos };\n    }\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\n    if (this.isIdle && this.zIndexVal !== 1) this.zIndexVal = 1;\n    requestAnimationFrame(() => this.render());\n  }\n\n  private showNextImage() {\n    let dx = this.mousePos.x - this.cacheMousePos.x;\n    let dy = this.mousePos.y - this.cacheMousePos.y;\n    let angle = Math.atan2(dy, dx) * (180 / Math.PI);\n    if (angle < 0) angle += 360;\n    if (angle > 90 && angle <= 270) angle += 180;\n    const isMovingClockwise = angle >= this.lastAngle;\n    this.lastAngle = angle;\n    let startAngle = isMovingClockwise ? angle - 10 : angle + 10;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance !== 0) {\n      dx /= distance;\n      dy /= distance;\n    }\n    dx *= distance / 150;\n    dy *= distance / 150;\n\n    ++this.zIndexVal;\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\n    const img = this.images[this.imgPosition];\n    gsap.killTweensOf(img.DOM.el);\n\n    gsap\n      .timeline({\n        onStart: () => this.onImageActivated(),\n        onComplete: () => this.onImageDeactivated()\n      })\n      .fromTo(\n        img.DOM.el,\n        {\n          opacity: 1,\n          filter: 'brightness(80%)',\n          scale: 0.1,\n          zIndex: this.zIndexVal,\n          x: this.cacheMousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.cacheMousePos.y - (img.rect?.height ?? 0) / 2,\n          rotation: startAngle\n        },\n        {\n          duration: 1,\n          ease: 'power2',\n          scale: 1,\n          filter: 'brightness(100%)',\n          x: this.mousePos.x - (img.rect?.width ?? 0) / 2 + dx * 70,\n          y: this.mousePos.y - (img.rect?.height ?? 0) / 2 + dy * 70,\n          rotation: this.lastAngle\n        },\n        0\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 0.4,\n          ease: 'expo',\n          opacity: 0\n        },\n        0.5\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 1.5,\n          ease: 'power4',\n          x: `+=${dx * 120}`,\n          y: `+=${dy * 120}`\n        },\n        0.05\n      );\n  }\n\n  private onImageActivated() {\n    this.activeImagesCount++;\n    this.isIdle = false;\n  }\n\n  private onImageDeactivated() {\n    this.activeImagesCount--;\n    if (this.activeImagesCount === 0) this.isIdle = true;\n  }\n}\n\nclass ImageTrailVariant6 {\n  private container: HTMLDivElement;\n  private DOM: { el: HTMLDivElement };\n  private images: ImageItem[];\n  private imagesTotal: number;\n  private imgPosition: number;\n  private zIndexVal: number;\n  private activeImagesCount: number;\n  private isIdle: boolean;\n  private threshold: number;\n  private mousePos: { x: number; y: number };\n  private lastMousePos: { x: number; y: number };\n  private cacheMousePos: { x: number; y: number };\n\n  constructor(container: HTMLDivElement) {\n    this.container = container;\n    this.DOM = { el: container };\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img as HTMLDivElement));\n    this.imagesTotal = this.images.length;\n    this.imgPosition = 0;\n    this.zIndexVal = 1;\n    this.activeImagesCount = 0;\n    this.isIdle = true;\n    this.threshold = 80;\n    this.mousePos = { x: 0, y: 0 };\n    this.lastMousePos = { x: 0, y: 0 };\n    this.cacheMousePos = { x: 0, y: 0 };\n\n    const handlePointerMove = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n    };\n    container.addEventListener('mousemove', handlePointerMove);\n    container.addEventListener('touchmove', handlePointerMove);\n\n    const initRender = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n      this.cacheMousePos = { ...this.mousePos };\n      requestAnimationFrame(() => this.render());\n      container.removeEventListener('mousemove', initRender as EventListener);\n      container.removeEventListener('touchmove', initRender as EventListener);\n    };\n    container.addEventListener('mousemove', initRender as EventListener);\n    container.addEventListener('touchmove', initRender as EventListener);\n  }\n\n  private render() {\n    const distance = getMouseDistance(this.mousePos, this.lastMousePos);\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.3);\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.3);\n\n    if (distance > this.threshold) {\n      this.showNextImage();\n      this.lastMousePos = { ...this.mousePos };\n    }\n    if (this.isIdle && this.zIndexVal !== 1) {\n      this.zIndexVal = 1;\n    }\n    requestAnimationFrame(() => this.render());\n  }\n\n  private mapSpeedToSize(speed: number, minSize: number, maxSize: number) {\n    const maxSpeed = 200;\n    return minSize + (maxSize - minSize) * Math.min(speed / maxSpeed, 1);\n  }\n\n  private mapSpeedToBrightness(speed: number, minB: number, maxB: number) {\n    const maxSpeed = 70;\n    return minB + (maxB - minB) * Math.min(speed / maxSpeed, 1);\n  }\n\n  private mapSpeedToBlur(speed: number, minBlur: number, maxBlur: number) {\n    const maxSpeed = 90;\n    return minBlur + (maxBlur - minBlur) * Math.min(speed / maxSpeed, 1);\n  }\n\n  private mapSpeedToGrayscale(speed: number, minG: number, maxG: number) {\n    const maxSpeed = 90;\n    return minG + (maxG - minG) * Math.min(speed / maxSpeed, 1);\n  }\n\n  private showNextImage() {\n    const dx = this.mousePos.x - this.cacheMousePos.x;\n    const dy = this.mousePos.y - this.cacheMousePos.y;\n    const speed = Math.sqrt(dx * dx + dy * dy);\n\n    ++this.zIndexVal;\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\n    const img = this.images[this.imgPosition];\n\n    const scaleFactor = this.mapSpeedToSize(speed, 0.3, 2);\n    const brightnessValue = this.mapSpeedToBrightness(speed, 0, 1.3);\n    const blurValue = this.mapSpeedToBlur(speed, 20, 0);\n    const grayscaleValue = this.mapSpeedToGrayscale(speed, 600, 0);\n\n    gsap.killTweensOf(img.DOM.el);\n    gsap\n      .timeline({\n        onStart: () => this.onImageActivated(),\n        onComplete: () => this.onImageDeactivated()\n      })\n      .fromTo(\n        img.DOM.el,\n        {\n          opacity: 1,\n          scale: 0,\n          zIndex: this.zIndexVal,\n          x: this.cacheMousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.cacheMousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        {\n          duration: 0.8,\n          ease: 'power3',\n          scale: scaleFactor,\n          filter: `grayscale(${grayscaleValue * 100}%) brightness(${brightnessValue * 100}%) blur(${blurValue}px)`,\n          x: this.mousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.mousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        0\n      )\n      .fromTo(\n        img.DOM.inner,\n        { scale: 2 },\n        {\n          duration: 0.8,\n          ease: 'power3',\n          scale: 1\n        },\n        0\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 0.4,\n          ease: 'power3.in',\n          opacity: 0,\n          scale: 0.2\n        },\n        0.45\n      );\n  }\n\n  private onImageActivated() {\n    this.activeImagesCount++;\n    this.isIdle = false;\n  }\n\n  private onImageDeactivated() {\n    this.activeImagesCount--;\n    if (this.activeImagesCount === 0) {\n      this.isIdle = true;\n    }\n  }\n}\n\nfunction getNewPosition(position: number, offset: number, arr: ImageItem[]) {\n  const realOffset = Math.abs(offset) % arr.length;\n  if (position - realOffset >= 0) {\n    return position - realOffset;\n  } else {\n    return arr.length - (realOffset - position);\n  }\n}\n\nclass ImageTrailVariant7 {\n  private container: HTMLDivElement;\n  private DOM: { el: HTMLDivElement };\n  private images: ImageItem[];\n  private imagesTotal: number;\n  private imgPosition: number;\n  private zIndexVal: number;\n  private activeImagesCount: number;\n  private isIdle: boolean;\n  private threshold: number;\n  private mousePos: { x: number; y: number };\n  private lastMousePos: { x: number; y: number };\n  private cacheMousePos: { x: number; y: number };\n  private visibleImagesCount: number;\n  private visibleImagesTotal: number;\n\n  constructor(container: HTMLDivElement) {\n    this.container = container;\n    this.DOM = { el: container };\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img as HTMLDivElement));\n    this.imagesTotal = this.images.length;\n    this.imgPosition = 0;\n    this.zIndexVal = 1;\n    this.activeImagesCount = 0;\n    this.isIdle = true;\n    this.threshold = 80;\n    this.mousePos = { x: 0, y: 0 };\n    this.lastMousePos = { x: 0, y: 0 };\n    this.cacheMousePos = { x: 0, y: 0 };\n    this.visibleImagesCount = 0;\n    this.visibleImagesTotal = 9;\n    this.visibleImagesTotal = Math.min(this.visibleImagesTotal, this.imagesTotal - 1);\n\n    const handlePointerMove = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n    };\n    container.addEventListener('mousemove', handlePointerMove);\n    container.addEventListener('touchmove', handlePointerMove);\n\n    const initRender = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n      this.cacheMousePos = { ...this.mousePos };\n      requestAnimationFrame(() => this.render());\n      container.removeEventListener('mousemove', initRender as EventListener);\n      container.removeEventListener('touchmove', initRender as EventListener);\n    };\n    container.addEventListener('mousemove', initRender as EventListener);\n    container.addEventListener('touchmove', initRender as EventListener);\n  }\n\n  private render() {\n    const distance = getMouseDistance(this.mousePos, this.lastMousePos);\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.3);\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.3);\n\n    if (distance > this.threshold) {\n      this.showNextImage();\n      this.lastMousePos = { ...this.mousePos };\n    }\n    if (this.isIdle && this.zIndexVal !== 1) this.zIndexVal = 1;\n\n    requestAnimationFrame(() => this.render());\n  }\n\n  private showNextImage() {\n    ++this.zIndexVal;\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\n    const img = this.images[this.imgPosition];\n    ++this.visibleImagesCount;\n\n    gsap.killTweensOf(img.DOM.el);\n    const scaleValue = gsap.utils.random(0.5, 1.6);\n\n    gsap\n      .timeline({\n        onStart: () => this.onImageActivated(),\n        onComplete: () => this.onImageDeactivated()\n      })\n      .fromTo(\n        img.DOM.el,\n        {\n          scale: scaleValue - Math.max(gsap.utils.random(0.2, 0.6), 0),\n          rotationZ: 0,\n          opacity: 1,\n          zIndex: this.zIndexVal,\n          x: this.cacheMousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.cacheMousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        {\n          duration: 0.4,\n          ease: 'power3',\n          scale: scaleValue,\n          rotationZ: gsap.utils.random(-3, 3),\n          x: this.mousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.mousePos.y - (img.rect?.height ?? 0) / 2\n        },\n        0\n      );\n\n    if (this.visibleImagesCount >= this.visibleImagesTotal) {\n      const lastInQueue = getNewPosition(this.imgPosition, this.visibleImagesTotal, this.images);\n      const oldImg = this.images[lastInQueue];\n      gsap.to(oldImg.DOM.el, {\n        duration: 0.4,\n        ease: 'power4',\n        opacity: 0,\n        scale: 1.3,\n        onComplete: () => {\n          if (this.activeImagesCount === 0) {\n            this.isIdle = true;\n          }\n        }\n      });\n    }\n  }\n\n  private onImageActivated() {\n    this.activeImagesCount++;\n    this.isIdle = false;\n  }\n\n  private onImageDeactivated() {\n    this.activeImagesCount--;\n  }\n}\n\nclass ImageTrailVariant8 {\n  private container: HTMLDivElement;\n  private DOM: { el: HTMLDivElement };\n  private images: ImageItem[];\n  private imagesTotal: number;\n  private imgPosition: number;\n  private zIndexVal: number;\n  private activeImagesCount: number;\n  private isIdle: boolean;\n  private threshold: number;\n  private mousePos: { x: number; y: number };\n  private lastMousePos: { x: number; y: number };\n  private cacheMousePos: { x: number; y: number };\n  private rotation: { x: number; y: number };\n  private cachedRotation: { x: number; y: number };\n  private zValue: number;\n  private cachedZValue: number;\n\n  constructor(container: HTMLDivElement) {\n    this.container = container;\n    this.DOM = { el: container };\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img as HTMLDivElement));\n    this.imagesTotal = this.images.length;\n    this.imgPosition = 0;\n    this.zIndexVal = 1;\n    this.activeImagesCount = 0;\n    this.isIdle = true;\n    this.threshold = 80;\n    this.mousePos = { x: 0, y: 0 };\n    this.lastMousePos = { x: 0, y: 0 };\n    this.cacheMousePos = { x: 0, y: 0 };\n    this.rotation = { x: 0, y: 0 };\n    this.cachedRotation = { x: 0, y: 0 };\n    this.zValue = 0;\n    this.cachedZValue = 0;\n\n    const handlePointerMove = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n    };\n    container.addEventListener('mousemove', handlePointerMove);\n    container.addEventListener('touchmove', handlePointerMove);\n\n    const initRender = (ev: MouseEvent | TouchEvent) => {\n      const rect = container.getBoundingClientRect();\n      this.mousePos = getLocalPointerPos(ev, rect);\n      this.cacheMousePos = { ...this.mousePos };\n      requestAnimationFrame(() => this.render());\n      container.removeEventListener('mousemove', initRender as EventListener);\n      container.removeEventListener('touchmove', initRender as EventListener);\n    };\n    container.addEventListener('mousemove', initRender as EventListener);\n    container.addEventListener('touchmove', initRender as EventListener);\n  }\n\n  private render() {\n    const distance = getMouseDistance(this.mousePos, this.lastMousePos);\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\n\n    if (distance > this.threshold) {\n      this.showNextImage();\n      this.lastMousePos = { ...this.mousePos };\n    }\n    if (this.isIdle && this.zIndexVal !== 1) {\n      this.zIndexVal = 1;\n    }\n    requestAnimationFrame(() => this.render());\n  }\n\n  private showNextImage() {\n    const rect = this.container.getBoundingClientRect();\n    const centerX = rect.width / 2;\n    const centerY = rect.height / 2;\n    const relX = this.mousePos.x - centerX;\n    const relY = this.mousePos.y - centerY;\n\n    this.rotation.x = -(relY / centerY) * 30;\n    this.rotation.y = (relX / centerX) * 30;\n    this.cachedRotation = { ...this.rotation };\n\n    const distanceFromCenter = Math.sqrt(relX * relX + relY * relY);\n    const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);\n    const proportion = distanceFromCenter / maxDistance;\n    this.zValue = proportion * 1200 - 600;\n    this.cachedZValue = this.zValue;\n    const normalizedZ = (this.zValue + 600) / 1200;\n    const brightness = 0.2 + normalizedZ * 2.3;\n\n    ++this.zIndexVal;\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\n    const img = this.images[this.imgPosition];\n    gsap.killTweensOf(img.DOM.el);\n\n    gsap\n      .timeline({\n        onStart: () => this.onImageActivated(),\n        onComplete: () => this.onImageDeactivated()\n      })\n      .set(this.DOM.el, { perspective: 1000 }, 0)\n      .fromTo(\n        img.DOM.el,\n        {\n          opacity: 1,\n          z: 0,\n          scale: 1 + this.cachedZValue / 1000,\n          zIndex: this.zIndexVal,\n          x: this.cacheMousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.cacheMousePos.y - (img.rect?.height ?? 0) / 2,\n          rotationX: this.cachedRotation.x,\n          rotationY: this.cachedRotation.y,\n          filter: `brightness(${brightness})`\n        },\n        {\n          duration: 1,\n          ease: 'expo',\n          scale: 1 + this.zValue / 1000,\n          x: this.mousePos.x - (img.rect?.width ?? 0) / 2,\n          y: this.mousePos.y - (img.rect?.height ?? 0) / 2,\n          rotationX: this.rotation.x,\n          rotationY: this.rotation.y\n        },\n        0\n      )\n      .to(\n        img.DOM.el,\n        {\n          duration: 0.4,\n          ease: 'power2',\n          opacity: 0,\n          z: -800\n        },\n        0.3\n      );\n  }\n\n  private onImageActivated() {\n    this.activeImagesCount++;\n    this.isIdle = false;\n  }\n\n  private onImageDeactivated() {\n    this.activeImagesCount--;\n    if (this.activeImagesCount === 0) {\n      this.isIdle = true;\n    }\n  }\n}\n\ntype ImageTrailConstructor =\n  | typeof ImageTrailVariant1\n  | typeof ImageTrailVariant2\n  | typeof ImageTrailVariant3\n  | typeof ImageTrailVariant4\n  | typeof ImageTrailVariant5\n  | typeof ImageTrailVariant6\n  | typeof ImageTrailVariant7\n  | typeof ImageTrailVariant8;\n\nconst variantMap: Record<number, ImageTrailConstructor> = {\n  1: ImageTrailVariant1,\n  2: ImageTrailVariant2,\n  3: ImageTrailVariant3,\n  4: ImageTrailVariant4,\n  5: ImageTrailVariant5,\n  6: ImageTrailVariant6,\n  7: ImageTrailVariant7,\n  8: ImageTrailVariant8\n};\n\ninterface ImageTrailProps {\n  items?: string[];\n  variant?: number;\n}\n\nexport default function ImageTrail({ items = [], variant = 1 }: ImageTrailProps): JSX.Element {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const Cls = variantMap[variant] || variantMap[1];\n    new Cls(containerRef.current);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [variant, items]);\n\n  return (\n    <div className=\"w-full h-full relative z-[100] rounded-lg bg-transparent overflow-visible\" ref={containerRef}>\n      {items.map((url, i) => (\n        <div\n          className=\"content__img w-[190px] aspect-[1.1] rounded-[15px] absolute top-0 left-0 opacity-0 overflow-hidden [will-change:transform,filter]\"\n          key={i}\n        >\n          <div\n            className=\"content__img-inner bg-center bg-cover w-[calc(100%+20px)] h-[calc(100%+20px)] absolute top-[-10px] left-[-10px]\"\n            style={{ backgroundImage: `url(${url})` }}\n          />\n        </div>\n      ))}\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "laser-flow",
      "type": "component",
      "description": "Flowing laser animation effect.",
      "category": "animations",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/laser-flow.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\n\ntype Props = {\n  className?: string;\n  style?: React.CSSProperties;\n  wispDensity?: number;\n  dpr?: number;\n  mouseSmoothTime?: number;\n  mouseTiltStrength?: number;\n  horizontalBeamOffset?: number;\n  verticalBeamOffset?: number;\n  flowSpeed?: number;\n  verticalSizing?: number;\n  horizontalSizing?: number;\n  fogIntensity?: number;\n  fogScale?: number;\n  wispSpeed?: number;\n  wispIntensity?: number;\n  flowStrength?: number;\n  decay?: number;\n  falloffStart?: number;\n  fogFallSpeed?: number;\n  color?: string;\n};\n\nconst VERT = `\nprecision highp float;\nattribute vec3 position;\nvoid main(){\n  gl_Position = vec4(position, 1.0);\n}\n`;\n\nconst FRAG = `\n#ifdef GL_ES\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\nprecision mediump int;\n\nuniform float iTime;\nuniform vec3 iResolution;\nuniform vec4 iMouse;\nuniform float uWispDensity;\nuniform float uTiltScale;\nuniform float uFlowTime;\nuniform float uFogTime;\nuniform float uBeamXFrac;\nuniform float uBeamYFrac;\nuniform float uFlowSpeed;\nuniform float uVLenFactor;\nuniform float uHLenFactor;\nuniform float uFogIntensity;\nuniform float uFogScale;\nuniform float uWSpeed;\nuniform float uWIntensity;\nuniform float uFlowStrength;\nuniform float uDecay;\nuniform float uFalloffStart;\nuniform float uFogFallSpeed;\nuniform vec3 uColor;\nuniform float uFade;\n\n// Core beam/flare shaping and dynamics\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPS 1e-6\n#define EDGE_SOFT (DT_LOCAL*4.0)\n#define DT_LOCAL 0.0038\n#define TAP_RADIUS 6\n#define R_H 150.0\n#define R_V 150.0\n#define FLARE_HEIGHT 16.0\n#define FLARE_AMOUNT 8.0\n#define FLARE_EXP 2.0\n#define TOP_FADE_START 0.1\n#define TOP_FADE_EXP 1.0\n#define FLOW_PERIOD 0.5\n#define FLOW_SHARPNESS 1.5\n\n// Wisps (animated micro-streaks) that travel along the beam\n#define W_BASE_X 1.5\n#define W_LAYER_GAP 0.25\n#define W_LANES 10\n#define W_SIDE_DECAY 0.5\n#define W_HALF 0.01\n#define W_AA 0.15\n#define W_CELL 20.0\n#define W_SEG_MIN 0.01\n#define W_SEG_MAX 0.55\n#define W_CURVE_AMOUNT 15.0\n#define W_CURVE_RANGE (FLARE_HEIGHT - 3.0)\n#define W_BOTTOM_EXP 10.0\n\n// Volumetric fog controls\n#define FOG_ON 1\n#define FOG_CONTRAST 1.2\n#define FOG_SPEED_U 0.1\n#define FOG_SPEED_V -0.1\n#define FOG_OCTAVES 5\n#define FOG_BOTTOM_BIAS 0.8\n#define FOG_TILT_TO_MOUSE 0.05\n#define FOG_TILT_DEADZONE 0.01\n#define FOG_TILT_MAX_X 0.35\n#define FOG_TILT_SHAPE 1.5\n#define FOG_BEAM_MIN 0.0\n#define FOG_BEAM_MAX 0.75\n#define FOG_MASK_GAMMA 0.5\n#define FOG_EXPAND_SHAPE 12.2\n#define FOG_EDGE_MIX 0.5\n\n// Horizontal vignette for the fog volume\n#define HFOG_EDGE_START 0.20\n#define HFOG_EDGE_END 0.98\n#define HFOG_EDGE_GAMMA 1.4\n#define HFOG_Y_RADIUS 25.0\n#define HFOG_Y_SOFT 60.0\n\n// Beam extents and edge masking\n#define EDGE_X0 0.22\n#define EDGE_X1 0.995\n#define EDGE_X_GAMMA 1.25\n#define EDGE_LUMA_T0 0.0\n#define EDGE_LUMA_T1 2.0\n#define DITHER_STRENGTH 1.0\n\n    float g(float x){return x<=0.00031308?12.92*x:1.055*pow(x,1.0/2.4)-0.055;}\n    float bs(vec2 p,vec2 q,float powr){\n        float d=distance(p,q),f=powr*uFalloffStart,r=(f*f)/(d*d+EPS);\n        return powr*min(1.0,r);\n    }\n    float bsa(vec2 p,vec2 q,float powr,vec2 s){\n        vec2 d=p-q; float dd=(d.x*d.x)/(s.x*s.x)+(d.y*d.y)/(s.y*s.y),f=powr*uFalloffStart,r=(f*f)/(dd+EPS);\n        return powr*min(1.0,r);\n    }\n    float tri01(float x){float f=fract(x);return 1.0-abs(f*2.0-1.0);}\n    float tauWf(float t,float tmin,float tmax){float a=smoothstep(tmin,tmin+EDGE_SOFT,t),b=1.0-smoothstep(tmax-EDGE_SOFT,tmax,t);return max(0.0,a*b);} \n    float h21(vec2 p){p=fract(p*vec2(123.34,456.21));p+=dot(p,p+34.123);return fract(p.x*p.y);}\n    float vnoise(vec2 p){\n        vec2 i=floor(p),f=fract(p);\n        float a=h21(i),b=h21(i+vec2(1,0)),c=h21(i+vec2(0,1)),d=h21(i+vec2(1,1));\n        vec2 u=f*f*(3.0-2.0*f);\n        return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\n    }\n    float fbm2(vec2 p){\n        float v=0.0,amp=0.6; mat2 m=mat2(0.86,0.5,-0.5,0.86);\n        for(int i=0;i<FOG_OCTAVES;++i){v+=amp*vnoise(p); p=m*p*2.03+17.1; amp*=0.52;}\n        return v;\n    }\n    float rGate(float x,float l){float a=smoothstep(0.0,W_AA,x),b=1.0-smoothstep(l,l+W_AA,x);return max(0.0,a*b);}\n    float flareY(float y){float t=clamp(1.0-(clamp(y,0.0,FLARE_HEIGHT)/max(FLARE_HEIGHT,EPS)),0.0,1.0);return pow(t,FLARE_EXP);}\n\n    float vWisps(vec2 uv,float topF){\n    float y=uv.y,yf=(y+uFlowTime*uWSpeed)/W_CELL;\n    float dRaw=clamp(uWispDensity,0.0,2.0),d=dRaw<=0.0?1.0:dRaw;\n    float lanesF=floor(float(W_LANES)*min(d,1.0)+0.5); // WebGL1-safe\n    int lanes=int(max(1.0,lanesF));\n    float sp=min(d,1.0),ep=max(d-1.0,0.0);\n    float fm=flareY(max(y,0.0)),rm=clamp(1.0-(y/max(W_CURVE_RANGE,EPS)),0.0,1.0),cm=fm*rm;\n    const float G=0.05; float xS=1.0+(FLARE_AMOUNT*W_CURVE_AMOUNT*G)*cm;\n    float sPix=clamp(y/R_V,0.0,1.0),bGain=pow(1.0-sPix,W_BOTTOM_EXP),sum=0.0;\n    for(int s=0;s<2;++s){\n        float sgn=s==0?-1.0:1.0;\n        for(int i=0;i<W_LANES;++i){\n            if(i>=lanes) break;\n            float off=W_BASE_X+float(i)*W_LAYER_GAP,xc=sgn*(off*xS);\n            float dx=abs(uv.x-xc),lat=1.0-smoothstep(W_HALF,W_HALF+W_AA,dx),amp=exp(-off*W_SIDE_DECAY);\n            float seed=h21(vec2(off,sgn*17.0)),yf2=yf+seed*7.0,ci=floor(yf2),fy=fract(yf2);\n            float seg=mix(W_SEG_MIN,W_SEG_MAX,h21(vec2(ci,off*2.3)));\n            float spR=h21(vec2(ci,off+sgn*31.0)),seg1=rGate(fy,seg)*step(spR,sp);\n            if(ep>0.0){float spR2=h21(vec2(ci*3.1+7.0,off*5.3+sgn*13.0)); float f2=fract(fy+0.5); seg1+=rGate(f2,seg*0.9)*step(spR2,ep);}\n            sum+=amp*lat*seg1;\n        }\n    }\n    float span=smoothstep(-3.0,0.0,y)*(1.0-smoothstep(R_V-6.0,R_V,y));\n    return uWIntensity*sum*topF*bGain*span;\n}\n\nvoid mainImage(out vec4 fc,in vec2 frag){\n    vec2 C=iResolution.xy*.5; float invW=1.0/max(C.x,1.0);\n    float sc=512.0/iResolution.x*.4;\n    vec2 uv=(frag-C)*sc,off=vec2(uBeamXFrac*iResolution.x*sc,uBeamYFrac*iResolution.y*sc);\n    vec2 uvc = uv - off;\n    float a=0.0,b=0.0;\n    float basePhase=1.5*PI+uDecay*.5; float tauMin=basePhase-uDecay; float tauMax=basePhase;\n    float cx=clamp(uvc.x/(R_H*uHLenFactor),-1.0,1.0),tH=clamp(TWO_PI-acos(cx),tauMin,tauMax);\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\n        float tu=tH+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\n        float spd=max(abs(sin(tu)),0.02),u=clamp((basePhase-tu)/max(uDecay,EPS),0.0,1.0),env=pow(1.0-abs(u*2.0-1.0),0.8);\n        vec2 p=vec2((R_H*uHLenFactor)*cos(tu),0.0);\n        a+=wt*bs(uvc,p,env*spd);\n    }\n    float yPix=uvc.y,cy=clamp(-yPix/(R_V*uVLenFactor),-1.0,1.0),tV=clamp(TWO_PI-acos(cy),tauMin,tauMax);\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\n        float tu=tV+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\n        float yb=(-R_V)*cos(tu),s=clamp(yb/R_V,0.0,1.0),spd=max(abs(sin(tu)),0.02);\n        float env=pow(1.0-s,0.6)*spd;\n        float cap=1.0-smoothstep(TOP_FADE_START,1.0,s); cap=pow(cap,TOP_FADE_EXP); env*=cap;\n        float ph=s/max(FLOW_PERIOD,EPS)+uFlowTime*uFlowSpeed;\n        float fl=pow(tri01(ph),FLOW_SHARPNESS);\n        env*=mix(1.0-uFlowStrength,1.0,fl);\n        float yp=(-R_V*uVLenFactor)*cos(tu),m=pow(smoothstep(FLARE_HEIGHT,0.0,yp),FLARE_EXP),wx=1.0+FLARE_AMOUNT*m;\n        vec2 sig=vec2(wx,1.0),p=vec2(0.0,yp);\n        float mask=step(0.0,yp);\n        b+=wt*bsa(uvc,p,mask*env,sig);\n    }\n    float sPix=clamp(yPix/R_V,0.0,1.0),topA=pow(1.0-smoothstep(TOP_FADE_START,1.0,sPix),TOP_FADE_EXP);\n    float L=a+b*topA;\n    float w=vWisps(vec2(uvc.x,yPix),topA);\n    float fog=0.0;\n#if FOG_ON\n    vec2 fuv=uvc*uFogScale;\n    float mAct=step(1.0,length(iMouse.xy)),nx=((iMouse.x-C.x)*invW)*mAct;\n    float ax = abs(nx);\n    float stMag = mix(ax, pow(ax, FOG_TILT_SHAPE), 0.35);\n    float st = sign(nx) * stMag * uTiltScale;\n    st = clamp(st, -FOG_TILT_MAX_X, FOG_TILT_MAX_X);\n    vec2 dir=normalize(vec2(st,1.0));\n    fuv+=uFogTime*uFogFallSpeed*dir;\n    vec2 prp=vec2(-dir.y,dir.x);\n    fuv+=prp*(0.08*sin(dot(uvc,prp)*0.08+uFogTime*0.9));\n    float n=fbm2(fuv+vec2(fbm2(fuv+vec2(7.3,2.1)),fbm2(fuv+vec2(-3.7,5.9)))*0.6);\n    n=pow(clamp(n,0.0,1.0),FOG_CONTRAST);\n    float pixW = 1.0 / max(iResolution.y, 1.0);\n#ifdef GL_OES_standard_derivatives\n    float wL = max(fwidth(L), pixW);\n#else\n    float wL = pixW;\n#endif\n    float m0=pow(smoothstep(FOG_BEAM_MIN - wL, FOG_BEAM_MAX + wL, L),FOG_MASK_GAMMA);\n    float bm=1.0-pow(1.0-m0,FOG_EXPAND_SHAPE); bm=mix(bm*m0,bm,FOG_EDGE_MIX);\n    float yP=1.0-smoothstep(HFOG_Y_RADIUS,HFOG_Y_RADIUS+HFOG_Y_SOFT,abs(yPix));\n    float nxF=abs((frag.x-C.x)*invW),hE=1.0-smoothstep(HFOG_EDGE_START,HFOG_EDGE_END,nxF); hE=pow(clamp(hE,0.0,1.0),HFOG_EDGE_GAMMA);\n    float hW=mix(1.0,hE,clamp(yP,0.0,1.0));\n    float bBias=mix(1.0,1.0-sPix,FOG_BOTTOM_BIAS);\n    float browserFogIntensity = uFogIntensity;\n    browserFogIntensity *= 1.8;\n    float radialFade = 1.0 - smoothstep(0.0, 0.7, length(uvc) / 120.0);\n    float safariFog = n * browserFogIntensity * bBias * bm * hW * radialFade;\n    fog = safariFog;\n#endif\n    float LF=L+fog;\n    float dith=(h21(frag)-0.5)*(DITHER_STRENGTH/255.0);\n    float tone=g(LF+w);\n    vec3 col=tone*uColor+dith;\n    float alpha=clamp(g(L+w*0.6)+dith*0.6,0.0,1.0);\n    float nxE=abs((frag.x-C.x)*invW),xF=pow(clamp(1.0-smoothstep(EDGE_X0,EDGE_X1,nxE),0.0,1.0),EDGE_X_GAMMA);\n    float scene=LF+max(0.0,w)*0.5,hi=smoothstep(EDGE_LUMA_T0,EDGE_LUMA_T1,scene);\n    float eM=mix(xF,1.0,hi);\n    col*=eM; alpha*=eM;\n    col*=uFade; alpha*=uFade;\n    fc=vec4(col,alpha);\n}\n\nvoid main(){\n  vec4 fc;\n  mainImage(fc, gl_FragCoord.xy);\n  gl_FragColor = fc;\n}\n`;\n\nexport const LaserFlow: React.FC<Props> = ({\n  className,\n  style,\n  wispDensity = 1,\n  dpr,\n  mouseSmoothTime = 0.0,\n  mouseTiltStrength = 0.01,\n  horizontalBeamOffset = 0.1,\n  verticalBeamOffset = 0.0,\n  flowSpeed = 0.35,\n  verticalSizing = 2.0,\n  horizontalSizing = 0.5,\n  fogIntensity = 0.45,\n  fogScale = 0.3,\n  wispSpeed = 15.0,\n  wispIntensity = 5.0,\n  flowStrength = 0.25,\n  decay = 1.1,\n  falloffStart = 1.2,\n  fogFallSpeed = 0.6,\n  color = '#FF79C6'\n}) => {\n  const mountRef = useRef<HTMLDivElement | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const uniformsRef = useRef<any>(null);\n  const hasFadedRef = useRef(false);\n  const rectRef = useRef<DOMRect | null>(null);\n  const baseDprRef = useRef<number>(1);\n  const currentDprRef = useRef<number>(1);\n  const lastSizeRef = useRef({ width: 0, height: 0, dpr: 0 });\n  const fpsSamplesRef = useRef<number[]>([]);\n  const lastFpsCheckRef = useRef<number>(performance.now());\n  const emaDtRef = useRef<number>(16.7); // ms\n  const pausedRef = useRef<boolean>(false);\n  const inViewRef = useRef<boolean>(true);\n\n  const hexToRGB = (hex: string) => {\n    let c = hex.trim();\n    if (c[0] === '#') c = c.slice(1);\n    if (c.length === 3)\n      c = c\n        .split('')\n        .map(x => x + x)\n        .join('');\n    const n = parseInt(c, 16) || 0xffffff;\n    return { r: ((n >> 16) & 255) / 255, g: ((n >> 8) & 255) / 255, b: (n & 255) / 255 };\n  };\n\n  useEffect(() => {\n    const mount = mountRef.current!;\n    const renderer = new THREE.WebGLRenderer({\n      antialias: false,\n      alpha: false,\n      depth: false,\n      stencil: false,\n      powerPreference: 'high-performance',\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: false,\n      failIfMajorPerformanceCaveat: false,\n      logarithmicDepthBuffer: false\n    });\n    rendererRef.current = renderer;\n\n    baseDprRef.current = Math.min(dpr ?? (window.devicePixelRatio || 1), 2);\n    currentDprRef.current = baseDprRef.current;\n\n    renderer.setPixelRatio(currentDprRef.current);\n    renderer.shadowMap.enabled = false;\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.setClearColor(0x000000, 1);\n    const canvas = renderer.domElement;\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.display = 'block';\n    mount.appendChild(canvas);\n\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 3));\n\n    const uniforms = {\n      iTime: { value: 0 },\n      iResolution: { value: new THREE.Vector3(1, 1, 1) },\n      iMouse: { value: new THREE.Vector4(0, 0, 0, 0) },\n      uWispDensity: { value: wispDensity },\n      uTiltScale: { value: mouseTiltStrength },\n      uFlowTime: { value: 0 },\n      uFogTime: { value: 0 },\n      uBeamXFrac: { value: horizontalBeamOffset },\n      uBeamYFrac: { value: verticalBeamOffset },\n      uFlowSpeed: { value: flowSpeed },\n      uVLenFactor: { value: verticalSizing },\n      uHLenFactor: { value: horizontalSizing },\n      uFogIntensity: { value: fogIntensity },\n      uFogScale: { value: fogScale },\n      uWSpeed: { value: wispSpeed },\n      uWIntensity: { value: wispIntensity },\n      uFlowStrength: { value: flowStrength },\n      uDecay: { value: decay },\n      uFalloffStart: { value: falloffStart },\n      uFogFallSpeed: { value: fogFallSpeed },\n      uColor: { value: new THREE.Vector3(1, 1, 1) },\n      uFade: { value: hasFadedRef.current ? 1 : 0 }\n    };\n    uniformsRef.current = uniforms;\n\n    const material = new THREE.RawShaderMaterial({\n      vertexShader: VERT,\n      fragmentShader: FRAG,\n      uniforms,\n      transparent: false,\n      depthTest: false,\n      depthWrite: false,\n      blending: THREE.NormalBlending\n    });\n\n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.frustumCulled = false;\n    scene.add(mesh);\n\n    const clock = new THREE.Clock();\n    let prevTime = 0;\n    let fade = hasFadedRef.current ? 1 : 0;\n\n    const mouseTarget = new THREE.Vector2(0, 0);\n    const mouseSmooth = new THREE.Vector2(0, 0);\n\n    const setSizeNow = () => {\n      const w = mount.clientWidth || 1;\n      const h = mount.clientHeight || 1;\n      const pr = currentDprRef.current;\n\n      const last = lastSizeRef.current;\n      const sizeChanged = Math.abs(w - last.width) > 0.5 || Math.abs(h - last.height) > 0.5;\n      const dprChanged = Math.abs(pr - last.dpr) > 0.01;\n      if (!sizeChanged && !dprChanged) {\n        return;\n      }\n\n      lastSizeRef.current = { width: w, height: h, dpr: pr };\n      renderer.setPixelRatio(pr);\n      renderer.setSize(w, h, false);\n      uniforms.iResolution.value.set(w * pr, h * pr, pr);\n      rectRef.current = canvas.getBoundingClientRect();\n\n      if (!pausedRef.current) {\n        renderer.render(scene, camera);\n      }\n    };\n\n    let resizeRaf = 0;\n    const scheduleResize = () => {\n      if (resizeRaf) cancelAnimationFrame(resizeRaf);\n      resizeRaf = requestAnimationFrame(setSizeNow);\n    };\n\n    setSizeNow();\n    const ro = new ResizeObserver(scheduleResize);\n    ro.observe(mount);\n\n    const io = new IntersectionObserver(\n      entries => {\n        inViewRef.current = entries[0]?.isIntersecting ?? true;\n      },\n      { root: null, threshold: 0 }\n    );\n    io.observe(mount);\n\n    const onVis = () => {\n      pausedRef.current = document.hidden;\n    };\n    document.addEventListener('visibilitychange', onVis, { passive: true });\n\n    const updateMouse = (clientX: number, clientY: number) => {\n      const rect = rectRef.current;\n      if (!rect) return;\n      const x = clientX - rect.left;\n      const y = clientY - rect.top;\n      const ratio = currentDprRef.current;\n      const hb = rect.height * ratio;\n      mouseTarget.set(x * ratio, hb - y * ratio);\n    };\n    const onMove = (ev: PointerEvent | MouseEvent) => updateMouse(ev.clientX, ev.clientY);\n    const onLeave = () => mouseTarget.set(0, 0);\n    canvas.addEventListener('pointermove', onMove as any, { passive: true });\n    canvas.addEventListener('pointerdown', onMove as any, { passive: true });\n    canvas.addEventListener('pointerenter', onMove as any, { passive: true });\n    canvas.addEventListener('pointerleave', onLeave as any, { passive: true });\n\n    const onCtxLost = (e: Event) => {\n      e.preventDefault();\n      pausedRef.current = true;\n    };\n    const onCtxRestored = () => {\n      pausedRef.current = false;\n      scheduleResize();\n    };\n    canvas.addEventListener('webglcontextlost', onCtxLost, false);\n    canvas.addEventListener('webglcontextrestored', onCtxRestored, false);\n\n    let raf = 0;\n\n    const clamp = (v: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, v));\n    const dprFloor = 0.6;\n    const lowerThresh = 50;\n    const upperThresh = 58;\n    let lastDprChangeRef = 0;\n    const dprChangeCooldown = 2000;\n\n    const adjustDprIfNeeded = (now: number) => {\n      const elapsed = now - lastFpsCheckRef.current;\n      if (elapsed < 750) return;\n\n      const samples = fpsSamplesRef.current;\n      if (samples.length === 0) {\n        lastFpsCheckRef.current = now;\n        return;\n      }\n      const avgFps = samples.reduce((a, b) => a + b, 0) / samples.length;\n\n      let next = currentDprRef.current;\n      const base = baseDprRef.current;\n\n      if (avgFps < lowerThresh) {\n        next = clamp(currentDprRef.current * 0.85, dprFloor, base);\n      } else if (avgFps > upperThresh && currentDprRef.current < base) {\n        next = clamp(currentDprRef.current * 1.1, dprFloor, base);\n      }\n\n      if (Math.abs(next - currentDprRef.current) > 0.01 && now - lastDprChangeRef > dprChangeCooldown) {\n        currentDprRef.current = next;\n        lastDprChangeRef = now;\n        setSizeNow();\n      }\n\n      fpsSamplesRef.current = [];\n      lastFpsCheckRef.current = now;\n    };\n\n    const animate = () => {\n      raf = requestAnimationFrame(animate);\n      if (pausedRef.current || !inViewRef.current) return;\n\n      const t = clock.getElapsedTime();\n      const dt = Math.max(0, t - prevTime);\n      prevTime = t;\n\n      const dtMs = dt * 1000;\n      emaDtRef.current = emaDtRef.current * 0.9 + dtMs * 0.1;\n      const instFps = 1000 / Math.max(1, emaDtRef.current);\n      fpsSamplesRef.current.push(instFps);\n\n      uniforms.iTime.value = t;\n\n      const cdt = Math.min(0.033, Math.max(0.001, dt));\n      (uniforms.uFlowTime.value as number) += cdt;\n      (uniforms.uFogTime.value as number) += cdt;\n\n      if (!hasFadedRef.current) {\n        const fadeDur = 1.0;\n        fade = Math.min(1, fade + cdt / fadeDur);\n        uniforms.uFade.value = fade;\n        if (fade >= 1) hasFadedRef.current = true;\n      }\n\n      const tau = Math.max(1e-3, mouseSmoothTime);\n      const alpha = 1 - Math.exp(-cdt / tau);\n      mouseSmooth.lerp(mouseTarget, alpha);\n      uniforms.iMouse.value.set(mouseSmooth.x, mouseSmooth.y, 0, 0);\n\n      renderer.render(scene, camera);\n\n      adjustDprIfNeeded(performance.now());\n    };\n\n    animate();\n\n    return () => {\n      cancelAnimationFrame(raf);\n      ro.disconnect();\n      io.disconnect();\n      document.removeEventListener('visibilitychange', onVis);\n      canvas.removeEventListener('pointermove', onMove as any);\n      canvas.removeEventListener('pointerdown', onMove as any);\n      canvas.removeEventListener('pointerenter', onMove as any);\n      canvas.removeEventListener('pointerleave', onLeave as any);\n      canvas.removeEventListener('webglcontextlost', onCtxLost);\n      canvas.removeEventListener('webglcontextrestored', onCtxRestored);\n      geometry.dispose();\n      material.dispose();\n      renderer.dispose();\n      if (mount.contains(canvas)) mount.removeChild(canvas);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dpr]);\n\n  useEffect(() => {\n    const uniforms = uniformsRef.current;\n    if (!uniforms) return;\n\n    uniforms.uWispDensity.value = wispDensity;\n    uniforms.uTiltScale.value = mouseTiltStrength;\n    uniforms.uBeamXFrac.value = horizontalBeamOffset;\n    uniforms.uBeamYFrac.value = verticalBeamOffset;\n    uniforms.uFlowSpeed.value = flowSpeed;\n    uniforms.uVLenFactor.value = verticalSizing;\n    uniforms.uHLenFactor.value = horizontalSizing;\n    uniforms.uFogIntensity.value = fogIntensity;\n    uniforms.uFogScale.value = fogScale;\n    uniforms.uWSpeed.value = wispSpeed;\n    uniforms.uWIntensity.value = wispIntensity;\n    uniforms.uFlowStrength.value = flowStrength;\n    uniforms.uDecay.value = decay;\n    uniforms.uFalloffStart.value = falloffStart;\n    uniforms.uFogFallSpeed.value = fogFallSpeed;\n\n    const { r, g, b } = hexToRGB(color || '#FFFFFF');\n    uniforms.uColor.value.set(r, g, b);\n  }, [\n    wispDensity,\n    mouseTiltStrength,\n    horizontalBeamOffset,\n    verticalBeamOffset,\n    flowSpeed,\n    verticalSizing,\n    horizontalSizing,\n    fogIntensity,\n    fogScale,\n    wispSpeed,\n    wispIntensity,\n    flowStrength,\n    decay,\n    falloffStart,\n    fogFallSpeed,\n    color\n  ]);\n\n  return <div ref={mountRef} className={`w-full h-full relative ${className || ''}`} style={style} />;\n};\n\nexport default LaserFlow;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "logo-loop",
      "type": "component",
      "description": "Looping logo animation.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/logo-loop.tsx",
          "content": "import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nexport type LogoItem =\n  | {\n      node: React.ReactNode;\n      href?: string;\n      title?: string;\n      ariaLabel?: string;\n    }\n  | {\n      src: string;\n      alt?: string;\n      href?: string;\n      title?: string;\n      srcSet?: string;\n      sizes?: string;\n      width?: number;\n      height?: number;\n    };\n\nexport interface LogoLoopProps {\n  logos: LogoItem[];\n  speed?: number;\n  direction?: 'left' | 'right' | 'up' | 'down';\n  width?: number | string;\n  logoHeight?: number;\n  gap?: number;\n  pauseOnHover?: boolean;\n  hoverSpeed?: number;\n  fadeOut?: boolean;\n  fadeOutColor?: string;\n  scaleOnHover?: boolean;\n  renderItem?: (item: LogoItem, key: React.Key) => React.ReactNode;\n  ariaLabel?: string;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst ANIMATION_CONFIG = {\n  SMOOTH_TAU: 0.25,\n  MIN_COPIES: 2,\n  COPY_HEADROOM: 2\n} as const;\n\nconst toCssLength = (value?: number | string): string | undefined =>\n  typeof value === 'number' ? `${value}px` : (value ?? undefined);\n\nconst cx = (...parts: Array<string | false | null | undefined>) => parts.filter(Boolean).join(' ');\n\nconst useResizeObserver = (\n  callback: () => void,\n  elements: Array<React.RefObject<Element | null>>,\n  dependencies: React.DependencyList\n) => {\n  useEffect(() => {\n    if (!window.ResizeObserver) {\n      const handleResize = () => callback();\n      window.addEventListener('resize', handleResize);\n      callback();\n      return () => window.removeEventListener('resize', handleResize);\n    }\n\n    const observers = elements.map(ref => {\n      if (!ref.current) return null;\n      const observer = new ResizeObserver(callback);\n      observer.observe(ref.current);\n      return observer;\n    });\n\n    callback();\n\n    return () => {\n      observers.forEach(observer => observer?.disconnect());\n    };\n  }, dependencies);\n};\n\nconst useImageLoader = (\n  seqRef: React.RefObject<HTMLUListElement | null>,\n  onLoad: () => void,\n  dependencies: React.DependencyList\n) => {\n  useEffect(() => {\n    const images = seqRef.current?.querySelectorAll('img') ?? [];\n\n    if (images.length === 0) {\n      onLoad();\n      return;\n    }\n\n    let remainingImages = images.length;\n    const handleImageLoad = () => {\n      remainingImages -= 1;\n      if (remainingImages === 0) {\n        onLoad();\n      }\n    };\n\n    images.forEach(img => {\n      const htmlImg = img as HTMLImageElement;\n      if (htmlImg.complete) {\n        handleImageLoad();\n      } else {\n        htmlImg.addEventListener('load', handleImageLoad, { once: true });\n        htmlImg.addEventListener('error', handleImageLoad, { once: true });\n      }\n    });\n\n    return () => {\n      images.forEach(img => {\n        img.removeEventListener('load', handleImageLoad);\n        img.removeEventListener('error', handleImageLoad);\n      });\n    };\n  }, dependencies);\n};\n\nconst useAnimationLoop = (\n  trackRef: React.RefObject<HTMLDivElement | null>,\n  targetVelocity: number,\n  seqWidth: number,\n  seqHeight: number,\n  isHovered: boolean,\n  hoverSpeed: number | undefined,\n  isVertical: boolean\n) => {\n  const rafRef = useRef<number | null>(null);\n  const lastTimestampRef = useRef<number | null>(null);\n  const offsetRef = useRef(0);\n  const velocityRef = useRef(0);\n\n  useEffect(() => {\n    const track = trackRef.current;\n    if (!track) return;\n\n    const prefersReduced =\n      typeof window !== 'undefined' &&\n      window.matchMedia &&\n      window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n\n    const seqSize = isVertical ? seqHeight : seqWidth;\n\n    if (seqSize > 0) {\n      offsetRef.current = ((offsetRef.current % seqSize) + seqSize) % seqSize;\n      const transformValue = isVertical\n        ? `translate3d(0, ${-offsetRef.current}px, 0)`\n        : `translate3d(${-offsetRef.current}px, 0, 0)`;\n      track.style.transform = transformValue;\n    }\n\n    if (prefersReduced) {\n      track.style.transform = isVertical ? 'translate3d(0, 0, 0)' : 'translate3d(0, 0, 0)';\n      return () => {\n        lastTimestampRef.current = null;\n      };\n    }\n\n    const animate = (timestamp: number) => {\n      if (lastTimestampRef.current === null) {\n        lastTimestampRef.current = timestamp;\n      }\n\n      const deltaTime = Math.max(0, timestamp - lastTimestampRef.current) / 1000;\n      lastTimestampRef.current = timestamp;\n\n      const target = isHovered && hoverSpeed !== undefined ? hoverSpeed : targetVelocity;\n\n      const easingFactor = 1 - Math.exp(-deltaTime / ANIMATION_CONFIG.SMOOTH_TAU);\n      velocityRef.current += (target - velocityRef.current) * easingFactor;\n\n      if (seqSize > 0) {\n        let nextOffset = offsetRef.current + velocityRef.current * deltaTime;\n        nextOffset = ((nextOffset % seqSize) + seqSize) % seqSize;\n        offsetRef.current = nextOffset;\n\n        const transformValue = isVertical\n          ? `translate3d(0, ${-offsetRef.current}px, 0)`\n          : `translate3d(${-offsetRef.current}px, 0, 0)`;\n        track.style.transform = transformValue;\n      }\n\n      rafRef.current = requestAnimationFrame(animate);\n    };\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    return () => {\n      if (rafRef.current !== null) {\n        cancelAnimationFrame(rafRef.current);\n        rafRef.current = null;\n      }\n      lastTimestampRef.current = null;\n    };\n  }, [targetVelocity, seqWidth, seqHeight, isHovered, hoverSpeed, isVertical]);\n};\n\nexport const LogoLoop = React.memo<LogoLoopProps>(\n  ({\n    logos,\n    speed = 120,\n    direction = 'left',\n    width = '100%',\n    logoHeight = 28,\n    gap = 32,\n    pauseOnHover,\n    hoverSpeed,\n    fadeOut = false,\n    fadeOutColor,\n    scaleOnHover = false,\n    renderItem,\n    ariaLabel = 'Partner logos',\n    className,\n    style\n  }) => {\n    const containerRef = useRef<HTMLDivElement>(null);\n    const trackRef = useRef<HTMLDivElement>(null);\n    const seqRef = useRef<HTMLUListElement>(null);\n\n    const [seqWidth, setSeqWidth] = useState<number>(0);\n    const [seqHeight, setSeqHeight] = useState<number>(0);\n    const [copyCount, setCopyCount] = useState<number>(ANIMATION_CONFIG.MIN_COPIES);\n    const [isHovered, setIsHovered] = useState<boolean>(false);\n\n    const effectiveHoverSpeed = useMemo(() => {\n      if (hoverSpeed !== undefined) return hoverSpeed;\n      if (pauseOnHover === true) return 0;\n      if (pauseOnHover === false) return undefined;\n      return 0;\n    }, [hoverSpeed, pauseOnHover]);\n\n    const isVertical = direction === 'up' || direction === 'down';\n\n    const targetVelocity = useMemo(() => {\n      const magnitude = Math.abs(speed);\n      let directionMultiplier: number;\n      if (isVertical) {\n        directionMultiplier = direction === 'up' ? 1 : -1;\n      } else {\n        directionMultiplier = direction === 'left' ? 1 : -1;\n      }\n      const speedMultiplier = speed < 0 ? -1 : 1;\n      return magnitude * directionMultiplier * speedMultiplier;\n    }, [speed, direction, isVertical]);\n\n    const updateDimensions = useCallback(() => {\n      const containerWidth = containerRef.current?.clientWidth ?? 0;\n      const sequenceRect = seqRef.current?.getBoundingClientRect?.();\n      const sequenceWidth = sequenceRect?.width ?? 0;\n      const sequenceHeight = sequenceRect?.height ?? 0;\n      if (isVertical) {\n        const parentHeight = containerRef.current?.parentElement?.clientHeight ?? 0;\n        if (containerRef.current && parentHeight > 0) {\n          const targetHeight = Math.ceil(parentHeight);\n          if (containerRef.current.style.height !== `${targetHeight}px`)\n            containerRef.current.style.height = `${targetHeight}px`;\n        }\n        if (sequenceHeight > 0) {\n          setSeqHeight(Math.ceil(sequenceHeight));\n          const viewport = containerRef.current?.clientHeight ?? parentHeight ?? sequenceHeight;\n          const copiesNeeded = Math.ceil(viewport / sequenceHeight) + ANIMATION_CONFIG.COPY_HEADROOM;\n          setCopyCount(Math.max(ANIMATION_CONFIG.MIN_COPIES, copiesNeeded));\n        }\n      } else if (sequenceWidth > 0) {\n        setSeqWidth(Math.ceil(sequenceWidth));\n        const copiesNeeded = Math.ceil(containerWidth / sequenceWidth) + ANIMATION_CONFIG.COPY_HEADROOM;\n        setCopyCount(Math.max(ANIMATION_CONFIG.MIN_COPIES, copiesNeeded));\n      }\n    }, [isVertical]);\n\n    useResizeObserver(updateDimensions, [containerRef, seqRef], [logos, gap, logoHeight, isVertical]);\n\n    useImageLoader(seqRef, updateDimensions, [logos, gap, logoHeight, isVertical]);\n\n    useAnimationLoop(trackRef, targetVelocity, seqWidth, seqHeight, isHovered, effectiveHoverSpeed, isVertical);\n\n    const cssVariables = useMemo(\n      () =>\n        ({\n          '--logoloop-gap': `${gap}px`,\n          '--logoloop-logoHeight': `${logoHeight}px`,\n          ...(fadeOutColor && { '--logoloop-fadeColor': fadeOutColor })\n        }) as React.CSSProperties,\n      [gap, logoHeight, fadeOutColor]\n    );\n\n    const rootClasses = useMemo(\n      () =>\n        cx(\n          'relative group',\n          isVertical ? 'overflow-hidden h-full inline-block' : 'overflow-x-hidden',\n          '[--logoloop-gap:32px]',\n          '[--logoloop-logoHeight:28px]',\n          '[--logoloop-fadeColorAuto:#ffffff]',\n          'dark:[--logoloop-fadeColorAuto:#0b0b0b]',\n          scaleOnHover && 'py-[calc(var(--logoloop-logoHeight)*0.1)]',\n          className\n        ),\n      [isVertical, scaleOnHover, className]\n    );\n\n    const handleMouseEnter = useCallback(() => {\n      if (effectiveHoverSpeed !== undefined) setIsHovered(true);\n    }, [effectiveHoverSpeed]);\n    const handleMouseLeave = useCallback(() => {\n      if (effectiveHoverSpeed !== undefined) setIsHovered(false);\n    }, [effectiveHoverSpeed]);\n\n    const renderLogoItem = useCallback(\n      (item: LogoItem, key: React.Key) => {\n        if (renderItem) {\n          return (\n            <li\n              className={cx(\n                'flex-none text-[length:var(--logoloop-logoHeight)] leading-[1]',\n                isVertical ? 'mb-[var(--logoloop-gap)]' : 'mr-[var(--logoloop-gap)]',\n                scaleOnHover && 'overflow-visible group/item'\n              )}\n              key={key}\n              role=\"listitem\"\n            >\n              {renderItem(item, key)}\n            </li>\n          );\n        }\n\n        const isNodeItem = 'node' in item;\n\n        const content = isNodeItem ? (\n          <span\n            className={cx(\n              'inline-flex items-center',\n              'motion-reduce:transition-none',\n              scaleOnHover &&\n                'transition-transform duration-300 ease-[cubic-bezier(0.4,0,0.2,1)] group-hover/item:scale-120'\n            )}\n            aria-hidden={!!(item as any).href && !(item as any).ariaLabel}\n          >\n            {(item as any).node}\n          </span>\n        ) : (\n          <img\n            className={cx(\n              'h-[var(--logoloop-logoHeight)] w-auto block object-contain',\n              '[-webkit-user-drag:none] pointer-events-none',\n              '[image-rendering:-webkit-optimize-contrast]',\n              'motion-reduce:transition-none',\n              scaleOnHover &&\n                'transition-transform duration-300 ease-[cubic-bezier(0.4,0,0.2,1)] group-hover/item:scale-120'\n            )}\n            src={(item as any).src}\n            srcSet={(item as any).srcSet}\n            sizes={(item as any).sizes}\n            width={(item as any).width}\n            height={(item as any).height}\n            alt={(item as any).alt ?? ''}\n            title={(item as any).title}\n            loading=\"lazy\"\n            decoding=\"async\"\n            draggable={false}\n          />\n        );\n\n        const itemAriaLabel = isNodeItem\n          ? ((item as any).ariaLabel ?? (item as any).title)\n          : ((item as any).alt ?? (item as any).title);\n\n        const inner = (item as any).href ? (\n          <a\n            className={cx(\n              'inline-flex items-center no-underline rounded',\n              'transition-opacity duration-200 ease-linear',\n              'hover:opacity-80',\n              'focus-visible:outline focus-visible:outline-current focus-visible:outline-offset-2'\n            )}\n            href={(item as any).href}\n            aria-label={itemAriaLabel || 'logo link'}\n            target=\"_blank\"\n            rel=\"noreferrer noopener\"\n          >\n            {content}\n          </a>\n        ) : (\n          content\n        );\n\n        return (\n          <li\n            className={cx(\n              'flex-none text-[length:var(--logoloop-logoHeight)] leading-[1]',\n              isVertical ? 'mb-[var(--logoloop-gap)]' : 'mr-[var(--logoloop-gap)]',\n              scaleOnHover && 'overflow-visible group/item'\n            )}\n            key={key}\n            role=\"listitem\"\n          >\n            {inner}\n          </li>\n        );\n      },\n      [isVertical, scaleOnHover, renderItem]\n    );\n\n    const logoLists = useMemo(\n      () =>\n        Array.from({ length: copyCount }, (_, copyIndex) => (\n          <ul\n            className={cx('flex items-center', isVertical && 'flex-col')}\n            key={`copy-${copyIndex}`}\n            role=\"list\"\n            aria-hidden={copyIndex > 0}\n            ref={copyIndex === 0 ? seqRef : undefined}\n          >\n            {logos.map((item, itemIndex) => renderLogoItem(item, `${copyIndex}-${itemIndex}`))}\n          </ul>\n        )),\n      [copyCount, logos, renderLogoItem, isVertical]\n    );\n\n    const containerStyle = useMemo(\n      (): React.CSSProperties => ({\n        width: isVertical\n          ? toCssLength(width) === '100%'\n            ? undefined\n            : toCssLength(width)\n          : (toCssLength(width) ?? '100%'),\n        ...cssVariables,\n        ...style\n      }),\n      [width, cssVariables, style, isVertical]\n    );\n\n    return (\n      <div ref={containerRef} className={rootClasses} style={containerStyle} role=\"region\" aria-label={ariaLabel}>\n        {fadeOut && (\n          <>\n            {isVertical ? (\n              <>\n                <div\n                  aria-hidden\n                  className={cx(\n                    'pointer-events-none absolute inset-x-0 top-0 z-10',\n                    'h-[clamp(24px,8%,120px)]',\n                    'bg-[linear-gradient(to_bottom,var(--logoloop-fadeColor,var(--logoloop-fadeColorAuto))_0%,rgba(0,0,0,0)_100%)]'\n                  )}\n                />\n                <div\n                  aria-hidden\n                  className={cx(\n                    'pointer-events-none absolute inset-x-0 bottom-0 z-10',\n                    'h-[clamp(24px,8%,120px)]',\n                    'bg-[linear-gradient(to_top,var(--logoloop-fadeColor,var(--logoloop-fadeColorAuto))_0%,rgba(0,0,0,0)_100%)]'\n                  )}\n                />\n              </>\n            ) : (\n              <>\n                <div\n                  aria-hidden\n                  className={cx(\n                    'pointer-events-none absolute inset-y-0 left-0 z-10',\n                    'w-[clamp(24px,8%,120px)]',\n                    'bg-[linear-gradient(to_right,var(--logoloop-fadeColor,var(--logoloop-fadeColorAuto))_0%,rgba(0,0,0,0)_100%)]'\n                  )}\n                />\n                <div\n                  aria-hidden\n                  className={cx(\n                    'pointer-events-none absolute inset-y-0 right-0 z-10',\n                    'w-[clamp(24px,8%,120px)]',\n                    'bg-[linear-gradient(to_left,var(--logoloop-fadeColor,var(--logoloop-fadeColorAuto))_0%,rgba(0,0,0,0)_100%)]'\n                  )}\n                />\n              </>\n            )}\n          </>\n        )}\n\n        <div\n          className={cx(\n            'flex will-change-transform select-none relative z-0',\n            'motion-reduce:transform-none',\n            isVertical ? 'flex-col h-max w-full' : 'flex-row w-max'\n          )}\n          ref={trackRef}\n          onMouseEnter={handleMouseEnter}\n          onMouseLeave={handleMouseLeave}\n        >\n          {logoLists}\n        </div>\n      </div>\n    );\n  }\n);\n\nLogoLoop.displayName = 'LogoLoop';\n\nexport default LogoLoop;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "magic-card",
      "type": "component",
      "description": "A spotlight effect that follows your mouse cursor and highlights borders on hover.",
      "category": "animations",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/magic-card.tsx",
          "content": "\"use client\"\n\nimport React, { useCallback, useEffect } from \"react\"\nimport { motion, useMotionTemplate, useMotionValue } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface MagicCardProps {\n  children?: React.ReactNode\n  className?: string\n  gradientSize?: number\n  gradientColor?: string\n  gradientOpacity?: number\n  gradientFrom?: string\n  gradientTo?: string\n}\n\nexport function MagicCard({\n  children,\n  className,\n  gradientSize = 200,\n  gradientColor = \"#262626\",\n  gradientOpacity = 0.8,\n  gradientFrom = \"#9E7AFF\",\n  gradientTo = \"#FE8BBB\",\n}: MagicCardProps) {\n  const mouseX = useMotionValue(-gradientSize)\n  const mouseY = useMotionValue(-gradientSize)\n  const reset = useCallback(() => {\n    mouseX.set(-gradientSize)\n    mouseY.set(-gradientSize)\n  }, [gradientSize, mouseX, mouseY])\n\n  const handlePointerMove = useCallback(\n    (e: React.PointerEvent<HTMLDivElement>) => {\n      const rect = e.currentTarget.getBoundingClientRect()\n      mouseX.set(e.clientX - rect.left)\n      mouseY.set(e.clientY - rect.top)\n    },\n    [mouseX, mouseY]\n  )\n\n  useEffect(() => {\n    reset()\n  }, [reset])\n\n  useEffect(() => {\n    const handleGlobalPointerOut = (e: PointerEvent) => {\n      if (!e.relatedTarget) {\n        reset()\n      }\n    }\n\n    const handleVisibility = () => {\n      if (document.visibilityState !== \"visible\") {\n        reset()\n      }\n    }\n\n    window.addEventListener(\"pointerout\", handleGlobalPointerOut)\n    window.addEventListener(\"blur\", reset)\n    document.addEventListener(\"visibilitychange\", handleVisibility)\n\n    return () => {\n      window.removeEventListener(\"pointerout\", handleGlobalPointerOut)\n      window.removeEventListener(\"blur\", reset)\n      document.removeEventListener(\"visibilitychange\", handleVisibility)\n    }\n  }, [reset])\n\n  return (\n    <div\n      className={cn(\"group relative rounded-[inherit]\", className)}\n      onPointerMove={handlePointerMove}\n      onPointerLeave={reset}\n      onPointerEnter={reset}\n    >\n      <motion.div\n        className=\"bg-border pointer-events-none absolute inset-0 rounded-[inherit] duration-300 group-hover:opacity-100\"\n        style={{\n          background: useMotionTemplate`\n          radial-gradient(${gradientSize}px circle at ${mouseX}px ${mouseY}px,\n          ${gradientFrom}, \n          ${gradientTo}, \n          var(--border) 100%\n          )\n          `,\n        }}\n      />\n      <div className=\"bg-background absolute inset-px rounded-[inherit]\" />\n      <motion.div\n        className=\"pointer-events-none absolute inset-px rounded-[inherit] opacity-0 transition-opacity duration-300 group-hover:opacity-100\"\n        style={{\n          background: useMotionTemplate`\n            radial-gradient(${gradientSize}px circle at ${mouseX}px ${mouseY}px, ${gradientColor}, transparent 100%)\n          `,\n          opacity: gradientOpacity,\n        }}\n      />\n      <div className=\"relative\">{children}</div>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "magnet",
      "type": "component",
      "description": "Magnetic attraction effect on hover.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/magnet.tsx",
          "content": "import React, { useState, useEffect, useRef, ReactNode, HTMLAttributes } from 'react';\n\ninterface MagnetProps extends HTMLAttributes<HTMLDivElement> {\n  children: ReactNode;\n  padding?: number;\n  disabled?: boolean;\n  magnetStrength?: number;\n  activeTransition?: string;\n  inactiveTransition?: string;\n  wrapperClassName?: string;\n  innerClassName?: string;\n}\n\nconst Magnet: React.FC<MagnetProps> = ({\n  children,\n  padding = 100,\n  disabled = false,\n  magnetStrength = 2,\n  activeTransition = 'transform 0.3s ease-out',\n  inactiveTransition = 'transform 0.5s ease-in-out',\n  wrapperClassName = '',\n  innerClassName = '',\n  ...props\n}) => {\n  const [isActive, setIsActive] = useState<boolean>(false);\n  const [position, setPosition] = useState<{ x: number; y: number }>({ x: 0, y: 0 });\n  const magnetRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (disabled) {\n      setPosition({ x: 0, y: 0 });\n      return;\n    }\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!magnetRef.current) return;\n\n      const { left, top, width, height } = magnetRef.current.getBoundingClientRect();\n      const centerX = left + width / 2;\n      const centerY = top + height / 2;\n\n      const distX = Math.abs(centerX - e.clientX);\n      const distY = Math.abs(centerY - e.clientY);\n\n      if (distX < width / 2 + padding && distY < height / 2 + padding) {\n        setIsActive(true);\n        const offsetX = (e.clientX - centerX) / magnetStrength;\n        const offsetY = (e.clientY - centerY) / magnetStrength;\n        setPosition({ x: offsetX, y: offsetY });\n      } else {\n        setIsActive(false);\n        setPosition({ x: 0, y: 0 });\n      }\n    };\n\n    window.addEventListener('mousemove', handleMouseMove);\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, [padding, disabled, magnetStrength]);\n\n  const transitionStyle = isActive ? activeTransition : inactiveTransition;\n\n  return (\n    <div\n      ref={magnetRef}\n      className={wrapperClassName}\n      style={{ position: 'relative', display: 'inline-block' }}\n      {...props}\n    >\n      <div\n        className={innerClassName}\n        style={{\n          transform: `translate3d(${position.x}px, ${position.y}px, 0)`,\n          transition: transitionStyle,\n          willChange: 'transform'\n        }}\n      >\n        {children}\n      </div>\n    </div>\n  );\n};\n\nexport default Magnet;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "magnet-lines",
      "type": "component",
      "description": "Magnetic lines animation effect.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/magnet-lines.tsx",
          "content": "import React, { useRef, useEffect, CSSProperties } from 'react';\n\ninterface MagnetLinesProps {\n  rows?: number;\n  columns?: number;\n  containerSize?: string;\n  lineColor?: string;\n  lineWidth?: string;\n  lineHeight?: string;\n  baseAngle?: number;\n  className?: string;\n  style?: CSSProperties;\n}\n\nconst MagnetLines: React.FC<MagnetLinesProps> = ({\n  rows = 9,\n  columns = 9,\n  containerSize = '80vmin',\n  lineColor = '#efefef',\n  lineWidth = '1vmin',\n  lineHeight = '6vmin',\n  baseAngle = -10,\n  className = '',\n  style = {}\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const items = container.querySelectorAll<HTMLSpanElement>('span');\n\n    const onPointerMove = (pointer: { x: number; y: number }) => {\n      items.forEach(item => {\n        const rect = item.getBoundingClientRect();\n        const centerX = rect.x + rect.width / 2;\n        const centerY = rect.y + rect.height / 2;\n\n        const b = pointer.x - centerX;\n        const a = pointer.y - centerY;\n        const c = Math.sqrt(a * a + b * b) || 1;\n        const r = ((Math.acos(b / c) * 180) / Math.PI) * (pointer.y > centerY ? 1 : -1);\n\n        item.style.setProperty('--rotate', `${r}deg`);\n      });\n    };\n\n    const handlePointerMove = (e: PointerEvent) => {\n      onPointerMove({ x: e.x, y: e.y });\n    };\n\n    window.addEventListener('pointermove', handlePointerMove);\n\n    if (items.length) {\n      const middleIndex = Math.floor(items.length / 2);\n      const rect = items[middleIndex].getBoundingClientRect();\n      onPointerMove({ x: rect.x, y: rect.y });\n    }\n\n    return () => {\n      window.removeEventListener('pointermove', handlePointerMove);\n    };\n  }, []);\n\n  const total = rows * columns;\n  const spans = Array.from({ length: total }, (_, i) => (\n    <span\n      key={i}\n      className=\"block origin-center\"\n      style={{\n        backgroundColor: lineColor,\n        width: lineWidth,\n        height: lineHeight,\n        //@ts-ignore\n        '--rotate': `${baseAngle}deg`,\n        transform: 'rotate(var(--rotate))',\n        willChange: 'transform'\n      }}\n    />\n  ));\n\n  return (\n    <div\n      ref={containerRef}\n      className={`grid place-items-center ${className}`}\n      style={{\n        gridTemplateColumns: `repeat(${columns}, 1fr)`,\n        gridTemplateRows: `repeat(${rows}, 1fr)`,\n        width: containerSize,\n        height: containerSize,\n        ...style\n      }}\n    >\n      {spans}\n    </div>\n  );\n};\n\nexport default MagnetLines;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "meta-balls",
      "type": "component",
      "description": "Metaballs animation effect.",
      "category": "animations",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/meta-balls.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { Renderer, Program, Mesh, Triangle, Transform, Vec3, Camera } from 'ogl';\n\ntype MetaBallsProps = {\n  color?: string;\n  speed?: number;\n  enableMouseInteraction?: boolean;\n  hoverSmoothness?: number;\n  animationSize?: number;\n  ballCount?: number;\n  clumpFactor?: number;\n  cursorBallSize?: number;\n  cursorBallColor?: string;\n  enableTransparency?: boolean;\n};\n\nfunction parseHexColor(hex: string): [number, number, number] {\n  const c = hex.replace('#', '');\n  const r = parseInt(c.substring(0, 2), 16) / 255;\n  const g = parseInt(c.substring(2, 4), 16) / 255;\n  const b = parseInt(c.substring(4, 6), 16) / 255;\n  return [r, g, b];\n}\n\nfunction fract(x: number): number {\n  return x - Math.floor(x);\n}\n\nfunction hash31(p: number): number[] {\n  let r = [p * 0.1031, p * 0.103, p * 0.0973].map(fract);\n  const r_yzx = [r[1], r[2], r[0]];\n  const dotVal = r[0] * (r_yzx[0] + 33.33) + r[1] * (r_yzx[1] + 33.33) + r[2] * (r_yzx[2] + 33.33);\n  for (let i = 0; i < 3; i++) {\n    r[i] = fract(r[i] + dotVal);\n  }\n  return r;\n}\n\nfunction hash33(v: number[]): number[] {\n  let p = [v[0] * 0.1031, v[1] * 0.103, v[2] * 0.0973].map(fract);\n  const p_yxz = [p[1], p[0], p[2]];\n  const dotVal = p[0] * (p_yxz[0] + 33.33) + p[1] * (p_yxz[1] + 33.33) + p[2] * (p_yxz[2] + 33.33);\n  for (let i = 0; i < 3; i++) {\n    p[i] = fract(p[i] + dotVal);\n  }\n  const p_xxy = [p[0], p[0], p[1]];\n  const p_yxx = [p[1], p[0], p[0]];\n  const p_zyx = [p[2], p[1], p[0]];\n  const result: number[] = [];\n  for (let i = 0; i < 3; i++) {\n    result[i] = fract((p_xxy[i] + p_yxx[i]) * p_zyx[i]);\n  }\n  return result;\n}\n\nconst vertex = `#version 300 es\nprecision highp float;\nlayout(location = 0) in vec2 position;\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst fragment = `#version 300 es\nprecision highp float;\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec3 iMouse;\nuniform vec3 iColor;\nuniform vec3 iCursorColor;\nuniform float iAnimationSize;\nuniform int iBallCount;\nuniform float iCursorBallSize;\nuniform vec3 iMetaBalls[50];\nuniform float iClumpFactor;\nuniform bool enableTransparency;\nout vec4 outColor;\nconst float PI = 3.14159265359;\n \nfloat getMetaBallValue(vec2 c, float r, vec2 p) {\n    vec2 d = p - c;\n    float dist2 = dot(d, d);\n    return (r * r) / dist2;\n}\n \nvoid main() {\n    vec2 fc = gl_FragCoord.xy;\n    float scale = iAnimationSize / iResolution.y;\n    vec2 coord = (fc - iResolution.xy * 0.5) * scale;\n    vec2 mouseW = (iMouse.xy - iResolution.xy * 0.5) * scale;\n    float m1 = 0.0;\n    for (int i = 0; i < 50; i++) {\n        if (i >= iBallCount) break;\n        m1 += getMetaBallValue(iMetaBalls[i].xy, iMetaBalls[i].z, coord);\n    }\n    float m2 = getMetaBallValue(mouseW, iCursorBallSize, coord);\n    float total = m1 + m2;\n    float f = smoothstep(-1.0, 1.0, (total - 1.3) / min(1.0, fwidth(total)));\n    vec3 cFinal = vec3(0.0);\n    if (total > 0.0) {\n        float alpha1 = m1 / total;\n        float alpha2 = m2 / total;\n        cFinal = iColor * alpha1 + iCursorColor * alpha2;\n    }\n    outColor = vec4(cFinal * f, enableTransparency ? f : 1.0);\n}\n`;\n\ntype BallParams = {\n  st: number;\n  dtFactor: number;\n  baseScale: number;\n  toggle: number;\n  radius: number;\n};\n\nconst MetaBalls: React.FC<MetaBallsProps> = ({\n  color = '#ffffff',\n  speed = 0.3,\n  enableMouseInteraction = true,\n  hoverSmoothness = 0.05,\n  animationSize = 30,\n  ballCount = 15,\n  clumpFactor = 1,\n  cursorBallSize = 3,\n  cursorBallColor = '#ffffff',\n  enableTransparency = false\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const dpr = 1;\n    const renderer = new Renderer({\n      dpr,\n      alpha: true,\n      premultipliedAlpha: false\n    });\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, enableTransparency ? 0 : 1);\n    container.appendChild(gl.canvas);\n\n    const camera = new Camera(gl, {\n      left: -1,\n      right: 1,\n      top: 1,\n      bottom: -1,\n      near: 0.1,\n      far: 10\n    });\n    camera.position.z = 1;\n\n    const geometry = new Triangle(gl);\n    const [r1, g1, b1] = parseHexColor(color);\n    const [r2, g2, b2] = parseHexColor(cursorBallColor);\n\n    const metaBallsUniform: Vec3[] = [];\n    for (let i = 0; i < 50; i++) {\n      metaBallsUniform.push(new Vec3(0, 0, 0));\n    }\n\n    const program = new Program(gl, {\n      vertex,\n      fragment,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: { value: new Vec3(0, 0, 0) },\n        iMouse: { value: new Vec3(0, 0, 0) },\n        iColor: { value: new Vec3(r1, g1, b1) },\n        iCursorColor: { value: new Vec3(r2, g2, b2) },\n        iAnimationSize: { value: animationSize },\n        iBallCount: { value: ballCount },\n        iCursorBallSize: { value: cursorBallSize },\n        iMetaBalls: { value: metaBallsUniform },\n        iClumpFactor: { value: clumpFactor },\n        enableTransparency: { value: enableTransparency }\n      }\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n    const scene = new Transform();\n    mesh.setParent(scene);\n\n    const maxBalls = 50;\n    const effectiveBallCount = Math.min(ballCount, maxBalls);\n    const ballParams: BallParams[] = [];\n    for (let i = 0; i < effectiveBallCount; i++) {\n      const idx = i + 1;\n      const h1 = hash31(idx);\n      const st = h1[0] * (2 * Math.PI);\n      const dtFactor = 0.1 * Math.PI + h1[1] * (0.4 * Math.PI - 0.1 * Math.PI);\n      const baseScale = 5.0 + h1[1] * (10.0 - 5.0);\n      const h2 = hash33(h1);\n      const toggle = Math.floor(h2[0] * 2.0);\n      const radiusVal = 0.5 + h2[2] * (2.0 - 0.5);\n      ballParams.push({ st, dtFactor, baseScale, toggle, radius: radiusVal });\n    }\n\n    const mouseBallPos = { x: 0, y: 0 };\n    let pointerInside = false;\n    let pointerX = 0;\n    let pointerY = 0;\n\n    function resize() {\n      if (!container) return;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n      renderer.setSize(width * dpr, height * dpr);\n      gl.canvas.style.width = `${width}px`;\n      gl.canvas.style.height = `${height}px`;\n      program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, 0);\n    }\n    window.addEventListener('resize', resize);\n    resize();\n\n    function onPointerMove(e: PointerEvent) {\n      if (!enableMouseInteraction || !container) return;\n      const rect = container.getBoundingClientRect();\n      const px = e.clientX - rect.left;\n      const py = e.clientY - rect.top;\n      pointerX = (px / rect.width) * gl.canvas.width;\n      pointerY = (1 - py / rect.height) * gl.canvas.height;\n    }\n    function onPointerEnter() {\n      if (!enableMouseInteraction) return;\n      pointerInside = true;\n    }\n    function onPointerLeave() {\n      if (!enableMouseInteraction) return;\n      pointerInside = false;\n    }\n    container.addEventListener('pointermove', onPointerMove);\n    container.addEventListener('pointerenter', onPointerEnter);\n    container.addEventListener('pointerleave', onPointerLeave);\n\n    const startTime = performance.now();\n    let animationFrameId: number;\n    function update(t: number) {\n      animationFrameId = requestAnimationFrame(update);\n      const elapsed = (t - startTime) * 0.001;\n      program.uniforms.iTime.value = elapsed;\n\n      for (let i = 0; i < effectiveBallCount; i++) {\n        const p = ballParams[i];\n        const dt = elapsed * speed * p.dtFactor;\n        const th = p.st + dt;\n        const x = Math.cos(th);\n        const y = Math.sin(th + dt * p.toggle);\n        const posX = x * p.baseScale * clumpFactor;\n        const posY = y * p.baseScale * clumpFactor;\n        metaBallsUniform[i].set(posX, posY, p.radius);\n      }\n\n      let targetX: number, targetY: number;\n      if (pointerInside) {\n        targetX = pointerX;\n        targetY = pointerY;\n      } else {\n        const cx = gl.canvas.width * 0.5;\n        const cy = gl.canvas.height * 0.5;\n        const rx = gl.canvas.width * 0.15;\n        const ry = gl.canvas.height * 0.15;\n        targetX = cx + Math.cos(elapsed * speed) * rx;\n        targetY = cy + Math.sin(elapsed * speed) * ry;\n      }\n      mouseBallPos.x += (targetX - mouseBallPos.x) * hoverSmoothness;\n      mouseBallPos.y += (targetY - mouseBallPos.y) * hoverSmoothness;\n      program.uniforms.iMouse.value.set(mouseBallPos.x, mouseBallPos.y, 0);\n\n      renderer.render({ scene, camera });\n    }\n    animationFrameId = requestAnimationFrame(update);\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n      window.removeEventListener('resize', resize);\n      container.removeEventListener('pointermove', onPointerMove);\n      container.removeEventListener('pointerenter', onPointerEnter);\n      container.removeEventListener('pointerleave', onPointerLeave);\n      container.removeChild(gl.canvas);\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\n    };\n  }, [\n    color,\n    cursorBallColor,\n    speed,\n    enableMouseInteraction,\n    hoverSmoothness,\n    animationSize,\n    ballCount,\n    clumpFactor,\n    cursorBallSize,\n    enableTransparency\n  ]);\n\n  return <div ref={containerRef} className=\"w-full h-full relative\" />;\n};\n\nexport default MetaBalls;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "metallic-paint",
      "type": "component",
      "description": "Metallic paint animation effect.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/metallic-paint.tsx",
          "content": "'use client';\n\nimport { useEffect, useRef, useState, useCallback } from 'react';\n\nconst vertexShader = `#version 300 es\nprecision highp float;\nin vec2 a_position;\nout vec2 vP;\nvoid main(){vP=a_position*.5+.5;gl_Position=vec4(a_position,0.,1.);}`;\n\nconst fragmentShader = `#version 300 es\nprecision highp float;\nin vec2 vP;\nout vec4 oC;\nuniform sampler2D u_tex;\nuniform float u_time,u_ratio,u_imgRatio,u_seed,u_scale,u_refract,u_blur,u_liquid;\nuniform float u_bright,u_contrast,u_angle,u_fresnel,u_sharp,u_wave,u_noise,u_chroma;\nuniform float u_distort,u_contour;\nuniform vec3 u_lightColor,u_darkColor,u_tint;\n\nvec3 sC,sM;\n\nvec3 pW(vec3 v){\n  vec3 i=floor(v),f=fract(v),s=sign(fract(v*.5)-.5),h=fract(sM*i+i.yzx),c=f*(f-1.);\n  return s*c*((h*16.-4.)*c-1.);\n}\n\nvec3 aF(vec3 b,vec3 c){return pW(b+c.zxy-pW(b.zxy+c.yzx)+pW(b.yzx+c.xyz));}\nvec3 lM(vec3 s,vec3 p){return(p+aF(s,p))*.5;}\n\nvec2 fA(){\n  vec2 c=vP-.5;\n  c.x*=u_ratio>u_imgRatio?u_ratio/u_imgRatio:1.;\n  c.y*=u_ratio>u_imgRatio?1.:u_imgRatio/u_ratio;\n  return vec2(c.x+.5,.5-c.y);\n}\n\nvec2 rot(vec2 p,float r){float c=cos(r),s=sin(r);return vec2(p.x*c+p.y*s,p.y*c-p.x*s);}\n\nfloat bM(vec2 c,float t){\n  vec2 l=smoothstep(vec2(0.),vec2(t),c),u=smoothstep(vec2(0.),vec2(t),1.-c);\n  return l.x*l.y*u.x*u.y;\n}\n\nfloat mG(float hi,float lo,float t,float sh,float cv){\n  sh*=(2.-u_sharp);\n  float ci=smoothstep(.15,.85,cv),r=lo;\n  float e1=.08/u_scale;\n  r=mix(r,hi,smoothstep(0.,sh*1.5,t));\n  r=mix(r,lo,smoothstep(e1-sh,e1+sh,t));\n  float e2=e1+.05/u_scale*(1.-ci*.35);\n  r=mix(r,hi,smoothstep(e2-sh,e2+sh,t));\n  float e3=e2+.025/u_scale*(1.-ci*.45);\n  r=mix(r,lo,smoothstep(e3-sh,e3+sh,t));\n  float e4=e1+.1/u_scale;\n  r=mix(r,hi,smoothstep(e4-sh,e4+sh,t));\n  float rm=1.-e4,gT=clamp((t-e4)/rm,0.,1.);\n  r=mix(r,mix(hi,lo,smoothstep(0.,1.,gT)),smoothstep(e4-sh*.5,e4+sh*.5,t));\n  return r;\n}\n\nvoid main(){\n  sC=fract(vec3(.7548,.5698,.4154)*(u_seed+17.31))+.5;\n  sM=fract(sC.zxy-sC.yzx*1.618);\n  vec2 sc=vec2(vP.x*u_ratio,1.-vP.y);\n  float angleRad=u_angle*3.14159/180.;\n  sc=rot(sc-.5,angleRad)+.5;\n  sc=clamp(sc,0.,1.);\n  float sl=sc.x-sc.y,an=u_time*.001;\n  vec2 iC=fA();\n  vec4 texSample=texture(u_tex,iC);\n  float dp=texSample.r;\n  float shapeMask=texSample.a;\n  vec3 hi=u_lightColor*u_bright;\n  vec3 lo=u_darkColor*(2.-u_bright);\n  lo.b+=smoothstep(.6,1.4,sc.x+sc.y)*.08;\n  vec2 fC=sc-.5;\n  float rd=length(fC+vec2(0.,sl*.15));\n  vec2 ag=rot(fC,(.22-sl*.18)*3.14159);\n  float cv=1.-pow(rd*1.65,1.15);\n  cv*=pow(sc.y,.35);\n  float vs=shapeMask;\n  vs*=bM(iC,.01);\n  float fr=pow(1.-cv,u_fresnel)*.3;\n  vs=min(vs+fr*vs,1.);\n  float mT=an*.0625;\n  vec3 wO=vec3(-1.05,1.35,1.55);\n  vec3 wA=aF(vec3(31.,73.,56.),mT+wO)*.22*u_wave;\n  vec3 wB=aF(vec3(24.,64.,42.),mT-wO.yzx)*.22*u_wave;\n  vec2 nC=sc*45.*u_noise;\n  nC+=aF(sC.zxy,an*.17*sC.yzx-sc.yxy*.35).xy*18.*u_wave;\n  vec3 tC=vec3(.00041,.00053,.00076)*mT+wB*nC.x+wA*nC.y;\n  tC=lM(sC,tC);\n  tC=lM(sC+1.618,tC);\n  float tb=sin(tC.x*3.14159)*.5+.5;\n  tb=tb*2.-1.;\n  float noiseVal=pW(vec3(sc*8.+an,an*.5)).x;\n  float edgeFactor=smoothstep(0.,.5,dp)*smoothstep(1.,.5,dp);\n  float lD=dp+(1.-dp)*u_liquid*tb;\n  lD+=noiseVal*u_distort*.15*edgeFactor;\n  float rB=clamp(1.-cv,0.,1.);\n  float fl=ag.x+sl;\n  fl+=noiseVal*sl*u_distort*edgeFactor;\n  fl*=mix(1.,1.-dp*.5,u_contour);\n  fl-=dp*u_contour*.8;\n  float eI=smoothstep(0.,1.,lD)*smoothstep(1.,0.,lD);\n  fl-=tb*sl*1.8*eI;\n  float cA=cv*clamp(pow(sc.y,.12),.25,1.);\n  fl*=.12+(1.05-lD)*cA;\n  fl*=smoothstep(1.,.65,lD);\n  float vA1=smoothstep(.08,.18,sc.y)*smoothstep(.38,.18,sc.y);\n  float vA2=smoothstep(.08,.18,1.-sc.y)*smoothstep(.38,.18,1.-sc.y);\n  fl+=vA1*.16+vA2*.025;\n  fl*=.45+pow(sc.y,2.)*.55;\n  fl*=u_scale;\n  fl-=an;\n  float rO=rB+cv*tb*.025;\n  float vM1=smoothstep(-.12,.18,sc.y)*smoothstep(.48,.08,sc.y);\n  float cM1=smoothstep(.35,.55,cv)*smoothstep(.95,.35,cv);\n  rO+=vM1*cM1*4.5;\n  rO-=sl;\n  float bO=rB*1.25;\n  float vM2=smoothstep(-.02,.35,sc.y)*smoothstep(.75,.08,sc.y);\n  float cM2=smoothstep(.35,.55,cv)*smoothstep(.75,.35,cv);\n  bO+=vM2*cM2*.9;\n  bO-=lD*.18;\n  rO*=u_refract*u_chroma;\n  bO*=u_refract*u_chroma;\n  float sf=u_blur;\n  float rP=fract(fl+rO);\n  float rC=mG(hi.r,lo.r,rP,sf+.018+u_refract*cv*.025,cv);\n  float gP=fract(fl);\n  float gC=mG(hi.g,lo.g,gP,sf+.008/max(.01,1.-sl),cv);\n  float bP=fract(fl-bO);\n  float bC=mG(hi.b,lo.b,bP,sf+.008,cv);\n  vec3 col=vec3(rC,gC,bC);\n  col=(col-.5)*u_contrast+.5;\n  col=clamp(col,0.,1.);\n  col=mix(col,1.-min(vec3(1.),(1.-col)/max(u_tint,vec3(.001))),length(u_tint-1.)*.5);\n  col=clamp(col,0.,1.);\n  oC=vec4(col*vs,vs);\n}`;\n\ninterface MetallicPaintProps {\n  imageSrc: string;\n  seed?: number;\n  scale?: number;\n  refraction?: number;\n  blur?: number;\n  liquid?: number;\n  speed?: number;\n  brightness?: number;\n  contrast?: number;\n  angle?: number;\n  fresnel?: number;\n  lightColor?: string;\n  darkColor?: string;\n  patternSharpness?: number;\n  waveAmplitude?: number;\n  noiseScale?: number;\n  chromaticSpread?: number;\n  mouseAnimation?: boolean;\n  distortion?: number;\n  contour?: number;\n  tintColor?: string;\n}\n\nfunction processImage(img: HTMLImageElement): ImageData {\n  const MAX_SIZE = 1000;\n  const MIN_SIZE = 500;\n  let width = img.naturalWidth || img.width;\n  let height = img.naturalHeight || img.height;\n\n  if (width > MAX_SIZE || height > MAX_SIZE || width < MIN_SIZE || height < MIN_SIZE) {\n    const scale =\n      width > height\n        ? width > MAX_SIZE\n          ? MAX_SIZE / width\n          : width < MIN_SIZE\n            ? MIN_SIZE / width\n            : 1\n        : height > MAX_SIZE\n          ? MAX_SIZE / height\n          : height < MIN_SIZE\n            ? MIN_SIZE / height\n            : 1;\n    width = Math.round(width * scale);\n    height = Math.round(height * scale);\n  }\n\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d')!;\n  ctx.drawImage(img, 0, 0, width, height);\n\n  const imageData = ctx.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  const size = width * height;\n  const alphaValues = new Float32Array(size);\n  const shapeMask = new Uint8Array(size);\n  const boundaryMask = new Uint8Array(size);\n\n  for (let i = 0; i < size; i++) {\n    const idx = i * 4;\n    const r = data[idx],\n      g = data[idx + 1],\n      b = data[idx + 2],\n      a = data[idx + 3];\n    const isBackground = (r > 250 && g > 250 && b > 250 && a === 255) || a < 5;\n    alphaValues[i] = isBackground ? 0 : a / 255;\n    shapeMask[i] = alphaValues[i] > 0.1 ? 1 : 0;\n  }\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const idx = y * width + x;\n      if (!shapeMask[idx]) continue;\n      if (\n        x === 0 ||\n        x === width - 1 ||\n        y === 0 ||\n        y === height - 1 ||\n        !shapeMask[idx - 1] ||\n        !shapeMask[idx + 1] ||\n        !shapeMask[idx - width] ||\n        !shapeMask[idx + width]\n      ) {\n        boundaryMask[idx] = 1;\n      }\n    }\n  }\n\n  const u = new Float32Array(size);\n  const ITERATIONS = 200;\n  const C = 0.01;\n  const omega = 1.85;\n\n  for (let iter = 0; iter < ITERATIONS; iter++) {\n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        const idx = y * width + x;\n        if (!shapeMask[idx] || boundaryMask[idx]) continue;\n        const sum =\n          (shapeMask[idx + 1] ? u[idx + 1] : 0) +\n          (shapeMask[idx - 1] ? u[idx - 1] : 0) +\n          (shapeMask[idx + width] ? u[idx + width] : 0) +\n          (shapeMask[idx - width] ? u[idx - width] : 0);\n        const newVal = (C + sum) / 4;\n        u[idx] = omega * newVal + (1 - omega) * u[idx];\n      }\n    }\n  }\n\n  let maxVal = 0;\n  for (let i = 0; i < size; i++) if (u[i] > maxVal) maxVal = u[i];\n  if (maxVal === 0) maxVal = 1;\n\n  const outData = ctx.createImageData(width, height);\n  for (let i = 0; i < size; i++) {\n    const px = i * 4;\n    const depth = u[i] / maxVal;\n    const gray = Math.round(255 * (1 - depth * depth));\n    outData.data[px] = outData.data[px + 1] = outData.data[px + 2] = gray;\n    outData.data[px + 3] = Math.round(alphaValues[i] * 255);\n  }\n\n  return outData;\n}\n\nfunction hexToRgb(hex: string): [number, number, number] {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255]\n    : [1, 1, 1];\n}\n\nexport default function MetallicPaint({\n  imageSrc,\n  seed = 42,\n  scale = 4,\n  refraction = 0.01,\n  blur = 0.015,\n  liquid = 0.75,\n  speed = 0.3,\n  brightness = 2,\n  contrast = 0.5,\n  angle = 0,\n  fresnel = 1,\n  lightColor = '#ffffff',\n  darkColor = '#000000',\n  patternSharpness = 1,\n  waveAmplitude = 1,\n  noiseScale = 0.5,\n  chromaticSpread = 2,\n  mouseAnimation = false,\n  distortion = 1,\n  contour = 0.2,\n  tintColor = '#feb3ff'\n}: MetallicPaintProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const glRef = useRef<WebGL2RenderingContext | null>(null);\n  const programRef = useRef<WebGLProgram | null>(null);\n  const uniformsRef = useRef<Record<string, WebGLUniformLocation | null>>({});\n  const textureRef = useRef<WebGLTexture | null>(null);\n  const animTimeRef = useRef(0);\n  const lastTimeRef = useRef(0);\n  const rafRef = useRef<number | null>(null);\n  const imgDataRef = useRef<ImageData | null>(null);\n  const speedRef = useRef(speed);\n  const mouseRef = useRef({ x: 0.5, y: 0.5, targetX: 0.5, targetY: 0.5 });\n  const mouseAnimRef = useRef(mouseAnimation);\n\n  const [ready, setReady] = useState(false);\n  const [textureReady, setTextureReady] = useState(false);\n\n  useEffect(() => {\n    speedRef.current = speed;\n  }, [speed]);\n  useEffect(() => {\n    mouseAnimRef.current = mouseAnimation;\n  }, [mouseAnimation]);\n\n  const initGL = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return false;\n\n    const gl = canvas.getContext('webgl2', { antialias: true, alpha: true });\n    if (!gl) return false;\n\n    const compile = (src: string, type: number): WebGLShader | null => {\n      const s = gl.createShader(type);\n      if (!s) return null;\n      gl.shaderSource(s, src);\n      gl.compileShader(s);\n      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {\n        console.error(gl.getShaderInfoLog(s));\n        return null;\n      }\n      return s;\n    };\n\n    const vs = compile(vertexShader, gl.VERTEX_SHADER);\n    const fs = compile(fragmentShader, gl.FRAGMENT_SHADER);\n    if (!vs || !fs) return false;\n\n    const prog = gl.createProgram();\n    if (!prog) return false;\n    gl.attachShader(prog, vs);\n    gl.attachShader(prog, fs);\n    gl.linkProgram(prog);\n    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n      console.error(gl.getProgramInfoLog(prog));\n      return false;\n    }\n\n    const uniforms: Record<string, WebGLUniformLocation | null> = {};\n    const count = gl.getProgramParameter(prog, gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < count; i++) {\n      const info = gl.getActiveUniform(prog, i);\n      if (info) uniforms[info.name] = gl.getUniformLocation(prog, info.name);\n    }\n\n    const verts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\n    const buf = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n    gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);\n\n    gl.useProgram(prog);\n    const pos = gl.getAttribLocation(prog, 'a_position');\n    gl.enableVertexAttribArray(pos);\n    gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);\n\n    glRef.current = gl;\n    programRef.current = prog;\n    uniformsRef.current = uniforms;\n\n    return true;\n  }, []);\n\n  const uploadTexture = useCallback((imgData: ImageData) => {\n    const gl = glRef.current;\n    const uniforms = uniformsRef.current;\n    if (!gl || !imgData) return;\n\n    if (textureRef.current) gl.deleteTexture(textureRef.current);\n\n    const tex = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, imgData.width, imgData.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imgData.data);\n    gl.uniform1i(uniforms.u_tex, 0);\n\n    const ratio = imgData.width / imgData.height;\n    gl.uniform1f(uniforms.u_imgRatio, ratio);\n    gl.uniform1f(uniforms.u_ratio, 1);\n\n    textureRef.current = tex;\n    imgDataRef.current = imgData;\n  }, []);\n\n  useEffect(() => {\n    if (!initGL()) return;\n\n    const canvas = canvasRef.current;\n    const gl = glRef.current;\n    if (!canvas || !gl) return;\n\n    const side = 1000 * devicePixelRatio;\n    canvas.width = side;\n    canvas.height = side;\n    gl.viewport(0, 0, side, side);\n\n    setReady(true);\n\n    return () => {\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      if (textureRef.current && glRef.current) {\n        glRef.current.deleteTexture(textureRef.current);\n      }\n    };\n  }, [initGL]);\n\n  useEffect(() => {\n    if (!ready || !imageSrc) return;\n\n    setTextureReady(false);\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => {\n      const imgData = processImage(img);\n      uploadTexture(imgData);\n      setTextureReady(true);\n    };\n    img.src = imageSrc;\n  }, [ready, imageSrc, uploadTexture]);\n\n  useEffect(() => {\n    const gl = glRef.current;\n    const u = uniformsRef.current;\n    if (!gl || !ready) return;\n\n    gl.uniform1f(u.u_seed, seed);\n    gl.uniform1f(u.u_scale, scale);\n    gl.uniform1f(u.u_refract, refraction);\n    gl.uniform1f(u.u_blur, blur);\n    gl.uniform1f(u.u_liquid, liquid);\n    gl.uniform1f(u.u_bright, brightness);\n    gl.uniform1f(u.u_contrast, contrast);\n    gl.uniform1f(u.u_angle, angle);\n    gl.uniform1f(u.u_fresnel, fresnel);\n\n    const light = hexToRgb(lightColor);\n    const dark = hexToRgb(darkColor);\n    const tint = hexToRgb(tintColor);\n    gl.uniform3f(u.u_lightColor, light[0], light[1], light[2]);\n    gl.uniform3f(u.u_darkColor, dark[0], dark[1], dark[2]);\n    gl.uniform1f(u.u_sharp, patternSharpness);\n    gl.uniform1f(u.u_wave, waveAmplitude);\n    gl.uniform1f(u.u_noise, noiseScale);\n    gl.uniform1f(u.u_chroma, chromaticSpread);\n    gl.uniform1f(u.u_distort, distortion);\n    gl.uniform1f(u.u_contour, contour);\n    gl.uniform3f(u.u_tint, tint[0], tint[1], tint[2]);\n  }, [\n    ready,\n    seed,\n    scale,\n    refraction,\n    blur,\n    liquid,\n    brightness,\n    contrast,\n    angle,\n    fresnel,\n    lightColor,\n    darkColor,\n    patternSharpness,\n    waveAmplitude,\n    noiseScale,\n    chromaticSpread,\n    distortion,\n    contour,\n    tintColor\n  ]);\n\n  useEffect(() => {\n    if (!ready || !textureReady) return;\n\n    const gl = glRef.current;\n    const u = uniformsRef.current;\n    const canvas = canvasRef.current;\n    const mouse = mouseRef.current;\n    if (!gl || !canvas) return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      mouse.targetX = (e.clientX - rect.left) / rect.width;\n      mouse.targetY = (e.clientY - rect.top) / rect.height;\n    };\n\n    canvas.addEventListener('mousemove', handleMouseMove);\n\n    const render = (time: number) => {\n      const delta = time - lastTimeRef.current;\n      lastTimeRef.current = time;\n\n      if (mouseAnimRef.current) {\n        mouse.x += (mouse.targetX - mouse.x) * 0.08;\n        mouse.y += (mouse.targetY - mouse.y) * 0.08;\n        animTimeRef.current = mouse.x * 3000 + mouse.y * 1500;\n      } else {\n        animTimeRef.current += delta * speedRef.current;\n      }\n\n      gl.uniform1f(u.u_time, animTimeRef.current);\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n      rafRef.current = requestAnimationFrame(render);\n    };\n\n    lastTimeRef.current = performance.now();\n    rafRef.current = requestAnimationFrame(render);\n\n    return () => {\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      canvas.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, [ready, textureReady]);\n\n  return <canvas ref={canvasRef} className=\"block h-full w-full object-contain\" />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "meteors",
      "type": "component",
      "description": "A meteor shower effect.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/meteors.tsx",
          "content": "\"use client\"\n\nimport React, { useEffect, useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface MeteorsProps {\n  number?: number\n  minDelay?: number\n  maxDelay?: number\n  minDuration?: number\n  maxDuration?: number\n  angle?: number\n  className?: string\n}\n\nexport const Meteors = ({\n  number = 20,\n  minDelay = 0.2,\n  maxDelay = 1.2,\n  minDuration = 2,\n  maxDuration = 10,\n  angle = 215,\n  className,\n}: MeteorsProps) => {\n  const [meteorStyles, setMeteorStyles] = useState<Array<React.CSSProperties>>(\n    []\n  )\n\n  useEffect(() => {\n    const styles = [...new Array(number)].map(() => ({\n      \"--angle\": -angle + \"deg\",\n      top: \"-5%\",\n      left: `calc(0% + ${Math.floor(Math.random() * window.innerWidth)}px)`,\n      animationDelay: Math.random() * (maxDelay - minDelay) + minDelay + \"s\",\n      animationDuration:\n        Math.floor(Math.random() * (maxDuration - minDuration) + minDuration) +\n        \"s\",\n    }))\n    setMeteorStyles(styles)\n  }, [number, minDelay, maxDelay, minDuration, maxDuration, angle])\n\n  return (\n    <>\n      {[...meteorStyles].map((style, idx) => (\n        // Meteor Head\n        <span\n          key={idx}\n          style={{ ...style }}\n          className={cn(\n            \"animate-meteor pointer-events-none absolute size-0.5 rotate-[var(--angle)] rounded-full bg-zinc-500 shadow-[0_0_0_1px_#ffffff10]\",\n            className\n          )}\n        >\n          {/* Meteor Tail */}\n          <div className=\"pointer-events-none absolute top-1/2 -z-10 h-px w-[50px] -translate-y-1/2 bg-gradient-to-r from-zinc-500 to-transparent\" />\n        </span>\n      ))}\n    </>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "neon-gradient-card",
      "type": "component",
      "description": "A beautiful neon card effect",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/neon-gradient-card.tsx",
          "content": "\"use client\"\n\nimport {\n  CSSProperties,\n  ReactElement,\n  ReactNode,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface NeonColorsProps {\n  firstColor: string\n  secondColor: string\n}\n\ninterface NeonGradientCardProps extends React.HTMLAttributes<HTMLDivElement> {\n  /**\n   * @default <div />\n   * @type ReactElement\n   * @description\n   * The component to be rendered as the card\n   * */\n  as?: ReactElement\n  /**\n   * @default \"\"\n   * @type string\n   * @description\n   * The className of the card\n   */\n  className?: string\n\n  /**\n   * @default \"\"\n   * @type ReactNode\n   * @description\n   * The children of the card\n   * */\n  children?: ReactNode\n\n  /**\n   * @default 5\n   * @type number\n   * @description\n   * The size of the border in pixels\n   * */\n  borderSize?: number\n\n  /**\n   * @default 20\n   * @type number\n   * @description\n   * The size of the radius in pixels\n   * */\n  borderRadius?: number\n\n  /**\n   * @default \"{ firstColor: '#ff00aa', secondColor: '#00FFF1' }\"\n   * @type string\n   * @description\n   * The colors of the neon gradient\n   * */\n  neonColors?: NeonColorsProps\n}\n\nexport const NeonGradientCard: React.FC<NeonGradientCardProps> = ({\n  className,\n  children,\n  borderSize = 2,\n  borderRadius = 20,\n  neonColors = {\n    firstColor: \"#ff00aa\",\n    secondColor: \"#00FFF1\",\n  },\n  ...props\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null)\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const { offsetWidth, offsetHeight } = containerRef.current\n        setDimensions({ width: offsetWidth, height: offsetHeight })\n      }\n    }\n\n    updateDimensions()\n    window.addEventListener(\"resize\", updateDimensions)\n\n    return () => {\n      window.removeEventListener(\"resize\", updateDimensions)\n    }\n  }, [])\n\n  useEffect(() => {\n    if (containerRef.current) {\n      const { offsetWidth, offsetHeight } = containerRef.current\n      setDimensions({ width: offsetWidth, height: offsetHeight })\n    }\n  }, [children])\n\n  return (\n    <div\n      ref={containerRef}\n      style={\n        {\n          \"--border-size\": `${borderSize}px`,\n          \"--border-radius\": `${borderRadius}px`,\n          \"--neon-first-color\": neonColors.firstColor,\n          \"--neon-second-color\": neonColors.secondColor,\n          \"--card-width\": `${dimensions.width}px`,\n          \"--card-height\": `${dimensions.height}px`,\n          \"--card-content-radius\": `${borderRadius - borderSize}px`,\n          \"--pseudo-element-background-image\": `linear-gradient(0deg, ${neonColors.firstColor}, ${neonColors.secondColor})`,\n          \"--pseudo-element-width\": `${dimensions.width + borderSize * 2}px`,\n          \"--pseudo-element-height\": `${dimensions.height + borderSize * 2}px`,\n          \"--after-blur\": `${dimensions.width / 3}px`,\n        } as CSSProperties\n      }\n      className={cn(\n        \"relative z-10 size-full rounded-[var(--border-radius)]\",\n        className\n      )}\n      {...props}\n    >\n      <div\n        className={cn(\n          \"relative size-full min-h-[inherit] rounded-[var(--card-content-radius)] bg-gray-100 p-6\",\n          \"before:absolute before:-top-[var(--border-size)] before:-left-[var(--border-size)] before:-z-10 before:block\",\n          \"before:h-[var(--pseudo-element-height)] before:w-[var(--pseudo-element-width)] before:rounded-[var(--border-radius)] before:content-['']\",\n          \"before:bg-[linear-gradient(0deg,var(--neon-first-color),var(--neon-second-color))] before:bg-[length:100%_200%]\",\n          \"before:animate-background-position-spin\",\n          \"after:absolute after:-top-[var(--border-size)] after:-left-[var(--border-size)] after:-z-10 after:block\",\n          \"after:h-[var(--pseudo-element-height)] after:w-[var(--pseudo-element-width)] after:rounded-[var(--border-radius)] after:blur-[var(--after-blur)] after:content-['']\",\n          \"after:bg-[linear-gradient(0deg,var(--neon-first-color),var(--neon-second-color))] after:bg-[length:100%_200%] after:opacity-80\",\n          \"after:animate-background-position-spin\",\n          \"dark:bg-neutral-900\",\n          \"break-words\"\n        )}\n      >\n        {children}\n      </div>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "noise",
      "type": "component",
      "description": "Visual noise overlay effect.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/noise.tsx",
          "content": "import React, { useRef, useEffect } from 'react';\n\ninterface NoiseProps {\n  patternSize?: number;\n  patternScaleX?: number;\n  patternScaleY?: number;\n  patternRefreshInterval?: number;\n  patternAlpha?: number;\n}\n\nconst Noise: React.FC<NoiseProps> = ({\n  patternSize = 250,\n  patternScaleX = 1,\n  patternScaleY = 1,\n  patternRefreshInterval = 2,\n  patternAlpha = 15\n}) => {\n  const grainRef = useRef<HTMLCanvasElement | null>(null);\n\n  useEffect(() => {\n    const canvas = grainRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d', { alpha: true });\n    if (!ctx) return;\n\n    let frame = 0;\n    let animationId: number;\n\n    const canvasSize = 1024;\n\n    const resize = () => {\n      if (!canvas) return;\n      canvas.width = canvasSize;\n      canvas.height = canvasSize;\n\n      canvas.style.width = '100vw';\n      canvas.style.height = '100vh';\n    };\n\n    const drawGrain = () => {\n      const imageData = ctx.createImageData(canvasSize, canvasSize);\n      const data = imageData.data;\n\n      for (let i = 0; i < data.length; i += 4) {\n        const value = Math.random() * 255;\n        data[i] = value;\n        data[i + 1] = value;\n        data[i + 2] = value;\n        data[i + 3] = patternAlpha;\n      }\n\n      ctx.putImageData(imageData, 0, 0);\n    };\n\n    const loop = () => {\n      if (frame % patternRefreshInterval === 0) {\n        drawGrain();\n      }\n      frame++;\n      animationId = window.requestAnimationFrame(loop);\n    };\n\n    window.addEventListener('resize', resize);\n    resize();\n    loop();\n\n    return () => {\n      window.removeEventListener('resize', resize);\n      window.cancelAnimationFrame(animationId);\n    };\n  }, [patternSize, patternScaleX, patternScaleY, patternRefreshInterval, patternAlpha]);\n\n  return (\n    <canvas\n      className=\"pointer-events-none absolute top-0 left-0 h-screen w-screen\"\n      ref={grainRef}\n      style={{\n        imageRendering: 'pixelated'\n      }}\n    />\n  );\n};\n\nexport default Noise;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "orbit-images",
      "type": "component",
      "description": "Images orbiting in a circular path.",
      "category": "animations",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/orbit-images.tsx",
          "content": "// Component created by Dominik Koch\n// https://x.com/dominikkoch\n\nimport { useMemo, useEffect, useRef, useState, ReactNode } from 'react';\nimport { motion, useMotionValue, useTransform, animate, MotionValue } from 'motion/react';\n\ntype OrbitShape =\n  | 'ellipse'\n  | 'circle'\n  | 'square'\n  | 'rectangle'\n  | 'triangle'\n  | 'star'\n  | 'heart'\n  | 'infinity'\n  | 'wave'\n  | 'custom';\n\ninterface OrbitImagesProps {\n  images?: string[];\n  altPrefix?: string;\n  shape?: OrbitShape;\n  customPath?: string;\n  baseWidth?: number;\n  radiusX?: number;\n  radiusY?: number;\n  radius?: number;\n  starPoints?: number;\n  starInnerRatio?: number;\n  rotation?: number;\n  duration?: number;\n  itemSize?: number;\n  direction?: 'normal' | 'reverse';\n  fill?: boolean;\n  width?: number | '100%';\n  height?: number | 'auto';\n  className?: string;\n  showPath?: boolean;\n  pathColor?: string;\n  pathWidth?: number;\n  easing?: 'linear' | 'easeIn' | 'easeOut' | 'easeInOut';\n  paused?: boolean;\n  centerContent?: ReactNode;\n  responsive?: boolean;\n}\n\ninterface OrbitItemProps {\n  item: ReactNode;\n  index: number;\n  totalItems: number;\n  path: string;\n  itemSize: number;\n  rotation: number;\n  progress: MotionValue<number>;\n  fill: boolean;\n}\n\nfunction generateEllipsePath(cx: number, cy: number, rx: number, ry: number): string {\n  return `M ${cx - rx} ${cy} A ${rx} ${ry} 0 1 0 ${cx + rx} ${cy} A ${rx} ${ry} 0 1 0 ${cx - rx} ${cy}`;\n}\n\nfunction generateCirclePath(cx: number, cy: number, r: number): string {\n  return generateEllipsePath(cx, cy, r, r);\n}\n\nfunction generateSquarePath(cx: number, cy: number, size: number): string {\n  const h = size / 2;\n  return `M ${cx - h} ${cy - h} L ${cx + h} ${cy - h} L ${cx + h} ${cy + h} L ${cx - h} ${cy + h} Z`;\n}\n\nfunction generateRectanglePath(cx: number, cy: number, w: number, h: number): string {\n  const hw = w / 2;\n  const hh = h / 2;\n  return `M ${cx - hw} ${cy - hh} L ${cx + hw} ${cy - hh} L ${cx + hw} ${cy + hh} L ${cx - hw} ${cy + hh} Z`;\n}\n\nfunction generateTrianglePath(cx: number, cy: number, size: number): string {\n  const height = (size * Math.sqrt(3)) / 2;\n  const hs = size / 2;\n  return `M ${cx} ${cy - height / 1.5} L ${cx + hs} ${cy + height / 3} L ${cx - hs} ${cy + height / 3} Z`;\n}\n\nfunction generateStarPath(cx: number, cy: number, outerR: number, innerR: number, points: number): string {\n  const step = Math.PI / points;\n  let path = '';\n  for (let i = 0; i < 2 * points; i++) {\n    const r = i % 2 === 0 ? outerR : innerR;\n    const angle = i * step - Math.PI / 2;\n    const x = cx + r * Math.cos(angle);\n    const y = cy + r * Math.sin(angle);\n    path += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;\n  }\n  return path + ' Z';\n}\n\nfunction generateHeartPath(cx: number, cy: number, size: number): string {\n  const s = size / 30;\n  return `M ${cx} ${cy + 12 * s} C ${cx - 20 * s} ${cy - 5 * s}, ${cx - 12 * s} ${cy - 18 * s}, ${cx} ${cy - 8 * s} C ${cx + 12 * s} ${cy - 18 * s}, ${cx + 20 * s} ${cy - 5 * s}, ${cx} ${cy + 12 * s}`;\n}\n\nfunction generateInfinityPath(cx: number, cy: number, w: number, h: number): string {\n  const hw = w / 2;\n  const hh = h / 2;\n  return `M ${cx} ${cy} C ${cx + hw * 0.5} ${cy - hh}, ${cx + hw} ${cy - hh}, ${cx + hw} ${cy} C ${cx + hw} ${cy + hh}, ${cx + hw * 0.5} ${cy + hh}, ${cx} ${cy} C ${cx - hw * 0.5} ${cy + hh}, ${cx - hw} ${cy + hh}, ${cx - hw} ${cy} C ${cx - hw} ${cy - hh}, ${cx - hw * 0.5} ${cy - hh}, ${cx} ${cy}`;\n}\n\nfunction generateWavePath(cx: number, cy: number, w: number, amplitude: number, waves: number): string {\n  const pts: string[] = [];\n  const segs = waves * 20;\n  const hw = w / 2;\n  for (let i = 0; i <= segs; i++) {\n    const x = cx - hw + (w * i) / segs;\n    const y = cy + Math.sin((i / segs) * waves * 2 * Math.PI) * amplitude;\n    pts.push(i === 0 ? `M ${x} ${y}` : `L ${x} ${y}`);\n  }\n  for (let i = segs; i >= 0; i--) {\n    const x = cx - hw + (w * i) / segs;\n    const y = cy - Math.sin((i / segs) * waves * 2 * Math.PI) * amplitude;\n    pts.push(`L ${x} ${y}`);\n  }\n  return pts.join(' ') + ' Z';\n}\n\nfunction OrbitItem({ item, index, totalItems, path, itemSize, rotation, progress, fill }: OrbitItemProps) {\n  const itemOffset = fill ? (index / totalItems) * 100 : 0;\n\n  const offsetDistance = useTransform(progress, (p: number) => {\n    const offset = (((p + itemOffset) % 100) + 100) % 100;\n    return `${offset}%`;\n  });\n\n  return (\n    <motion.div\n      className=\"absolute will-change-transform select-none\"\n      style={{\n        width: itemSize,\n        height: itemSize,\n        offsetPath: `path(\"${path}\")`,\n        offsetRotate: '0deg',\n        offsetAnchor: 'center center',\n        offsetDistance,\n      }}\n    >\n      <div style={{ transform: `rotate(${-rotation}deg)` }}>{item}</div>\n    </motion.div>\n  );\n}\n\nexport default function OrbitImages({\n  images = [],\n  altPrefix = 'Orbiting image',\n  shape = 'ellipse',\n  customPath,\n  baseWidth = 1400,\n  radiusX = 700,\n  radiusY = 170,\n  radius = 300,\n  starPoints = 5,\n  starInnerRatio = 0.5,\n  rotation = -8,\n  duration = 40,\n  itemSize = 64,\n  direction = 'normal',\n  fill = true,\n  width = 100,\n  height = 100,\n  className = '',\n  showPath = false,\n  pathColor = 'rgba(0,0,0,0.1)',\n  pathWidth = 2,\n  easing = 'linear',\n  paused = false,\n  centerContent,\n  responsive = false,\n}: OrbitImagesProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [scale, setScale] = useState(1);\n\n  const designCenterX = baseWidth / 2;\n  const designCenterY = baseWidth / 2;\n\n  const path = useMemo(() => {\n    switch (shape) {\n      case 'circle':\n        return generateCirclePath(designCenterX, designCenterY, radius);\n      case 'ellipse':\n        return generateEllipsePath(designCenterX, designCenterY, radiusX, radiusY);\n      case 'square':\n        return generateSquarePath(designCenterX, designCenterY, radius * 2);\n      case 'rectangle':\n        return generateRectanglePath(designCenterX, designCenterY, radiusX * 2, radiusY * 2);\n      case 'triangle':\n        return generateTrianglePath(designCenterX, designCenterY, radius * 2);\n      case 'star':\n        return generateStarPath(designCenterX, designCenterY, radius, radius * starInnerRatio, starPoints);\n      case 'heart':\n        return generateHeartPath(designCenterX, designCenterY, radius * 2);\n      case 'infinity':\n        return generateInfinityPath(designCenterX, designCenterY, radiusX * 2, radiusY * 2);\n      case 'wave':\n        return generateWavePath(designCenterX, designCenterY, radiusX * 2, radiusY, 3);\n      case 'custom':\n        return customPath || generateCirclePath(designCenterX, designCenterY, radius);\n      default:\n        return generateEllipsePath(designCenterX, designCenterY, radiusX, radiusY);\n    }\n  }, [shape, customPath, designCenterX, designCenterY, radiusX, radiusY, radius, starPoints, starInnerRatio]);\n\n  useEffect(() => {\n    if (!responsive || !containerRef.current) return;\n    const updateScale = () => {\n      if (!containerRef.current) return;\n      setScale(containerRef.current.clientWidth / baseWidth);\n    };\n    updateScale();\n    const observer = new ResizeObserver(updateScale);\n    observer.observe(containerRef.current);\n    return () => observer.disconnect();\n  }, [responsive, baseWidth]);\n\n  const progress = useMotionValue(0);\n\n  useEffect(() => {\n    if (paused) return;\n    const controls = animate(progress, direction === 'reverse' ? -100 : 100, {\n      duration,\n      ease: easing,\n      repeat: Infinity,\n      repeatType: 'loop',\n    });\n    return () => controls.stop();\n  }, [progress, duration, easing, direction, paused]);\n\n  const containerWidth = responsive ? '100%' : (typeof width === 'number' ? width : '100%');\n  const containerHeight = responsive ? 'auto' : (typeof height === 'number' ? height : (typeof width === 'number' ? width : 'auto'));\n\n  const items = images.map((src, index) => (\n    <img\n      key={src}\n      src={src}\n      alt={`${altPrefix} ${index + 1}`}\n      draggable={false}\n      className=\"w-full h-full object-contain\"\n    />\n  ));\n\n  return (\n    <div\n      ref={containerRef}\n      className={`relative mx-auto ${className}`}\n      style={{\n        width: containerWidth,\n        height: containerHeight,\n        aspectRatio: responsive ? '1 / 1' : undefined,\n      }}\n      aria-hidden=\"true\"\n    >\n      <div\n        className={responsive ? 'absolute left-1/2 top-1/2' : 'relative w-full h-full'}\n        style={{\n          width: responsive ? baseWidth : '100%',\n          height: responsive ? baseWidth : '100%',\n          transform: responsive ? `translate(-50%, -50%) scale(${scale})` : undefined,\n          transformOrigin: 'center center',\n        }}\n      >\n        <div\n          className=\"relative w-full h-full\"\n          style={{\n            transform: `rotate(${rotation}deg)`,\n            transformOrigin: 'center center',\n          }}\n        >\n          {showPath && (\n            <svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={`0 0 ${baseWidth} ${baseWidth}`}\n              className=\"absolute inset-0 pointer-events-none\"\n            >\n              <path d={path} fill=\"none\" stroke={pathColor} strokeWidth={pathWidth / scale} />\n            </svg>\n          )}\n\n          {items.map((item, index) => (\n            <OrbitItem\n              key={index}\n              item={item}\n              index={index}\n              totalItems={items.length}\n              path={path}\n              itemSize={itemSize}\n              rotation={rotation}\n              progress={progress}\n              fill={fill}\n            />\n          ))}\n        </div>\n      </div>\n\n      {centerContent && (\n        <div className=\"absolute inset-0 flex items-center justify-center z-10\">\n          {centerContent}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "orbiting-circles",
      "type": "component",
      "description": "A collection of circles which move in orbit along a circular path",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/orbiting-circles.tsx",
          "content": "import React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface OrbitingCirclesProps extends React.HTMLAttributes<HTMLDivElement> {\n  className?: string\n  children?: React.ReactNode\n  reverse?: boolean\n  duration?: number\n  delay?: number\n  radius?: number\n  path?: boolean\n  iconSize?: number\n  speed?: number\n}\n\nexport function OrbitingCircles({\n  className,\n  children,\n  reverse,\n  duration = 20,\n  radius = 160,\n  path = true,\n  iconSize = 30,\n  speed = 1,\n  ...props\n}: OrbitingCirclesProps) {\n  const calculatedDuration = duration / speed\n  return (\n    <>\n      {path && (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          version=\"1.1\"\n          className=\"pointer-events-none absolute inset-0 size-full\"\n        >\n          <circle\n            className=\"stroke-black/10 stroke-1 dark:stroke-white/10\"\n            cx=\"50%\"\n            cy=\"50%\"\n            r={radius}\n            fill=\"none\"\n          />\n        </svg>\n      )}\n      {React.Children.map(children, (child, index) => {\n        const angle = (360 / React.Children.count(children)) * index\n        return (\n          <div\n            style={\n              {\n                \"--duration\": calculatedDuration,\n                \"--radius\": radius,\n                \"--angle\": angle,\n                \"--icon-size\": `${iconSize}px`,\n              } as React.CSSProperties\n            }\n            className={cn(\n              `animate-orbit absolute flex size-[var(--icon-size)] transform-gpu items-center justify-center rounded-full`,\n              { \"[animation-direction:reverse]\": reverse },\n              className\n            )}\n            {...props}\n          >\n            {child}\n          </div>\n        )\n      })}\n    </>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "particles",
      "type": "component",
      "description": "Particles for adding visual flair to your website.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/particles.tsx",
          "content": "\"use client\"\n\nimport React, {\n  ComponentPropsWithoutRef,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface MousePosition {\n  x: number\n  y: number\n}\n\nfunction MousePosition(): MousePosition {\n  const [mousePosition, setMousePosition] = useState<MousePosition>({\n    x: 0,\n    y: 0,\n  })\n\n  useEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      setMousePosition({ x: event.clientX, y: event.clientY })\n    }\n\n    window.addEventListener(\"mousemove\", handleMouseMove)\n\n    return () => {\n      window.removeEventListener(\"mousemove\", handleMouseMove)\n    }\n  }, [])\n\n  return mousePosition\n}\n\ninterface ParticlesProps extends ComponentPropsWithoutRef<\"div\"> {\n  className?: string\n  quantity?: number\n  staticity?: number\n  ease?: number\n  size?: number\n  refresh?: boolean\n  color?: string\n  vx?: number\n  vy?: number\n}\n\nfunction hexToRgb(hex: string): number[] {\n  hex = hex.replace(\"#\", \"\")\n\n  if (hex.length === 3) {\n    hex = hex\n      .split(\"\")\n      .map((char) => char + char)\n      .join(\"\")\n  }\n\n  const hexInt = parseInt(hex, 16)\n  const red = (hexInt >> 16) & 255\n  const green = (hexInt >> 8) & 255\n  const blue = hexInt & 255\n  return [red, green, blue]\n}\n\ntype Circle = {\n  x: number\n  y: number\n  translateX: number\n  translateY: number\n  size: number\n  alpha: number\n  targetAlpha: number\n  dx: number\n  dy: number\n  magnetism: number\n}\n\nexport const Particles: React.FC<ParticlesProps> = ({\n  className = \"\",\n  quantity = 100,\n  staticity = 50,\n  ease = 50,\n  size = 0.4,\n  refresh = false,\n  color = \"#ffffff\",\n  vx = 0,\n  vy = 0,\n  ...props\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const canvasContainerRef = useRef<HTMLDivElement>(null)\n  const context = useRef<CanvasRenderingContext2D | null>(null)\n  const circles = useRef<Circle[]>([])\n  const mousePosition = MousePosition()\n  const mouse = useRef<{ x: number; y: number }>({ x: 0, y: 0 })\n  const canvasSize = useRef<{ w: number; h: number }>({ w: 0, h: 0 })\n  const dpr = typeof window !== \"undefined\" ? window.devicePixelRatio : 1\n  const rafID = useRef<number | null>(null)\n  const resizeTimeout = useRef<NodeJS.Timeout | null>(null)\n\n  useEffect(() => {\n    if (canvasRef.current) {\n      context.current = canvasRef.current.getContext(\"2d\")\n    }\n    initCanvas()\n    animate()\n\n    const handleResize = () => {\n      if (resizeTimeout.current) {\n        clearTimeout(resizeTimeout.current)\n      }\n      resizeTimeout.current = setTimeout(() => {\n        initCanvas()\n      }, 200)\n    }\n\n    window.addEventListener(\"resize\", handleResize)\n\n    return () => {\n      if (rafID.current != null) {\n        window.cancelAnimationFrame(rafID.current)\n      }\n      if (resizeTimeout.current) {\n        clearTimeout(resizeTimeout.current)\n      }\n      window.removeEventListener(\"resize\", handleResize)\n    }\n  }, [color])\n\n  useEffect(() => {\n    onMouseMove()\n  }, [mousePosition.x, mousePosition.y])\n\n  useEffect(() => {\n    initCanvas()\n  }, [refresh])\n\n  const initCanvas = () => {\n    resizeCanvas()\n    drawParticles()\n  }\n\n  const onMouseMove = () => {\n    if (canvasRef.current) {\n      const rect = canvasRef.current.getBoundingClientRect()\n      const { w, h } = canvasSize.current\n      const x = mousePosition.x - rect.left - w / 2\n      const y = mousePosition.y - rect.top - h / 2\n      const inside = x < w / 2 && x > -w / 2 && y < h / 2 && y > -h / 2\n      if (inside) {\n        mouse.current.x = x\n        mouse.current.y = y\n      }\n    }\n  }\n\n  const resizeCanvas = () => {\n    if (canvasContainerRef.current && canvasRef.current && context.current) {\n      canvasSize.current.w = canvasContainerRef.current.offsetWidth\n      canvasSize.current.h = canvasContainerRef.current.offsetHeight\n\n      canvasRef.current.width = canvasSize.current.w * dpr\n      canvasRef.current.height = canvasSize.current.h * dpr\n      canvasRef.current.style.width = `${canvasSize.current.w}px`\n      canvasRef.current.style.height = `${canvasSize.current.h}px`\n      context.current.scale(dpr, dpr)\n\n      // Clear existing particles and create new ones with exact quantity\n      circles.current = []\n      for (let i = 0; i < quantity; i++) {\n        const circle = circleParams()\n        drawCircle(circle)\n      }\n    }\n  }\n\n  const circleParams = (): Circle => {\n    const x = Math.floor(Math.random() * canvasSize.current.w)\n    const y = Math.floor(Math.random() * canvasSize.current.h)\n    const translateX = 0\n    const translateY = 0\n    const pSize = Math.floor(Math.random() * 2) + size\n    const alpha = 0\n    const targetAlpha = parseFloat((Math.random() * 0.6 + 0.1).toFixed(1))\n    const dx = (Math.random() - 0.5) * 0.1\n    const dy = (Math.random() - 0.5) * 0.1\n    const magnetism = 0.1 + Math.random() * 4\n    return {\n      x,\n      y,\n      translateX,\n      translateY,\n      size: pSize,\n      alpha,\n      targetAlpha,\n      dx,\n      dy,\n      magnetism,\n    }\n  }\n\n  const rgb = hexToRgb(color)\n\n  const drawCircle = (circle: Circle, update = false) => {\n    if (context.current) {\n      const { x, y, translateX, translateY, size, alpha } = circle\n      context.current.translate(translateX, translateY)\n      context.current.beginPath()\n      context.current.arc(x, y, size, 0, 2 * Math.PI)\n      context.current.fillStyle = `rgba(${rgb.join(\", \")}, ${alpha})`\n      context.current.fill()\n      context.current.setTransform(dpr, 0, 0, dpr, 0, 0)\n\n      if (!update) {\n        circles.current.push(circle)\n      }\n    }\n  }\n\n  const clearContext = () => {\n    if (context.current) {\n      context.current.clearRect(\n        0,\n        0,\n        canvasSize.current.w,\n        canvasSize.current.h\n      )\n    }\n  }\n\n  const drawParticles = () => {\n    clearContext()\n    const particleCount = quantity\n    for (let i = 0; i < particleCount; i++) {\n      const circle = circleParams()\n      drawCircle(circle)\n    }\n  }\n\n  const remapValue = (\n    value: number,\n    start1: number,\n    end1: number,\n    start2: number,\n    end2: number\n  ): number => {\n    const remapped =\n      ((value - start1) * (end2 - start2)) / (end1 - start1) + start2\n    return remapped > 0 ? remapped : 0\n  }\n\n  const animate = () => {\n    clearContext()\n    circles.current.forEach((circle: Circle, i: number) => {\n      // Handle the alpha value\n      const edge = [\n        circle.x + circle.translateX - circle.size, // distance from left edge\n        canvasSize.current.w - circle.x - circle.translateX - circle.size, // distance from right edge\n        circle.y + circle.translateY - circle.size, // distance from top edge\n        canvasSize.current.h - circle.y - circle.translateY - circle.size, // distance from bottom edge\n      ]\n      const closestEdge = edge.reduce((a, b) => Math.min(a, b))\n      const remapClosestEdge = parseFloat(\n        remapValue(closestEdge, 0, 20, 0, 1).toFixed(2)\n      )\n      if (remapClosestEdge > 1) {\n        circle.alpha += 0.02\n        if (circle.alpha > circle.targetAlpha) {\n          circle.alpha = circle.targetAlpha\n        }\n      } else {\n        circle.alpha = circle.targetAlpha * remapClosestEdge\n      }\n      circle.x += circle.dx + vx\n      circle.y += circle.dy + vy\n      circle.translateX +=\n        (mouse.current.x / (staticity / circle.magnetism) - circle.translateX) /\n        ease\n      circle.translateY +=\n        (mouse.current.y / (staticity / circle.magnetism) - circle.translateY) /\n        ease\n\n      drawCircle(circle, true)\n\n      // circle gets out of the canvas\n      if (\n        circle.x < -circle.size ||\n        circle.x > canvasSize.current.w + circle.size ||\n        circle.y < -circle.size ||\n        circle.y > canvasSize.current.h + circle.size\n      ) {\n        // remove the circle from the array\n        circles.current.splice(i, 1)\n        // create a new circle\n        const newCircle = circleParams()\n        drawCircle(newCircle)\n      }\n    })\n    rafID.current = window.requestAnimationFrame(animate)\n  }\n\n  return (\n    <div\n      className={cn(\"pointer-events-none\", className)}\n      ref={canvasContainerRef}\n      aria-hidden=\"true\"\n      {...props}\n    >\n      <canvas ref={canvasRef} className=\"size-full\" />\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "pixel-image",
      "type": "component",
      "description": "A component that displays an image with a pixelated effect.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/pixel-image.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useMemo, useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ntype Grid = {\n  rows: number\n  cols: number\n}\n\nconst DEFAULT_GRIDS: Record<string, Grid> = {\n  \"6x4\": { rows: 4, cols: 6 },\n  \"8x8\": { rows: 8, cols: 8 },\n  \"8x3\": { rows: 3, cols: 8 },\n  \"4x6\": { rows: 6, cols: 4 },\n  \"3x8\": { rows: 8, cols: 3 },\n}\n\ntype PredefinedGridKey = keyof typeof DEFAULT_GRIDS\n\ninterface PixelImageProps {\n  src: string\n  grid?: PredefinedGridKey\n  customGrid?: Grid\n  grayscaleAnimation?: boolean\n  pixelFadeInDuration?: number // in ms\n  maxAnimationDelay?: number // in ms\n  colorRevealDelay?: number // in ms\n}\n\nexport const PixelImage = ({\n  src,\n  grid = \"6x4\",\n  grayscaleAnimation = true,\n  pixelFadeInDuration = 1000,\n  maxAnimationDelay = 1200,\n  colorRevealDelay = 1300,\n  customGrid,\n}: PixelImageProps) => {\n  const [isVisible, setIsVisible] = useState(false)\n  const [showColor, setShowColor] = useState(false)\n\n  const MIN_GRID = 1\n  const MAX_GRID = 16\n\n  const { rows, cols } = useMemo(() => {\n    const isValidGrid = (grid?: Grid) => {\n      if (!grid) return false\n      const { rows, cols } = grid\n      return (\n        Number.isInteger(rows) &&\n        Number.isInteger(cols) &&\n        rows >= MIN_GRID &&\n        cols >= MIN_GRID &&\n        rows <= MAX_GRID &&\n        cols <= MAX_GRID\n      )\n    }\n\n    return isValidGrid(customGrid) ? customGrid! : DEFAULT_GRIDS[grid]\n  }, [customGrid, grid])\n\n  useEffect(() => {\n    setIsVisible(true)\n    const colorTimeout = setTimeout(() => {\n      setShowColor(true)\n    }, colorRevealDelay)\n    return () => clearTimeout(colorTimeout)\n  }, [colorRevealDelay])\n\n  const pieces = useMemo(() => {\n    const total = rows * cols\n    return Array.from({ length: total }, (_, index) => {\n      const row = Math.floor(index / cols)\n      const col = index % cols\n\n      const clipPath = `polygon(\n        ${col * (100 / cols)}% ${row * (100 / rows)}%,\n        ${(col + 1) * (100 / cols)}% ${row * (100 / rows)}%,\n        ${(col + 1) * (100 / cols)}% ${(row + 1) * (100 / rows)}%,\n        ${col * (100 / cols)}% ${(row + 1) * (100 / rows)}%\n      )`\n\n      const delay = Math.random() * maxAnimationDelay\n      return {\n        clipPath,\n        delay,\n      }\n    })\n  }, [rows, cols, maxAnimationDelay])\n\n  return (\n    <div className=\"relative h-72 w-72 select-none md:h-96 md:w-96\">\n      {pieces.map((piece, index) => (\n        <div\n          key={index}\n          className={cn(\n            \"absolute inset-0 transition-all ease-out\",\n            isVisible ? \"opacity-100\" : \"opacity-0\"\n          )}\n          style={{\n            clipPath: piece.clipPath,\n            transitionDelay: `${piece.delay}ms`,\n            transitionDuration: `${pixelFadeInDuration}ms`,\n          }}\n        >\n          <img\n            src={src}\n            alt={`Pixel image piece ${index + 1}`}\n            className={cn(\n              \"z-1 rounded-[2.5rem] object-cover\",\n              grayscaleAnimation && (showColor ? \"grayscale-0\" : \"grayscale\")\n            )}\n            style={{\n              transition: grayscaleAnimation\n                ? `filter ${pixelFadeInDuration}ms cubic-bezier(0.4, 0, 0.2, 1)`\n                : \"none\",\n            }}\n            draggable={false}\n          />\n        </div>\n      ))}\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "pixel-trail",
      "type": "component",
      "description": "Pixelated trail following the cursor.",
      "category": "animations",
      "dependencies": [
        "three",
        "@react-three/fiber",
        "@react-three/drei"
      ],
      "files": [
        {
          "path": "components/ui/pixel-trail.tsx",
          "content": "/* eslint-disable react/no-unknown-property */\nimport React, { useMemo } from 'react';\nimport { Canvas, useThree, CanvasProps, ThreeEvent } from '@react-three/fiber';\nimport { shaderMaterial, useTrailTexture } from '@react-three/drei';\nimport * as THREE from 'three';\n\ninterface GooeyFilterProps {\n  id?: string;\n  strength?: number;\n}\n\ninterface DotMaterialUniforms {\n  resolution: THREE.Vector2;\n  mouseTrail: THREE.Texture | null;\n  gridSize: number;\n  pixelColor: THREE.Color;\n}\n\ninterface SceneProps {\n  gridSize: number;\n  trailSize: number;\n  maxAge: number;\n  interpolate: number;\n  easingFunction: (x: number) => number;\n  pixelColor: string;\n}\n\ninterface PixelTrailProps {\n  gridSize?: number;\n  trailSize?: number;\n  maxAge?: number;\n  interpolate?: number;\n  easingFunction?: (x: number) => number;\n  canvasProps?: Partial<CanvasProps>;\n  glProps?: WebGLContextAttributes & { powerPreference?: string };\n  gooeyFilter?: { id: string; strength: number };\n  color?: string;\n  className?: string;\n}\n\nconst GooeyFilter: React.FC<GooeyFilterProps> = ({ id = 'goo-filter', strength = 10 }) => {\n  return (\n    <svg className=\"absolute overflow-hidden z-1\">\n      <defs>\n        <filter id={id}>\n          <feGaussianBlur in=\"SourceGraphic\" stdDeviation={strength} result=\"blur\" />\n          <feColorMatrix in=\"blur\" type=\"matrix\" values=\"1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9\" result=\"goo\" />\n          <feComposite in=\"SourceGraphic\" in2=\"goo\" operator=\"atop\" />\n        </filter>\n      </defs>\n    </svg>\n  );\n};\n\nconst DotMaterial = shaderMaterial(\n  {\n    resolution: new THREE.Vector2(),\n    mouseTrail: null,\n    gridSize: 100,\n    pixelColor: new THREE.Color('#ffffff')\n  },\n  /* glsl vertex shader */ `\n    varying vec2 vUv;\n    void main() {\n      gl_Position = vec4(position.xy, 0.0, 1.0);\n    }\n  `,\n  /* glsl fragment shader */ `\n    uniform vec2 resolution;\n    uniform sampler2D mouseTrail;\n    uniform float gridSize;\n    uniform vec3 pixelColor;\n\n    vec2 coverUv(vec2 uv) {\n      vec2 s = resolution.xy / max(resolution.x, resolution.y);\n      vec2 newUv = (uv - 0.5) * s + 0.5;\n      return clamp(newUv, 0.0, 1.0);\n    }\n\n    float sdfCircle(vec2 p, float r) {\n        return length(p - 0.5) - r;\n    }\n\n    void main() {\n      vec2 screenUv = gl_FragCoord.xy / resolution;\n      vec2 uv = coverUv(screenUv);\n\n      vec2 gridUv = fract(uv * gridSize);\n      vec2 gridUvCenter = (floor(uv * gridSize) + 0.5) / gridSize;\n\n      float trail = texture2D(mouseTrail, gridUvCenter).r;\n\n      gl_FragColor = vec4(pixelColor, trail);\n    }\n  `\n);\n\nfunction Scene({ gridSize, trailSize, maxAge, interpolate, easingFunction, pixelColor }: SceneProps) {\n  const size = useThree(s => s.size);\n  const viewport = useThree(s => s.viewport);\n\n  const dotMaterial = useMemo(() => new DotMaterial(), []);\n  dotMaterial.uniforms.pixelColor.value = new THREE.Color(pixelColor);\n\n  const [trail, onMove] = useTrailTexture({\n    size: 512,\n    radius: trailSize,\n    maxAge: maxAge,\n    interpolate: interpolate || 0.1,\n    ease: easingFunction || ((x: number) => x)\n  }) as [THREE.Texture | null, (e: ThreeEvent<PointerEvent>) => void];\n\n  if (trail) {\n    trail.minFilter = THREE.NearestFilter;\n    trail.magFilter = THREE.NearestFilter;\n    trail.wrapS = THREE.ClampToEdgeWrapping;\n    trail.wrapT = THREE.ClampToEdgeWrapping;\n  }\n\n  const scale = Math.max(viewport.width, viewport.height) / 2;\n\n  return (\n    <mesh scale={[scale, scale, 1]} onPointerMove={onMove}>\n      <planeGeometry args={[2, 2]} />\n      <primitive\n        object={dotMaterial}\n        gridSize={gridSize}\n        resolution={[size.width * viewport.dpr, size.height * viewport.dpr]}\n        mouseTrail={trail}\n      />\n    </mesh>\n  );\n}\n\nexport default function PixelTrail({\n  gridSize = 40,\n  trailSize = 0.1,\n  maxAge = 250,\n  interpolate = 5,\n  easingFunction = (x: number) => x,\n  canvasProps = {},\n  glProps = {\n    antialias: false,\n    powerPreference: 'high-performance',\n    alpha: true\n  },\n  gooeyFilter,\n  color = '#ffffff',\n  className = ''\n}: PixelTrailProps) {\n  return (\n    <>\n      {gooeyFilter && <GooeyFilter id={gooeyFilter.id} strength={gooeyFilter.strength} />}\n      <Canvas\n        {...canvasProps}\n        gl={glProps}\n        className={`absolute z-1 ${className}`}\n        style={gooeyFilter ? { filter: `url(#${gooeyFilter.id})` } : undefined}\n      >\n        <Scene\n          gridSize={gridSize}\n          trailSize={trailSize}\n          maxAge={maxAge}\n          interpolate={interpolate}\n          easingFunction={easingFunction}\n          pixelColor={color}\n        />\n      </Canvas>\n    </>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "pixel-transition",
      "type": "component",
      "description": "Pixel-based transition effect.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/pixel-transition.tsx",
          "content": "import React, { useRef, useEffect, useState, CSSProperties } from 'react';\nimport { gsap } from 'gsap';\n\ninterface PixelTransitionProps {\n  firstContent: React.ReactNode | string;\n  secondContent: React.ReactNode | string;\n  gridSize?: number;\n  pixelColor?: string;\n  animationStepDuration?: number;\n  once?: boolean;\n  className?: string;\n  style?: CSSProperties;\n  aspectRatio?: string;\n}\n\nconst PixelTransition: React.FC<PixelTransitionProps> = ({\n  firstContent,\n  secondContent,\n  gridSize = 7,\n  pixelColor = 'currentColor',\n  animationStepDuration = 0.3,\n  once = false,\n  aspectRatio = '100%',\n  className = '',\n  style = {}\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const pixelGridRef = useRef<HTMLDivElement | null>(null);\n  const activeRef = useRef<HTMLDivElement | null>(null);\n  const delayedCallRef = useRef<gsap.core.Tween | null>(null);\n\n  const [isActive, setIsActive] = useState<boolean>(false);\n\n  const isTouchDevice =\n    'ontouchstart' in window || navigator.maxTouchPoints > 0 || window.matchMedia('(pointer: coarse)').matches;\n\n  useEffect(() => {\n    const pixelGridEl = pixelGridRef.current;\n    if (!pixelGridEl) return;\n\n    pixelGridEl.innerHTML = '';\n\n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        const pixel = document.createElement('div');\n        pixel.classList.add('pixelated-image-card__pixel');\n        pixel.classList.add('absolute', 'hidden');\n        pixel.style.backgroundColor = pixelColor;\n\n        const size = 100 / gridSize;\n        pixel.style.width = `${size}%`;\n        pixel.style.height = `${size}%`;\n        pixel.style.left = `${col * size}%`;\n        pixel.style.top = `${row * size}%`;\n\n        pixelGridEl.appendChild(pixel);\n      }\n    }\n  }, [gridSize, pixelColor]);\n\n  const animatePixels = (activate: boolean): void => {\n    setIsActive(activate);\n\n    const pixelGridEl = pixelGridRef.current;\n    const activeEl = activeRef.current;\n    if (!pixelGridEl || !activeEl) return;\n\n    const pixels = pixelGridEl.querySelectorAll<HTMLDivElement>('.pixelated-image-card__pixel');\n    if (!pixels.length) return;\n\n    gsap.killTweensOf(pixels);\n    if (delayedCallRef.current) {\n      delayedCallRef.current.kill();\n    }\n\n    gsap.set(pixels, { display: 'none' });\n\n    const totalPixels = pixels.length;\n    const staggerDuration = animationStepDuration / totalPixels;\n\n    gsap.to(pixels, {\n      display: 'block',\n      duration: 0,\n      stagger: {\n        each: staggerDuration,\n        from: 'random'\n      }\n    });\n\n    delayedCallRef.current = gsap.delayedCall(animationStepDuration, () => {\n      activeEl.style.display = activate ? 'block' : 'none';\n      activeEl.style.pointerEvents = activate ? 'none' : '';\n    });\n\n    gsap.to(pixels, {\n      display: 'none',\n      duration: 0,\n      delay: animationStepDuration,\n      stagger: {\n        each: staggerDuration,\n        from: 'random'\n      }\n    });\n  };\n\n  const handleEnter = (): void => {\n    if (!isActive) animatePixels(true);\n  };\n  const handleLeave = (): void => {\n    if (isActive && !once) animatePixels(false);\n  };\n  const handleClick = (): void => {\n    if (!isActive) animatePixels(true);\n    else if (isActive && !once) animatePixels(false);\n  };\n  return (\n    <div\n      ref={containerRef}\n      className={`\n        ${className}\n        bg-[#222]\n        text-white\n        rounded-[15px]\n        border-2\n        border-white\n        w-[300px]\n        max-w-full\n        relative\n        overflow-hidden\n      `}\n      style={style}\n      onMouseEnter={!isTouchDevice ? handleEnter : undefined}\n      onMouseLeave={!isTouchDevice ? handleLeave : undefined}\n      onClick={isTouchDevice ? handleClick : undefined}\n      onFocus={!isTouchDevice ? handleEnter : undefined}\n      onBlur={!isTouchDevice ? handleLeave : undefined}\n      tabIndex={0}\n    >\n      <div style={{ paddingTop: aspectRatio }} />\n\n      <div className=\"absolute inset-0 w-full h-full\" aria-hidden={isActive}>\n        {firstContent}\n      </div>\n\n      <div\n        ref={activeRef}\n        className=\"absolute inset-0 w-full h-full z-[2]\"\n        style={{ display: 'none' }}\n        aria-hidden={!isActive}\n      >\n        {secondContent}\n      </div>\n\n      <div ref={pixelGridRef} className=\"absolute inset-0 w-full h-full pointer-events-none z-[3]\" />\n    </div>\n  );\n};\n\nexport default PixelTransition;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "ribbons",
      "type": "component",
      "description": "Animated ribbons effect.",
      "category": "animations",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/ribbons.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { Renderer, Transform, Vec3, Color, Polyline } from 'ogl';\n\ninterface RibbonsProps {\n  colors?: string[];\n  baseSpring?: number;\n  baseFriction?: number;\n  baseThickness?: number;\n  offsetFactor?: number;\n  maxAge?: number;\n  pointCount?: number;\n  speedMultiplier?: number;\n  enableFade?: boolean;\n  enableShaderEffect?: boolean;\n  effectAmplitude?: number;\n  backgroundColor?: number[];\n}\n\nconst Ribbons: React.FC<RibbonsProps> = ({\n  colors = ['#ff9346', '#7cff67', '#ffee51', '#5227FF'],\n  baseSpring = 0.03,\n  baseFriction = 0.9,\n  baseThickness = 30,\n  offsetFactor = 0.05,\n  maxAge = 500,\n  pointCount = 50,\n  speedMultiplier = 0.6,\n  enableFade = false,\n  enableShaderEffect = false,\n  effectAmplitude = 2,\n  backgroundColor = [0, 0, 0, 0]\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const renderer = new Renderer({ dpr: window.devicePixelRatio || 2, alpha: true });\n    const gl = renderer.gl;\n    if (Array.isArray(backgroundColor) && backgroundColor.length === 4) {\n      gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], backgroundColor[3]);\n    } else {\n      gl.clearColor(0, 0, 0, 0);\n    }\n\n    gl.canvas.style.position = 'absolute';\n    gl.canvas.style.top = '0';\n    gl.canvas.style.left = '0';\n    gl.canvas.style.width = '100%';\n    gl.canvas.style.height = '100%';\n    container.appendChild(gl.canvas);\n\n    const scene = new Transform();\n    const lines: {\n      spring: number;\n      friction: number;\n      mouseVelocity: Vec3;\n      mouseOffset: Vec3;\n      points: Vec3[];\n      polyline: Polyline;\n    }[] = [];\n\n    const vertex = `\n      precision highp float;\n      \n      attribute vec3 position;\n      attribute vec3 next;\n      attribute vec3 prev;\n      attribute vec2 uv;\n      attribute float side;\n      \n      uniform vec2 uResolution;\n      uniform float uDPR;\n      uniform float uThickness;\n      uniform float uTime;\n      uniform float uEnableShaderEffect;\n      uniform float uEffectAmplitude;\n      \n      varying vec2 vUV;\n      \n      vec4 getPosition() {\n          vec4 current = vec4(position, 1.0);\n          vec2 aspect = vec2(uResolution.x / uResolution.y, 1.0);\n          vec2 nextScreen = next.xy * aspect;\n          vec2 prevScreen = prev.xy * aspect;\n          vec2 tangent = normalize(nextScreen - prevScreen);\n          vec2 normal = vec2(-tangent.y, tangent.x);\n          normal /= aspect;\n          normal *= mix(1.0, 0.1, pow(abs(uv.y - 0.5) * 2.0, 2.0));\n          float dist = length(nextScreen - prevScreen);\n          normal *= smoothstep(0.0, 0.02, dist);\n          float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n          float pixelWidth = current.w * pixelWidthRatio;\n          normal *= pixelWidth * uThickness;\n          current.xy -= normal * side;\n          if(uEnableShaderEffect > 0.5) {\n            current.xy += normal * sin(uTime + current.x * 10.0) * uEffectAmplitude;\n          }\n          return current;\n      }\n      \n      void main() {\n          vUV = uv;\n          gl_Position = getPosition();\n      }\n    `;\n\n    const fragment = `\n      precision highp float;\n      uniform vec3 uColor;\n      uniform float uOpacity;\n      uniform float uEnableFade;\n      varying vec2 vUV;\n      void main() {\n          float fadeFactor = 1.0;\n          if(uEnableFade > 0.5) {\n              fadeFactor = 1.0 - smoothstep(0.0, 1.0, vUV.y);\n          }\n          gl_FragColor = vec4(uColor, uOpacity * fadeFactor);\n      }\n    `;\n\n    function resize() {\n      if (!container) return;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n      renderer.setSize(width, height);\n      lines.forEach(line => line.polyline.resize());\n    }\n    window.addEventListener('resize', resize);\n\n    const center = (colors.length - 1) / 2;\n    colors.forEach((color, index) => {\n      const spring = baseSpring + (Math.random() - 0.5) * 0.05;\n      const friction = baseFriction + (Math.random() - 0.5) * 0.05;\n      const thickness = baseThickness + (Math.random() - 0.5) * 3;\n      const mouseOffset = new Vec3(\n        (index - center) * offsetFactor + (Math.random() - 0.5) * 0.01,\n        (Math.random() - 0.5) * 0.1,\n        0\n      );\n\n      const line = {\n        spring,\n        friction,\n        mouseVelocity: new Vec3(),\n        mouseOffset,\n        points: [] as Vec3[],\n        polyline: {} as Polyline\n      };\n\n      const count = pointCount;\n      const points: Vec3[] = [];\n      for (let i = 0; i < count; i++) {\n        points.push(new Vec3());\n      }\n      line.points = points;\n\n      line.polyline = new Polyline(gl, {\n        points,\n        vertex,\n        fragment,\n        uniforms: {\n          uColor: { value: new Color(color) },\n          uThickness: { value: thickness },\n          uOpacity: { value: 1.0 },\n          uTime: { value: 0.0 },\n          uEnableShaderEffect: { value: enableShaderEffect ? 1.0 : 0.0 },\n          uEffectAmplitude: { value: effectAmplitude },\n          uEnableFade: { value: enableFade ? 1.0 : 0.0 }\n        }\n      });\n      line.polyline.mesh.setParent(scene);\n      lines.push(line);\n    });\n\n    resize();\n\n    const mouse = new Vec3();\n    function updateMouse(e: MouseEvent | TouchEvent) {\n      let x: number, y: number;\n      if (!container) return;\n      const rect = container.getBoundingClientRect();\n      if ('changedTouches' in e && e.changedTouches.length) {\n        x = e.changedTouches[0].clientX - rect.left;\n        y = e.changedTouches[0].clientY - rect.top;\n      } else if (e instanceof MouseEvent) {\n        x = e.clientX - rect.left;\n        y = e.clientY - rect.top;\n      } else {\n        x = 0;\n        y = 0;\n      }\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n      mouse.set((x / width) * 2 - 1, (y / height) * -2 + 1, 0);\n    }\n    container.addEventListener('mousemove', updateMouse);\n    container.addEventListener('touchstart', updateMouse);\n    container.addEventListener('touchmove', updateMouse);\n\n    const tmp = new Vec3();\n    let frameId: number;\n    let lastTime = performance.now();\n    function update() {\n      frameId = requestAnimationFrame(update);\n      const currentTime = performance.now();\n      const dt = currentTime - lastTime;\n      lastTime = currentTime;\n\n      lines.forEach(line => {\n        tmp.copy(mouse).add(line.mouseOffset).sub(line.points[0]).multiply(line.spring);\n        line.mouseVelocity.add(tmp).multiply(line.friction);\n        line.points[0].add(line.mouseVelocity);\n\n        for (let i = 1; i < line.points.length; i++) {\n          if (isFinite(maxAge) && maxAge > 0) {\n            const segmentDelay = maxAge / (line.points.length - 1);\n            const alpha = Math.min(1, (dt * speedMultiplier) / segmentDelay);\n            line.points[i].lerp(line.points[i - 1], alpha);\n          } else {\n            line.points[i].lerp(line.points[i - 1], 0.9);\n          }\n        }\n        if (line.polyline.mesh.program.uniforms.uTime) {\n          line.polyline.mesh.program.uniforms.uTime.value = currentTime * 0.001;\n        }\n        line.polyline.updateGeometry();\n      });\n\n      renderer.render({ scene });\n    }\n    update();\n\n    return () => {\n      window.removeEventListener('resize', resize);\n      container.removeEventListener('mousemove', updateMouse);\n      container.removeEventListener('touchstart', updateMouse);\n      container.removeEventListener('touchmove', updateMouse);\n      cancelAnimationFrame(frameId);\n      if (gl.canvas && gl.canvas.parentNode === container) {\n        container.removeChild(gl.canvas);\n      }\n    };\n  }, [\n    colors,\n    baseSpring,\n    baseFriction,\n    baseThickness,\n    offsetFactor,\n    maxAge,\n    pointCount,\n    speedMultiplier,\n    enableFade,\n    enableShaderEffect,\n    effectAmplitude,\n    backgroundColor\n  ]);\n\n  return <div ref={containerRef} className=\"relative w-full h-full\" />;\n};\n\nexport default Ribbons;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "scroll-progress",
      "type": "component",
      "description": "Animated Scroll Progress for your pages",
      "category": "animations",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/scroll-progress.tsx",
          "content": "\"use client\"\n\nimport { motion, MotionProps, useScroll } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface ScrollProgressProps extends Omit<\n  React.HTMLAttributes<HTMLElement>,\n  keyof MotionProps\n> {\n  ref?: React.Ref<HTMLDivElement>\n}\n\nexport function ScrollProgress({\n  className,\n  ref,\n  ...props\n}: ScrollProgressProps) {\n  const { scrollYProgress } = useScroll()\n\n  return (\n    <motion.div\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 top-0 z-50 h-px origin-left bg-gradient-to-r from-[#A97CF8] via-[#F38CB8] to-[#FDCC92]\",\n        className\n      )}\n      style={{\n        scaleX: scrollYProgress,\n      }}\n      {...props}\n    />\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "shape-blur",
      "type": "component",
      "description": "Blurred shape animation.",
      "category": "animations",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/shape-blur.tsx",
          "content": "import React, { useRef, useEffect, FC } from 'react';\nimport * as THREE from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 v_texcoord;\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    v_texcoord = uv;\n}\n`;\n\nconst fragmentShader = /* glsl */ `\nvarying vec2 v_texcoord;\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform float u_shapeSize;\nuniform float u_roundness;\nuniform float u_borderSize;\nuniform float u_circleSize;\nuniform float u_circleEdge;\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n\n#ifndef VAR\n#define VAR 0\n#endif\n\n#ifndef FNC_COORD\n#define FNC_COORD\nvec2 coord(in vec2 p) {\n    p = p / u_resolution.xy;\n    if (u_resolution.x > u_resolution.y) {\n        p.x *= u_resolution.x / u_resolution.y;\n        p.x += (u_resolution.y - u_resolution.x) / u_resolution.y / 2.0;\n    } else {\n        p.y *= u_resolution.y / u_resolution.x;\n        p.y += (u_resolution.x - u_resolution.y) / u_resolution.x / 2.0;\n    }\n    p -= 0.5;\n    p *= vec2(-1.0, 1.0);\n    return p;\n}\n#endif\n\n#define st0 coord(gl_FragCoord.xy)\n#define mx coord(u_mouse * u_pixelRatio)\n\nfloat sdRoundRect(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\nfloat sdCircle(in vec2 st, in vec2 center) {\n    return length(st - center) * 2.0;\n}\nfloat sdPoly(in vec2 p, in float w, in int sides) {\n    float a = atan(p.x, p.y) + PI;\n    float r = TWO_PI / float(sides);\n    float d = cos(floor(0.5 + a / r) * r - a) * length(max(abs(p) * 1.0, 0.0));\n    return d * 2.0 - w;\n}\n\nfloat aastep(float threshold, float value) {\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold - afwidth, threshold + afwidth, value);\n}\nfloat fill(in float x) { return 1.0 - aastep(0.0, x); }\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\nfloat stroke(in float d, in float t) { return (1.0 - aastep(t, abs(d))); }\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return clamp(d, 0.0, 1.0);\n}\n\nfloat strokeAA(float x, float size, float w, float edge) {\n    float afwidth = length(vec2(dFdx(x), dFdy(x))) * 0.70710678;\n    float d = smoothstep(size - edge - afwidth, size + edge + afwidth, x + w * 0.5)\n            - smoothstep(size - edge - afwidth, size + edge + afwidth, x - w * 0.5);\n    return clamp(d, 0.0, 1.0);\n}\n\nvoid main() {\n    vec2 st = st0 + 0.5;\n    vec2 posMouse = mx * vec2(1., -1.) + 0.5;\n\n    float size = u_shapeSize;\n    float roundness = u_roundness;\n    float borderSize = u_borderSize;\n    float circleSize = u_circleSize;\n    float circleEdge = u_circleEdge;\n\n    float sdfCircle = fill(\n        sdCircle(st, posMouse),\n        circleSize,\n        circleEdge\n    );\n\n    float sdf;\n    if (VAR == 0) {\n        sdf = sdRoundRect(st, vec2(size), roundness);\n        sdf = strokeAA(sdf, 0.0, borderSize, sdfCircle) * 4.0;\n    } else if (VAR == 1) {\n        sdf = sdCircle(st, vec2(0.5));\n        sdf = fill(sdf, 0.6, sdfCircle) * 1.2;\n    } else if (VAR == 2) {\n        sdf = sdCircle(st, vec2(0.5));\n        sdf = strokeAA(sdf, 0.58, 0.02, sdfCircle) * 4.0;\n    } else if (VAR == 3) {\n        sdf = sdPoly(st - vec2(0.5, 0.45), 0.3, 3);\n        sdf = fill(sdf, 0.05, sdfCircle) * 1.4;\n    }\n\n    vec3 color = vec3(1.0);\n    float alpha = sdf;\n    gl_FragColor = vec4(color.rgb, alpha);\n}\n`;\n\ninterface ShapeBlurProps {\n  className?: string;\n  variation?: number;\n  pixelRatioProp?: number;\n  shapeSize?: number;\n  roundness?: number;\n  borderSize?: number;\n  circleSize?: number;\n  circleEdge?: number;\n}\n\nconst ShapeBlur: FC<ShapeBlurProps> = ({\n  className = '',\n  variation = 0,\n  pixelRatioProp = 2,\n  shapeSize = 1.2,\n  roundness = 0.4,\n  borderSize = 0.05,\n  circleSize = 0.3,\n  circleEdge = 0.5\n}) => {\n  const mountRef = useRef<HTMLDivElement | null>(null);\n\n  useEffect(() => {\n    const mount = mountRef.current;\n    if (!mount) return;\n\n    let animationFrameId: number;\n    let time = 0,\n      lastTime = 0;\n\n    const vMouse = new THREE.Vector2();\n    const vMouseDamp = new THREE.Vector2();\n    const vResolution = new THREE.Vector2();\n\n    let w = 1,\n      h = 1;\n\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera();\n    camera.position.z = 1;\n\n    const renderer = new THREE.WebGLRenderer({ alpha: true });\n    renderer.setClearColor(0x000000, 0);\n    mount.appendChild(renderer.domElement);\n\n    const geo = new THREE.PlaneGeometry(1, 1);\n    const material = new THREE.ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        u_mouse: { value: vMouseDamp },\n        u_resolution: { value: vResolution },\n        u_pixelRatio: { value: pixelRatioProp },\n        u_shapeSize: { value: shapeSize },\n        u_roundness: { value: roundness },\n        u_borderSize: { value: borderSize },\n        u_circleSize: { value: circleSize },\n        u_circleEdge: { value: circleEdge }\n      },\n      defines: { VAR: variation },\n      transparent: true\n    });\n\n    const quad = new THREE.Mesh(geo, material);\n    scene.add(quad);\n\n    const onPointerMove = (e: PointerEvent | MouseEvent) => {\n      if (!mount) return;\n      const rect = mount.getBoundingClientRect();\n      vMouse.set(e.clientX - rect.left, e.clientY - rect.top);\n    };\n\n    document.addEventListener('mousemove', onPointerMove);\n    document.addEventListener('pointermove', onPointerMove);\n\n    const resize = () => {\n      if (!mountRef.current) return;\n      const container = mountRef.current;\n      w = container.clientWidth;\n      h = container.clientHeight;\n      const dpr = Math.min(window.devicePixelRatio || 1, 2);\n\n      renderer.setSize(w, h);\n      renderer.setPixelRatio(dpr);\n\n      camera.left = -w / 2;\n      camera.right = w / 2;\n      camera.top = h / 2;\n      camera.bottom = -h / 2;\n      camera.updateProjectionMatrix();\n\n      quad.scale.set(w, h, 1);\n      vResolution.set(w, h).multiplyScalar(dpr);\n      material.uniforms.u_pixelRatio.value = dpr;\n    };\n\n    resize();\n    window.addEventListener('resize', resize);\n\n    const ro = new ResizeObserver(() => resize());\n    ro.observe(mountRef.current as Element);\n\n    const update = () => {\n      time = performance.now() * 0.001;\n      const dt = time - lastTime;\n      lastTime = time;\n\n      vMouseDamp.x = THREE.MathUtils.damp(vMouseDamp.x, vMouse.x, 8, dt);\n      vMouseDamp.y = THREE.MathUtils.damp(vMouseDamp.y, vMouse.y, 8, dt);\n\n      renderer.render(scene, camera);\n      animationFrameId = requestAnimationFrame(update);\n    };\n    update();\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n      window.removeEventListener('resize', resize);\n      ro.disconnect();\n      document.removeEventListener('mousemove', onPointerMove);\n      document.removeEventListener('pointermove', onPointerMove);\n      mount.removeChild(renderer.domElement);\n      renderer.dispose();\n    };\n  }, [variation, pixelRatioProp, shapeSize, roundness, borderSize, circleSize, circleEdge]);\n\n  return <div ref={mountRef} className={`w-full h-full ${className}`} />;\n};\n\nexport default ShapeBlur;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "shine-border",
      "type": "component",
      "description": "Shine border is an animated background border effect.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/shine-border.tsx",
          "content": "\"use client\"\n\nimport * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface ShineBorderProps extends React.HTMLAttributes<HTMLDivElement> {\n  /**\n   * Width of the border in pixels\n   * @default 1\n   */\n  borderWidth?: number\n  /**\n   * Duration of the animation in seconds\n   * @default 14\n   */\n  duration?: number\n  /**\n   * Color of the border, can be a single color or an array of colors\n   * @default \"#000000\"\n   */\n  shineColor?: string | string[]\n}\n\n/**\n * Shine Border\n *\n * An animated background border effect component with configurable properties.\n */\nexport function ShineBorder({\n  borderWidth = 1,\n  duration = 14,\n  shineColor = \"#000000\",\n  className,\n  style,\n  ...props\n}: ShineBorderProps) {\n  return (\n    <div\n      style={\n        {\n          \"--border-width\": `${borderWidth}px`,\n          \"--duration\": `${duration}s`,\n          backgroundImage: `radial-gradient(transparent,transparent, ${\n            Array.isArray(shineColor) ? shineColor.join(\",\") : shineColor\n          },transparent,transparent)`,\n          backgroundSize: \"300% 300%\",\n          mask: `linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0)`,\n          WebkitMask: `linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0)`,\n          WebkitMaskComposite: \"xor\",\n          maskComposite: \"exclude\",\n          padding: \"var(--border-width)\",\n          ...style,\n        } as React.CSSProperties\n      }\n      className={cn(\n        \"motion-safe:animate-shine pointer-events-none absolute inset-0 size-full rounded-[inherit] will-change-[background-position]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ]
      }
    },
    {
      "name": "splash-cursor",
      "type": "component",
      "description": "Splash effect cursor.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/splash-cursor.tsx",
          "content": "'use client';\nimport React, { useEffect, useRef } from 'react';\n\ninterface ColorRGB {\n  r: number;\n  g: number;\n  b: number;\n}\n\ninterface SplashCursorProps {\n  SIM_RESOLUTION?: number;\n  DYE_RESOLUTION?: number;\n  CAPTURE_RESOLUTION?: number;\n  DENSITY_DISSIPATION?: number;\n  VELOCITY_DISSIPATION?: number;\n  PRESSURE?: number;\n  PRESSURE_ITERATIONS?: number;\n  CURL?: number;\n  SPLAT_RADIUS?: number;\n  SPLAT_FORCE?: number;\n  SHADING?: boolean;\n  COLOR_UPDATE_SPEED?: number;\n  BACK_COLOR?: ColorRGB;\n  TRANSPARENT?: boolean;\n}\n\ninterface Pointer {\n  id: number;\n  texcoordX: number;\n  texcoordY: number;\n  prevTexcoordX: number;\n  prevTexcoordY: number;\n  deltaX: number;\n  deltaY: number;\n  down: boolean;\n  moved: boolean;\n  color: ColorRGB;\n}\n\nfunction pointerPrototype(): Pointer {\n  return {\n    id: -1,\n    texcoordX: 0,\n    texcoordY: 0,\n    prevTexcoordX: 0,\n    prevTexcoordY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    down: false,\n    moved: false,\n    color: { r: 0, g: 0, b: 0 }\n  };\n}\n\nexport default function SplashCursor({\n  SIM_RESOLUTION = 128,\n  DYE_RESOLUTION = 1440,\n  CAPTURE_RESOLUTION = 512,\n  DENSITY_DISSIPATION = 3.5,\n  VELOCITY_DISSIPATION = 2,\n  PRESSURE = 0.1,\n  PRESSURE_ITERATIONS = 20,\n  CURL = 3,\n  SPLAT_RADIUS = 0.2,\n  SPLAT_FORCE = 6000,\n  SHADING = true,\n  COLOR_UPDATE_SPEED = 10,\n  BACK_COLOR = { r: 0.5, g: 0, b: 0 },\n  TRANSPARENT = true\n}: SplashCursorProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    let pointers: Pointer[] = [pointerPrototype()];\n\n    let config = {\n      SIM_RESOLUTION: SIM_RESOLUTION!,\n      DYE_RESOLUTION: DYE_RESOLUTION!,\n      CAPTURE_RESOLUTION: CAPTURE_RESOLUTION!,\n      DENSITY_DISSIPATION: DENSITY_DISSIPATION!,\n      VELOCITY_DISSIPATION: VELOCITY_DISSIPATION!,\n      PRESSURE: PRESSURE!,\n      PRESSURE_ITERATIONS: PRESSURE_ITERATIONS!,\n      CURL: CURL!,\n      SPLAT_RADIUS: SPLAT_RADIUS!,\n      SPLAT_FORCE: SPLAT_FORCE!,\n      SHADING,\n      COLOR_UPDATE_SPEED: COLOR_UPDATE_SPEED!,\n      PAUSED: false,\n      BACK_COLOR,\n      TRANSPARENT\n    };\n\n    const { gl, ext } = getWebGLContext(canvas);\n    if (!gl || !ext) return;\n\n    if (!ext.supportLinearFiltering) {\n      config.DYE_RESOLUTION = 256;\n      config.SHADING = false;\n    }\n\n    function getWebGLContext(canvas: HTMLCanvasElement) {\n      const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n      };\n\n      let gl = canvas.getContext('webgl2', params) as WebGL2RenderingContext | null;\n\n      if (!gl) {\n        gl = (canvas.getContext('webgl', params) ||\n          canvas.getContext('experimental-webgl', params)) as WebGL2RenderingContext | null;\n      }\n\n      if (!gl) {\n        throw new Error('Unable to initialize WebGL.');\n      }\n\n      const isWebGL2 = 'drawBuffers' in gl;\n\n      let supportLinearFiltering = false;\n      let halfFloat = null;\n\n      if (isWebGL2) {\n        (gl as WebGL2RenderingContext).getExtension('EXT_color_buffer_float');\n        supportLinearFiltering = !!(gl as WebGL2RenderingContext).getExtension('OES_texture_float_linear');\n      } else {\n        halfFloat = gl.getExtension('OES_texture_half_float');\n        supportLinearFiltering = !!gl.getExtension('OES_texture_half_float_linear');\n      }\n\n      gl.clearColor(0, 0, 0, 1);\n\n      const halfFloatTexType = isWebGL2\n        ? (gl as WebGL2RenderingContext).HALF_FLOAT\n        : (halfFloat && (halfFloat as any).HALF_FLOAT_OES) || 0;\n\n      let formatRGBA: any;\n      let formatRG: any;\n      let formatR: any;\n\n      if (isWebGL2) {\n        formatRGBA = getSupportedFormat(gl, (gl as WebGL2RenderingContext).RGBA16F, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(\n          gl,\n          (gl as WebGL2RenderingContext).RG16F,\n          (gl as WebGL2RenderingContext).RG,\n          halfFloatTexType\n        );\n        formatR = getSupportedFormat(\n          gl,\n          (gl as WebGL2RenderingContext).R16F,\n          (gl as WebGL2RenderingContext).RED,\n          halfFloatTexType\n        );\n      } else {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n      }\n\n      return {\n        gl,\n        ext: {\n          formatRGBA,\n          formatRG,\n          formatR,\n          halfFloatTexType,\n          supportLinearFiltering\n        }\n      };\n    }\n\n    function getSupportedFormat(\n      gl: WebGLRenderingContext | WebGL2RenderingContext,\n      internalFormat: number,\n      format: number,\n      type: number\n    ): { internalFormat: number; format: number } | null {\n      if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n        if ('drawBuffers' in gl) {\n          const gl2 = gl as WebGL2RenderingContext;\n          switch (internalFormat) {\n            case gl2.R16F:\n              return getSupportedFormat(gl2, gl2.RG16F, gl2.RG, type);\n            case gl2.RG16F:\n              return getSupportedFormat(gl2, gl2.RGBA16F, gl2.RGBA, type);\n            default:\n              return null;\n          }\n        }\n        return null;\n      }\n      return { internalFormat, format };\n    }\n\n    function supportRenderTextureFormat(\n      gl: WebGLRenderingContext | WebGL2RenderingContext,\n      internalFormat: number,\n      format: number,\n      type: number\n    ) {\n      const texture = gl.createTexture();\n      if (!texture) return false;\n\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n\n      const fbo = gl.createFramebuffer();\n      if (!fbo) return false;\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n      return status === gl.FRAMEBUFFER_COMPLETE;\n    }\n\n    function hashCode(s: string) {\n      if (!s.length) return 0;\n      let hash = 0;\n      for (let i = 0; i < s.length; i++) {\n        hash = (hash << 5) - hash + s.charCodeAt(i);\n        hash |= 0;\n      }\n      return hash;\n    }\n\n    function addKeywords(source: string, keywords: string[] | null) {\n      if (!keywords) return source;\n      let keywordsString = '';\n      for (const keyword of keywords) {\n        keywordsString += `#define ${keyword}\\n`;\n      }\n      return keywordsString + source;\n    }\n\n    function compileShader(type: number, source: string, keywords: string[] | null = null): WebGLShader | null {\n      const shaderSource = addKeywords(source, keywords);\n      const shader = gl.createShader(type);\n      if (!shader) return null;\n      gl.shaderSource(shader, shaderSource);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.trace(gl.getShaderInfoLog(shader));\n      }\n      return shader;\n    }\n\n    function createProgram(vertexShader: WebGLShader | null, fragmentShader: WebGLShader | null): WebGLProgram | null {\n      if (!vertexShader || !fragmentShader) return null;\n      const program = gl.createProgram();\n      if (!program) return null;\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.trace(gl.getProgramInfoLog(program));\n      }\n      return program;\n    }\n\n    function getUniforms(program: WebGLProgram) {\n      let uniforms: Record<string, WebGLUniformLocation | null> = {};\n      const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        const uniformInfo = gl.getActiveUniform(program, i);\n        if (uniformInfo) {\n          uniforms[uniformInfo.name] = gl.getUniformLocation(program, uniformInfo.name);\n        }\n      }\n      return uniforms;\n    }\n\n    class Program {\n      program: WebGLProgram | null;\n      uniforms: Record<string, WebGLUniformLocation | null>;\n\n      constructor(vertexShader: WebGLShader | null, fragmentShader: WebGLShader | null) {\n        this.program = createProgram(vertexShader, fragmentShader);\n        this.uniforms = this.program ? getUniforms(this.program) : {};\n      }\n\n      bind() {\n        if (this.program) gl.useProgram(this.program);\n      }\n    }\n\n    class Material {\n      vertexShader: WebGLShader | null;\n      fragmentShaderSource: string;\n      programs: Record<number, WebGLProgram | null>;\n      activeProgram: WebGLProgram | null;\n      uniforms: Record<string, WebGLUniformLocation | null>;\n\n      constructor(vertexShader: WebGLShader | null, fragmentShaderSource: string) {\n        this.vertexShader = vertexShader;\n        this.fragmentShaderSource = fragmentShaderSource;\n        this.programs = {};\n        this.activeProgram = null;\n        this.uniforms = {};\n      }\n\n      setKeywords(keywords: string[]) {\n        let hash = 0;\n        for (const kw of keywords) {\n          hash += hashCode(kw);\n        }\n        let program = this.programs[hash];\n        if (program == null) {\n          const fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n          program = createProgram(this.vertexShader, fragmentShader);\n          this.programs[hash] = program;\n        }\n        if (program === this.activeProgram) return;\n        if (program) {\n          this.uniforms = getUniforms(program);\n        }\n        this.activeProgram = program;\n      }\n\n      bind() {\n        if (this.activeProgram) {\n          gl.useProgram(this.activeProgram);\n        }\n      }\n    }\n\n    const baseVertexShader = compileShader(\n      gl.VERTEX_SHADER,\n      `\n      precision highp float;\n      attribute vec2 aPosition;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform vec2 texelSize;\n\n      void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n      }\n    `\n    );\n\n    const copyShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      uniform sampler2D uTexture;\n\n      void main () {\n          gl_FragColor = texture2D(uTexture, vUv);\n      }\n    `\n    );\n\n    const clearShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      uniform sampler2D uTexture;\n      uniform float value;\n\n      void main () {\n          gl_FragColor = value * texture2D(uTexture, vUv);\n      }\n    `\n    );\n\n    const displayShaderSource = `\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform sampler2D uTexture;\n      uniform sampler2D uDithering;\n      uniform vec2 ditherScale;\n      uniform vec2 texelSize;\n\n      vec3 linearToGamma (vec3 color) {\n          color = max(color, vec3(0));\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n      }\n\n      void main () {\n          vec3 c = texture2D(uTexture, vUv).rgb;\n          #ifdef SHADING\n              vec3 lc = texture2D(uTexture, vL).rgb;\n              vec3 rc = texture2D(uTexture, vR).rgb;\n              vec3 tc = texture2D(uTexture, vT).rgb;\n              vec3 bc = texture2D(uTexture, vB).rgb;\n\n              float dx = length(rc) - length(lc);\n              float dy = length(tc) - length(bc);\n\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n              vec3 l = vec3(0.0, 0.0, 1.0);\n\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n              c *= diffuse;\n          #endif\n\n          float a = max(c.r, max(c.g, c.b));\n          gl_FragColor = vec4(c, a);\n      }\n    `;\n\n    const splatShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      uniform sampler2D uTarget;\n      uniform float aspectRatio;\n      uniform vec3 color;\n      uniform vec2 point;\n      uniform float radius;\n\n      void main () {\n          vec2 p = vUv - point.xy;\n          p.x *= aspectRatio;\n          vec3 splat = exp(-dot(p, p) / radius) * color;\n          vec3 base = texture2D(uTarget, vUv).xyz;\n          gl_FragColor = vec4(base + splat, 1.0);\n      }\n    `\n    );\n\n    const advectionShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      uniform sampler2D uVelocity;\n      uniform sampler2D uSource;\n      uniform vec2 texelSize;\n      uniform vec2 dyeTexelSize;\n      uniform float dt;\n      uniform float dissipation;\n\n      vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n          vec2 st = uv / tsize - 0.5;\n          vec2 iuv = floor(st);\n          vec2 fuv = fract(st);\n\n          vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n          vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n          vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n          vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n          return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n      }\n\n      void main () {\n          #ifdef MANUAL_FILTERING\n              vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n              vec4 result = bilerp(uSource, coord, dyeTexelSize);\n          #else\n              vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n              vec4 result = texture2D(uSource, coord);\n          #endif\n          float decay = 1.0 + dissipation * dt;\n          gl_FragColor = result / decay;\n      }\n    `,\n      ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']\n    );\n\n    const divergenceShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      varying highp vec2 vL;\n      varying highp vec2 vR;\n      varying highp vec2 vT;\n      varying highp vec2 vB;\n      uniform sampler2D uVelocity;\n\n      void main () {\n          float L = texture2D(uVelocity, vL).x;\n          float R = texture2D(uVelocity, vR).x;\n          float T = texture2D(uVelocity, vT).y;\n          float B = texture2D(uVelocity, vB).y;\n\n          vec2 C = texture2D(uVelocity, vUv).xy;\n          if (vL.x < 0.0) { L = -C.x; }\n          if (vR.x > 1.0) { R = -C.x; }\n          if (vT.y > 1.0) { T = -C.y; }\n          if (vB.y < 0.0) { B = -C.y; }\n\n          float div = 0.5 * (R - L + T - B);\n          gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n      }\n    `\n    );\n\n    const curlShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      varying highp vec2 vL;\n      varying highp vec2 vR;\n      varying highp vec2 vT;\n      varying highp vec2 vB;\n      uniform sampler2D uVelocity;\n\n      void main () {\n          float L = texture2D(uVelocity, vL).y;\n          float R = texture2D(uVelocity, vR).y;\n          float T = texture2D(uVelocity, vT).x;\n          float B = texture2D(uVelocity, vB).x;\n          float vorticity = R - L - T + B;\n          gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n      }\n    `\n    );\n\n    const vorticityShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform sampler2D uVelocity;\n      uniform sampler2D uCurl;\n      uniform float curl;\n      uniform float dt;\n\n      void main () {\n          float L = texture2D(uCurl, vL).x;\n          float R = texture2D(uCurl, vR).x;\n          float T = texture2D(uCurl, vT).x;\n          float B = texture2D(uCurl, vB).x;\n          float C = texture2D(uCurl, vUv).x;\n\n          vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n          force /= length(force) + 0.0001;\n          force *= curl * C;\n          force.y *= -1.0;\n\n          vec2 velocity = texture2D(uVelocity, vUv).xy;\n          velocity += force * dt;\n          velocity = min(max(velocity, -1000.0), 1000.0);\n          gl_FragColor = vec4(velocity, 0.0, 1.0);\n      }\n    `\n    );\n\n    const pressureShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      varying highp vec2 vL;\n      varying highp vec2 vR;\n      varying highp vec2 vT;\n      varying highp vec2 vB;\n      uniform sampler2D uPressure;\n      uniform sampler2D uDivergence;\n\n      void main () {\n          float L = texture2D(uPressure, vL).x;\n          float R = texture2D(uPressure, vR).x;\n          float T = texture2D(uPressure, vT).x;\n          float B = texture2D(uPressure, vB).x;\n          float C = texture2D(uPressure, vUv).x;\n          float divergence = texture2D(uDivergence, vUv).x;\n          float pressure = (L + R + B + T - divergence) * 0.25;\n          gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n      }\n    `\n    );\n\n    const gradientSubtractShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      varying highp vec2 vL;\n      varying highp vec2 vR;\n      varying highp vec2 vT;\n      varying highp vec2 vB;\n      uniform sampler2D uPressure;\n      uniform sampler2D uVelocity;\n\n      void main () {\n          float L = texture2D(uPressure, vL).x;\n          float R = texture2D(uPressure, vR).x;\n          float T = texture2D(uPressure, vT).x;\n          float B = texture2D(uPressure, vB).x;\n          vec2 velocity = texture2D(uVelocity, vUv).xy;\n          velocity.xy -= vec2(R - L, T - B);\n          gl_FragColor = vec4(velocity, 0.0, 1.0);\n      }\n    `\n    );\n\n    const blit = (() => {\n      const buffer = gl.createBuffer()!;\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n      const elemBuffer = gl.createBuffer()!;\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elemBuffer);\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n\n      return (target: FBO | null, doClear = false) => {\n        if (!gl) return;\n        if (!target) {\n          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        } else {\n          gl.viewport(0, 0, target.width, target.height);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n        }\n        if (doClear) {\n          gl.clearColor(0, 0, 0, 1);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n      };\n    })();\n\n    interface FBO {\n      texture: WebGLTexture;\n      fbo: WebGLFramebuffer;\n      width: number;\n      height: number;\n      texelSizeX: number;\n      texelSizeY: number;\n      attach: (id: number) => number;\n    }\n\n    interface DoubleFBO {\n      width: number;\n      height: number;\n      texelSizeX: number;\n      texelSizeY: number;\n      read: FBO;\n      write: FBO;\n      swap: () => void;\n    }\n\n    let dye: DoubleFBO;\n    let velocity: DoubleFBO;\n    let divergence: FBO;\n    let curl: FBO;\n    let pressure: DoubleFBO;\n\n    const copyProgram = new Program(baseVertexShader, copyShader);\n    const clearProgram = new Program(baseVertexShader, clearShader);\n    const splatProgram = new Program(baseVertexShader, splatShader);\n    const advectionProgram = new Program(baseVertexShader, advectionShader);\n    const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n    const curlProgram = new Program(baseVertexShader, curlShader);\n    const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n    const pressureProgram = new Program(baseVertexShader, pressureShader);\n    const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n    const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n\n    function createFBO(w: number, h: number, internalFormat: number, format: number, type: number, param: number): FBO {\n      gl.activeTexture(gl.TEXTURE0);\n      const texture = gl.createTexture()!;\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n      const fbo = gl.createFramebuffer()!;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n      gl.viewport(0, 0, w, h);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      const texelSizeX = 1 / w;\n      const texelSizeY = 1 / h;\n\n      return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        texelSizeX,\n        texelSizeY,\n        attach(id: number) {\n          gl.activeTexture(gl.TEXTURE0 + id);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          return id;\n        }\n      };\n    }\n\n    function createDoubleFBO(\n      w: number,\n      h: number,\n      internalFormat: number,\n      format: number,\n      type: number,\n      param: number\n    ): DoubleFBO {\n      const fbo1 = createFBO(w, h, internalFormat, format, type, param);\n      const fbo2 = createFBO(w, h, internalFormat, format, type, param);\n      return {\n        width: w,\n        height: h,\n        texelSizeX: fbo1.texelSizeX,\n        texelSizeY: fbo1.texelSizeY,\n        read: fbo1,\n        write: fbo2,\n        swap() {\n          const tmp = this.read;\n          this.read = this.write;\n          this.write = tmp;\n        }\n      };\n    }\n\n    function resizeFBO(\n      target: FBO,\n      w: number,\n      h: number,\n      internalFormat: number,\n      format: number,\n      type: number,\n      param: number\n    ) {\n      const newFBO = createFBO(w, h, internalFormat, format, type, param);\n      copyProgram.bind();\n      if (copyProgram.uniforms.uTexture) gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n      blit(newFBO, false);\n      return newFBO;\n    }\n\n    function resizeDoubleFBO(\n      target: DoubleFBO,\n      w: number,\n      h: number,\n      internalFormat: number,\n      format: number,\n      type: number,\n      param: number\n    ) {\n      if (target.width === w && target.height === h) return target;\n      target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n      target.write = createFBO(w, h, internalFormat, format, type, param);\n      target.width = w;\n      target.height = h;\n      target.texelSizeX = 1 / w;\n      target.texelSizeY = 1 / h;\n      return target;\n    }\n\n    function initFramebuffers() {\n      const simRes = getResolution(config.SIM_RESOLUTION!);\n      const dyeRes = getResolution(config.DYE_RESOLUTION!);\n\n      const texType = ext.halfFloatTexType;\n      const rgba = ext.formatRGBA;\n      const rg = ext.formatRG;\n      const r = ext.formatR;\n      const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n      gl.disable(gl.BLEND);\n\n      if (!dye) {\n        dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n      } else {\n        dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n      }\n\n      if (!velocity) {\n        velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n      } else {\n        velocity = resizeDoubleFBO(\n          velocity,\n          simRes.width,\n          simRes.height,\n          rg.internalFormat,\n          rg.format,\n          texType,\n          filtering\n        );\n      }\n\n      divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n      curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n      pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    }\n\n    function updateKeywords() {\n      const displayKeywords: string[] = [];\n      if (config.SHADING) displayKeywords.push('SHADING');\n      displayMaterial.setKeywords(displayKeywords);\n    }\n\n    function getResolution(resolution: number) {\n      const w = gl.drawingBufferWidth;\n      const h = gl.drawingBufferHeight;\n      const aspectRatio = w / h;\n      let aspect = aspectRatio < 1 ? 1 / aspectRatio : aspectRatio;\n      const min = Math.round(resolution);\n      const max = Math.round(resolution * aspect);\n      if (w > h) {\n        return { width: max, height: min };\n      }\n      return { width: min, height: max };\n    }\n\n    function scaleByPixelRatio(input: number) {\n      const pixelRatio = window.devicePixelRatio || 1;\n      return Math.floor(input * pixelRatio);\n    }\n\n    updateKeywords();\n    initFramebuffers();\n\n    let lastUpdateTime = Date.now();\n    let colorUpdateTimer = 0.0;\n\n    function updateFrame() {\n      const dt = calcDeltaTime();\n      if (resizeCanvas()) initFramebuffers();\n      updateColors(dt);\n      applyInputs();\n      step(dt);\n      render(null);\n      requestAnimationFrame(updateFrame);\n    }\n\n    function calcDeltaTime() {\n      const now = Date.now();\n      let dt = (now - lastUpdateTime) / 1000;\n      dt = Math.min(dt, 0.016666);\n      lastUpdateTime = now;\n      return dt;\n    }\n\n    function resizeCanvas() {\n      const width = scaleByPixelRatio(canvas!.clientWidth);\n      const height = scaleByPixelRatio(canvas!.clientHeight);\n      if (canvas!.width !== width || canvas!.height !== height) {\n        canvas!.width = width;\n        canvas!.height = height;\n        return true;\n      }\n      return false;\n    }\n\n    function updateColors(dt: number) {\n      colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n      if (colorUpdateTimer >= 1) {\n        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n        pointers.forEach(p => {\n          p.color = generateColor();\n        });\n      }\n    }\n\n    function applyInputs() {\n      for (const p of pointers) {\n        if (p.moved) {\n          p.moved = false;\n          splatPointer(p);\n        }\n      }\n    }\n\n    function step(dt: number) {\n      gl.disable(gl.BLEND);\n\n      curlProgram.bind();\n      if (curlProgram.uniforms.texelSize) {\n        gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      }\n      if (curlProgram.uniforms.uVelocity) {\n        gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n      }\n      blit(curl);\n\n      vorticityProgram.bind();\n      if (vorticityProgram.uniforms.texelSize) {\n        gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      }\n      if (vorticityProgram.uniforms.uVelocity) {\n        gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n      }\n      if (vorticityProgram.uniforms.uCurl) {\n        gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n      }\n      if (vorticityProgram.uniforms.curl) {\n        gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n      }\n      if (vorticityProgram.uniforms.dt) {\n        gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n      }\n      blit(velocity.write);\n      velocity.swap();\n\n      divergenceProgram.bind();\n      if (divergenceProgram.uniforms.texelSize) {\n        gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      }\n      if (divergenceProgram.uniforms.uVelocity) {\n        gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n      }\n      blit(divergence);\n\n      clearProgram.bind();\n      if (clearProgram.uniforms.uTexture) {\n        gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n      }\n      if (clearProgram.uniforms.value) {\n        gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n      }\n      blit(pressure.write);\n      pressure.swap();\n\n      pressureProgram.bind();\n      if (pressureProgram.uniforms.texelSize) {\n        gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      }\n      if (pressureProgram.uniforms.uDivergence) {\n        gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n      }\n      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n        if (pressureProgram.uniforms.uPressure) {\n          gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n        }\n        blit(pressure.write);\n        pressure.swap();\n      }\n\n      gradienSubtractProgram.bind();\n      if (gradienSubtractProgram.uniforms.texelSize) {\n        gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      }\n      if (gradienSubtractProgram.uniforms.uPressure) {\n        gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n      }\n      if (gradienSubtractProgram.uniforms.uVelocity) {\n        gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n      }\n      blit(velocity.write);\n      velocity.swap();\n\n      advectionProgram.bind();\n      if (advectionProgram.uniforms.texelSize) {\n        gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      }\n      if (!ext.supportLinearFiltering && advectionProgram.uniforms.dyeTexelSize) {\n        gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n      }\n      const velocityId = velocity.read.attach(0);\n      if (advectionProgram.uniforms.uVelocity) {\n        gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n      }\n      if (advectionProgram.uniforms.uSource) {\n        gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n      }\n      if (advectionProgram.uniforms.dt) {\n        gl.uniform1f(advectionProgram.uniforms.dt, dt);\n      }\n      if (advectionProgram.uniforms.dissipation) {\n        gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n      }\n      blit(velocity.write);\n      velocity.swap();\n\n      if (!ext.supportLinearFiltering && advectionProgram.uniforms.dyeTexelSize) {\n        gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n      }\n      if (advectionProgram.uniforms.uVelocity) {\n        gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n      }\n      if (advectionProgram.uniforms.uSource) {\n        gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n      }\n      if (advectionProgram.uniforms.dissipation) {\n        gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n      }\n      blit(dye.write);\n      dye.swap();\n    }\n\n    function render(target: FBO | null) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n      drawDisplay(target);\n    }\n\n    function drawDisplay(target: FBO | null) {\n      const width = target ? target.width : gl.drawingBufferWidth;\n      const height = target ? target.height : gl.drawingBufferHeight;\n      displayMaterial.bind();\n      if (config.SHADING && displayMaterial.uniforms.texelSize) {\n        gl.uniform2f(displayMaterial.uniforms.texelSize, 1 / width, 1 / height);\n      }\n      if (displayMaterial.uniforms.uTexture) {\n        gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n      }\n      blit(target, false);\n    }\n\n    function splatPointer(pointer: Pointer) {\n      const dx = pointer.deltaX * config.SPLAT_FORCE;\n      const dy = pointer.deltaY * config.SPLAT_FORCE;\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n    }\n\n    function clickSplat(pointer: Pointer) {\n      const color = generateColor();\n      color.r *= 10;\n      color.g *= 10;\n      color.b *= 10;\n      const dx = 10 * (Math.random() - 0.5);\n      const dy = 30 * (Math.random() - 0.5);\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n    }\n\n    function splat(x: number, y: number, dx: number, dy: number, color: ColorRGB) {\n      splatProgram.bind();\n      if (splatProgram.uniforms.uTarget) {\n        gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n      }\n      if (splatProgram.uniforms.aspectRatio) {\n        gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas!.width / canvas!.height);\n      }\n      if (splatProgram.uniforms.point) {\n        gl.uniform2f(splatProgram.uniforms.point, x, y);\n      }\n      if (splatProgram.uniforms.color) {\n        gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0);\n      }\n      if (splatProgram.uniforms.radius) {\n        gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100)!);\n      }\n      blit(velocity.write);\n      velocity.swap();\n\n      if (splatProgram.uniforms.uTarget) {\n        gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n      }\n      if (splatProgram.uniforms.color) {\n        gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n      }\n      blit(dye.write);\n      dye.swap();\n    }\n\n    function correctRadius(radius: number) {\n      const aspectRatio = canvas!.width / canvas!.height;\n      if (aspectRatio > 1) radius *= aspectRatio;\n      return radius;\n    }\n\n    function updatePointerDownData(pointer: Pointer, id: number, posX: number, posY: number) {\n      pointer.id = id;\n      pointer.down = true;\n      pointer.moved = false;\n      pointer.texcoordX = posX / canvas!.width;\n      pointer.texcoordY = 1 - posY / canvas!.height;\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.deltaX = 0;\n      pointer.deltaY = 0;\n      pointer.color = generateColor();\n    }\n\n    function updatePointerMoveData(pointer: Pointer, posX: number, posY: number, color: ColorRGB) {\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.texcoordX = posX / canvas!.width;\n      pointer.texcoordY = 1 - posY / canvas!.height;\n      pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX)!;\n      pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY)!;\n      pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n      pointer.color = color;\n    }\n\n    function updatePointerUpData(pointer: Pointer) {\n      pointer.down = false;\n    }\n\n    function correctDeltaX(delta: number) {\n      const aspectRatio = canvas!.width / canvas!.height;\n      if (aspectRatio < 1) delta *= aspectRatio;\n      return delta;\n    }\n\n    function correctDeltaY(delta: number) {\n      const aspectRatio = canvas!.width / canvas!.height;\n      if (aspectRatio > 1) delta /= aspectRatio;\n      return delta;\n    }\n\n    function generateColor(): ColorRGB {\n      const c = HSVtoRGB(Math.random(), 1.0, 1.0);\n      c.r *= 0.15;\n      c.g *= 0.15;\n      c.b *= 0.15;\n      return c;\n    }\n\n    function HSVtoRGB(h: number, s: number, v: number): ColorRGB {\n      let r = 0,\n        g = 0,\n        b = 0;\n      const i = Math.floor(h * 6);\n      const f = h * 6 - i;\n      const p = v * (1 - s);\n      const q = v * (1 - f * s);\n      const t = v * (1 - (1 - f) * s);\n\n      switch (i % 6) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = p;\n          b = q;\n          break;\n      }\n      return { r, g, b };\n    }\n\n    function wrap(value: number, min: number, max: number) {\n      const range = max - min;\n      if (range === 0) return min;\n      return ((value - min) % range) + min;\n    }\n\n    window.addEventListener('mousedown', e => {\n      const pointer = pointers[0];\n      const posX = scaleByPixelRatio(e.clientX);\n      const posY = scaleByPixelRatio(e.clientY);\n      updatePointerDownData(pointer, -1, posX, posY);\n      clickSplat(pointer);\n    });\n\n    function handleFirstMouseMove(e: MouseEvent) {\n      const pointer = pointers[0];\n      const posX = scaleByPixelRatio(e.clientX);\n      const posY = scaleByPixelRatio(e.clientY);\n      const color = generateColor();\n      updateFrame();\n      updatePointerMoveData(pointer, posX, posY, color);\n      document.body.removeEventListener('mousemove', handleFirstMouseMove);\n    }\n    document.body.addEventListener('mousemove', handleFirstMouseMove);\n\n    window.addEventListener('mousemove', e => {\n      const pointer = pointers[0];\n      const posX = scaleByPixelRatio(e.clientX);\n      const posY = scaleByPixelRatio(e.clientY);\n      const color = pointer.color;\n      updatePointerMoveData(pointer, posX, posY, color);\n    });\n\n    function handleFirstTouchStart(e: TouchEvent) {\n      const touches = e.targetTouches;\n      const pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        const posX = scaleByPixelRatio(touches[i].clientX);\n        const posY = scaleByPixelRatio(touches[i].clientY);\n        updateFrame();\n        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n      }\n      document.body.removeEventListener('touchstart', handleFirstTouchStart);\n    }\n    document.body.addEventListener('touchstart', handleFirstTouchStart);\n\n    window.addEventListener(\n      'touchstart',\n      e => {\n        const touches = e.targetTouches;\n        const pointer = pointers[0];\n        for (let i = 0; i < touches.length; i++) {\n          const posX = scaleByPixelRatio(touches[i].clientX);\n          const posY = scaleByPixelRatio(touches[i].clientY);\n          updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n        }\n      },\n      false\n    );\n\n    window.addEventListener(\n      'touchmove',\n      e => {\n        const touches = e.targetTouches;\n        const pointer = pointers[0];\n        for (let i = 0; i < touches.length; i++) {\n          const posX = scaleByPixelRatio(touches[i].clientX);\n          const posY = scaleByPixelRatio(touches[i].clientY);\n          updatePointerMoveData(pointer, posX, posY, pointer.color);\n        }\n      },\n      false\n    );\n\n    window.addEventListener('touchend', e => {\n      const touches = e.changedTouches;\n      const pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        updatePointerUpData(pointer);\n      }\n    });\n  }, [\n    SIM_RESOLUTION,\n    DYE_RESOLUTION,\n    CAPTURE_RESOLUTION,\n    DENSITY_DISSIPATION,\n    VELOCITY_DISSIPATION,\n    PRESSURE,\n    PRESSURE_ITERATIONS,\n    CURL,\n    SPLAT_RADIUS,\n    SPLAT_FORCE,\n    SHADING,\n    COLOR_UPDATE_SPEED,\n    BACK_COLOR,\n    TRANSPARENT\n  ]);\n\n  return (\n    <div className=\"fixed top-0 left-0 z-50 pointer-events-none w-full h-full\">\n      <canvas ref={canvasRef} id=\"fluid\" className=\"w-screen h-screen block\"></canvas>\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "star-border",
      "type": "component",
      "description": "Animated star border effect.",
      "category": "animations",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/star-border.tsx",
          "content": "import React from 'react';\n\ntype StarBorderProps<T extends React.ElementType> = React.ComponentPropsWithoutRef<T> & {\n  as?: T;\n  className?: string;\n  children?: React.ReactNode;\n  color?: string;\n  speed?: React.CSSProperties['animationDuration'];\n  thickness?: number;\n};\n\nconst StarBorder = <T extends React.ElementType = 'button'>({\n  as,\n  className = '',\n  color = 'white',\n  speed = '6s',\n  thickness = 1,\n  children,\n  ...rest\n}: StarBorderProps<T>) => {\n  const Component = as || 'button';\n\n  return (\n    <Component\n      className={`relative inline-block overflow-hidden rounded-[20px] ${className}`}\n      {...(rest as any)}\n      style={{\n        padding: `${thickness}px 0`,\n        ...(rest as any).style\n      }}\n    >\n      <div\n        className=\"absolute w-[300%] h-[50%] opacity-70 bottom-[-11px] right-[-250%] rounded-full animate-star-movement-bottom z-0\"\n        style={{\n          background: `radial-gradient(circle, ${color}, transparent 10%)`,\n          animationDuration: speed\n        }}\n      ></div>\n      <div\n        className=\"absolute w-[300%] h-[50%] opacity-70 top-[-10px] left-[-250%] rounded-full animate-star-movement-top z-0\"\n        style={{\n          background: `radial-gradient(circle, ${color}, transparent 10%)`,\n          animationDuration: speed\n        }}\n      ></div>\n      <div className=\"relative z-1 bg-gradient-to-b from-black to-gray-900 border border-gray-800 text-white text-center text-[16px] py-[16px] px-[26px] rounded-[20px]\">\n        {children}\n      </div>\n    </Component>\n  );\n};\n\nexport default StarBorder;\n\n// tailwind.config.js\n// module.exports = {\n//   theme: {\n//     extend: {\n//       animation: {\n//         'star-movement-bottom': 'star-movement-bottom linear infinite alternate',\n//         'star-movement-top': 'star-movement-top linear infinite alternate',\n//       },\n//       keyframes: {\n//         'star-movement-bottom': {\n//           '0%': { transform: 'translate(0%, 0%)', opacity: '1' },\n//           '100%': { transform: 'translate(-100%, 0%)', opacity: '0' },\n//         },\n//         'star-movement-top': {\n//           '0%': { transform: 'translate(0%, 0%)', opacity: '1' },\n//           '100%': { transform: 'translate(100%, 0%)', opacity: '0' },\n//         },\n//       },\n//     },\n//   }\n// }\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "sticker-peel",
      "type": "component",
      "description": "Sticker peel animation.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/sticker-peel.tsx",
          "content": "import { useRef, useEffect, useMemo, CSSProperties } from 'react';\nimport { gsap } from 'gsap';\nimport { Draggable } from 'gsap/Draggable';\n\ngsap.registerPlugin(Draggable);\n\ninterface StickerPeelProps {\n  imageSrc: string;\n  rotate?: number;\n  peelBackHoverPct?: number;\n  peelBackActivePct?: number;\n  peelEasing?: string;\n  peelHoverEasing?: string;\n  width?: number;\n  shadowIntensity?: number;\n  lightingIntensity?: number;\n  initialPosition?: 'center' | 'random' | { x: number; y: number };\n  peelDirection?: number;\n  className?: string;\n}\n\ninterface CSSVars extends CSSProperties {\n  '--sticker-rotate'?: string;\n  '--sticker-p'?: string;\n  '--sticker-peelback-hover'?: string;\n  '--sticker-peelback-active'?: string;\n  '--sticker-peel-easing'?: string;\n  '--sticker-peel-hover-easing'?: string;\n  '--sticker-width'?: string;\n  '--sticker-shadow-opacity'?: number;\n  '--sticker-lighting-constant'?: number;\n  '--peel-direction'?: string;\n  '--sticker-start'?: string;\n  '--sticker-end'?: string;\n}\n\nconst StickerPeel: React.FC<StickerPeelProps> = ({\n  imageSrc,\n  rotate = 30,\n  peelBackHoverPct = 30,\n  peelBackActivePct = 40,\n  peelEasing = 'power3.out',\n  peelHoverEasing = 'power2.out',\n  width = 200,\n  shadowIntensity = 0.6,\n  lightingIntensity = 0.1,\n  initialPosition = 'center',\n  peelDirection = 0,\n  className = ''\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const dragTargetRef = useRef<HTMLDivElement>(null);\n  const pointLightRef = useRef<SVGFEPointLightElement>(null);\n  const pointLightFlippedRef = useRef<SVGFEPointLightElement>(null);\n  const draggableInstanceRef = useRef<Draggable | null>(null);\n\n  const defaultPadding = 12;\n\n  useEffect(() => {\n    const target = dragTargetRef.current;\n    if (!target) return;\n\n    let startX = 0,\n      startY = 0;\n\n    if (initialPosition === 'center') {\n      return;\n    }\n\n    if (typeof initialPosition === 'object' && initialPosition.x !== undefined && initialPosition.y !== undefined) {\n      startX = initialPosition.x;\n      startY = initialPosition.y;\n    }\n\n    gsap.set(target, { x: startX, y: startY });\n  }, [initialPosition]);\n\n  useEffect(() => {\n    const target = dragTargetRef.current;\n    if (!target) return;\n\n    const boundsEl = target.parentNode as HTMLElement;\n\n    const draggable = Draggable.create(target, {\n      type: 'x,y',\n      bounds: boundsEl,\n      inertia: true,\n      onDrag(this: Draggable) {\n        const rot = gsap.utils.clamp(-24, 24, this.deltaX * 0.4);\n        gsap.to(target, { rotation: rot, duration: 0.15, ease: 'power1.out' });\n      },\n      onDragEnd() {\n        const rotationEase = 'power2.out';\n        const duration = 0.8;\n        gsap.to(target, { rotation: 0, duration, ease: rotationEase });\n      }\n    });\n\n    draggableInstanceRef.current = draggable[0];\n\n    const handleResize = () => {\n      if (draggableInstanceRef.current) {\n        draggableInstanceRef.current.update();\n\n        const currentX = gsap.getProperty(target, 'x') as number;\n        const currentY = gsap.getProperty(target, 'y') as number;\n\n        const boundsRect = boundsEl.getBoundingClientRect();\n        const targetRect = target.getBoundingClientRect();\n\n        const maxX = boundsRect.width - targetRect.width;\n        const maxY = boundsRect.height - targetRect.height;\n\n        const newX = Math.max(0, Math.min(currentX, maxX));\n        const newY = Math.max(0, Math.min(currentY, maxY));\n\n        if (newX !== currentX || newY !== currentY) {\n          gsap.to(target, {\n            x: newX,\n            y: newY,\n            duration: 0.3,\n            ease: 'power2.out'\n          });\n        }\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('orientationchange', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('orientationchange', handleResize);\n      if (draggableInstanceRef.current) {\n        draggableInstanceRef.current.kill();\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    const updateLight = (e: Event) => {\n      const mouseEvent = e as MouseEvent;\n      const rect = containerRef.current?.getBoundingClientRect();\n      if (!rect) return;\n\n      const x = mouseEvent.clientX - rect.left;\n      const y = mouseEvent.clientY - rect.top;\n\n      if (pointLightRef.current) {\n        gsap.set(pointLightRef.current, { attr: { x, y } });\n      }\n\n      const normalizedAngle = Math.abs(peelDirection % 360);\n      if (pointLightFlippedRef.current) {\n        if (normalizedAngle !== 180) {\n          gsap.set(pointLightFlippedRef.current, {\n            attr: { x, y: rect.height - y }\n          });\n        } else {\n          gsap.set(pointLightFlippedRef.current, {\n            attr: { x: -1000, y: -1000 }\n          });\n        }\n      }\n    };\n\n    const container = containerRef.current;\n    const eventType = 'mousemove';\n\n    if (container) {\n      container.addEventListener(eventType, updateLight);\n      return () => container.removeEventListener(eventType, updateLight);\n    }\n  }, [peelDirection]);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleTouchStart = () => {\n      container.classList.add('touch-active');\n    };\n\n    const handleTouchEnd = () => {\n      container.classList.remove('touch-active');\n    };\n\n    container.addEventListener('touchstart', handleTouchStart);\n    container.addEventListener('touchend', handleTouchEnd);\n    container.addEventListener('touchcancel', handleTouchEnd);\n\n    return () => {\n      container.removeEventListener('touchstart', handleTouchStart);\n      container.removeEventListener('touchend', handleTouchEnd);\n      container.removeEventListener('touchcancel', handleTouchEnd);\n    };\n  }, []);\n\n  const cssVars: CSSVars = useMemo(\n    () => ({\n      '--sticker-rotate': `${rotate}deg`,\n      '--sticker-p': `${defaultPadding}px`,\n      '--sticker-peelback-hover': `${peelBackHoverPct}%`,\n      '--sticker-peelback-active': `${peelBackActivePct}%`,\n      '--sticker-peel-easing': peelEasing,\n      '--sticker-peel-hover-easing': peelHoverEasing,\n      '--sticker-width': `${width}px`,\n      '--sticker-shadow-opacity': shadowIntensity,\n      '--sticker-lighting-constant': lightingIntensity,\n      '--peel-direction': `${peelDirection}deg`,\n      '--sticker-start': `calc(-1 * ${defaultPadding}px)`,\n      '--sticker-end': `calc(100% + ${defaultPadding}px)`\n    }),\n    [\n      rotate,\n      peelBackHoverPct,\n      peelBackActivePct,\n      peelEasing,\n      peelHoverEasing,\n      width,\n      shadowIntensity,\n      lightingIntensity,\n      peelDirection,\n      defaultPadding\n    ]\n  );\n\n  const stickerMainStyle: CSSProperties = {\n    clipPath: `polygon(var(--sticker-start) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-end) var(--sticker-end), var(--sticker-start) var(--sticker-end))`,\n    transition: 'clip-path 0.6s ease-out',\n    filter: 'url(#dropShadow)',\n    willChange: 'clip-path, transform'\n  };\n\n  const flapStyle: CSSProperties = {\n    clipPath: `polygon(var(--sticker-start) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-start) var(--sticker-start))`,\n    top: `calc(-100% - var(--sticker-p) - var(--sticker-p))`,\n    transform: 'scaleY(-1)',\n    transition: 'all 0.6s ease-out',\n    willChange: 'clip-path, transform'\n  };\n\n  const imageStyle: CSSProperties = {\n    transform: `rotate(calc(${rotate}deg - ${peelDirection}deg))`,\n    width: `${width}px`\n  };\n\n  const shadowImageStyle: CSSProperties = {\n    ...imageStyle,\n    filter: 'url(#expandAndFill)'\n  };\n\n  return (\n    <div\n      className={`absolute cursor-grab active:cursor-grabbing transform-gpu ${className}`}\n      ref={dragTargetRef}\n      style={cssVars}\n    >\n      <style\n        dangerouslySetInnerHTML={{\n          __html: `\n          .sticker-container:hover .sticker-main,\n          .sticker-container.touch-active .sticker-main {\n            clip-path: polygon(var(--sticker-start) var(--sticker-peelback-hover), var(--sticker-end) var(--sticker-peelback-hover), var(--sticker-end) var(--sticker-end), var(--sticker-start) var(--sticker-end)) !important;\n          }\n          .sticker-container:hover .sticker-flap,\n          .sticker-container.touch-active .sticker-flap {\n            clip-path: polygon(var(--sticker-start) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-end) var(--sticker-peelback-hover), var(--sticker-start) var(--sticker-peelback-hover)) !important;\n            top: calc(-100% + 2 * var(--sticker-peelback-hover) - 1px) !important;\n          }\n          .sticker-container:active .sticker-main {\n            clip-path: polygon(var(--sticker-start) var(--sticker-peelback-active), var(--sticker-end) var(--sticker-peelback-active), var(--sticker-end) var(--sticker-end), var(--sticker-start) var(--sticker-end)) !important;\n          }\n          .sticker-container:active .sticker-flap {\n            clip-path: polygon(var(--sticker-start) var(--sticker-start), var(--sticker-end) var(--sticker-start), var(--sticker-end) var(--sticker-peelback-active), var(--sticker-start) var(--sticker-peelback-active)) !important;\n            top: calc(-100% + 2 * var(--sticker-peelback-active) - 1px) !important;\n          }\n        `\n        }}\n      />\n\n      <svg width=\"0\" height=\"0\">\n        <defs>\n          <filter id=\"pointLight\">\n            <feGaussianBlur stdDeviation=\"1\" result=\"blur\" />\n            <feSpecularLighting\n              result=\"spec\"\n              in=\"blur\"\n              specularExponent=\"100\"\n              specularConstant={lightingIntensity}\n              lightingColor=\"white\"\n            >\n              <fePointLight ref={pointLightRef} x=\"100\" y=\"100\" z=\"300\" />\n            </feSpecularLighting>\n            <feComposite in=\"spec\" in2=\"SourceGraphic\" result=\"lit\" />\n            <feComposite in=\"lit\" in2=\"SourceAlpha\" operator=\"in\" />\n          </filter>\n\n          <filter id=\"pointLightFlipped\">\n            <feGaussianBlur stdDeviation=\"10\" result=\"blur\" />\n            <feSpecularLighting\n              result=\"spec\"\n              in=\"blur\"\n              specularExponent=\"100\"\n              specularConstant={lightingIntensity * 7}\n              lightingColor=\"white\"\n            >\n              <fePointLight ref={pointLightFlippedRef} x=\"100\" y=\"100\" z=\"300\" />\n            </feSpecularLighting>\n            <feComposite in=\"spec\" in2=\"SourceGraphic\" result=\"lit\" />\n            <feComposite in=\"lit\" in2=\"SourceAlpha\" operator=\"in\" />\n          </filter>\n\n          <filter id=\"dropShadow\">\n            <feDropShadow\n              dx=\"2\"\n              dy=\"4\"\n              stdDeviation={3 * shadowIntensity}\n              floodColor=\"black\"\n              floodOpacity={shadowIntensity}\n            />\n          </filter>\n\n          <filter id=\"expandAndFill\">\n            <feOffset dx=\"0\" dy=\"0\" in=\"SourceAlpha\" result=\"shape\" />\n            <feFlood floodColor=\"rgb(179,179,179)\" result=\"flood\" />\n            <feComposite operator=\"in\" in=\"flood\" in2=\"shape\" />\n          </filter>\n        </defs>\n      </svg>\n\n      <div\n        className=\"sticker-container relative select-none touch-none sm:touch-auto\"\n        ref={containerRef}\n        style={{\n          WebkitUserSelect: 'none',\n          userSelect: 'none',\n          WebkitTouchCallout: 'none',\n          WebkitTapHighlightColor: 'transparent',\n          transform: `rotate(${peelDirection}deg)`,\n          transformOrigin: 'center'\n        }}\n      >\n        <div className=\"sticker-main\" style={stickerMainStyle}>\n          <div style={{ filter: 'url(#pointLight)' }}>\n            <img\n              src={imageSrc}\n              alt=\"\"\n              className=\"block\"\n              style={imageStyle}\n              draggable=\"false\"\n              onContextMenu={e => e.preventDefault()}\n            />\n          </div>\n        </div>\n\n        <div className=\"absolute top-4 left-2 w-full h-full opacity-40\" style={{ filter: 'brightness(0) blur(8px)' }}>\n          <div className=\"sticker-flap\" style={flapStyle}>\n            <img\n              src={imageSrc}\n              alt=\"\"\n              className=\"block\"\n              style={shadowImageStyle}\n              draggable=\"false\"\n              onContextMenu={e => e.preventDefault()}\n            />\n          </div>\n        </div>\n\n        <div className=\"sticker-flap absolute w-full h-full left-0\" style={flapStyle}>\n          <div style={{ filter: 'url(#pointLightFlipped)' }}>\n            <img\n              src={imageSrc}\n              alt=\"\"\n              className=\"block\"\n              style={shadowImageStyle}\n              draggable=\"false\"\n              onContextMenu={e => e.preventDefault()}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default StickerPeel;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "target-cursor",
      "type": "component",
      "description": "A target-style cursor effect.",
      "category": "animations",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/target-cursor.tsx",
          "content": "import React, { useEffect, useRef, useCallback, useMemo } from 'react';\nimport { gsap } from 'gsap';\n\nexport interface TargetCursorProps {\n  targetSelector?: string;\n  spinDuration?: number;\n  hideDefaultCursor?: boolean;\n  hoverDuration?: number;\n  parallaxOn?: boolean;\n}\n\nconst TargetCursor: React.FC<TargetCursorProps> = ({\n  targetSelector = '.cursor-target',\n  spinDuration = 2,\n  hideDefaultCursor = true,\n  hoverDuration = 0.2,\n  parallaxOn = true\n}) => {\n  const cursorRef = useRef<HTMLDivElement>(null);\n  const cornersRef = useRef<NodeListOf<HTMLDivElement> | null>(null);\n  const spinTl = useRef<gsap.core.Timeline | null>(null);\n  const dotRef = useRef<HTMLDivElement>(null);\n\n  const isActiveRef = useRef(false);\n  const targetCornerPositionsRef = useRef<{ x: number; y: number }[] | null>(null);\n  const tickerFnRef = useRef<(() => void) | null>(null);\n  const activeStrengthRef = useRef({ current: 0 });\n\n  const isMobile = useMemo(() => {\n    const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n    const isSmallScreen = window.innerWidth <= 768;\n    const userAgent = navigator.userAgent || navigator.vendor || (window as any).opera;\n    const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;\n    const isMobileUserAgent = mobileRegex.test(userAgent.toLowerCase());\n    return (hasTouchScreen && isSmallScreen) || isMobileUserAgent;\n  }, []);\n\n  const constants = useMemo(() => ({ borderWidth: 3, cornerSize: 12 }), []);\n\n  const moveCursor = useCallback((x: number, y: number) => {\n    if (!cursorRef.current) return;\n    gsap.to(cursorRef.current, { x, y, duration: 0.1, ease: 'power3.out' });\n  }, []);\n\n  useEffect(() => {\n    if (isMobile || !cursorRef.current) return;\n\n    const originalCursor = document.body.style.cursor;\n    if (hideDefaultCursor) {\n      document.body.style.cursor = 'none';\n    }\n\n    const cursor = cursorRef.current;\n    cornersRef.current = cursor.querySelectorAll<HTMLDivElement>('.target-cursor-corner');\n\n    let activeTarget: Element | null = null;\n    let currentLeaveHandler: (() => void) | null = null;\n    let resumeTimeout: ReturnType<typeof setTimeout> | null = null;\n\n    const cleanupTarget = (target: Element) => {\n      if (currentLeaveHandler) {\n        target.removeEventListener('mouseleave', currentLeaveHandler);\n      }\n      currentLeaveHandler = null;\n    };\n\n    gsap.set(cursor, {\n      xPercent: -50,\n      yPercent: -50,\n      x: window.innerWidth / 2,\n      y: window.innerHeight / 2\n    });\n\n    const createSpinTimeline = () => {\n      if (spinTl.current) {\n        spinTl.current.kill();\n      }\n      spinTl.current = gsap\n        .timeline({ repeat: -1 })\n        .to(cursor, { rotation: '+=360', duration: spinDuration, ease: 'none' });\n    };\n\n    createSpinTimeline();\n\n    const tickerFn = () => {\n      if (!targetCornerPositionsRef.current || !cursorRef.current || !cornersRef.current) {\n        return;\n      }\n      const strength = activeStrengthRef.current.current;\n      if (strength === 0) return;\n      const cursorX = gsap.getProperty(cursorRef.current, 'x') as number;\n      const cursorY = gsap.getProperty(cursorRef.current, 'y') as number;\n      const corners = Array.from(cornersRef.current);\n      corners.forEach((corner, i) => {\n        const currentX = gsap.getProperty(corner, 'x') as number;\n        const currentY = gsap.getProperty(corner, 'y') as number;\n        const targetX = targetCornerPositionsRef.current![i].x - cursorX;\n        const targetY = targetCornerPositionsRef.current![i].y - cursorY;\n        const finalX = currentX + (targetX - currentX) * strength;\n        const finalY = currentY + (targetY - currentY) * strength;\n        const duration = strength >= 0.99 ? (parallaxOn ? 0.2 : 0) : 0.05;\n        gsap.to(corner, {\n          x: finalX,\n          y: finalY,\n          duration: duration,\n          ease: duration === 0 ? 'none' : 'power1.out',\n          overwrite: 'auto'\n        });\n      });\n    };\n\n    tickerFnRef.current = tickerFn;\n\n    const moveHandler = (e: MouseEvent) => moveCursor(e.clientX, e.clientY);\n    window.addEventListener('mousemove', moveHandler);\n\n    const scrollHandler = () => {\n      if (!activeTarget || !cursorRef.current) return;\n      const mouseX = gsap.getProperty(cursorRef.current, 'x') as number;\n      const mouseY = gsap.getProperty(cursorRef.current, 'y') as number;\n      const elementUnderMouse = document.elementFromPoint(mouseX, mouseY);\n      const isStillOverTarget =\n        elementUnderMouse &&\n        (elementUnderMouse === activeTarget || elementUnderMouse.closest(targetSelector) === activeTarget);\n      if (!isStillOverTarget) {\n        currentLeaveHandler?.();\n      }\n    };\n    window.addEventListener('scroll', scrollHandler, { passive: true });\n\n    const mouseDownHandler = () => {\n      if (!dotRef.current) return;\n      gsap.to(dotRef.current, { scale: 0.7, duration: 0.3 });\n      gsap.to(cursorRef.current, { scale: 0.9, duration: 0.2 });\n    };\n\n    const mouseUpHandler = () => {\n      if (!dotRef.current) return;\n      gsap.to(dotRef.current, { scale: 1, duration: 0.3 });\n      gsap.to(cursorRef.current, { scale: 1, duration: 0.2 });\n    };\n\n    window.addEventListener('mousedown', mouseDownHandler);\n    window.addEventListener('mouseup', mouseUpHandler);\n\n    const enterHandler = (e: MouseEvent) => {\n      const directTarget = e.target as Element;\n      const allTargets: Element[] = [];\n      let current: Element | null = directTarget;\n      while (current && current !== document.body) {\n        if (current.matches(targetSelector)) {\n          allTargets.push(current);\n        }\n        current = current.parentElement;\n      }\n      const target = allTargets[0] || null;\n      if (!target || !cursorRef.current || !cornersRef.current) return;\n      if (activeTarget === target) return;\n      if (activeTarget) {\n        cleanupTarget(activeTarget);\n      }\n      if (resumeTimeout) {\n        clearTimeout(resumeTimeout);\n        resumeTimeout = null;\n      }\n\n      activeTarget = target;\n      const corners = Array.from(cornersRef.current);\n      corners.forEach(corner => gsap.killTweensOf(corner));\n      gsap.killTweensOf(cursorRef.current, 'rotation');\n      spinTl.current?.pause();\n      gsap.set(cursorRef.current, { rotation: 0 });\n\n      const rect = target.getBoundingClientRect();\n      const { borderWidth, cornerSize } = constants;\n      const cursorX = gsap.getProperty(cursorRef.current, 'x') as number;\n      const cursorY = gsap.getProperty(cursorRef.current, 'y') as number;\n\n      targetCornerPositionsRef.current = [\n        { x: rect.left - borderWidth, y: rect.top - borderWidth },\n        { x: rect.right + borderWidth - cornerSize, y: rect.top - borderWidth },\n        { x: rect.right + borderWidth - cornerSize, y: rect.bottom + borderWidth - cornerSize },\n        { x: rect.left - borderWidth, y: rect.bottom + borderWidth - cornerSize }\n      ];\n\n      isActiveRef.current = true;\n      gsap.ticker.add(tickerFnRef.current!);\n\n      gsap.to(activeStrengthRef.current, { current: 1, duration: hoverDuration, ease: 'power2.out' });\n\n      corners.forEach((corner, i) => {\n        gsap.to(corner, {\n          x: targetCornerPositionsRef.current![i].x - cursorX,\n          y: targetCornerPositionsRef.current![i].y - cursorY,\n          duration: 0.2,\n          ease: 'power2.out'\n        });\n      });\n\n      const leaveHandler = () => {\n        gsap.ticker.remove(tickerFnRef.current!);\n        isActiveRef.current = false;\n        targetCornerPositionsRef.current = null;\n        gsap.set(activeStrengthRef.current, { current: 0, overwrite: true });\n        activeTarget = null;\n        if (cornersRef.current) {\n          const corners = Array.from(cornersRef.current);\n          gsap.killTweensOf(corners);\n          const { cornerSize } = constants;\n          const positions = [\n            { x: -cornerSize * 1.5, y: -cornerSize * 1.5 },\n            { x: cornerSize * 0.5, y: -cornerSize * 1.5 },\n            { x: cornerSize * 0.5, y: cornerSize * 0.5 },\n            { x: -cornerSize * 1.5, y: cornerSize * 0.5 }\n          ];\n          const tl = gsap.timeline();\n          corners.forEach((corner, index) => {\n            tl.to(corner, { x: positions[index].x, y: positions[index].y, duration: 0.3, ease: 'power3.out' }, 0);\n          });\n        }\n        resumeTimeout = setTimeout(() => {\n          if (!activeTarget && cursorRef.current && spinTl.current) {\n            const currentRotation = gsap.getProperty(cursorRef.current, 'rotation') as number;\n            const normalizedRotation = currentRotation % 360;\n            spinTl.current.kill();\n            spinTl.current = gsap\n              .timeline({ repeat: -1 })\n              .to(cursorRef.current, { rotation: '+=360', duration: spinDuration, ease: 'none' });\n            gsap.to(cursorRef.current, {\n              rotation: normalizedRotation + 360,\n              duration: spinDuration * (1 - normalizedRotation / 360),\n              ease: 'none',\n              onComplete: () => {\n                spinTl.current?.restart();\n              }\n            });\n          }\n          resumeTimeout = null;\n        }, 50);\n        cleanupTarget(target);\n      };\n      currentLeaveHandler = leaveHandler;\n      target.addEventListener('mouseleave', leaveHandler);\n    };\n\n    window.addEventListener('mouseover', enterHandler as EventListener);\n\n    return () => {\n      if (tickerFnRef.current) {\n        gsap.ticker.remove(tickerFnRef.current);\n      }\n      window.removeEventListener('mousemove', moveHandler);\n      window.removeEventListener('mouseover', enterHandler as EventListener);\n      window.removeEventListener('scroll', scrollHandler);\n      window.removeEventListener('mousedown', mouseDownHandler);\n      window.removeEventListener('mouseup', mouseUpHandler);\n      if (activeTarget) {\n        cleanupTarget(activeTarget);\n      }\n      spinTl.current?.kill();\n      document.body.style.cursor = originalCursor;\n      isActiveRef.current = false;\n      targetCornerPositionsRef.current = null;\n      activeStrengthRef.current.current = 0;\n    };\n  }, [targetSelector, spinDuration, moveCursor, constants, hideDefaultCursor, isMobile, hoverDuration, parallaxOn]);\n\n  useEffect(() => {\n    if (isMobile || !cursorRef.current || !spinTl.current) return;\n    if (spinTl.current.isActive()) {\n      spinTl.current.kill();\n      spinTl.current = gsap\n        .timeline({ repeat: -1 })\n        .to(cursorRef.current, { rotation: '+=360', duration: spinDuration, ease: 'none' });\n    }\n  }, [spinDuration, isMobile]);\n\n  if (isMobile) {\n    return null;\n  }\n\n  return (\n    <div\n      ref={cursorRef}\n      className=\"fixed top-0 left-0 w-0 h-0 pointer-events-none z-[9999]\"\n      style={{ willChange: 'transform' }}\n    >\n      <div\n        ref={dotRef}\n        className=\"absolute top-1/2 left-1/2 w-1 h-1 bg-white rounded-full -translate-x-1/2 -translate-y-1/2\"\n        style={{ willChange: 'transform' }}\n      />\n      <div\n        className=\"target-cursor-corner absolute top-1/2 left-1/2 w-3 h-3 border-[3px] border-white -translate-x-[150%] -translate-y-[150%] border-r-0 border-b-0\"\n        style={{ willChange: 'transform' }}\n      />\n      <div\n        className=\"target-cursor-corner absolute top-1/2 left-1/2 w-3 h-3 border-[3px] border-white translate-x-1/2 -translate-y-[150%] border-l-0 border-b-0\"\n        style={{ willChange: 'transform' }}\n      />\n      <div\n        className=\"target-cursor-corner absolute top-1/2 left-1/2 w-3 h-3 border-[3px] border-white translate-x-1/2 translate-y-1/2 border-l-0 border-t-0\"\n        style={{ willChange: 'transform' }}\n      />\n      <div\n        className=\"target-cursor-corner absolute top-1/2 left-1/2 w-3 h-3 border-[3px] border-white -translate-x-[150%] translate-y-1/2 border-r-0 border-t-0\"\n        style={{ willChange: 'transform' }}\n      />\n    </div>\n  );\n};\n\nexport default TargetCursor;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "animation"
        ],
        "source": "react-bits"
      }
    },
    {
      "name": "animated-gradient-text",
      "type": "component",
      "description": "An animated gradient background which transitions between colors for text.",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/animated-gradient-text.tsx",
          "content": "import { ComponentPropsWithoutRef } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface AnimatedGradientTextProps extends ComponentPropsWithoutRef<\"div\"> {\n  speed?: number\n  colorFrom?: string\n  colorTo?: string\n}\n\nexport function AnimatedGradientText({\n  children,\n  className,\n  speed = 1,\n  colorFrom = \"#ffaa40\",\n  colorTo = \"#9c40ff\",\n  ...props\n}: AnimatedGradientTextProps) {\n  return (\n    <span\n      style={\n        {\n          \"--bg-size\": `${speed * 300}%`,\n          \"--color-from\": colorFrom,\n          \"--color-to\": colorTo,\n        } as React.CSSProperties\n      }\n      className={cn(\n        `animate-gradient inline bg-gradient-to-r from-[var(--color-from)] via-[var(--color-to)] to-[var(--color-from)] bg-[length:var(--bg-size)_100%] bg-clip-text text-transparent`,\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </span>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "animated-shiny-text",
      "type": "component",
      "description": "A light glare effect which pans across text making it appear as if it is shimmering.",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/animated-shiny-text.tsx",
          "content": "import { ComponentPropsWithoutRef, CSSProperties, FC } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface AnimatedShinyTextProps extends ComponentPropsWithoutRef<\"span\"> {\n  shimmerWidth?: number\n}\n\nexport const AnimatedShinyText: FC<AnimatedShinyTextProps> = ({\n  children,\n  className,\n  shimmerWidth = 100,\n  ...props\n}) => {\n  return (\n    <span\n      style={\n        {\n          \"--shiny-width\": `${shimmerWidth}px`,\n        } as CSSProperties\n      }\n      className={cn(\n        \"mx-auto max-w-md text-neutral-600/70 dark:text-neutral-400/70\",\n\n        // Shine effect\n        \"animate-shiny-text [background-size:var(--shiny-width)_100%] bg-clip-text [background-position:0_0] bg-no-repeat [transition:background-position_1s_cubic-bezier(.6,.6,0,1)_infinite]\",\n\n        // Shine gradient\n        \"bg-gradient-to-r from-transparent via-black/80 via-50% to-transparent dark:via-white/80\",\n\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </span>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "ascii-text",
      "type": "component",
      "description": "Renders text with an ASCII art style effect using Three.js.",
      "category": "text",
      "dependencies": [
        "three"
      ],
      "files": [
        {
          "path": "components/ui/ascii-text.tsx",
          "content": "// Component ported and enhanced from https://codepen.io/JuanFuentes/pen/eYEeoyE\n\nimport { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\n\nconst vertexShader = `\nvarying vec2 vUv;\nuniform float uTime;\nuniform float mouse;\nuniform float uEnableWaves;\n\nvoid main() {\n    vUv = uv;\n    float time = uTime * 5.;\n\n    float waveFactor = uEnableWaves;\n\n    vec3 transformed = position;\n\n    transformed.x += sin(time + position.y) * 0.5 * waveFactor;\n    transformed.y += cos(time + position.z) * 0.15 * waveFactor;\n    transformed.z += sin(time + position.x) * waveFactor;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);\n}\n`;\n\nconst fragmentShader = `\nvarying vec2 vUv;\nuniform float mouse;\nuniform float uTime;\nuniform sampler2D uTexture;\n\nvoid main() {\n    float time = uTime;\n    vec2 pos = vUv;\n    \n    float move = sin(time + mouse) * 0.01;\n    float r = texture2D(uTexture, pos + cos(time * 2. - time + pos.x) * .01).r;\n    float g = texture2D(uTexture, pos + tan(time * .5 + pos.x - time) * .01).g;\n    float b = texture2D(uTexture, pos - cos(time * 2. + time + pos.y) * .01).b;\n    float a = texture2D(uTexture, pos).a;\n    gl_FragColor = vec4(r, g, b, a);\n}\n`;\n\nfunction map(n: number, start: number, stop: number, start2: number, stop2: number) {\n  return ((n - start) / (stop - start)) * (stop2 - start2) + start2;\n}\n\nconst PX_RATIO = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n\ninterface AsciiFilterOptions {\n  fontSize?: number;\n  fontFamily?: string;\n  charset?: string;\n  invert?: boolean;\n}\n\nclass AsciiFilter {\n  renderer: THREE.WebGLRenderer;\n  domElement: HTMLDivElement;\n  pre: HTMLPreElement;\n  canvas: HTMLCanvasElement;\n  context: CanvasRenderingContext2D | null;\n  deg: number;\n  invert: boolean;\n  fontSize: number;\n  fontFamily: string;\n  charset: string;\n  width: number = 0;\n  height: number = 0;\n  center: { x: number; y: number } = { x: 0, y: 0 };\n  mouse: { x: number; y: number } = { x: 0, y: 0 };\n  cols: number = 0;\n  rows: number = 0;\n\n  constructor(renderer: THREE.WebGLRenderer, { fontSize, fontFamily, charset, invert }: AsciiFilterOptions = {}) {\n    this.renderer = renderer;\n    this.domElement = document.createElement('div');\n    this.domElement.style.position = 'absolute';\n    this.domElement.style.top = '0';\n    this.domElement.style.left = '0';\n    this.domElement.style.width = '100%';\n    this.domElement.style.height = '100%';\n\n    this.pre = document.createElement('pre');\n    this.domElement.appendChild(this.pre);\n\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    this.domElement.appendChild(this.canvas);\n\n    this.deg = 0;\n    this.invert = invert ?? true;\n    this.fontSize = fontSize ?? 12;\n    this.fontFamily = fontFamily ?? \"'Courier New', monospace\";\n    this.charset = charset ?? ' .\\'`^\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$';\n\n    if (this.context) {\n      this.context.imageSmoothingEnabled = false;\n      this.context.imageSmoothingEnabled = false;\n    }\n\n    this.onMouseMove = this.onMouseMove.bind(this);\n    document.addEventListener('mousemove', this.onMouseMove);\n  }\n\n  setSize(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n    this.renderer.setSize(width, height);\n    this.reset();\n\n    this.center = { x: width / 2, y: height / 2 };\n    this.mouse = { x: this.center.x, y: this.center.y };\n  }\n\n  reset() {\n    if (this.context) {\n      this.context.font = `${this.fontSize}px ${this.fontFamily}`;\n      const charWidth = this.context.measureText('A').width;\n\n      this.cols = Math.floor(this.width / (this.fontSize * (charWidth / this.fontSize)));\n      this.rows = Math.floor(this.height / this.fontSize);\n\n      this.canvas.width = this.cols;\n      this.canvas.height = this.rows;\n      this.pre.style.fontFamily = this.fontFamily;\n      this.pre.style.fontSize = `${this.fontSize}px`;\n      this.pre.style.margin = '0';\n      this.pre.style.padding = '0';\n      this.pre.style.lineHeight = '1em';\n      this.pre.style.position = 'absolute';\n      this.pre.style.left = '50%';\n      this.pre.style.top = '50%';\n      this.pre.style.transform = 'translate(-50%, -50%)';\n      this.pre.style.zIndex = '9';\n      this.pre.style.backgroundAttachment = 'fixed';\n      this.pre.style.mixBlendMode = 'difference';\n    }\n  }\n\n  render(scene: THREE.Scene, camera: THREE.Camera) {\n    this.renderer.render(scene, camera);\n\n    const w = this.canvas.width;\n    const h = this.canvas.height;\n    if (this.context) {\n      this.context.clearRect(0, 0, w, h);\n      if (this.context && w && h) {\n        this.context.drawImage(this.renderer.domElement, 0, 0, w, h);\n      }\n\n      this.asciify(this.context, w, h);\n      this.hue();\n    }\n  }\n\n  onMouseMove(e: MouseEvent) {\n    this.mouse = { x: e.clientX * PX_RATIO, y: e.clientY * PX_RATIO };\n  }\n\n  get dx() {\n    return this.mouse.x - this.center.x;\n  }\n\n  get dy() {\n    return this.mouse.y - this.center.y;\n  }\n\n  hue() {\n    const deg = (Math.atan2(this.dy, this.dx) * 180) / Math.PI;\n    this.deg += (deg - this.deg) * 0.075;\n    this.domElement.style.filter = `hue-rotate(${this.deg.toFixed(1)}deg)`;\n  }\n\n  asciify(ctx: CanvasRenderingContext2D, w: number, h: number) {\n    if (w && h) {\n      const imgData = ctx.getImageData(0, 0, w, h).data;\n      let str = '';\n      for (let y = 0; y < h; y++) {\n        for (let x = 0; x < w; x++) {\n          const i = x * 4 + y * 4 * w;\n          const [r, g, b, a] = [imgData[i], imgData[i + 1], imgData[i + 2], imgData[i + 3]];\n\n          if (a === 0) {\n            str += ' ';\n            continue;\n          }\n\n          let gray = (0.3 * r + 0.6 * g + 0.1 * b) / 255;\n          let idx = Math.floor((1 - gray) * (this.charset.length - 1));\n          if (this.invert) idx = this.charset.length - idx - 1;\n          str += this.charset[idx];\n        }\n        str += '\\n';\n      }\n      this.pre.innerHTML = str;\n    }\n  }\n\n  dispose() {\n    document.removeEventListener('mousemove', this.onMouseMove);\n  }\n}\n\ninterface CanvasTxtOptions {\n  fontSize?: number;\n  fontFamily?: string;\n  color?: string;\n}\n\nclass CanvasTxt {\n  canvas: HTMLCanvasElement;\n  context: CanvasRenderingContext2D | null;\n  txt: string;\n  fontSize: number;\n  fontFamily: string;\n  color: string;\n  font: string;\n\n  constructor(txt: string, { fontSize = 200, fontFamily = 'Arial', color = '#fdf9f3' }: CanvasTxtOptions = {}) {\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    this.txt = txt;\n    this.fontSize = fontSize;\n    this.fontFamily = fontFamily;\n    this.color = color;\n\n    this.font = `600 ${this.fontSize}px ${this.fontFamily}`;\n  }\n\n  resize() {\n    if (this.context) {\n      this.context.font = this.font;\n      const metrics = this.context.measureText(this.txt);\n\n      const textWidth = Math.ceil(metrics.width) + 20;\n      const textHeight = Math.ceil(metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent) + 20;\n\n      this.canvas.width = textWidth;\n      this.canvas.height = textHeight;\n    }\n  }\n\n  render() {\n    if (this.context) {\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      this.context.fillStyle = this.color;\n      this.context.font = this.font;\n\n      const metrics = this.context.measureText(this.txt);\n      const yPos = 10 + metrics.actualBoundingBoxAscent;\n\n      this.context.fillText(this.txt, 10, yPos);\n    }\n  }\n\n  get width() {\n    return this.canvas.width;\n  }\n\n  get height() {\n    return this.canvas.height;\n  }\n\n  get texture() {\n    return this.canvas;\n  }\n}\n\ninterface CanvAsciiOptions {\n  text: string;\n  asciiFontSize: number;\n  textFontSize: number;\n  textColor: string;\n  planeBaseHeight: number;\n  enableWaves: boolean;\n}\n\nclass CanvAscii {\n  textString: string;\n  asciiFontSize: number;\n  textFontSize: number;\n  textColor: string;\n  planeBaseHeight: number;\n  container: HTMLElement;\n  width: number;\n  height: number;\n  enableWaves: boolean;\n  camera: THREE.PerspectiveCamera;\n  scene: THREE.Scene;\n  mouse: { x: number; y: number };\n  textCanvas!: CanvasTxt;\n  texture!: THREE.CanvasTexture;\n  geometry!: THREE.PlaneGeometry;\n  material!: THREE.ShaderMaterial;\n  mesh!: THREE.Mesh;\n  renderer!: THREE.WebGLRenderer;\n  filter!: AsciiFilter;\n  center!: { x: number; y: number };\n  animationFrameId: number = 0;\n\n  constructor(\n    { text, asciiFontSize, textFontSize, textColor, planeBaseHeight, enableWaves }: CanvAsciiOptions,\n    containerElem: HTMLElement,\n    width: number,\n    height: number\n  ) {\n    this.textString = text;\n    this.asciiFontSize = asciiFontSize;\n    this.textFontSize = textFontSize;\n    this.textColor = textColor;\n    this.planeBaseHeight = planeBaseHeight;\n    this.container = containerElem;\n    this.width = width;\n    this.height = height;\n    this.enableWaves = enableWaves;\n\n    this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 1, 1000);\n    this.camera.position.z = 30;\n\n    this.scene = new THREE.Scene();\n    this.mouse = { x: this.width / 2, y: this.height / 2 };\n\n    this.onMouseMove = this.onMouseMove.bind(this);\n  }\n\n  async init() {\n    try {\n      await document.fonts.load('600 200px \"IBM Plex Mono\"');\n      await document.fonts.load('500 12px \"IBM Plex Mono\"');\n    } catch (e) {}\n    await document.fonts.ready;\n    this.setMesh();\n    this.setRenderer();\n  }\n\n  setMesh() {\n    this.textCanvas = new CanvasTxt(this.textString, {\n      fontSize: this.textFontSize,\n      fontFamily: 'IBM Plex Mono',\n      color: this.textColor\n    });\n    this.textCanvas.resize();\n    this.textCanvas.render();\n\n    this.texture = new THREE.CanvasTexture(this.textCanvas.texture);\n    this.texture.minFilter = THREE.NearestFilter;\n\n    const textAspect = this.textCanvas.width / this.textCanvas.height;\n    const baseH = this.planeBaseHeight;\n    const planeW = baseH * textAspect;\n    const planeH = baseH;\n\n    this.geometry = new THREE.PlaneGeometry(planeW, planeH, 36, 36);\n    this.material = new THREE.ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      transparent: true,\n      uniforms: {\n        uTime: { value: 0 },\n        mouse: { value: 1.0 },\n        uTexture: { value: this.texture },\n        uEnableWaves: { value: this.enableWaves ? 1.0 : 0.0 }\n      }\n    });\n\n    this.mesh = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.mesh);\n  }\n\n  setRenderer() {\n    this.renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });\n    this.renderer.setPixelRatio(1);\n    this.renderer.setClearColor(0x000000, 0);\n\n    this.filter = new AsciiFilter(this.renderer, {\n      fontFamily: 'IBM Plex Mono',\n      fontSize: this.asciiFontSize,\n      invert: true\n    });\n\n    this.container.appendChild(this.filter.domElement);\n    this.setSize(this.width, this.height);\n\n    this.container.addEventListener('mousemove', this.onMouseMove);\n    this.container.addEventListener('touchmove', this.onMouseMove);\n  }\n\n  setSize(w: number, h: number) {\n    this.width = w;\n    this.height = h;\n\n    this.camera.aspect = w / h;\n    this.camera.updateProjectionMatrix();\n\n    this.filter.setSize(w, h);\n\n    this.center = { x: w / 2, y: h / 2 };\n  }\n\n  load() {\n    this.animate();\n  }\n\n  onMouseMove(evt: MouseEvent | TouchEvent) {\n    const e = (evt as TouchEvent).touches ? (evt as TouchEvent).touches[0] : (evt as MouseEvent);\n    const bounds = this.container.getBoundingClientRect();\n    const x = e.clientX - bounds.left;\n    const y = e.clientY - bounds.top;\n    this.mouse = { x, y };\n  }\n\n  animate() {\n    const animateFrame = () => {\n      this.animationFrameId = requestAnimationFrame(animateFrame);\n      this.render();\n    };\n    animateFrame();\n  }\n\n  render() {\n    const time = new Date().getTime() * 0.001;\n\n    this.textCanvas.render();\n    this.texture.needsUpdate = true;\n\n    (this.mesh.material as THREE.ShaderMaterial).uniforms.uTime.value = Math.sin(time);\n\n    this.updateRotation();\n    this.filter.render(this.scene, this.camera);\n  }\n\n  updateRotation() {\n    const x = map(this.mouse.y, 0, this.height, 0.5, -0.5);\n    const y = map(this.mouse.x, 0, this.width, -0.5, 0.5);\n\n    this.mesh.rotation.x += (x - this.mesh.rotation.x) * 0.05;\n    this.mesh.rotation.y += (y - this.mesh.rotation.y) * 0.05;\n  }\n\n  clear() {\n    this.scene.traverse(object => {\n      const obj = object as unknown as THREE.Mesh;\n      if (!obj.isMesh) return;\n      [obj.material].flat().forEach(material => {\n        material.dispose();\n        Object.keys(material).forEach(key => {\n          const matProp = material[key as keyof typeof material];\n          if (matProp && typeof matProp === 'object' && 'dispose' in matProp && typeof matProp.dispose === 'function') {\n            matProp.dispose();\n          }\n        });\n      });\n      obj.geometry.dispose();\n    });\n    this.scene.clear();\n  }\n\n  dispose() {\n    cancelAnimationFrame(this.animationFrameId);\n    if (this.filter) {\n      this.filter.dispose();\n      if (this.filter.domElement.parentNode) {\n        this.container.removeChild(this.filter.domElement);\n      }\n    }\n    this.container.removeEventListener('mousemove', this.onMouseMove);\n    this.container.removeEventListener('touchmove', this.onMouseMove);\n    this.clear();\n    if (this.renderer) {\n      this.renderer.dispose();\n    }\n  }\n}\n\ninterface ASCIITextProps {\n  text?: string;\n  asciiFontSize?: number;\n  textFontSize?: number;\n  textColor?: string;\n  planeBaseHeight?: number;\n  enableWaves?: boolean;\n}\n\nexport default function ASCIIText({\n  text = 'David!',\n  asciiFontSize = 8,\n  textFontSize = 200,\n  textColor = '#fdf9f3',\n  planeBaseHeight = 8,\n  enableWaves = true\n}: ASCIITextProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const asciiRef = useRef<CanvAscii | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    let cancelled = false;\n    let observer: IntersectionObserver | null = null;\n    let ro: ResizeObserver | null = null;\n\n    const createAndInit = async (container: HTMLDivElement, w: number, h: number) => {\n      const instance = new CanvAscii(\n        { text, asciiFontSize, textFontSize, textColor, planeBaseHeight, enableWaves },\n        container,\n        w,\n        h\n      );\n      await instance.init();\n      return instance;\n    };\n\n    const setup = async () => {\n      const { width, height } = containerRef.current!.getBoundingClientRect();\n\n      if (width === 0 || height === 0) {\n        observer = new IntersectionObserver(\n          async ([entry]) => {\n            if (cancelled) return;\n            if (entry.isIntersecting && entry.boundingClientRect.width > 0 && entry.boundingClientRect.height > 0) {\n              const { width: w, height: h } = entry.boundingClientRect;\n              observer?.disconnect();\n              observer = null;\n\n              if (!cancelled) {\n                asciiRef.current = await createAndInit(containerRef.current!, w, h);\n                if (!cancelled && asciiRef.current) {\n                  asciiRef.current.load();\n                }\n              }\n            }\n          },\n          { threshold: 0.1 }\n        );\n        observer.observe(containerRef.current!);\n        return;\n      }\n\n      asciiRef.current = await createAndInit(containerRef.current!, width, height);\n      if (!cancelled && asciiRef.current) {\n        asciiRef.current.load();\n\n        ro = new ResizeObserver(entries => {\n          if (!entries[0] || !asciiRef.current) return;\n          const { width: w, height: h } = entries[0].contentRect;\n          if (w > 0 && h > 0) {\n            asciiRef.current.setSize(w, h);\n          }\n        });\n        ro.observe(containerRef.current!);\n      }\n    };\n\n    setup();\n\n    return () => {\n      cancelled = true;\n      if (observer) observer.disconnect();\n      if (ro) ro.disconnect();\n      if (asciiRef.current) {\n        asciiRef.current.dispose();\n        asciiRef.current = null;\n      }\n    };\n  }, [text, asciiFontSize, textFontSize, textColor, planeBaseHeight, enableWaves]);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"ascii-text-container\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: '100%'\n      }}\n    >\n      <style>{`\n        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@500;600&display=swap');\n\n        .ascii-text-container canvas {\n          position: absolute;\n          left: 0;\n          top: 0;\n          width: 100%;\n          height: 100%;\n          image-rendering: optimizeSpeed;\n          image-rendering: -moz-crisp-edges;\n          image-rendering: -o-crisp-edges;\n          image-rendering: -webkit-optimize-contrast;\n          image-rendering: optimize-contrast;\n          image-rendering: crisp-edges;\n          image-rendering: pixelated;\n        }\n\n        .ascii-text-container pre {\n          margin: 0;\n          user-select: none;\n          padding: 0;\n          line-height: 1em;\n          text-align: left;\n          position: absolute;\n          left: 0;\n          top: 0;\n          background-image: radial-gradient(circle, #ff6188 0%, #fc9867 50%, #ffd866 100%);\n          background-attachment: fixed;\n          -webkit-text-fill-color: transparent;\n          -webkit-background-clip: text;\n          z-index: 9;\n          mix-blend-mode: difference;\n        }\n      `}</style>\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import ASCIIText from \"./component\";\n\nexport default function ASCIITextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8 w-full h-[400px]\">\n      <ASCIIText text=\"Hello World\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "aurora-text",
      "type": "component",
      "description": "A beautiful aurora text effect",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/aurora-text.tsx",
          "content": "\"use client\"\n\nimport React, { memo } from \"react\"\n\ninterface AuroraTextProps {\n  children: React.ReactNode\n  className?: string\n  colors?: string[]\n  speed?: number\n}\n\nexport const AuroraText = memo(\n  ({\n    children,\n    className = \"\",\n    colors = [\"#FF0080\", \"#7928CA\", \"#0070F3\", \"#38bdf8\"],\n    speed = 1,\n  }: AuroraTextProps) => {\n    const gradientStyle = {\n      backgroundImage: `linear-gradient(135deg, ${colors.join(\", \")}, ${\n        colors[0]\n      })`,\n      WebkitBackgroundClip: \"text\",\n      WebkitTextFillColor: \"transparent\",\n      animationDuration: `${10 / speed}s`,\n    }\n\n    return (\n      <span className={`relative inline-block ${className}`}>\n        <span className=\"sr-only\">{children}</span>\n        <span\n          className=\"animate-aurora relative bg-size-[200%_auto] bg-clip-text text-transparent\"\n          style={gradientStyle}\n          aria-hidden=\"true\"\n        >\n          {children}\n        </span>\n      </span>\n    )\n  }\n)\n\nAuroraText.displayName = \"AuroraText\"\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "blur-text",
      "type": "component",
      "description": "Text animation with a blur reveal effect.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/blur-text.tsx",
          "content": "import { motion, Transition, Easing } from 'motion/react';\nimport { useEffect, useRef, useState, useMemo } from 'react';\n\ntype BlurTextProps = {\n  text?: string;\n  delay?: number;\n  className?: string;\n  animateBy?: 'words' | 'letters';\n  direction?: 'top' | 'bottom';\n  threshold?: number;\n  rootMargin?: string;\n  animationFrom?: Record<string, string | number>;\n  animationTo?: Array<Record<string, string | number>>;\n  easing?: Easing | Easing[];\n  onAnimationComplete?: () => void;\n  stepDuration?: number;\n};\n\nconst buildKeyframes = (\n  from: Record<string, string | number>,\n  steps: Array<Record<string, string | number>>\n): Record<string, Array<string | number>> => {\n  const keys = new Set<string>([...Object.keys(from), ...steps.flatMap(s => Object.keys(s))]);\n\n  const keyframes: Record<string, Array<string | number>> = {};\n  keys.forEach(k => {\n    keyframes[k] = [from[k], ...steps.map(s => s[k])];\n  });\n  return keyframes;\n};\n\nconst BlurText: React.FC<BlurTextProps> = ({\n  text = '',\n  delay = 200,\n  className = '',\n  animateBy = 'words',\n  direction = 'top',\n  threshold = 0.1,\n  rootMargin = '0px',\n  animationFrom,\n  animationTo,\n  easing = (t: number) => t,\n  onAnimationComplete,\n  stepDuration = 0.35\n}) => {\n  const elements = animateBy === 'words' ? text.split(' ') : text.split('');\n  const [inView, setInView] = useState(false);\n  const ref = useRef<HTMLParagraphElement>(null);\n\n  useEffect(() => {\n    if (!ref.current) return;\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setInView(true);\n          observer.unobserve(ref.current as Element);\n        }\n      },\n      { threshold, rootMargin }\n    );\n    observer.observe(ref.current);\n    return () => observer.disconnect();\n  }, [threshold, rootMargin]);\n\n  const defaultFrom = useMemo(\n    () =>\n      direction === 'top' ? { filter: 'blur(10px)', opacity: 0, y: -50 } : { filter: 'blur(10px)', opacity: 0, y: 50 },\n    [direction]\n  );\n\n  const defaultTo = useMemo(\n    () => [\n      {\n        filter: 'blur(5px)',\n        opacity: 0.5,\n        y: direction === 'top' ? 5 : -5\n      },\n      { filter: 'blur(0px)', opacity: 1, y: 0 }\n    ],\n    [direction]\n  );\n\n  const fromSnapshot = animationFrom ?? defaultFrom;\n  const toSnapshots = animationTo ?? defaultTo;\n\n  const stepCount = toSnapshots.length + 1;\n  const totalDuration = stepDuration * (stepCount - 1);\n  const times = Array.from({ length: stepCount }, (_, i) => (stepCount === 1 ? 0 : i / (stepCount - 1)));\n\n  return (\n    <p ref={ref} className={`blur-text ${className} flex flex-wrap`}>\n      {elements.map((segment, index) => {\n        const animateKeyframes = buildKeyframes(fromSnapshot, toSnapshots);\n\n        const spanTransition: Transition = {\n          duration: totalDuration,\n          times,\n          delay: (index * delay) / 1000,\n          ease: easing\n        };\n\n        return (\n          <motion.span\n            key={index}\n            initial={fromSnapshot}\n            animate={inView ? animateKeyframes : fromSnapshot}\n            transition={spanTransition}\n            onAnimationComplete={index === elements.length - 1 ? onAnimationComplete : undefined}\n            style={{\n              display: 'inline-block',\n              willChange: 'transform, filter, opacity'\n            }}\n          >\n            {segment === ' ' ? '\\u00A0' : segment}\n            {animateBy === 'words' && index < elements.length - 1 && '\\u00A0'}\n          </motion.span>\n        );\n      })}\n    </p>\n  );\n};\n\nexport default BlurText;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import BlurText from \"./component\";\n\nexport default function BlurTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <BlurText text=\"Hello World\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "circular-text",
      "type": "component",
      "description": "Text arranged and animated in a circular path.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/circular-text.tsx",
          "content": "import React, { useEffect } from 'react';\nimport { motion, useAnimation, useMotionValue, MotionValue, Transition } from 'motion/react';\ninterface CircularTextProps {\n  text: string;\n  spinDuration?: number;\n  onHover?: 'slowDown' | 'speedUp' | 'pause' | 'goBonkers';\n  className?: string;\n}\n\nconst getRotationTransition = (duration: number, from: number, loop: boolean = true) => ({\n  from,\n  to: from + 360,\n  ease: 'linear' as const,\n  duration,\n  type: 'tween' as const,\n  repeat: loop ? Infinity : 0\n});\n\nconst getTransition = (duration: number, from: number) => ({\n  rotate: getRotationTransition(duration, from),\n  scale: {\n    type: 'spring' as const,\n    damping: 20,\n    stiffness: 300\n  }\n});\n\nconst CircularText: React.FC<CircularTextProps> = ({\n  text,\n  spinDuration = 20,\n  onHover = 'speedUp',\n  className = ''\n}) => {\n  const letters = Array.from(text);\n  const controls = useAnimation();\n  const rotation: MotionValue<number> = useMotionValue(0);\n\n  useEffect(() => {\n    const start = rotation.get();\n    controls.start({\n      rotate: start + 360,\n      scale: 1,\n      transition: getTransition(spinDuration, start)\n    });\n  }, [spinDuration, text, onHover, controls]);\n\n  const handleHoverStart = () => {\n    const start = rotation.get();\n\n    if (!onHover) return;\n\n    let transitionConfig: ReturnType<typeof getTransition> | Transition;\n    let scaleVal = 1;\n\n    switch (onHover) {\n      case 'slowDown':\n        transitionConfig = getTransition(spinDuration * 2, start);\n        break;\n      case 'speedUp':\n        transitionConfig = getTransition(spinDuration / 4, start);\n        break;\n      case 'pause':\n        transitionConfig = {\n          rotate: { type: 'spring', damping: 20, stiffness: 300 },\n          scale: { type: 'spring', damping: 20, stiffness: 300 }\n        };\n        break;\n      case 'goBonkers':\n        transitionConfig = getTransition(spinDuration / 20, start);\n        scaleVal = 0.8;\n        break;\n      default:\n        transitionConfig = getTransition(spinDuration, start);\n    }\n\n    controls.start({\n      rotate: start + 360,\n      scale: scaleVal,\n      transition: transitionConfig\n    });\n  };\n\n  const handleHoverEnd = () => {\n    const start = rotation.get();\n    controls.start({\n      rotate: start + 360,\n      scale: 1,\n      transition: getTransition(spinDuration, start)\n    });\n  };\n\n  return (\n    <motion.div\n      className={`m-0 mx-auto rounded-full w-[200px] h-[200px] relative font-black text-white text-center cursor-pointer origin-center ${className}`}\n      style={{ rotate: rotation }}\n      initial={{ rotate: 0 }}\n      animate={controls}\n      onMouseEnter={handleHoverStart}\n      onMouseLeave={handleHoverEnd}\n    >\n      {letters.map((letter, i) => {\n        const rotationDeg = (360 / letters.length) * i;\n        const factor = Math.PI / letters.length;\n        const x = factor * i;\n        const y = factor * i;\n        const transform = `rotateZ(${rotationDeg}deg) translate3d(${x}px, ${y}px, 0)`;\n\n        return (\n          <span\n            key={i}\n            className=\"absolute inline-block inset-0 text-2xl transition-all duration-500 ease-[cubic-bezier(0,0,0,1)]\"\n            style={{ transform, WebkitTransform: transform }}\n          >\n            {letter}\n          </span>\n        );\n      })}\n    </motion.div>\n  );\n};\n\nexport default CircularText;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import CircularText from \"./component\";\n\nexport default function CircularTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <CircularText text=\"Hello World  React Bits  \" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "comic-text",
      "type": "component",
      "description": "Comic text animation",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/comic-text.tsx",
          "content": "\"use client\"\n\nimport { CSSProperties } from \"react\"\nimport { motion } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ntype ComicTextProps = {\n  children: string\n  className?: string\n  style?: CSSProperties\n  fontSize?: number\n}\n\nexport function ComicText({\n  children,\n  className,\n  style,\n  fontSize = 5,\n}: ComicTextProps) {\n  if (typeof children !== \"string\") {\n    throw new Error(\"children must be a string\")\n  }\n\n  const dotColor = \"#EF4444\"\n  const backgroundColor = \"#FACC15\"\n\n  return (\n    <motion.div\n      className={cn(\"text-center select-none\", className)}\n      style={{\n        fontSize: `${fontSize}rem`,\n        fontFamily: \"'Bangers', 'Comic Sans MS', 'Impact', sans-serif\",\n        fontWeight: \"900\",\n        WebkitTextStroke: `${fontSize * 0.35}px #000000`, // Thick black outline\n        transform: \"skewX(-10deg)\",\n        textTransform: \"uppercase\",\n        filter: `\n          drop-shadow(5px 5px 0px #000000) \n          drop-shadow(3px 3px 0px ${dotColor})\n        `,\n        backgroundColor: backgroundColor,\n        backgroundImage: `radial-gradient(circle at 1px 1px, ${dotColor} 1px, transparent 0)`,\n        backgroundSize: \"8px 8px\",\n        backgroundClip: \"text\",\n        WebkitBackgroundClip: \"text\",\n        WebkitTextFillColor: \"transparent\",\n        ...style,\n      }}\n      initial={{ opacity: 0, scale: 0.8, rotate: -2 }}\n      animate={{ opacity: 1, scale: 1, rotate: 0 }}\n      transition={{\n        duration: 0.6,\n        ease: [0.175, 0.885, 0.32, 1.275],\n        type: \"spring\",\n      }}\n    >\n      {children}\n    </motion.div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "count-up",
      "type": "component",
      "description": "Animated number counting up effect.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/count-up.tsx",
          "content": "import { useInView, useMotionValue, useSpring } from 'motion/react';\nimport { useCallback, useEffect, useRef } from 'react';\n\ninterface CountUpProps {\n  to: number;\n  from?: number;\n  direction?: 'up' | 'down';\n  delay?: number;\n  duration?: number;\n  className?: string;\n  startWhen?: boolean;\n  separator?: string;\n  onStart?: () => void;\n  onEnd?: () => void;\n}\n\nexport default function CountUp({\n  to,\n  from = 0,\n  direction = 'up',\n  delay = 0,\n  duration = 2,\n  className = '',\n  startWhen = true,\n  separator = '',\n  onStart,\n  onEnd\n}: CountUpProps) {\n  const ref = useRef<HTMLSpanElement>(null);\n  const motionValue = useMotionValue(direction === 'down' ? to : from);\n\n  const damping = 20 + 40 * (1 / duration);\n  const stiffness = 100 * (1 / duration);\n\n  const springValue = useSpring(motionValue, {\n    damping,\n    stiffness\n  });\n\n  const isInView = useInView(ref, { once: true, margin: '0px' });\n\n  const getDecimalPlaces = (num: number): number => {\n    const str = num.toString();\n    if (str.includes('.')) {\n      const decimals = str.split('.')[1];\n      if (parseInt(decimals) !== 0) {\n        return decimals.length;\n      }\n    }\n    return 0;\n  };\n\n  const maxDecimals = Math.max(getDecimalPlaces(from), getDecimalPlaces(to));\n\n  const formatValue = useCallback(\n    (latest: number) => {\n      const hasDecimals = maxDecimals > 0;\n\n      const options: Intl.NumberFormatOptions = {\n        useGrouping: !!separator,\n        minimumFractionDigits: hasDecimals ? maxDecimals : 0,\n        maximumFractionDigits: hasDecimals ? maxDecimals : 0\n      };\n\n      const formattedNumber = Intl.NumberFormat('en-US', options).format(latest);\n\n      return separator ? formattedNumber.replace(/,/g, separator) : formattedNumber;\n    },\n    [maxDecimals, separator]\n  );\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.textContent = formatValue(direction === 'down' ? to : from);\n    }\n  }, [from, to, direction, formatValue]);\n\n  useEffect(() => {\n    if (isInView && startWhen) {\n      if (typeof onStart === 'function') {\n        onStart();\n      }\n\n      const timeoutId = setTimeout(() => {\n        motionValue.set(direction === 'down' ? from : to);\n      }, delay * 1000);\n\n      const durationTimeoutId = setTimeout(\n        () => {\n          if (typeof onEnd === 'function') {\n            onEnd();\n          }\n        },\n        delay * 1000 + duration * 1000\n      );\n\n      return () => {\n        clearTimeout(timeoutId);\n        clearTimeout(durationTimeoutId);\n      };\n    }\n  }, [isInView, startWhen, motionValue, direction, from, to, delay, onStart, onEnd, duration]);\n\n  useEffect(() => {\n    const unsubscribe = springValue.on('change', (latest: number) => {\n      if (ref.current) {\n        ref.current.textContent = formatValue(latest);\n      }\n    });\n\n    return () => unsubscribe();\n  }, [springValue, formatValue]);\n\n  return <span className={className} ref={ref} />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import CountUp from \"./component\";\n\nexport default function CountUpExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8 text-4xl font-bold\">\n      <CountUp to={1000} />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "curved-loop",
      "type": "component",
      "description": "Marquee text that flows along a curved SVG path.",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/curved-loop.tsx",
          "content": "import { useRef, useEffect, useState, useMemo, useId, FC, PointerEvent } from 'react';\n\ninterface CurvedLoopProps {\n  marqueeText?: string;\n  speed?: number;\n  className?: string;\n  curveAmount?: number;\n  direction?: 'left' | 'right';\n  interactive?: boolean;\n}\n\nconst CurvedLoop: FC<CurvedLoopProps> = ({\n  marqueeText = '',\n  speed = 2,\n  className,\n  curveAmount = 400,\n  direction = 'left',\n  interactive = true\n}) => {\n  const text = useMemo(() => {\n    const hasTrailing = /\\s|\\u00A0$/.test(marqueeText);\n    return (hasTrailing ? marqueeText.replace(/\\s+$/, '') : marqueeText) + '\\u00A0';\n  }, [marqueeText]);\n\n  const measureRef = useRef<SVGTextElement | null>(null);\n  const textPathRef = useRef<SVGTextPathElement | null>(null);\n  const pathRef = useRef<SVGPathElement | null>(null);\n  const [spacing, setSpacing] = useState(0);\n  const [offset, setOffset] = useState(0);\n  const uid = useId();\n  const pathId = `curve-${uid}`;\n  const pathD = `M-100,40 Q500,${40 + curveAmount} 1540,40`;\n\n  const dragRef = useRef(false);\n  const lastXRef = useRef(0);\n  const dirRef = useRef<'left' | 'right'>(direction);\n  const velRef = useRef(0);\n\n  const textLength = spacing;\n  const totalText = textLength\n    ? Array(Math.ceil(1800 / textLength) + 2)\n        .fill(text)\n        .join('')\n    : text;\n  const ready = spacing > 0;\n\n  useEffect(() => {\n    if (measureRef.current) setSpacing(measureRef.current.getComputedTextLength());\n  }, [text, className]);\n\n  useEffect(() => {\n    if (!spacing) return;\n    if (textPathRef.current) {\n      const initial = -spacing;\n      textPathRef.current.setAttribute('startOffset', initial + 'px');\n      setOffset(initial);\n    }\n  }, [spacing]);\n\n  useEffect(() => {\n    if (!spacing || !ready) return;\n    let frame = 0;\n    const step = () => {\n      if (!dragRef.current && textPathRef.current) {\n        const delta = dirRef.current === 'right' ? speed : -speed;\n        const currentOffset = parseFloat(textPathRef.current.getAttribute('startOffset') || '0');\n        let newOffset = currentOffset + delta;\n        const wrapPoint = spacing;\n        if (newOffset <= -wrapPoint) newOffset += wrapPoint;\n        if (newOffset > 0) newOffset -= wrapPoint;\n        textPathRef.current.setAttribute('startOffset', newOffset + 'px');\n        setOffset(newOffset);\n      }\n      frame = requestAnimationFrame(step);\n    };\n    frame = requestAnimationFrame(step);\n    return () => cancelAnimationFrame(frame);\n  }, [spacing, speed, ready]);\n\n  const onPointerDown = (e: PointerEvent) => {\n    if (!interactive) return;\n    dragRef.current = true;\n    lastXRef.current = e.clientX;\n    velRef.current = 0;\n    (e.target as HTMLElement).setPointerCapture(e.pointerId);\n  };\n\n  const onPointerMove = (e: PointerEvent) => {\n    if (!interactive || !dragRef.current || !textPathRef.current) return;\n    const dx = e.clientX - lastXRef.current;\n    lastXRef.current = e.clientX;\n    velRef.current = dx;\n    const currentOffset = parseFloat(textPathRef.current.getAttribute('startOffset') || '0');\n    let newOffset = currentOffset + dx;\n    const wrapPoint = spacing;\n    if (newOffset <= -wrapPoint) newOffset += wrapPoint;\n    if (newOffset > 0) newOffset -= wrapPoint;\n    textPathRef.current.setAttribute('startOffset', newOffset + 'px');\n    setOffset(newOffset);\n  };\n\n  const endDrag = () => {\n    if (!interactive) return;\n    dragRef.current = false;\n    dirRef.current = velRef.current > 0 ? 'right' : 'left';\n  };\n\n  const cursorStyle = interactive ? (dragRef.current ? 'grabbing' : 'grab') : 'auto';\n\n  return (\n    <div\n      className=\"min-h-screen flex items-center justify-center w-full\"\n      style={{ visibility: ready ? 'visible' : 'hidden', cursor: cursorStyle }}\n      onPointerDown={onPointerDown}\n      onPointerMove={onPointerMove}\n      onPointerUp={endDrag}\n      onPointerLeave={endDrag}\n    >\n      <svg\n        className=\"select-none w-full overflow-visible block aspect-[100/12] text-[6rem] font-bold uppercase leading-none\"\n        viewBox=\"0 0 1440 120\"\n      >\n        <text ref={measureRef} xmlSpace=\"preserve\" style={{ visibility: 'hidden', opacity: 0, pointerEvents: 'none' }}>\n          {text}\n        </text>\n        <defs>\n          <path ref={pathRef} id={pathId} d={pathD} fill=\"none\" stroke=\"transparent\" />\n        </defs>\n        {ready && (\n          <text xmlSpace=\"preserve\" className={`fill-white ${className ?? ''}`}>\n            <textPath ref={textPathRef} href={`#${pathId}`} startOffset={offset + 'px'} xmlSpace=\"preserve\">\n              {totalText}\n            </textPath>\n          </text>\n        )}\n      </svg>\n    </div>\n  );\n};\n\nexport default CurvedLoop;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import CurvedLoop from \"./component\";\n\nexport default function CurvedLoopExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8 w-full\">\n      <CurvedLoop marqueeText=\"Hello World \" speed={2} />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "decrypted-text",
      "type": "component",
      "description": "Text that decrypts itself with a scrambling animation.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/decrypted-text.tsx",
          "content": "import { useEffect, useState, useRef } from 'react';\nimport { motion } from 'motion/react';\nimport type { HTMLMotionProps } from 'motion/react';\n\ninterface DecryptedTextProps extends HTMLMotionProps<'span'> {\n  text: string;\n  speed?: number;\n  maxIterations?: number;\n  sequential?: boolean;\n  revealDirection?: 'start' | 'end' | 'center';\n  useOriginalCharsOnly?: boolean;\n  characters?: string;\n  className?: string;\n  encryptedClassName?: string;\n  parentClassName?: string;\n  animateOn?: 'view' | 'hover' | 'both';\n}\n\nexport default function DecryptedText({\n  text,\n  speed = 50,\n  maxIterations = 10,\n  sequential = false,\n  revealDirection = 'start',\n  useOriginalCharsOnly = false,\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+',\n  className = '',\n  parentClassName = '',\n  encryptedClassName = '',\n  animateOn = 'hover',\n  ...props\n}: DecryptedTextProps) {\n  const [displayText, setDisplayText] = useState<string>(text);\n  const [isHovering, setIsHovering] = useState<boolean>(false);\n  const [isScrambling, setIsScrambling] = useState<boolean>(false);\n  const [revealedIndices, setRevealedIndices] = useState<Set<number>>(new Set());\n  const [hasAnimated, setHasAnimated] = useState<boolean>(false);\n  const containerRef = useRef<HTMLSpanElement>(null);\n\n  useEffect(() => {\n    let interval: ReturnType<typeof setInterval>;\n    let currentIteration = 0;\n\n    const getNextIndex = (revealedSet: Set<number>): number => {\n      const textLength = text.length;\n      switch (revealDirection) {\n        case 'start':\n          return revealedSet.size;\n        case 'end':\n          return textLength - 1 - revealedSet.size;\n        case 'center': {\n          const middle = Math.floor(textLength / 2);\n          const offset = Math.floor(revealedSet.size / 2);\n          const nextIndex = revealedSet.size % 2 === 0 ? middle + offset : middle - offset - 1;\n\n          if (nextIndex >= 0 && nextIndex < textLength && !revealedSet.has(nextIndex)) {\n            return nextIndex;\n          }\n          for (let i = 0; i < textLength; i++) {\n            if (!revealedSet.has(i)) return i;\n          }\n          return 0;\n        }\n        default:\n          return revealedSet.size;\n      }\n    };\n\n    const availableChars = useOriginalCharsOnly\n      ? Array.from(new Set(text.split(''))).filter(char => char !== ' ')\n      : characters.split('');\n\n    const shuffleText = (originalText: string, currentRevealed: Set<number>): string => {\n      if (useOriginalCharsOnly) {\n        const positions = originalText.split('').map((char, i) => ({\n          char,\n          isSpace: char === ' ',\n          index: i,\n          isRevealed: currentRevealed.has(i)\n        }));\n\n        const nonSpaceChars = positions.filter(p => !p.isSpace && !p.isRevealed).map(p => p.char);\n\n        for (let i = nonSpaceChars.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];\n        }\n\n        let charIndex = 0;\n        return positions\n          .map(p => {\n            if (p.isSpace) return ' ';\n            if (p.isRevealed) return originalText[p.index];\n            return nonSpaceChars[charIndex++];\n          })\n          .join('');\n      } else {\n        return originalText\n          .split('')\n          .map((char, i) => {\n            if (char === ' ') return ' ';\n            if (currentRevealed.has(i)) return originalText[i];\n            return availableChars[Math.floor(Math.random() * availableChars.length)];\n          })\n          .join('');\n      }\n    };\n\n    if (isHovering) {\n      setIsScrambling(true);\n      interval = setInterval(() => {\n        setRevealedIndices(prevRevealed => {\n          if (sequential) {\n            if (prevRevealed.size < text.length) {\n              const nextIndex = getNextIndex(prevRevealed);\n              const newRevealed = new Set(prevRevealed);\n              newRevealed.add(nextIndex);\n              setDisplayText(shuffleText(text, newRevealed));\n              return newRevealed;\n            } else {\n              clearInterval(interval);\n              setIsScrambling(false);\n              return prevRevealed;\n            }\n          } else {\n            setDisplayText(shuffleText(text, prevRevealed));\n            currentIteration++;\n            if (currentIteration >= maxIterations) {\n              clearInterval(interval);\n              setIsScrambling(false);\n              setDisplayText(text);\n            }\n            return prevRevealed;\n          }\n        });\n      }, speed);\n    } else {\n      setDisplayText(text);\n      setRevealedIndices(new Set());\n      setIsScrambling(false);\n    }\n\n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [isHovering, text, speed, maxIterations, sequential, revealDirection, characters, useOriginalCharsOnly]);\n\n  useEffect(() => {\n    if (animateOn !== 'view' && animateOn !== 'both') return;\n\n    const observerCallback = (entries: IntersectionObserverEntry[]) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting && !hasAnimated) {\n          setIsHovering(true);\n          setHasAnimated(true);\n        }\n      });\n    };\n\n    const observerOptions = {\n      root: null,\n      rootMargin: '0px',\n      threshold: 0.1\n    };\n\n    const observer = new IntersectionObserver(observerCallback, observerOptions);\n    const currentRef = containerRef.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n\n    return () => {\n      if (currentRef) observer.unobserve(currentRef);\n    };\n  }, [animateOn, hasAnimated]);\n\n  const hoverProps =\n    animateOn === 'hover' || animateOn === 'both'\n      ? {\n          onMouseEnter: () => setIsHovering(true),\n          onMouseLeave: () => setIsHovering(false)\n        }\n      : {};\n\n  return (\n    <motion.span\n      ref={containerRef}\n      className={`inline-block whitespace-pre-wrap ${parentClassName}`}\n      {...hoverProps}\n      {...props}\n    >\n      <span className=\"sr-only\">{displayText}</span>\n\n      <span aria-hidden=\"true\">\n        {displayText.split('').map((char, index) => {\n          const isRevealedOrDone = revealedIndices.has(index) || !isScrambling || !isHovering;\n\n          return (\n            <span key={index} className={isRevealedOrDone ? className : encryptedClassName}>\n              {char}\n            </span>\n          );\n        })}\n      </span>\n    </motion.span>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import DecryptedText from \"./component\";\n\nexport default function DecryptedTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8 text-2xl\">\n      <DecryptedText text=\"Hello World\" animateOn=\"view\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "falling-text",
      "type": "component",
      "description": "Physics-based falling text effect using Matter.js.",
      "category": "text",
      "dependencies": [
        "matter-js"
      ],
      "files": [
        {
          "path": "components/ui/falling-text.tsx",
          "content": "import { useRef, useState, useEffect } from 'react';\nimport Matter from 'matter-js';\n\ninterface FallingTextProps {\n  text?: string;\n  highlightWords?: string[];\n  trigger?: 'auto' | 'scroll' | 'click' | 'hover';\n  backgroundColor?: string;\n  wireframes?: boolean;\n  gravity?: number;\n  mouseConstraintStiffness?: number;\n  fontSize?: string;\n}\n\nconst FallingText: React.FC<FallingTextProps> = ({\n  text = '',\n  highlightWords = [],\n  trigger = 'auto',\n  backgroundColor = 'transparent',\n  wireframes = false,\n  gravity = 1,\n  mouseConstraintStiffness = 0.2,\n  fontSize = '1rem'\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const textRef = useRef<HTMLDivElement | null>(null);\n  const canvasContainerRef = useRef<HTMLDivElement | null>(null);\n\n  const [effectStarted, setEffectStarted] = useState(false);\n\n  useEffect(() => {\n    if (!textRef.current) return;\n    const words = text.split(' ');\n\n    const newHTML = words\n      .map(word => {\n        const isHighlighted = highlightWords.some(hw => word.startsWith(hw));\n        return `<span\n          class=\"inline-block mx-[2px] select-none ${isHighlighted ? 'text-cyan-500 font-bold' : ''}\"\n        >\n          ${word}\n        </span>`;\n      })\n      .join(' ');\n\n    textRef.current.innerHTML = newHTML;\n  }, [text, highlightWords]);\n\n  useEffect(() => {\n    if (trigger === 'auto') {\n      setEffectStarted(true);\n      return;\n    }\n    if (trigger === 'scroll' && containerRef.current) {\n      const observer = new IntersectionObserver(\n        ([entry]) => {\n          if (entry.isIntersecting) {\n            setEffectStarted(true);\n            observer.disconnect();\n          }\n        },\n        { threshold: 0.1 }\n      );\n      observer.observe(containerRef.current);\n      return () => observer.disconnect();\n    }\n  }, [trigger]);\n\n  useEffect(() => {\n    if (!effectStarted) return;\n\n    const { Engine, Render, World, Bodies, Runner, Mouse, MouseConstraint } = Matter;\n\n    if (!containerRef.current || !canvasContainerRef.current) return;\n\n    const containerRect = containerRef.current.getBoundingClientRect();\n    const width = containerRect.width;\n    const height = containerRect.height;\n\n    if (width <= 0 || height <= 0) return;\n\n    const engine = Engine.create();\n    engine.world.gravity.y = gravity;\n\n    const render = Render.create({\n      element: canvasContainerRef.current,\n      engine,\n      options: {\n        width,\n        height,\n        background: backgroundColor,\n        wireframes\n      }\n    });\n\n    const boundaryOptions = {\n      isStatic: true,\n      render: { fillStyle: 'transparent' }\n    };\n    const floor = Bodies.rectangle(width / 2, height + 25, width, 50, boundaryOptions);\n    const leftWall = Bodies.rectangle(-25, height / 2, 50, height, boundaryOptions);\n    const rightWall = Bodies.rectangle(width + 25, height / 2, 50, height, boundaryOptions);\n    const ceiling = Bodies.rectangle(width / 2, -25, width, 50, boundaryOptions);\n\n    if (!textRef.current) return;\n    const wordSpans = textRef.current.querySelectorAll('span');\n    const wordBodies = [...wordSpans].map(elem => {\n      const rect = elem.getBoundingClientRect();\n\n      const x = rect.left - containerRect.left + rect.width / 2;\n      const y = rect.top - containerRect.top + rect.height / 2;\n\n      const body = Bodies.rectangle(x, y, rect.width, rect.height, {\n        render: { fillStyle: 'transparent' },\n        restitution: 0.8,\n        frictionAir: 0.01,\n        friction: 0.2\n      });\n      Matter.Body.setVelocity(body, {\n        x: (Math.random() - 0.5) * 5,\n        y: 0\n      });\n      Matter.Body.setAngularVelocity(body, (Math.random() - 0.5) * 0.05);\n\n      return { elem, body };\n    });\n\n    wordBodies.forEach(({ elem, body }) => {\n      elem.style.position = 'absolute';\n      elem.style.left = `${body.position.x - body.bounds.max.x + body.bounds.min.x / 2}px`;\n      elem.style.top = `${body.position.y - body.bounds.max.y + body.bounds.min.y / 2}px`;\n      elem.style.transform = 'none';\n    });\n\n    const mouse = Mouse.create(containerRef.current);\n    const mouseConstraint = MouseConstraint.create(engine, {\n      mouse,\n      constraint: {\n        stiffness: mouseConstraintStiffness,\n        render: { visible: false }\n      }\n    });\n    render.mouse = mouse;\n\n    World.add(engine.world, [floor, leftWall, rightWall, ceiling, mouseConstraint, ...wordBodies.map(wb => wb.body)]);\n\n    const runner = Runner.create();\n    Runner.run(runner, engine);\n    Render.run(render);\n\n    const updateLoop = () => {\n      wordBodies.forEach(({ body, elem }) => {\n        const { x, y } = body.position;\n        elem.style.left = `${x}px`;\n        elem.style.top = `${y}px`;\n        elem.style.transform = `translate(-50%, -50%) rotate(${body.angle}rad)`;\n      });\n      Matter.Engine.update(engine);\n      requestAnimationFrame(updateLoop);\n    };\n    updateLoop();\n\n    return () => {\n      Render.stop(render);\n      Runner.stop(runner);\n      if (render.canvas && canvasContainerRef.current) {\n        canvasContainerRef.current.removeChild(render.canvas);\n      }\n      World.clear(engine.world, false);\n      Engine.clear(engine);\n    };\n  }, [effectStarted, gravity, wireframes, backgroundColor, mouseConstraintStiffness]);\n\n  const handleTrigger = () => {\n    if (!effectStarted && (trigger === 'click' || trigger === 'hover')) {\n      setEffectStarted(true);\n    }\n  };\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"relative z-[1] w-full h-full cursor-pointer text-center pt-8 overflow-hidden\"\n      onClick={trigger === 'click' ? handleTrigger : undefined}\n      onMouseEnter={trigger === 'hover' ? handleTrigger : undefined}\n    >\n      <div\n        ref={textRef}\n        className=\"inline-block\"\n        style={{\n          fontSize,\n          lineHeight: 1.4\n        }}\n      />\n\n      <div className=\"absolute top-0 left-0 z-0\" ref={canvasContainerRef} />\n    </div>\n  );\n};\n\nexport default FallingText;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import FallingText from \"./component\";\n\nexport default function FallingTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8 w-full h-[400px]\">\n      <FallingText text=\"Hello World from Falling Text\" trigger=\"auto\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "fuzzy-text",
      "type": "component",
      "description": "Text rendered with a fuzzy, vibrating canvas effect.",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/fuzzy-text.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\n\ninterface FuzzyTextProps {\n  children: React.ReactNode;\n  fontSize?: number | string;\n  fontWeight?: string | number;\n  fontFamily?: string;\n  color?: string;\n  enableHover?: boolean;\n  baseIntensity?: number;\n  hoverIntensity?: number;\n  fuzzRange?: number;\n  fps?: number;\n  direction?: 'horizontal' | 'vertical' | 'both';\n  transitionDuration?: number;\n  clickEffect?: boolean;\n  glitchMode?: boolean;\n  glitchInterval?: number;\n  glitchDuration?: number;\n  gradient?: string[] | null;\n  letterSpacing?: number;\n  className?: string;\n}\n\nconst FuzzyText: React.FC<FuzzyTextProps> = ({\n  children,\n  fontSize = 'clamp(2rem, 8vw, 8rem)',\n  fontWeight = 900,\n  fontFamily = 'inherit',\n  color = '#fff',\n  enableHover = true,\n  baseIntensity = 0.18,\n  hoverIntensity = 0.5,\n  fuzzRange = 30,\n  fps = 60,\n  direction = 'horizontal',\n  transitionDuration = 0,\n  clickEffect = false,\n  glitchMode = false,\n  glitchInterval = 2000,\n  glitchDuration = 200,\n  gradient = null,\n  letterSpacing = 0,\n  className = ''\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement & { cleanupFuzzyText?: () => void }>(null);\n\n  useEffect(() => {\n    let animationFrameId: number;\n    let isCancelled = false;\n    let glitchTimeoutId: ReturnType<typeof setTimeout>;\n    let glitchEndTimeoutId: ReturnType<typeof setTimeout>;\n    let clickTimeoutId: ReturnType<typeof setTimeout>;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const init = async () => {\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n\n      const computedFontFamily =\n        fontFamily === 'inherit' ? window.getComputedStyle(canvas).fontFamily || 'sans-serif' : fontFamily;\n\n      const fontSizeStr = typeof fontSize === 'number' ? `${fontSize}px` : fontSize;\n      const fontString = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\n\n      try {\n        await document.fonts.load(fontString);\n      } catch {\n        await document.fonts.ready;\n      }\n      if (isCancelled) return;\n\n      let numericFontSize: number;\n      if (typeof fontSize === 'number') {\n        numericFontSize = fontSize;\n      } else {\n        const temp = document.createElement('span');\n        temp.style.fontSize = fontSize;\n        document.body.appendChild(temp);\n        const computedSize = window.getComputedStyle(temp).fontSize;\n        numericFontSize = parseFloat(computedSize);\n        document.body.removeChild(temp);\n      }\n\n      const text = React.Children.toArray(children).join('');\n\n      const offscreen = document.createElement('canvas');\n      const offCtx = offscreen.getContext('2d');\n      if (!offCtx) return;\n\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\n      offCtx.textBaseline = 'alphabetic';\n\n      let totalWidth = 0;\n      if (letterSpacing !== 0) {\n        for (const char of text) {\n          totalWidth += offCtx.measureText(char).width + letterSpacing;\n        }\n        totalWidth -= letterSpacing;\n      } else {\n        totalWidth = offCtx.measureText(text).width;\n      }\n\n      const metrics = offCtx.measureText(text);\n      const actualLeft = metrics.actualBoundingBoxLeft ?? 0;\n      const actualRight = letterSpacing !== 0 ? totalWidth : (metrics.actualBoundingBoxRight ?? metrics.width);\n      const actualAscent = metrics.actualBoundingBoxAscent ?? numericFontSize;\n      const actualDescent = metrics.actualBoundingBoxDescent ?? numericFontSize * 0.2;\n\n      const textBoundingWidth = Math.ceil(letterSpacing !== 0 ? totalWidth : actualLeft + actualRight);\n      const tightHeight = Math.ceil(actualAscent + actualDescent);\n\n      const extraWidthBuffer = 10;\n      const offscreenWidth = textBoundingWidth + extraWidthBuffer;\n\n      offscreen.width = offscreenWidth;\n      offscreen.height = tightHeight;\n\n      const xOffset = extraWidthBuffer / 2;\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\n      offCtx.textBaseline = 'alphabetic';\n\n      if (gradient && Array.isArray(gradient) && gradient.length >= 2) {\n        const grad = offCtx.createLinearGradient(0, 0, offscreenWidth, 0);\n        gradient.forEach((c, i) => grad.addColorStop(i / (gradient.length - 1), c));\n        offCtx.fillStyle = grad;\n      } else {\n        offCtx.fillStyle = color;\n      }\n\n      if (letterSpacing !== 0) {\n        let xPos = xOffset;\n        for (const char of text) {\n          offCtx.fillText(char, xPos, actualAscent);\n          xPos += offCtx.measureText(char).width + letterSpacing;\n        }\n      } else {\n        offCtx.fillText(text, xOffset - actualLeft, actualAscent);\n      }\n\n      const horizontalMargin = fuzzRange + 20;\n      const verticalMargin = direction === 'vertical' || direction === 'both' ? fuzzRange + 10 : 0;\n      canvas.width = offscreenWidth + horizontalMargin * 2;\n      canvas.height = tightHeight + verticalMargin * 2;\n      ctx.translate(horizontalMargin, verticalMargin);\n\n      const interactiveLeft = horizontalMargin + xOffset;\n      const interactiveTop = verticalMargin;\n      const interactiveRight = interactiveLeft + textBoundingWidth;\n      const interactiveBottom = interactiveTop + tightHeight;\n\n      let isHovering = false;\n      let isClicking = false;\n      let isGlitching = false;\n      let currentIntensity = baseIntensity;\n      let targetIntensity = baseIntensity;\n      let lastFrameTime = 0;\n      const frameDuration = 1000 / fps;\n\n      const startGlitchLoop = () => {\n        if (!glitchMode || isCancelled) return;\n        glitchTimeoutId = setTimeout(() => {\n          if (isCancelled) return;\n          isGlitching = true;\n          glitchEndTimeoutId = setTimeout(() => {\n            isGlitching = false;\n            startGlitchLoop();\n          }, glitchDuration);\n        }, glitchInterval);\n      };\n\n      if (glitchMode) startGlitchLoop();\n\n      const run = (timestamp: number) => {\n        if (isCancelled) return;\n\n        if (timestamp - lastFrameTime < frameDuration) {\n          animationFrameId = window.requestAnimationFrame(run);\n          return;\n        }\n        lastFrameTime = timestamp;\n\n        ctx.clearRect(\n          -fuzzRange - 20,\n          -fuzzRange - 10,\n          offscreenWidth + 2 * (fuzzRange + 20),\n          tightHeight + 2 * (fuzzRange + 10)\n        );\n\n        if (isClicking) {\n          targetIntensity = 1;\n        } else if (isGlitching) {\n          targetIntensity = 1;\n        } else if (isHovering) {\n          targetIntensity = hoverIntensity;\n        } else {\n          targetIntensity = baseIntensity;\n        }\n\n        if (transitionDuration > 0) {\n          const step = 1 / (transitionDuration / frameDuration);\n          if (currentIntensity < targetIntensity) {\n            currentIntensity = Math.min(currentIntensity + step, targetIntensity);\n          } else if (currentIntensity > targetIntensity) {\n            currentIntensity = Math.max(currentIntensity - step, targetIntensity);\n          }\n        } else {\n          currentIntensity = targetIntensity;\n        }\n\n        for (let j = 0; j < tightHeight; j++) {\n          let dx = 0,\n            dy = 0;\n          if (direction === 'horizontal' || direction === 'both') {\n            dx = Math.floor(currentIntensity * (Math.random() - 0.5) * fuzzRange);\n          }\n          if (direction === 'vertical' || direction === 'both') {\n            dy = Math.floor(currentIntensity * (Math.random() - 0.5) * fuzzRange * 0.5);\n          }\n          ctx.drawImage(offscreen, 0, j, offscreenWidth, 1, dx, j + dy, offscreenWidth, 1);\n        }\n        animationFrameId = window.requestAnimationFrame(run);\n      };\n\n      animationFrameId = window.requestAnimationFrame(run);\n\n      const isInsideTextArea = (x: number, y: number) =>\n        x >= interactiveLeft && x <= interactiveRight && y >= interactiveTop && y <= interactiveBottom;\n\n      const handleMouseMove = (e: MouseEvent) => {\n        if (!enableHover) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        isHovering = isInsideTextArea(x, y);\n      };\n\n      const handleMouseLeave = () => {\n        isHovering = false;\n      };\n\n      const handleClick = () => {\n        if (!clickEffect) return;\n        isClicking = true;\n        clearTimeout(clickTimeoutId);\n        clickTimeoutId = setTimeout(() => {\n          isClicking = false;\n        }, 150);\n      };\n\n      const handleTouchMove = (e: TouchEvent) => {\n        if (!enableHover) return;\n        e.preventDefault();\n        const rect = canvas.getBoundingClientRect();\n        const touch = e.touches[0];\n        const x = touch.clientX - rect.left;\n        const y = touch.clientY - rect.top;\n        isHovering = isInsideTextArea(x, y);\n      };\n\n      const handleTouchEnd = () => {\n        isHovering = false;\n      };\n\n      if (enableHover) {\n        canvas.addEventListener('mousemove', handleMouseMove);\n        canvas.addEventListener('mouseleave', handleMouseLeave);\n        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });\n        canvas.addEventListener('touchend', handleTouchEnd);\n      }\n\n      if (clickEffect) {\n        canvas.addEventListener('click', handleClick);\n      }\n\n      const cleanup = () => {\n        window.cancelAnimationFrame(animationFrameId);\n        clearTimeout(glitchTimeoutId);\n        clearTimeout(glitchEndTimeoutId);\n        clearTimeout(clickTimeoutId);\n        if (enableHover) {\n          canvas.removeEventListener('mousemove', handleMouseMove);\n          canvas.removeEventListener('mouseleave', handleMouseLeave);\n          canvas.removeEventListener('touchmove', handleTouchMove);\n          canvas.removeEventListener('touchend', handleTouchEnd);\n        }\n        if (clickEffect) {\n          canvas.removeEventListener('click', handleClick);\n        }\n      };\n\n      canvas.cleanupFuzzyText = cleanup;\n    };\n\n    init();\n\n    return () => {\n      isCancelled = true;\n      window.cancelAnimationFrame(animationFrameId);\n      clearTimeout(glitchTimeoutId);\n      clearTimeout(glitchEndTimeoutId);\n      clearTimeout(clickTimeoutId);\n      if (canvas && canvas.cleanupFuzzyText) {\n        canvas.cleanupFuzzyText();\n      }\n    };\n  }, [\n    children,\n    fontSize,\n    fontWeight,\n    fontFamily,\n    color,\n    enableHover,\n    baseIntensity,\n    hoverIntensity,\n    fuzzRange,\n    fps,\n    direction,\n    transitionDuration,\n    clickEffect,\n    glitchMode,\n    glitchInterval,\n    glitchDuration,\n    gradient,\n    letterSpacing\n  ]);\n\n  return <canvas ref={canvasRef} className={className} />;\n};\n\nexport default FuzzyText;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import FuzzyText from \"./component\";\n\nexport default function FuzzyTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <FuzzyText>Hello World</FuzzyText>\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "glitch-text",
      "type": "component",
      "description": "Text with a glitch distortion animation effect.",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/glitch-text.tsx",
          "content": "import { FC, CSSProperties } from 'react';\n\ninterface GlitchTextProps {\n  children: string;\n  speed?: number;\n  enableShadows?: boolean;\n  enableOnHover?: boolean;\n  className?: string;\n}\n\ninterface CustomCSSProperties extends CSSProperties {\n  '--after-duration': string;\n  '--before-duration': string;\n  '--after-shadow': string;\n  '--before-shadow': string;\n}\n\nconst GlitchText: FC<GlitchTextProps> = ({\n  children,\n  speed = 0.5,\n  enableShadows = true,\n  enableOnHover = false,\n  className = ''\n}) => {\n  const inlineStyles: CustomCSSProperties = {\n    '--after-duration': `${speed * 3}s`,\n    '--before-duration': `${speed * 2}s`,\n    '--after-shadow': enableShadows ? '-5px 0 red' : 'none',\n    '--before-shadow': enableShadows ? '5px 0 cyan' : 'none'\n  };\n\n  const baseClasses = 'text-white text-[clamp(2rem,10vw,8rem)] font-black relative mx-auto select-none cursor-pointer';\n\n  const pseudoClasses = !enableOnHover\n    ? 'after:content-[attr(data-text)] after:absolute after:top-0 after:left-[10px] after:text-white after:bg-[#060010] after:overflow-hidden after:[clip-path:inset(0_0_0_0)] after:[text-shadow:var(--after-shadow)] after:animate-glitch-after ' +\n      'before:content-[attr(data-text)] before:absolute before:top-0 before:left-[-10px] before:text-white before:bg-[#060010] before:overflow-hidden before:[clip-path:inset(0_0_0_0)] before:[text-shadow:var(--before-shadow)] before:animate-glitch-before'\n    : \"after:content-[''] after:absolute after:top-0 after:left-[10px] after:text-white after:bg-[#060010] after:overflow-hidden after:[clip-path:inset(0_0_0_0)] after:opacity-0 \" +\n      \"before:content-[''] before:absolute before:top-0 before:left-[-10px] before:text-white before:bg-[#060010] before:overflow-hidden before:[clip-path:inset(0_0_0_0)] before:opacity-0 \" +\n      'hover:after:content-[attr(data-text)] hover:after:opacity-100 hover:after:[text-shadow:var(--after-shadow)] hover:after:animate-glitch-after ' +\n      'hover:before:content-[attr(data-text)] hover:before:opacity-100 hover:before:[text-shadow:var(--before-shadow)] hover:before:animate-glitch-before';\n\n  const combinedClasses = `${baseClasses} ${pseudoClasses} ${className}`;\n\n  return (\n    <div style={inlineStyles} data-text={children} className={combinedClasses}>\n      {children}\n    </div>\n  );\n};\n\nexport default GlitchText;\n\n// tailwind.config.js\n// module.exports = {\n//   theme: {\n//     extend: {\n//       keyframes: {\n//         glitch: {\n//           \"0%\": { \"clip-path\": \"inset(20% 0 50% 0)\" },\n//           \"5%\": { \"clip-path\": \"inset(10% 0 60% 0)\" },\n//           \"10%\": { \"clip-path\": \"inset(15% 0 55% 0)\" },\n//           \"15%\": { \"clip-path\": \"inset(25% 0 35% 0)\" },\n//           \"20%\": { \"clip-path\": \"inset(30% 0 40% 0)\" },\n//           \"25%\": { \"clip-path\": \"inset(40% 0 20% 0)\" },\n//           \"30%\": { \"clip-path\": \"inset(10% 0 60% 0)\" },\n//           \"35%\": { \"clip-path\": \"inset(15% 0 55% 0)\" },\n//           \"40%\": { \"clip-path\": \"inset(25% 0 35% 0)\" },\n//           \"45%\": { \"clip-path\": \"inset(30% 0 40% 0)\" },\n//           \"50%\": { \"clip-path\": \"inset(20% 0 50% 0)\" },\n//           \"55%\": { \"clip-path\": \"inset(10% 0 60% 0)\" },\n//           \"60%\": { \"clip-path\": \"inset(15% 0 55% 0)\" },\n//           \"65%\": { \"clip-path\": \"inset(25% 0 35% 0)\" },\n//           \"70%\": { \"clip-path\": \"inset(30% 0 40% 0)\" },\n//           \"75%\": { \"clip-path\": \"inset(40% 0 20% 0)\" },\n//           \"80%\": { \"clip-path\": \"inset(20% 0 50% 0)\" },\n//           \"85%\": { \"clip-path\": \"inset(10% 0 60% 0)\" },\n//           \"90%\": { \"clip-path\": \"inset(15% 0 55% 0)\" },\n//           \"95%\": { \"clip-path\": \"inset(25% 0 35% 0)\" },\n//           \"100%\": { \"clip-path\": \"inset(30% 0 40% 0)\" },\n//         },\n//       },\n//       animation: {\n//         \"glitch-after\": \"glitch var(--after-duration) infinite linear alternate-reverse\",\n//         \"glitch-before\": \"glitch var(--before-duration) infinite linear alternate-reverse\",\n//       },\n//     },\n//   },\n//   plugins: [],\n// };\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import GlitchText from \"./component\";\n\nexport default function GlitchTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <GlitchText>Hello World</GlitchText>\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "highlighter",
      "type": "component",
      "description": "A text highlighter that mimics the effect of a human-drawn marker stroke.",
      "category": "text",
      "dependencies": [
        "rough-notation"
      ],
      "files": [
        {
          "path": "components/ui/highlighter.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useRef } from \"react\"\nimport type React from \"react\"\nimport { useInView } from \"motion/react\"\nimport { annotate } from \"rough-notation\"\nimport { type RoughAnnotation } from \"rough-notation/lib/model\"\n\ntype AnnotationAction =\n  | \"highlight\"\n  | \"underline\"\n  | \"box\"\n  | \"circle\"\n  | \"strike-through\"\n  | \"crossed-off\"\n  | \"bracket\"\n\ninterface HighlighterProps {\n  children: React.ReactNode\n  action?: AnnotationAction\n  color?: string\n  strokeWidth?: number\n  animationDuration?: number\n  iterations?: number\n  padding?: number\n  multiline?: boolean\n  isView?: boolean\n}\n\nexport function Highlighter({\n  children,\n  action = \"highlight\",\n  color = \"#ffd1dc\",\n  strokeWidth = 1.5,\n  animationDuration = 600,\n  iterations = 2,\n  padding = 2,\n  multiline = true,\n  isView = false,\n}: HighlighterProps) {\n  const elementRef = useRef<HTMLSpanElement>(null)\n  const annotationRef = useRef<RoughAnnotation | null>(null)\n\n  const isInView = useInView(elementRef, {\n    once: true,\n    margin: \"-10%\",\n  })\n\n  // If isView is false, always show. If isView is true, wait for inView\n  const shouldShow = !isView || isInView\n\n  useEffect(() => {\n    if (!shouldShow) return\n\n    const element = elementRef.current\n    if (!element) return\n\n    const annotationConfig = {\n      type: action,\n      color,\n      strokeWidth,\n      animationDuration,\n      iterations,\n      padding,\n      multiline,\n    }\n\n    const annotation = annotate(element, annotationConfig)\n\n    annotationRef.current = annotation\n    annotationRef.current.show()\n\n    const resizeObserver = new ResizeObserver(() => {\n      annotation.hide()\n      annotation.show()\n    })\n\n    resizeObserver.observe(element)\n    resizeObserver.observe(document.body)\n\n    return () => {\n      if (element) {\n        annotate(element, { type: action }).remove()\n        resizeObserver.disconnect()\n      }\n    }\n  }, [\n    shouldShow,\n    action,\n    color,\n    strokeWidth,\n    animationDuration,\n    iterations,\n    padding,\n    multiline,\n  ])\n\n  return (\n    <span ref={elementRef} className=\"relative inline-block bg-transparent\">\n      {children}\n    </span>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "hyper-text",
      "type": "component",
      "description": "A text animation that scrambles letters before revealing the final text.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/hyper-text.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useRef, useState } from \"react\"\nimport { AnimatePresence, motion, MotionProps } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ntype CharacterSet = string[] | readonly string[]\n\ninterface HyperTextProps extends MotionProps {\n  /** The text content to be animated */\n  children: string\n  /** Optional className for styling */\n  className?: string\n  /** Duration of the animation in milliseconds */\n  duration?: number\n  /** Delay before animation starts in milliseconds */\n  delay?: number\n  /** Component to render as - defaults to div */\n  as?: React.ElementType\n  /** Whether to start animation when element comes into view */\n  startOnView?: boolean\n  /** Whether to trigger animation on hover */\n  animateOnHover?: boolean\n  /** Custom character set for scramble effect. Defaults to uppercase alphabet */\n  characterSet?: CharacterSet\n}\n\nconst DEFAULT_CHARACTER_SET = Object.freeze(\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\")\n) as readonly string[]\n\nconst getRandomInt = (max: number): number => Math.floor(Math.random() * max)\n\nexport function HyperText({\n  children,\n  className,\n  duration = 800,\n  delay = 0,\n  as: Component = \"div\",\n  startOnView = false,\n  animateOnHover = true,\n  characterSet = DEFAULT_CHARACTER_SET,\n  ...props\n}: HyperTextProps) {\n  const MotionComponent = motion.create(Component, {\n    forwardMotionProps: true,\n  })\n\n  const [displayText, setDisplayText] = useState<string[]>(() =>\n    children.split(\"\")\n  )\n  const [isAnimating, setIsAnimating] = useState(false)\n  const iterationCount = useRef(0)\n  const elementRef = useRef<HTMLElement>(null)\n\n  const handleAnimationTrigger = () => {\n    if (animateOnHover && !isAnimating) {\n      iterationCount.current = 0\n      setIsAnimating(true)\n    }\n  }\n\n  // Handle animation start based on view or delay\n  useEffect(() => {\n    if (!startOnView) {\n      const startTimeout = setTimeout(() => {\n        setIsAnimating(true)\n      }, delay)\n      return () => clearTimeout(startTimeout)\n    }\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setTimeout(() => {\n            setIsAnimating(true)\n          }, delay)\n          observer.disconnect()\n        }\n      },\n      { threshold: 0.1, rootMargin: \"-30% 0px -30% 0px\" }\n    )\n\n    if (elementRef.current) {\n      observer.observe(elementRef.current)\n    }\n\n    return () => observer.disconnect()\n  }, [delay, startOnView])\n\n  // Handle scramble animation\n  useEffect(() => {\n    if (!isAnimating) return\n\n    const maxIterations = children.length\n    const startTime = performance.now()\n    let animationFrameId: number\n\n    const animate = (currentTime: number) => {\n      const elapsed = currentTime - startTime\n      const progress = Math.min(elapsed / duration, 1)\n\n      iterationCount.current = progress * maxIterations\n\n      setDisplayText((currentText) =>\n        currentText.map((letter, index) =>\n          letter === \" \"\n            ? letter\n            : index <= iterationCount.current\n              ? children[index]\n              : characterSet[getRandomInt(characterSet.length)]\n        )\n      )\n\n      if (progress < 1) {\n        animationFrameId = requestAnimationFrame(animate)\n      } else {\n        setIsAnimating(false)\n      }\n    }\n\n    animationFrameId = requestAnimationFrame(animate)\n\n    return () => cancelAnimationFrame(animationFrameId)\n  }, [children, duration, isAnimating, characterSet])\n\n  return (\n    <MotionComponent\n      ref={elementRef}\n      className={cn(\"overflow-hidden py-2 text-4xl font-bold\", className)}\n      onMouseEnter={handleAnimationTrigger}\n      {...props}\n    >\n      <AnimatePresence>\n        {displayText.map((letter, index) => (\n          <motion.span\n            key={index}\n            className={cn(\"font-mono\", letter === \" \" ? \"w-3\" : \"\")}\n          >\n            {letter.toUpperCase()}\n          </motion.span>\n        ))}\n      </AnimatePresence>\n    </MotionComponent>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "line-shadow-text",
      "type": "component",
      "description": "A text component with a moving line shadow.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/line-shadow-text.tsx",
          "content": "\"use client\"\n\nimport { motion, MotionProps } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface LineShadowTextProps\n  extends\n    Omit<React.HTMLAttributes<HTMLElement>, keyof MotionProps>,\n    MotionProps {\n  shadowColor?: string\n  as?: React.ElementType\n}\n\nexport function LineShadowText({\n  children,\n  shadowColor = \"black\",\n  className,\n  as: Component = \"span\",\n  ...props\n}: LineShadowTextProps) {\n  const MotionComponent = motion.create(Component)\n  const content = typeof children === \"string\" ? children : null\n\n  if (!content) {\n    throw new Error(\"LineShadowText only accepts string content\")\n  }\n\n  return (\n    <MotionComponent\n      style={{ \"--shadow-color\": shadowColor } as React.CSSProperties}\n      className={cn(\n        \"relative z-0 inline-flex\",\n        \"after:absolute after:top-[0.04em] after:left-[0.04em] after:content-[attr(data-text)]\",\n        \"after:bg-[linear-gradient(45deg,transparent_45%,var(--shadow-color)_45%,var(--shadow-color)_55%,transparent_0)]\",\n        \"after:-z-10 after:bg-[length:0.06em_0.06em] after:bg-clip-text after:text-transparent\",\n        \"after:animate-line-shadow\",\n        className\n      )}\n      data-text={content}\n      {...props}\n    >\n      {content}\n    </MotionComponent>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "morphing-text",
      "type": "component",
      "description": "A dynamic text morphing component.",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/morphing-text.tsx",
          "content": "\"use client\"\n\nimport { useCallback, useEffect, useRef } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst morphTime = 1.5\nconst cooldownTime = 0.5\n\nconst useMorphingText = (texts: string[]) => {\n  const textIndexRef = useRef(0)\n  const morphRef = useRef(0)\n  const cooldownRef = useRef(0)\n  const timeRef = useRef(new Date())\n\n  const text1Ref = useRef<HTMLSpanElement>(null)\n  const text2Ref = useRef<HTMLSpanElement>(null)\n\n  const setStyles = useCallback(\n    (fraction: number) => {\n      const [current1, current2] = [text1Ref.current, text2Ref.current]\n      if (!current1 || !current2) return\n\n      current2.style.filter = `blur(${Math.min(8 / fraction - 8, 100)}px)`\n      current2.style.opacity = `${Math.pow(fraction, 0.4) * 100}%`\n\n      const invertedFraction = 1 - fraction\n      current1.style.filter = `blur(${Math.min(\n        8 / invertedFraction - 8,\n        100\n      )}px)`\n      current1.style.opacity = `${Math.pow(invertedFraction, 0.4) * 100}%`\n\n      current1.textContent = texts[textIndexRef.current % texts.length]\n      current2.textContent = texts[(textIndexRef.current + 1) % texts.length]\n    },\n    [texts]\n  )\n\n  const doMorph = useCallback(() => {\n    morphRef.current -= cooldownRef.current\n    cooldownRef.current = 0\n\n    let fraction = morphRef.current / morphTime\n\n    if (fraction > 1) {\n      cooldownRef.current = cooldownTime\n      fraction = 1\n    }\n\n    setStyles(fraction)\n\n    if (fraction === 1) {\n      textIndexRef.current++\n    }\n  }, [setStyles])\n\n  const doCooldown = useCallback(() => {\n    morphRef.current = 0\n    const [current1, current2] = [text1Ref.current, text2Ref.current]\n    if (current1 && current2) {\n      current2.style.filter = \"none\"\n      current2.style.opacity = \"100%\"\n      current1.style.filter = \"none\"\n      current1.style.opacity = \"0%\"\n    }\n  }, [])\n\n  useEffect(() => {\n    let animationFrameId: number\n\n    const animate = () => {\n      animationFrameId = requestAnimationFrame(animate)\n\n      const newTime = new Date()\n      const dt = (newTime.getTime() - timeRef.current.getTime()) / 1000\n      timeRef.current = newTime\n\n      cooldownRef.current -= dt\n\n      if (cooldownRef.current <= 0) doMorph()\n      else doCooldown()\n    }\n\n    animate()\n    return () => {\n      cancelAnimationFrame(animationFrameId)\n    }\n  }, [doMorph, doCooldown])\n\n  return { text1Ref, text2Ref }\n}\n\ninterface MorphingTextProps {\n  className?: string\n  texts: string[]\n}\n\nconst Texts: React.FC<Pick<MorphingTextProps, \"texts\">> = ({ texts }) => {\n  const { text1Ref, text2Ref } = useMorphingText(texts)\n  return (\n    <>\n      <span\n        className=\"absolute inset-x-0 top-0 m-auto inline-block w-full\"\n        ref={text1Ref}\n      />\n      <span\n        className=\"absolute inset-x-0 top-0 m-auto inline-block w-full\"\n        ref={text2Ref}\n      />\n    </>\n  )\n}\n\nconst SvgFilters: React.FC = () => (\n  <svg\n    id=\"filters\"\n    className=\"fixed h-0 w-0\"\n    preserveAspectRatio=\"xMidYMid slice\"\n  >\n    <defs>\n      <filter id=\"threshold\">\n        <feColorMatrix\n          in=\"SourceGraphic\"\n          type=\"matrix\"\n          values=\"1 0 0 0 0\n                  0 1 0 0 0\n                  0 0 1 0 0\n                  0 0 0 255 -140\"\n        />\n      </filter>\n    </defs>\n  </svg>\n)\n\nexport const MorphingText: React.FC<MorphingTextProps> = ({\n  texts,\n  className,\n}) => (\n  <div\n    className={cn(\n      \"relative mx-auto h-16 w-full max-w-screen-md text-center font-sans text-[40pt] leading-none font-bold [filter:url(#threshold)_blur(0.6px)] md:h-24 lg:text-[6rem]\",\n      className\n    )}\n  >\n    <Texts texts={texts} />\n    <SvgFilters />\n  </div>\n)\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "number-ticker",
      "type": "component",
      "description": "Animate numbers to count up or down to a target number",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/number-ticker.tsx",
          "content": "\"use client\"\n\nimport { ComponentPropsWithoutRef, useEffect, useRef } from \"react\"\nimport { useInView, useMotionValue, useSpring } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface NumberTickerProps extends ComponentPropsWithoutRef<\"span\"> {\n  value: number\n  startValue?: number\n  direction?: \"up\" | \"down\"\n  delay?: number\n  decimalPlaces?: number\n}\n\nexport function NumberTicker({\n  value,\n  startValue = 0,\n  direction = \"up\",\n  delay = 0,\n  className,\n  decimalPlaces = 0,\n  ...props\n}: NumberTickerProps) {\n  const ref = useRef<HTMLSpanElement>(null)\n  const motionValue = useMotionValue(direction === \"down\" ? value : startValue)\n  const springValue = useSpring(motionValue, {\n    damping: 60,\n    stiffness: 100,\n  })\n  const isInView = useInView(ref, { once: true, margin: \"0px\" })\n\n  useEffect(() => {\n    if (isInView) {\n      const timer = setTimeout(() => {\n        motionValue.set(direction === \"down\" ? startValue : value)\n      }, delay * 1000)\n      return () => clearTimeout(timer)\n    }\n  }, [motionValue, isInView, delay, value, direction, startValue])\n\n  useEffect(\n    () =>\n      springValue.on(\"change\", (latest) => {\n        if (ref.current) {\n          ref.current.textContent = Intl.NumberFormat(\"en-US\", {\n            minimumFractionDigits: decimalPlaces,\n            maximumFractionDigits: decimalPlaces,\n          }).format(Number(latest.toFixed(decimalPlaces)))\n        }\n      }),\n    [springValue, decimalPlaces]\n  )\n\n  return (\n    <span\n      ref={ref}\n      className={cn(\n        \"inline-block tracking-wider text-black tabular-nums dark:text-white\",\n        className\n      )}\n      {...props}\n    >\n      {startValue}\n    </span>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "rotating-text",
      "type": "component",
      "description": "Animated text that rotates through a list of strings.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/rotating-text.tsx",
          "content": "import React, { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react';\nimport {\n  motion,\n  AnimatePresence,\n  Transition,\n  type VariantLabels,\n  type Target,\n  type TargetAndTransition\n} from 'motion/react';\n\nfunction cn(...classes: (string | undefined | null | boolean)[]): string {\n  return classes.filter(Boolean).join(' ');\n}\n\nexport interface RotatingTextRef {\n  next: () => void;\n  previous: () => void;\n  jumpTo: (index: number) => void;\n  reset: () => void;\n}\n\nexport interface RotatingTextProps\n  extends Omit<\n    React.ComponentPropsWithoutRef<typeof motion.span>,\n    'children' | 'transition' | 'initial' | 'animate' | 'exit'\n  > {\n  texts: string[];\n  transition?: Transition;\n  initial?: boolean | Target | VariantLabels;\n  animate?: boolean | VariantLabels | TargetAndTransition;\n  exit?: Target | VariantLabels;\n  animatePresenceMode?: 'sync' | 'wait';\n  animatePresenceInitial?: boolean;\n  rotationInterval?: number;\n  staggerDuration?: number;\n  staggerFrom?: 'first' | 'last' | 'center' | 'random' | number;\n  loop?: boolean;\n  auto?: boolean;\n  splitBy?: string;\n  onNext?: (index: number) => void;\n  mainClassName?: string;\n  splitLevelClassName?: string;\n  elementLevelClassName?: string;\n}\n\nconst RotatingText = forwardRef<RotatingTextRef, RotatingTextProps>(\n  (\n    {\n      texts,\n      transition = { type: 'spring', damping: 25, stiffness: 300 },\n      initial = { y: '100%', opacity: 0 },\n      animate = { y: 0, opacity: 1 },\n      exit = { y: '-120%', opacity: 0 },\n      animatePresenceMode = 'wait',\n      animatePresenceInitial = false,\n      rotationInterval = 2000,\n      staggerDuration = 0,\n      staggerFrom = 'first',\n      loop = true,\n      auto = true,\n      splitBy = 'characters',\n      onNext,\n      mainClassName,\n      splitLevelClassName,\n      elementLevelClassName,\n      ...rest\n    },\n    ref\n  ) => {\n    const [currentTextIndex, setCurrentTextIndex] = useState<number>(0);\n\n    const splitIntoCharacters = (text: string): string[] => {\n      if (typeof Intl !== 'undefined' && Intl.Segmenter) {\n        const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });\n        return Array.from(segmenter.segment(text), segment => segment.segment);\n      }\n      return Array.from(text);\n    };\n\n    const elements = useMemo(() => {\n      const currentText: string = texts[currentTextIndex];\n      if (splitBy === 'characters') {\n        const words = currentText.split(' ');\n        return words.map((word, i) => ({\n          characters: splitIntoCharacters(word),\n          needsSpace: i !== words.length - 1\n        }));\n      }\n      if (splitBy === 'words') {\n        return currentText.split(' ').map((word, i, arr) => ({\n          characters: [word],\n          needsSpace: i !== arr.length - 1\n        }));\n      }\n      if (splitBy === 'lines') {\n        return currentText.split('\\n').map((line, i, arr) => ({\n          characters: [line],\n          needsSpace: i !== arr.length - 1\n        }));\n      }\n\n      return currentText.split(splitBy).map((part, i, arr) => ({\n        characters: [part],\n        needsSpace: i !== arr.length - 1\n      }));\n    }, [texts, currentTextIndex, splitBy]);\n\n    const getStaggerDelay = useCallback(\n      (index: number, totalChars: number): number => {\n        const total = totalChars;\n        if (staggerFrom === 'first') return index * staggerDuration;\n        if (staggerFrom === 'last') return (total - 1 - index) * staggerDuration;\n        if (staggerFrom === 'center') {\n          const center = Math.floor(total / 2);\n          return Math.abs(center - index) * staggerDuration;\n        }\n        if (staggerFrom === 'random') {\n          const randomIndex = Math.floor(Math.random() * total);\n          return Math.abs(randomIndex - index) * staggerDuration;\n        }\n        return Math.abs((staggerFrom as number) - index) * staggerDuration;\n      },\n      [staggerFrom, staggerDuration]\n    );\n\n    const handleIndexChange = useCallback(\n      (newIndex: number) => {\n        setCurrentTextIndex(newIndex);\n        if (onNext) onNext(newIndex);\n      },\n      [onNext]\n    );\n\n    const next = useCallback(() => {\n      const nextIndex = currentTextIndex === texts.length - 1 ? (loop ? 0 : currentTextIndex) : currentTextIndex + 1;\n      if (nextIndex !== currentTextIndex) {\n        handleIndexChange(nextIndex);\n      }\n    }, [currentTextIndex, texts.length, loop, handleIndexChange]);\n\n    const previous = useCallback(() => {\n      const prevIndex = currentTextIndex === 0 ? (loop ? texts.length - 1 : currentTextIndex) : currentTextIndex - 1;\n      if (prevIndex !== currentTextIndex) {\n        handleIndexChange(prevIndex);\n      }\n    }, [currentTextIndex, texts.length, loop, handleIndexChange]);\n\n    const jumpTo = useCallback(\n      (index: number) => {\n        const validIndex = Math.max(0, Math.min(index, texts.length - 1));\n        if (validIndex !== currentTextIndex) {\n          handleIndexChange(validIndex);\n        }\n      },\n      [texts.length, currentTextIndex, handleIndexChange]\n    );\n\n    const reset = useCallback(() => {\n      if (currentTextIndex !== 0) {\n        handleIndexChange(0);\n      }\n    }, [currentTextIndex, handleIndexChange]);\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        next,\n        previous,\n        jumpTo,\n        reset\n      }),\n      [next, previous, jumpTo, reset]\n    );\n\n    useEffect(() => {\n      if (!auto) return;\n      const intervalId = setInterval(next, rotationInterval);\n      return () => clearInterval(intervalId);\n    }, [next, rotationInterval, auto]);\n\n    return (\n      <motion.span\n        className={cn('flex flex-wrap whitespace-pre-wrap relative', mainClassName)}\n        {...rest}\n        layout\n        transition={transition}\n      >\n        <span className=\"sr-only\">{texts[currentTextIndex]}</span>\n        <AnimatePresence mode={animatePresenceMode} initial={animatePresenceInitial}>\n          <motion.span\n            key={currentTextIndex}\n            className={cn(splitBy === 'lines' ? 'flex flex-col w-full' : 'flex flex-wrap whitespace-pre-wrap relative')}\n            layout\n            aria-hidden=\"true\"\n          >\n            {elements.map((wordObj, wordIndex, array) => {\n              const previousCharsCount = array\n                .slice(0, wordIndex)\n                .reduce((sum, word) => sum + word.characters.length, 0);\n              return (\n                <span key={wordIndex} className={cn('inline-flex', splitLevelClassName)}>\n                  {wordObj.characters.map((char, charIndex) => (\n                    <motion.span\n                      key={charIndex}\n                      initial={initial}\n                      animate={animate}\n                      exit={exit}\n                      transition={{\n                        ...transition,\n                        delay: getStaggerDelay(\n                          previousCharsCount + charIndex,\n                          array.reduce((sum, word) => sum + word.characters.length, 0)\n                        )\n                      }}\n                      className={cn('inline-block', elementLevelClassName)}\n                    >\n                      {char}\n                    </motion.span>\n                  ))}\n                  {wordObj.needsSpace && <span className=\"whitespace-pre\"> </span>}\n                </span>\n              );\n            })}\n          </motion.span>\n        </AnimatePresence>\n      </motion.span>\n    );\n  }\n);\n\nRotatingText.displayName = 'RotatingText';\nexport default RotatingText;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import RotatingText from \"./component\";\n\nexport default function RotatingTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8 text-2xl\">\n      <RotatingText texts={[\"Hello\", \"World\", \"React\", \"Bits\"]} />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "scrambled-text",
      "type": "component",
      "description": "Text that scrambles on mouse proximity using GSAP.",
      "category": "text",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/scrambled-text.tsx",
          "content": "import React, { useEffect, useRef } from 'react';\nimport { gsap } from 'gsap';\nimport { SplitText } from 'gsap/SplitText';\nimport { ScrambleTextPlugin } from 'gsap/ScrambleTextPlugin';\n\ngsap.registerPlugin(SplitText, ScrambleTextPlugin);\n\nexport interface ScrambledTextProps {\n  radius?: number;\n  duration?: number;\n  speed?: number;\n  scrambleChars?: string;\n  className?: string;\n  style?: React.CSSProperties;\n  children: React.ReactNode;\n}\n\nconst ScrambledText: React.FC<ScrambledTextProps> = ({\n  radius = 100,\n  duration = 1.2,\n  speed = 0.5,\n  scrambleChars = '.:',\n  className = '',\n  style = {},\n  children\n}) => {\n  const rootRef = useRef<HTMLDivElement | null>(null);\n\n  useEffect(() => {\n    if (!rootRef.current) return;\n\n    const split = SplitText.create(rootRef.current.querySelector('p'), {\n      type: 'chars',\n      charsClass: 'inline-block will-change-transform'\n    });\n\n    split.chars.forEach(el => {\n      const c = el as HTMLElement;\n      gsap.set(c, { attr: { 'data-content': c.innerHTML } });\n    });\n\n    const handleMove = (e: PointerEvent) => {\n      split.chars.forEach(el => {\n        const c = el as HTMLElement;\n        const { left, top, width, height } = c.getBoundingClientRect();\n        const dx = e.clientX - (left + width / 2);\n        const dy = e.clientY - (top + height / 2);\n        const dist = Math.hypot(dx, dy);\n\n        if (dist < radius) {\n          gsap.to(c, {\n            overwrite: true,\n            duration: duration * (1 - dist / radius),\n            scrambleText: {\n              text: c.dataset.content || '',\n              chars: scrambleChars,\n              speed\n            },\n            ease: 'none'\n          });\n        }\n      });\n    };\n\n    const el = rootRef.current;\n    el.addEventListener('pointermove', handleMove);\n\n    return () => {\n      el.removeEventListener('pointermove', handleMove);\n      split.revert();\n    };\n  }, [radius, duration, speed, scrambleChars]);\n\n  return (\n    <div\n      ref={rootRef}\n      className={`m-[7vw] max-w-[800px] font-mono text-[clamp(14px,4vw,32px)] text-white ${className}`}\n      style={style}\n    >\n      <p>{children}</p>\n    </div>\n  );\n};\n\nexport default ScrambledText;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import ScrambledText from \"./component\";\n\nexport default function ScrambledTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <ScrambledText>\n        <p>Hello World</p>\n      </ScrambledText>\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "scroll-based-velocity",
      "type": "component",
      "description": "Scrolling text whose speed changes based on scroll speed",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/scroll-based-velocity.tsx",
          "content": "\"use client\"\n\nimport React, { useContext, useEffect, useRef, useState } from \"react\"\nimport {\n  motion,\n  useAnimationFrame,\n  useMotionValue,\n  useScroll,\n  useSpring,\n  useTransform,\n  useVelocity,\n} from \"motion/react\"\nimport type { MotionValue } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface ScrollVelocityRowProps extends React.HTMLAttributes<HTMLDivElement> {\n  children: React.ReactNode\n  baseVelocity?: number\n  direction?: 1 | -1\n}\n\nexport const wrap = (min: number, max: number, v: number) => {\n  const rangeSize = max - min\n  return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min\n}\n\nconst ScrollVelocityContext = React.createContext<MotionValue<number> | null>(\n  null\n)\n\nexport function ScrollVelocityContainer({\n  children,\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  const { scrollY } = useScroll()\n  const scrollVelocity = useVelocity(scrollY)\n  const smoothVelocity = useSpring(scrollVelocity, {\n    damping: 50,\n    stiffness: 400,\n  })\n  const velocityFactor = useTransform(smoothVelocity, (v) => {\n    const sign = v < 0 ? -1 : 1\n    const magnitude = Math.min(5, (Math.abs(v) / 1000) * 5)\n    return sign * magnitude\n  })\n\n  return (\n    <ScrollVelocityContext.Provider value={velocityFactor}>\n      <div className={cn(\"relative w-full\", className)} {...props}>\n        {children}\n      </div>\n    </ScrollVelocityContext.Provider>\n  )\n}\n\nexport function ScrollVelocityRow(props: ScrollVelocityRowProps) {\n  const sharedVelocityFactor = useContext(ScrollVelocityContext)\n  if (sharedVelocityFactor) {\n    return (\n      <ScrollVelocityRowImpl {...props} velocityFactor={sharedVelocityFactor} />\n    )\n  }\n  return <ScrollVelocityRowLocal {...props} />\n}\n\ninterface ScrollVelocityRowImplProps extends ScrollVelocityRowProps {\n  velocityFactor: MotionValue<number>\n}\n\nfunction ScrollVelocityRowImpl({\n  children,\n  baseVelocity = 5,\n  direction = 1,\n  className,\n  velocityFactor,\n  ...props\n}: ScrollVelocityRowImplProps) {\n  const containerRef = useRef<HTMLDivElement>(null)\n  const blockRef = useRef<HTMLDivElement>(null)\n  const [numCopies, setNumCopies] = useState(1)\n\n  const baseX = useMotionValue(0)\n  const baseDirectionRef = useRef<number>(direction >= 0 ? 1 : -1)\n  const currentDirectionRef = useRef<number>(direction >= 0 ? 1 : -1)\n  const unitWidth = useMotionValue(0)\n\n  const isInViewRef = useRef(true)\n  const isPageVisibleRef = useRef(true)\n  const prefersReducedMotionRef = useRef(false)\n\n  useEffect(() => {\n    const container = containerRef.current\n    const block = blockRef.current\n    if (!container || !block) return\n\n    const updateSizes = () => {\n      const cw = container.offsetWidth || 0\n      const bw = block.scrollWidth || 0\n      unitWidth.set(bw)\n      const nextCopies = bw > 0 ? Math.max(3, Math.ceil(cw / bw) + 2) : 1\n      setNumCopies((prev) => (prev === nextCopies ? prev : nextCopies))\n    }\n\n    updateSizes()\n\n    const ro = new ResizeObserver(updateSizes)\n    ro.observe(container)\n    ro.observe(block)\n\n    const io = new IntersectionObserver(([entry]) => {\n      isInViewRef.current = entry.isIntersecting\n    })\n    io.observe(container)\n\n    const handleVisibility = () => {\n      isPageVisibleRef.current = document.visibilityState === \"visible\"\n    }\n    document.addEventListener(\"visibilitychange\", handleVisibility, {\n      passive: true,\n    })\n    handleVisibility()\n\n    const mq = window.matchMedia(\"(prefers-reduced-motion: reduce)\")\n    const handlePRM = () => {\n      prefersReducedMotionRef.current = mq.matches\n    }\n    mq.addEventListener(\"change\", handlePRM)\n    handlePRM()\n\n    return () => {\n      ro.disconnect()\n      io.disconnect()\n      document.removeEventListener(\"visibilitychange\", handleVisibility)\n      mq.removeEventListener(\"change\", handlePRM)\n    }\n  }, [children, unitWidth])\n\n  const x = useTransform([baseX, unitWidth], ([v, bw]) => {\n    const width = Number(bw) || 1\n    const offset = Number(v) || 0\n    return `${-wrap(0, width, offset)}px`\n  })\n\n  useAnimationFrame((_, delta) => {\n    if (!isInViewRef.current || !isPageVisibleRef.current) return\n    const dt = delta / 1000\n    const vf = velocityFactor.get()\n    const absVf = Math.min(5, Math.abs(vf))\n    const speedMultiplier = prefersReducedMotionRef.current ? 1 : 1 + absVf\n\n    if (absVf > 0.1) {\n      const scrollDirection = vf >= 0 ? 1 : -1\n      currentDirectionRef.current = baseDirectionRef.current * scrollDirection\n    }\n\n    const bw = unitWidth.get() || 0\n    if (bw <= 0) return\n    const pixelsPerSecond = (bw * baseVelocity) / 100\n    const moveBy =\n      currentDirectionRef.current * pixelsPerSecond * speedMultiplier * dt\n    baseX.set(baseX.get() + moveBy)\n  })\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\"w-full overflow-hidden whitespace-nowrap\", className)}\n      {...props}\n    >\n      <motion.div\n        className=\"inline-flex transform-gpu items-center will-change-transform select-none\"\n        style={{ x }}\n      >\n        {Array.from({ length: numCopies }).map((_, i) => (\n          <div\n            key={i}\n            ref={i === 0 ? blockRef : null}\n            aria-hidden={i !== 0}\n            className=\"inline-flex shrink-0 items-center\"\n          >\n            {children}\n          </div>\n        ))}\n      </motion.div>\n    </div>\n  )\n}\n\nfunction ScrollVelocityRowLocal(props: ScrollVelocityRowProps) {\n  const { scrollY } = useScroll()\n  const localVelocity = useVelocity(scrollY)\n  const localSmoothVelocity = useSpring(localVelocity, {\n    damping: 50,\n    stiffness: 400,\n  })\n  const localVelocityFactor = useTransform(localSmoothVelocity, (v) => {\n    const sign = v < 0 ? -1 : 1\n    const magnitude = Math.min(5, (Math.abs(v) / 1000) * 5)\n    return sign * magnitude\n  })\n  return (\n    <ScrollVelocityRowImpl {...props} velocityFactor={localVelocityFactor} />\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "scroll-float",
      "type": "component",
      "description": "Characters float into view on scroll using GSAP ScrollTrigger.",
      "category": "text",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/scroll-float.tsx",
          "content": "import React, { useEffect, useMemo, useRef, ReactNode, RefObject } from 'react';\nimport { gsap } from 'gsap';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\n\ngsap.registerPlugin(ScrollTrigger);\n\ninterface ScrollFloatProps {\n  children: ReactNode;\n  scrollContainerRef?: RefObject<HTMLElement>;\n  containerClassName?: string;\n  textClassName?: string;\n  animationDuration?: number;\n  ease?: string;\n  scrollStart?: string;\n  scrollEnd?: string;\n  stagger?: number;\n}\n\nconst ScrollFloat: React.FC<ScrollFloatProps> = ({\n  children,\n  scrollContainerRef,\n  containerClassName = '',\n  textClassName = '',\n  animationDuration = 1,\n  ease = 'back.inOut(2)',\n  scrollStart = 'center bottom+=50%',\n  scrollEnd = 'bottom bottom-=40%',\n  stagger = 0.03\n}) => {\n  const containerRef = useRef<HTMLHeadingElement>(null);\n\n  const splitText = useMemo(() => {\n    const text = typeof children === 'string' ? children : '';\n    return text.split('').map((char, index) => (\n      <span className=\"inline-block word\" key={index}>\n        {char === ' ' ? '\\u00A0' : char}\n      </span>\n    ));\n  }, [children]);\n\n  useEffect(() => {\n    const el = containerRef.current;\n    if (!el) return;\n\n    const scroller = scrollContainerRef && scrollContainerRef.current ? scrollContainerRef.current : window;\n\n    const charElements = el.querySelectorAll('.inline-block');\n\n    gsap.fromTo(\n      charElements,\n      {\n        willChange: 'opacity, transform',\n        opacity: 0,\n        yPercent: 120,\n        scaleY: 2.3,\n        scaleX: 0.7,\n        transformOrigin: '50% 0%'\n      },\n      {\n        duration: animationDuration,\n        ease: ease,\n        opacity: 1,\n        yPercent: 0,\n        scaleY: 1,\n        scaleX: 1,\n        stagger: stagger,\n        scrollTrigger: {\n          trigger: el,\n          scroller,\n          start: scrollStart,\n          end: scrollEnd,\n          scrub: true\n        }\n      }\n    );\n  }, [scrollContainerRef, animationDuration, ease, scrollStart, scrollEnd, stagger]);\n\n  return (\n    <h2 ref={containerRef} className={`my-5 overflow-hidden ${containerClassName}`}>\n      <span className={`inline-block text-[clamp(1.6rem,4vw,3rem)] leading-[1.5] ${textClassName}`}>{splitText}</span>\n    </h2>\n  );\n};\n\nexport default ScrollFloat;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import ScrollFloat from \"./component\";\n\nexport default function ScrollFloatExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <ScrollFloat>Hello World</ScrollFloat>\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "scroll-reveal",
      "type": "component",
      "description": "Words reveal with opacity and blur on scroll using GSAP.",
      "category": "text",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/scroll-reveal.tsx",
          "content": "import React, { useEffect, useRef, useMemo, ReactNode, RefObject } from 'react';\nimport { gsap } from 'gsap';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\n\ngsap.registerPlugin(ScrollTrigger);\n\ninterface ScrollRevealProps {\n  children: ReactNode;\n  scrollContainerRef?: RefObject<HTMLElement>;\n  enableBlur?: boolean;\n  baseOpacity?: number;\n  baseRotation?: number;\n  blurStrength?: number;\n  containerClassName?: string;\n  textClassName?: string;\n  rotationEnd?: string;\n  wordAnimationEnd?: string;\n}\n\nconst ScrollReveal: React.FC<ScrollRevealProps> = ({\n  children,\n  scrollContainerRef,\n  enableBlur = true,\n  baseOpacity = 0.1,\n  baseRotation = 3,\n  blurStrength = 4,\n  containerClassName = '',\n  textClassName = '',\n  rotationEnd = 'bottom bottom',\n  wordAnimationEnd = 'bottom bottom'\n}) => {\n  const containerRef = useRef<HTMLHeadingElement>(null);\n\n  const splitText = useMemo(() => {\n    const text = typeof children === 'string' ? children : '';\n    return text.split(/(\\s+)/).map((word, index) => {\n      if (word.match(/^\\s+$/)) return word;\n      return (\n        <span className=\"inline-block word\" key={index}>\n          {word}\n        </span>\n      );\n    });\n  }, [children]);\n\n  useEffect(() => {\n    const el = containerRef.current;\n    if (!el) return;\n\n    const scroller = scrollContainerRef && scrollContainerRef.current ? scrollContainerRef.current : window;\n\n    gsap.fromTo(\n      el,\n      { transformOrigin: '0% 50%', rotate: baseRotation },\n      {\n        ease: 'none',\n        rotate: 0,\n        scrollTrigger: {\n          trigger: el,\n          scroller,\n          start: 'top bottom',\n          end: rotationEnd,\n          scrub: true\n        }\n      }\n    );\n\n    const wordElements = el.querySelectorAll<HTMLElement>('.word');\n\n    gsap.fromTo(\n      wordElements,\n      { opacity: baseOpacity, willChange: 'opacity' },\n      {\n        ease: 'none',\n        opacity: 1,\n        stagger: 0.05,\n        scrollTrigger: {\n          trigger: el,\n          scroller,\n          start: 'top bottom-=20%',\n          end: wordAnimationEnd,\n          scrub: true\n        }\n      }\n    );\n\n    if (enableBlur) {\n      gsap.fromTo(\n        wordElements,\n        { filter: `blur(${blurStrength}px)` },\n        {\n          ease: 'none',\n          filter: 'blur(0px)',\n          stagger: 0.05,\n          scrollTrigger: {\n            trigger: el,\n            scroller,\n            start: 'top bottom-=20%',\n            end: wordAnimationEnd,\n            scrub: true\n          }\n        }\n      );\n    }\n\n    return () => {\n      ScrollTrigger.getAll().forEach(trigger => trigger.kill());\n    };\n  }, [scrollContainerRef, enableBlur, baseRotation, baseOpacity, rotationEnd, wordAnimationEnd, blurStrength]);\n\n  return (\n    <h2 ref={containerRef} className={`my-5 ${containerClassName}`}>\n      <p className={`text-[clamp(1.6rem,4vw,3rem)] leading-[1.5] font-semibold ${textClassName}`}>{splitText}</p>\n    </h2>\n  );\n};\n\nexport default ScrollReveal;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import ScrollReveal from \"./component\";\n\nexport default function ScrollRevealExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <ScrollReveal>Hello World from Scroll Reveal</ScrollReveal>\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "shuffle",
      "type": "component",
      "description": "Text characters shuffle and rearrange with a GSAP animation.",
      "category": "text",
      "dependencies": [
        "gsap",
        "@gsap/react"
      ],
      "files": [
        {
          "path": "components/ui/shuffle.tsx",
          "content": "import React, { useRef, useEffect, useState, useMemo } from 'react';\nimport { gsap } from 'gsap';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\nimport { SplitText as GSAPSplitText } from 'gsap/SplitText';\nimport { useGSAP } from '@gsap/react';\nimport { JSX } from 'react';\n\ngsap.registerPlugin(ScrollTrigger, GSAPSplitText);\n\nexport interface ShuffleProps {\n  text: string;\n  className?: string;\n  style?: React.CSSProperties;\n  shuffleDirection?: 'left' | 'right' | 'up' | 'down';\n  duration?: number;\n  maxDelay?: number;\n  ease?: string | ((t: number) => number);\n  threshold?: number;\n  rootMargin?: string;\n  tag?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p' | 'span';\n  textAlign?: React.CSSProperties['textAlign'];\n  onShuffleComplete?: () => void;\n  shuffleTimes?: number;\n  animationMode?: 'random' | 'evenodd';\n  loop?: boolean;\n  loopDelay?: number;\n  stagger?: number;\n  scrambleCharset?: string;\n  colorFrom?: string;\n  colorTo?: string;\n  triggerOnce?: boolean;\n  respectReducedMotion?: boolean;\n  triggerOnHover?: boolean;\n}\n\nconst Shuffle: React.FC<ShuffleProps> = ({\n  text,\n  className = '',\n  style = {},\n  shuffleDirection = 'right',\n  duration = 0.35,\n  maxDelay = 0,\n  ease = 'power3.out',\n  threshold = 0.1,\n  rootMargin = '-100px',\n  tag = 'p',\n  textAlign = 'center',\n  onShuffleComplete,\n  shuffleTimes = 1,\n  animationMode = 'evenodd',\n  loop = false,\n  loopDelay = 0,\n  stagger = 0.03,\n  scrambleCharset = '',\n  colorFrom,\n  colorTo,\n  triggerOnce = true,\n  respectReducedMotion = true,\n  triggerOnHover = true\n}) => {\n  const ref = useRef<HTMLElement>(null);\n  const [fontsLoaded, setFontsLoaded] = useState(false);\n  const [ready, setReady] = useState(false);\n\n  const splitRef = useRef<GSAPSplitText | null>(null);\n  const wrappersRef = useRef<HTMLElement[]>([]);\n  const tlRef = useRef<gsap.core.Timeline | null>(null);\n  const playingRef = useRef(false);\n  const hoverHandlerRef = useRef<((e: Event) => void) | null>(null);\n\n  useEffect(() => {\n    if ('fonts' in document) {\n      if (document.fonts.status === 'loaded') setFontsLoaded(true);\n      else document.fonts.ready.then(() => setFontsLoaded(true));\n    } else setFontsLoaded(true);\n  }, []);\n\n  const scrollTriggerStart = useMemo(() => {\n    const startPct = (1 - threshold) * 100;\n    const mm = /^(-?\\d+(?:\\.\\d+)?)(px|em|rem|%)?$/.exec(rootMargin || '');\n    const mv = mm ? parseFloat(mm[1]) : 0;\n    const mu = mm ? mm[2] || 'px' : 'px';\n    const sign = mv === 0 ? '' : mv < 0 ? `-=${Math.abs(mv)}${mu}` : `+=${mv}${mu}`;\n    return `top ${startPct}%${sign}`;\n  }, [threshold, rootMargin]);\n\n  useGSAP(\n    () => {\n      if (!ref.current || !text || !fontsLoaded) return;\n      if (respectReducedMotion && window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\n        onShuffleComplete?.();\n        return;\n      }\n\n      const el = ref.current as HTMLElement;\n      const start = scrollTriggerStart;\n\n      const removeHover = () => {\n        if (hoverHandlerRef.current && ref.current) {\n          ref.current.removeEventListener('mouseenter', hoverHandlerRef.current);\n          hoverHandlerRef.current = null;\n        }\n      };\n\n      const teardown = () => {\n        if (tlRef.current) {\n          tlRef.current.kill();\n          tlRef.current = null;\n        }\n        if (wrappersRef.current.length) {\n          wrappersRef.current.forEach(wrap => {\n            const inner = wrap.firstElementChild as HTMLElement | null;\n            const orig = inner?.querySelector('[data-orig=\"1\"]') as HTMLElement | null;\n            if (orig && wrap.parentNode) wrap.parentNode.replaceChild(orig, wrap);\n          });\n          wrappersRef.current = [];\n        }\n        try {\n          splitRef.current?.revert();\n        } catch {}\n        splitRef.current = null;\n        playingRef.current = false;\n      };\n\n      const build = () => {\n        teardown();\n\n        const computedFont = getComputedStyle(el).fontFamily;\n\n        splitRef.current = new GSAPSplitText(el, {\n          type: 'chars',\n          charsClass: 'shuffle-char',\n          wordsClass: 'shuffle-word',\n          linesClass: 'shuffle-line',\n          smartWrap: true,\n          reduceWhiteSpace: false\n        });\n\n        const chars = (splitRef.current.chars || []) as HTMLElement[];\n        wrappersRef.current = [];\n\n        const rolls = Math.max(1, Math.floor(shuffleTimes));\n        const rand = (set: string) => set.charAt(Math.floor(Math.random() * set.length)) || '';\n\n        chars.forEach(ch => {\n          const parent = ch.parentElement;\n          if (!parent) return;\n\n          const w = ch.getBoundingClientRect().width;\n          const h = ch.getBoundingClientRect().height;\n          if (!w) return;\n\n          const wrap = document.createElement('span');\n          wrap.className = 'inline-block overflow-hidden text-left';\n          Object.assign(wrap.style, {\n            width: w + 'px',\n            height: shuffleDirection === 'up' || shuffleDirection === 'down' ? h + 'px' : 'auto',\n            verticalAlign: 'bottom'\n          });\n\n          const inner = document.createElement('span');\n          inner.className =\n            'inline-block will-change-transform origin-left transform-gpu ' +\n            (shuffleDirection === 'up' || shuffleDirection === 'down' ? 'whitespace-normal' : 'whitespace-nowrap');\n\n          parent.insertBefore(wrap, ch);\n          wrap.appendChild(inner);\n\n          const firstOrig = ch.cloneNode(true) as HTMLElement;\n          firstOrig.className =\n            'text-left ' + (shuffleDirection === 'up' || shuffleDirection === 'down' ? 'block' : 'inline-block');\n          Object.assign(firstOrig.style, { width: w + 'px', fontFamily: computedFont });\n\n          ch.setAttribute('data-orig', '1');\n          ch.className =\n            'text-left ' + (shuffleDirection === 'up' || shuffleDirection === 'down' ? 'block' : 'inline-block');\n          Object.assign(ch.style, { width: w + 'px', fontFamily: computedFont });\n\n          inner.appendChild(firstOrig);\n          for (let k = 0; k < rolls; k++) {\n            const c = ch.cloneNode(true) as HTMLElement;\n            if (scrambleCharset) c.textContent = rand(scrambleCharset);\n            c.className =\n              'text-left ' + (shuffleDirection === 'up' || shuffleDirection === 'down' ? 'block' : 'inline-block');\n            Object.assign(c.style, { width: w + 'px', fontFamily: computedFont });\n            inner.appendChild(c);\n          }\n          inner.appendChild(ch);\n\n          const steps = rolls + 1;\n\n          if (shuffleDirection === 'right' || shuffleDirection === 'down') {\n            const firstCopy = inner.firstElementChild as HTMLElement | null;\n            const real = inner.lastElementChild as HTMLElement | null;\n            if (real) inner.insertBefore(real, inner.firstChild);\n            if (firstCopy) inner.appendChild(firstCopy);\n          }\n\n          let startX = 0;\n          let finalX = 0;\n          let startY = 0;\n          let finalY = 0;\n\n          if (shuffleDirection === 'right') {\n            startX = -steps * w;\n            finalX = 0;\n          } else if (shuffleDirection === 'left') {\n            startX = 0;\n            finalX = -steps * w;\n          } else if (shuffleDirection === 'down') {\n            startY = -steps * h;\n            finalY = 0;\n          } else if (shuffleDirection === 'up') {\n            startY = 0;\n            finalY = -steps * h;\n          }\n\n          if (shuffleDirection === 'left' || shuffleDirection === 'right') {\n            gsap.set(inner, { x: startX, y: 0, force3D: true });\n            inner.setAttribute('data-start-x', String(startX));\n            inner.setAttribute('data-final-x', String(finalX));\n          } else {\n            gsap.set(inner, { x: 0, y: startY, force3D: true });\n            inner.setAttribute('data-start-y', String(startY));\n            inner.setAttribute('data-final-y', String(finalY));\n          }\n\n          if (colorFrom) (inner.style as any).color = colorFrom;\n          wrappersRef.current.push(wrap);\n        });\n      };\n\n      const inners = () => wrappersRef.current.map(w => w.firstElementChild as HTMLElement);\n\n      const randomizeScrambles = () => {\n        if (!scrambleCharset) return;\n        wrappersRef.current.forEach(w => {\n          const strip = w.firstElementChild as HTMLElement;\n          if (!strip) return;\n          const kids = Array.from(strip.children) as HTMLElement[];\n          for (let i = 1; i < kids.length - 1; i++) {\n            kids[i].textContent = scrambleCharset.charAt(Math.floor(Math.random() * scrambleCharset.length));\n          }\n        });\n      };\n\n      const cleanupToStill = () => {\n        wrappersRef.current.forEach(w => {\n          const strip = w.firstElementChild as HTMLElement;\n          if (!strip) return;\n          const real = strip.querySelector('[data-orig=\"1\"]') as HTMLElement | null;\n          if (!real) return;\n          strip.replaceChildren(real);\n          strip.style.transform = 'none';\n          strip.style.willChange = 'auto';\n        });\n      };\n\n      const play = () => {\n        const strips = inners();\n        if (!strips.length) return;\n\n        playingRef.current = true;\n        const isVertical = shuffleDirection === 'up' || shuffleDirection === 'down';\n\n        const tl = gsap.timeline({\n          smoothChildTiming: true,\n          repeat: loop ? -1 : 0,\n          repeatDelay: loop ? loopDelay : 0,\n          onRepeat: () => {\n            if (scrambleCharset) randomizeScrambles();\n            if (isVertical) {\n              gsap.set(strips, { y: (i, t: HTMLElement) => parseFloat(t.getAttribute('data-start-y') || '0') });\n            } else {\n              gsap.set(strips, { x: (i, t: HTMLElement) => parseFloat(t.getAttribute('data-start-x') || '0') });\n            }\n            onShuffleComplete?.();\n          },\n          onComplete: () => {\n            playingRef.current = false;\n            if (!loop) {\n              cleanupToStill();\n              if (colorTo) gsap.set(strips, { color: colorTo });\n              onShuffleComplete?.();\n              armHover();\n            }\n          }\n        });\n\n        const addTween = (targets: HTMLElement[], at: number) => {\n          const vars: any = {\n            duration,\n            ease,\n            force3D: true,\n            stagger: animationMode === 'evenodd' ? stagger : 0\n          };\n          if (isVertical) {\n            vars.y = (i: number, t: HTMLElement) => parseFloat(t.getAttribute('data-final-y') || '0');\n          } else {\n            vars.x = (i: number, t: HTMLElement) => parseFloat(t.getAttribute('data-final-x') || '0');\n          }\n\n          tl.to(targets, vars, at);\n\n          if (colorFrom && colorTo) tl.to(targets, { color: colorTo, duration, ease }, at);\n        };\n\n        if (animationMode === 'evenodd') {\n          const odd = strips.filter((_, i) => i % 2 === 1);\n          const even = strips.filter((_, i) => i % 2 === 0);\n          const oddTotal = duration + Math.max(0, odd.length - 1) * stagger;\n          const evenStart = odd.length ? oddTotal * 0.7 : 0;\n          if (odd.length) addTween(odd, 0);\n          if (even.length) addTween(even, evenStart);\n        } else {\n          strips.forEach(strip => {\n            const d = Math.random() * maxDelay;\n            const vars: any = {\n              duration,\n              ease,\n              force3D: true\n            };\n            if (isVertical) {\n              vars.y = parseFloat(strip.getAttribute('data-final-y') || '0');\n            } else {\n              vars.x = parseFloat(strip.getAttribute('data-final-x') || '0');\n            }\n            tl.to(strip, vars, d);\n            if (colorFrom && colorTo) tl.fromTo(strip, { color: colorFrom }, { color: colorTo, duration, ease }, d);\n          });\n        }\n\n        tlRef.current = tl;\n      };\n\n      const armHover = () => {\n        if (!triggerOnHover || !ref.current) return;\n        removeHover();\n        const handler = () => {\n          if (playingRef.current) return;\n          build();\n          if (scrambleCharset) randomizeScrambles();\n          play();\n        };\n        hoverHandlerRef.current = handler;\n        ref.current.addEventListener('mouseenter', handler);\n      };\n\n      const create = () => {\n        build();\n        if (scrambleCharset) randomizeScrambles();\n        play();\n        armHover();\n        setReady(true);\n      };\n\n      const st = ScrollTrigger.create({\n        trigger: el,\n        start,\n        once: triggerOnce,\n        onEnter: create\n      });\n\n      return () => {\n        st.kill();\n        removeHover();\n        teardown();\n        setReady(false);\n      };\n    },\n    {\n      dependencies: [\n        text,\n        duration,\n        maxDelay,\n        ease,\n        scrollTriggerStart,\n        fontsLoaded,\n        shuffleDirection,\n        shuffleTimes,\n        animationMode,\n        loop,\n        loopDelay,\n        stagger,\n        scrambleCharset,\n        colorFrom,\n        colorTo,\n        triggerOnce,\n        respectReducedMotion,\n        triggerOnHover,\n        onShuffleComplete\n      ],\n      scope: ref\n    }\n  );\n\n  const baseTw = 'inline-block whitespace-normal break-words will-change-transform uppercase text-2xl leading-none';\n  const userHasFont = useMemo(() => className && /font[-[]/i.test(className), [className]);\n\n  const fallbackFont = useMemo(\n    () => (userHasFont ? {} : { fontFamily: `'Press Start 2P', sans-serif` }),\n    [userHasFont]\n  );\n\n  const commonStyle = useMemo(\n    () => ({\n      textAlign,\n      ...fallbackFont,\n      ...style\n    }),\n    [textAlign, fallbackFont, style]\n  );\n\n  const classes = useMemo(\n    () => `${baseTw} ${ready ? 'visible' : 'invisible'} ${className}`.trim(),\n    [baseTw, ready, className]\n  );\n  const Tag = (tag || 'p') as keyof JSX.IntrinsicElements;\n\n  return React.createElement(Tag, { ref: ref as any, className: classes, style: commonStyle }, text);\n};\n\nexport default Shuffle;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import Shuffle from \"./component\";\n\nexport default function ShuffleExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <Shuffle text=\"Hello World\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "sparkles-text",
      "type": "component",
      "description": "A dynamic text that generates continuous sparkles with smooth transitions.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/sparkles-text.tsx",
          "content": "\"use client\"\n\nimport { CSSProperties, ReactElement, useEffect, useState } from \"react\"\nimport { motion } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface Sparkle {\n  id: string\n  x: string\n  y: string\n  color: string\n  delay: number\n  scale: number\n  lifespan: number\n}\n\nconst Sparkle: React.FC<Sparkle> = ({ id, x, y, color, delay, scale }) => {\n  return (\n    <motion.svg\n      key={id}\n      className=\"pointer-events-none absolute z-20\"\n      initial={{ opacity: 0, left: x, top: y }}\n      animate={{\n        opacity: [0, 1, 0],\n        scale: [0, scale, 0],\n        rotate: [75, 120, 150],\n      }}\n      transition={{ duration: 0.8, repeat: Infinity, delay }}\n      width=\"21\"\n      height=\"21\"\n      viewBox=\"0 0 21 21\"\n    >\n      <path\n        d=\"M9.82531 0.843845C10.0553 0.215178 10.9446 0.215178 11.1746 0.843845L11.8618 2.72026C12.4006 4.19229 12.3916 6.39157 13.5 7.5C14.6084 8.60843 16.8077 8.59935 18.2797 9.13822L20.1561 9.82534C20.7858 10.0553 20.7858 10.9447 20.1561 11.1747L18.2797 11.8618C16.8077 12.4007 14.6084 12.3916 13.5 13.5C12.3916 14.6084 12.4006 16.8077 11.8618 18.2798L11.1746 20.1562C10.9446 20.7858 10.0553 20.7858 9.82531 20.1562L9.13819 18.2798C8.59932 16.8077 8.60843 14.6084 7.5 13.5C6.39157 12.3916 4.19225 12.4007 2.72023 11.8618L0.843814 11.1747C0.215148 10.9447 0.215148 10.0553 0.843814 9.82534L2.72023 9.13822C4.19225 8.59935 6.39157 8.60843 7.5 7.5C8.60843 6.39157 8.59932 4.19229 9.13819 2.72026L9.82531 0.843845Z\"\n        fill={color}\n      />\n    </motion.svg>\n  )\n}\n\ninterface SparklesTextProps {\n  /**\n   * @default <div />\n   * @type ReactElement\n   * @description\n   * The component to be rendered as the text\n   * */\n  as?: ReactElement\n\n  /**\n   * @default \"\"\n   * @type string\n   * @description\n   * The className of the text\n   */\n  className?: string\n\n  /**\n   * @required\n   * @type ReactNode\n   * @description\n   * The content to be displayed\n   * */\n  children: React.ReactNode\n\n  /**\n   * @default 10\n   * @type number\n   * @description\n   * The count of sparkles\n   * */\n  sparklesCount?: number\n\n  /**\n   * @default \"{first: '#9E7AFF', second: '#FE8BBB'}\"\n   * @type string\n   * @description\n   * The colors of the sparkles\n   * */\n  colors?: {\n    first: string\n    second: string\n  }\n}\n\nexport const SparklesText: React.FC<SparklesTextProps> = ({\n  children,\n  colors = { first: \"#9E7AFF\", second: \"#FE8BBB\" },\n  className,\n  sparklesCount = 10,\n  ...props\n}) => {\n  const [sparkles, setSparkles] = useState<Sparkle[]>([])\n\n  useEffect(() => {\n    const generateStar = (): Sparkle => {\n      const starX = `${Math.random() * 100}%`\n      const starY = `${Math.random() * 100}%`\n      const color = Math.random() > 0.5 ? colors.first : colors.second\n      const delay = Math.random() * 2\n      const scale = Math.random() * 1 + 0.3\n      const lifespan = Math.random() * 10 + 5\n      const id = `${starX}-${starY}-${Date.now()}`\n      return { id, x: starX, y: starY, color, delay, scale, lifespan }\n    }\n\n    const initializeStars = () => {\n      const newSparkles = Array.from({ length: sparklesCount }, generateStar)\n      setSparkles(newSparkles)\n    }\n\n    const updateStars = () => {\n      setSparkles((currentSparkles) =>\n        currentSparkles.map((star) => {\n          if (star.lifespan <= 0) {\n            return generateStar()\n          } else {\n            return { ...star, lifespan: star.lifespan - 0.1 }\n          }\n        })\n      )\n    }\n\n    initializeStars()\n    const interval = setInterval(updateStars, 100)\n\n    return () => clearInterval(interval)\n  }, [colors.first, colors.second, sparklesCount])\n\n  return (\n    <div\n      className={cn(\"text-6xl font-bold\", className)}\n      {...props}\n      style={\n        {\n          \"--sparkles-first-color\": `${colors.first}`,\n          \"--sparkles-second-color\": `${colors.second}`,\n        } as CSSProperties\n      }\n    >\n      <span className=\"relative inline-block\">\n        {sparkles.map((sparkle) => (\n          <Sparkle key={sparkle.id} {...sparkle} />\n        ))}\n        <strong>{children}</strong>\n      </span>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "spinning-text",
      "type": "component",
      "description": "The Spinning Text component animates text in a circular motion.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/spinning-text.tsx",
          "content": "\"use client\"\n\nimport React, { ComponentPropsWithoutRef } from \"react\"\nimport { motion, Transition, Variants } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface SpinningTextProps extends ComponentPropsWithoutRef<\"div\"> {\n  children: string | string[]\n  duration?: number\n  reverse?: boolean\n  radius?: number\n  transition?: Transition\n  variants?: {\n    container?: Variants\n    item?: Variants\n  }\n}\n\nconst BASE_TRANSITION: Transition = {\n  repeat: Infinity,\n  ease: \"linear\",\n}\n\nconst BASE_ITEM_VARIANTS: Variants = {\n  hidden: {\n    opacity: 1,\n  },\n  visible: {\n    opacity: 1,\n  },\n}\n\nexport function SpinningText({\n  children,\n  duration = 10,\n  reverse = false,\n  radius = 5,\n  transition,\n  variants,\n  className,\n  style,\n}: SpinningTextProps) {\n  if (typeof children !== \"string\" && !Array.isArray(children)) {\n    throw new Error(\"children must be a string or an array of strings\")\n  }\n\n  if (Array.isArray(children)) {\n    // Validate all elements are strings\n    if (!children.every((child) => typeof child === \"string\")) {\n      throw new Error(\"all elements in children array must be strings\")\n    }\n    children = children.join(\"\")\n  }\n\n  const letters = children.split(\"\")\n  letters.push(\" \")\n\n  const finalTransition: Transition = {\n    ...BASE_TRANSITION,\n    ...transition,\n    duration: (transition as { duration?: number })?.duration ?? duration,\n  }\n\n  const containerVariants: Variants = {\n    visible: { rotate: reverse ? -360 : 360 },\n    ...variants?.container,\n  }\n\n  const itemVariants: Variants = {\n    ...BASE_ITEM_VARIANTS,\n    ...variants?.item,\n  }\n\n  return (\n    <motion.div\n      className={cn(\"relative\", className)}\n      style={{\n        ...style,\n      }}\n      initial=\"hidden\"\n      animate=\"visible\"\n      variants={containerVariants}\n      transition={finalTransition}\n    >\n      {letters.map((letter, index) => (\n        <motion.span\n          aria-hidden=\"true\"\n          key={`${index}-${letter}`}\n          variants={itemVariants}\n          className=\"absolute top-1/2 left-1/2 inline-block\"\n          style={\n            {\n              \"--index\": index,\n              \"--total\": letters.length,\n              \"--radius\": radius,\n              transform: `\n                  translate(-50%, -50%)\n                  rotate(calc(360deg / var(--total) * var(--index)))\n                  translateY(calc(var(--radius, 5) * -1ch))\n                `,\n              transformOrigin: \"center\",\n            } as React.CSSProperties\n          }\n        >\n          {letter}\n        </motion.span>\n      ))}\n      <span className=\"sr-only\">{children}</span>\n    </motion.div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "split-text",
      "type": "component",
      "description": "Animated text splitting into characters or words with GSAP.",
      "category": "text",
      "dependencies": [
        "gsap",
        "@gsap/react"
      ],
      "files": [
        {
          "path": "components/ui/split-text.tsx",
          "content": "import React, { useRef, useEffect, useState } from 'react';\nimport { gsap } from 'gsap';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\nimport { SplitText as GSAPSplitText } from 'gsap/SplitText';\nimport { useGSAP } from '@gsap/react';\n\ngsap.registerPlugin(ScrollTrigger, GSAPSplitText, useGSAP);\n\nexport interface SplitTextProps {\n  text: string;\n  className?: string;\n  delay?: number;\n  duration?: number;\n  ease?: string | ((t: number) => number);\n  splitType?: 'chars' | 'words' | 'lines' | 'words, chars';\n  from?: gsap.TweenVars;\n  to?: gsap.TweenVars;\n  threshold?: number;\n  rootMargin?: string;\n  tag?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p' | 'span';\n  textAlign?: React.CSSProperties['textAlign'];\n  onLetterAnimationComplete?: () => void;\n}\n\nconst SplitText: React.FC<SplitTextProps> = ({\n  text,\n  className = '',\n  delay = 50,\n  duration = 1.25,\n  ease = 'power3.out',\n  splitType = 'chars',\n  from = { opacity: 0, y: 40 },\n  to = { opacity: 1, y: 0 },\n  threshold = 0.1,\n  rootMargin = '-100px',\n  tag = 'p',\n  textAlign = 'center',\n  onLetterAnimationComplete\n}) => {\n  const ref = useRef<HTMLParagraphElement>(null);\n  const animationCompletedRef = useRef(false);\n  const onCompleteRef = useRef(onLetterAnimationComplete);\n  const [fontsLoaded, setFontsLoaded] = useState<boolean>(false);\n\n  // Keep callback ref updated\n  useEffect(() => {\n    onCompleteRef.current = onLetterAnimationComplete;\n  }, [onLetterAnimationComplete]);\n\n  useEffect(() => {\n    if (document.fonts.status === 'loaded') {\n      setFontsLoaded(true);\n    } else {\n      document.fonts.ready.then(() => {\n        setFontsLoaded(true);\n      });\n    }\n  }, []);\n\n  useGSAP(\n    () => {\n      if (!ref.current || !text || !fontsLoaded) return;\n      // Prevent re-animation if already completed\n      if (animationCompletedRef.current) return;\n      const el = ref.current as HTMLElement & {\n        _rbsplitInstance?: GSAPSplitText;\n      };\n\n      if (el._rbsplitInstance) {\n        try {\n          el._rbsplitInstance.revert();\n        } catch (_) {}\n        el._rbsplitInstance = undefined;\n      }\n\n      const startPct = (1 - threshold) * 100;\n      const marginMatch = /^(-?\\d+(?:\\.\\d+)?)(px|em|rem|%)?$/.exec(rootMargin);\n      const marginValue = marginMatch ? parseFloat(marginMatch[1]) : 0;\n      const marginUnit = marginMatch ? marginMatch[2] || 'px' : 'px';\n      const sign =\n        marginValue === 0\n          ? ''\n          : marginValue < 0\n            ? `-=${Math.abs(marginValue)}${marginUnit}`\n            : `+=${marginValue}${marginUnit}`;\n      const start = `top ${startPct}%${sign}`;\n      let targets: Element[] = [];\n      const assignTargets = (self: GSAPSplitText) => {\n        if (splitType.includes('chars') && (self as GSAPSplitText).chars?.length)\n          targets = (self as GSAPSplitText).chars;\n        if (!targets.length && splitType.includes('words') && self.words.length) targets = self.words;\n        if (!targets.length && splitType.includes('lines') && self.lines.length) targets = self.lines;\n        if (!targets.length) targets = self.chars || self.words || self.lines;\n      };\n      const splitInstance = new GSAPSplitText(el, {\n        type: splitType,\n        smartWrap: true,\n        autoSplit: splitType === 'lines',\n        linesClass: 'split-line',\n        wordsClass: 'split-word',\n        charsClass: 'split-char',\n        reduceWhiteSpace: false,\n        onSplit: (self: GSAPSplitText) => {\n          assignTargets(self);\n          return gsap.fromTo(\n            targets,\n            { ...from },\n            {\n              ...to,\n              duration,\n              ease,\n              stagger: delay / 1000,\n              scrollTrigger: {\n                trigger: el,\n                start,\n                once: true,\n                fastScrollEnd: true,\n                anticipatePin: 0.4\n              },\n              onComplete: () => {\n                animationCompletedRef.current = true;\n                onCompleteRef.current?.();\n              },\n              willChange: 'transform, opacity',\n              force3D: true\n            }\n          );\n        }\n      });\n      el._rbsplitInstance = splitInstance;\n      return () => {\n        ScrollTrigger.getAll().forEach(st => {\n          if (st.trigger === el) st.kill();\n        });\n        try {\n          splitInstance.revert();\n        } catch (_) {}\n        el._rbsplitInstance = undefined;\n      };\n    },\n    {\n      dependencies: [\n        text,\n        delay,\n        duration,\n        ease,\n        splitType,\n        JSON.stringify(from),\n        JSON.stringify(to),\n        threshold,\n        rootMargin,\n        fontsLoaded\n      ],\n      scope: ref\n    }\n  );\n\n  const renderTag = () => {\n    const style: React.CSSProperties = {\n      textAlign,\n      wordWrap: 'break-word',\n      willChange: 'transform, opacity'\n    };\n    const classes = `split-parent overflow-hidden inline-block whitespace-normal ${className}`;\n    const Tag = (tag || 'p') as React.ElementType;\n\n    return (\n      // @ts-expect-error - dynamic tag element type\n      <Tag ref={ref} style={style} className={classes}>\n        {text}\n      </Tag>\n    );\n  };\n\n  return renderTag();\n};\n\nexport default SplitText;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import SplitText from \"./component\";\n\nexport default function SplitTextExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <SplitText text=\"Hello World\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "text-animate",
      "type": "component",
      "description": "A text animation component that animates text using a variety of different animations.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/text-animate.tsx",
          "content": "\"use client\"\n\nimport { ElementType, memo } from \"react\"\nimport { AnimatePresence, motion, MotionProps, Variants } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ntype AnimationType = \"text\" | \"word\" | \"character\" | \"line\"\ntype AnimationVariant =\n  | \"fadeIn\"\n  | \"blurIn\"\n  | \"blurInUp\"\n  | \"blurInDown\"\n  | \"slideUp\"\n  | \"slideDown\"\n  | \"slideLeft\"\n  | \"slideRight\"\n  | \"scaleUp\"\n  | \"scaleDown\"\n\ninterface TextAnimateProps extends MotionProps {\n  /**\n   * The text content to animate\n   */\n  children: string\n  /**\n   * The class name to be applied to the component\n   */\n  className?: string\n  /**\n   * The class name to be applied to each segment\n   */\n  segmentClassName?: string\n  /**\n   * The delay before the animation starts\n   */\n  delay?: number\n  /**\n   * The duration of the animation\n   */\n  duration?: number\n  /**\n   * Custom motion variants for the animation\n   */\n  variants?: Variants\n  /**\n   * The element type to render\n   */\n  as?: ElementType\n  /**\n   * How to split the text (\"text\", \"word\", \"character\")\n   */\n  by?: AnimationType\n  /**\n   * Whether to start animation when component enters viewport\n   */\n  startOnView?: boolean\n  /**\n   * Whether to animate only once\n   */\n  once?: boolean\n  /**\n   * The animation preset to use\n   */\n  animation?: AnimationVariant\n  /**\n   * Whether to enable accessibility features (default: true)\n   */\n  accessible?: boolean\n}\n\nconst staggerTimings: Record<AnimationType, number> = {\n  text: 0.06,\n  word: 0.05,\n  character: 0.03,\n  line: 0.06,\n}\n\nconst defaultContainerVariants = {\n  hidden: { opacity: 1 },\n  show: {\n    opacity: 1,\n    transition: {\n      delayChildren: 0,\n      staggerChildren: 0.05,\n    },\n  },\n  exit: {\n    opacity: 0,\n    transition: {\n      staggerChildren: 0.05,\n      staggerDirection: -1,\n    },\n  },\n}\n\nconst defaultItemVariants: Variants = {\n  hidden: { opacity: 0 },\n  show: {\n    opacity: 1,\n  },\n  exit: {\n    opacity: 0,\n  },\n}\n\nconst defaultItemAnimationVariants: Record<\n  AnimationVariant,\n  { container: Variants; item: Variants }\n> = {\n  fadeIn: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { opacity: 0, y: 20 },\n      show: {\n        opacity: 1,\n        y: 0,\n        transition: {\n          duration: 0.3,\n        },\n      },\n      exit: {\n        opacity: 0,\n        y: 20,\n        transition: { duration: 0.3 },\n      },\n    },\n  },\n  blurIn: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { opacity: 0, filter: \"blur(10px)\" },\n      show: {\n        opacity: 1,\n        filter: \"blur(0px)\",\n        transition: {\n          duration: 0.3,\n        },\n      },\n      exit: {\n        opacity: 0,\n        filter: \"blur(10px)\",\n        transition: { duration: 0.3 },\n      },\n    },\n  },\n  blurInUp: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { opacity: 0, filter: \"blur(10px)\", y: 20 },\n      show: {\n        opacity: 1,\n        filter: \"blur(0px)\",\n        y: 0,\n        transition: {\n          y: { duration: 0.3 },\n          opacity: { duration: 0.4 },\n          filter: { duration: 0.3 },\n        },\n      },\n      exit: {\n        opacity: 0,\n        filter: \"blur(10px)\",\n        y: 20,\n        transition: {\n          y: { duration: 0.3 },\n          opacity: { duration: 0.4 },\n          filter: { duration: 0.3 },\n        },\n      },\n    },\n  },\n  blurInDown: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { opacity: 0, filter: \"blur(10px)\", y: -20 },\n      show: {\n        opacity: 1,\n        filter: \"blur(0px)\",\n        y: 0,\n        transition: {\n          y: { duration: 0.3 },\n          opacity: { duration: 0.4 },\n          filter: { duration: 0.3 },\n        },\n      },\n    },\n  },\n  slideUp: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { y: 20, opacity: 0 },\n      show: {\n        y: 0,\n        opacity: 1,\n        transition: {\n          duration: 0.3,\n        },\n      },\n      exit: {\n        y: -20,\n        opacity: 0,\n        transition: {\n          duration: 0.3,\n        },\n      },\n    },\n  },\n  slideDown: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { y: -20, opacity: 0 },\n      show: {\n        y: 0,\n        opacity: 1,\n        transition: { duration: 0.3 },\n      },\n      exit: {\n        y: 20,\n        opacity: 0,\n        transition: { duration: 0.3 },\n      },\n    },\n  },\n  slideLeft: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { x: 20, opacity: 0 },\n      show: {\n        x: 0,\n        opacity: 1,\n        transition: { duration: 0.3 },\n      },\n      exit: {\n        x: -20,\n        opacity: 0,\n        transition: { duration: 0.3 },\n      },\n    },\n  },\n  slideRight: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { x: -20, opacity: 0 },\n      show: {\n        x: 0,\n        opacity: 1,\n        transition: { duration: 0.3 },\n      },\n      exit: {\n        x: 20,\n        opacity: 0,\n        transition: { duration: 0.3 },\n      },\n    },\n  },\n  scaleUp: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { scale: 0.5, opacity: 0 },\n      show: {\n        scale: 1,\n        opacity: 1,\n        transition: {\n          duration: 0.3,\n          scale: {\n            type: \"spring\",\n            damping: 15,\n            stiffness: 300,\n          },\n        },\n      },\n      exit: {\n        scale: 0.5,\n        opacity: 0,\n        transition: { duration: 0.3 },\n      },\n    },\n  },\n  scaleDown: {\n    container: defaultContainerVariants,\n    item: {\n      hidden: { scale: 1.5, opacity: 0 },\n      show: {\n        scale: 1,\n        opacity: 1,\n        transition: {\n          duration: 0.3,\n          scale: {\n            type: \"spring\",\n            damping: 15,\n            stiffness: 300,\n          },\n        },\n      },\n      exit: {\n        scale: 1.5,\n        opacity: 0,\n        transition: { duration: 0.3 },\n      },\n    },\n  },\n}\n\nconst TextAnimateBase = ({\n  children,\n  delay = 0,\n  duration = 0.3,\n  variants,\n  className,\n  segmentClassName,\n  as: Component = \"p\",\n  startOnView = true,\n  once = false,\n  by = \"word\",\n  animation = \"fadeIn\",\n  accessible = true,\n  ...props\n}: TextAnimateProps) => {\n  const MotionComponent = motion.create(Component)\n\n  let segments: string[] = []\n  switch (by) {\n    case \"word\":\n      segments = children.split(/(\\s+)/)\n      break\n    case \"character\":\n      segments = children.split(\"\")\n      break\n    case \"line\":\n      segments = children.split(\"\\n\")\n      break\n    case \"text\":\n    default:\n      segments = [children]\n      break\n  }\n\n  const finalVariants = variants\n    ? {\n        container: {\n          hidden: { opacity: 0 },\n          show: {\n            opacity: 1,\n            transition: {\n              opacity: { duration: 0.01, delay },\n              delayChildren: delay,\n              staggerChildren: duration / segments.length,\n            },\n          },\n          exit: {\n            opacity: 0,\n            transition: {\n              staggerChildren: duration / segments.length,\n              staggerDirection: -1,\n            },\n          },\n        },\n        item: variants,\n      }\n    : animation\n      ? {\n          container: {\n            ...defaultItemAnimationVariants[animation].container,\n            show: {\n              ...defaultItemAnimationVariants[animation].container.show,\n              transition: {\n                delayChildren: delay,\n                staggerChildren: duration / segments.length,\n              },\n            },\n            exit: {\n              ...defaultItemAnimationVariants[animation].container.exit,\n              transition: {\n                staggerChildren: duration / segments.length,\n                staggerDirection: -1,\n              },\n            },\n          },\n          item: defaultItemAnimationVariants[animation].item,\n        }\n      : { container: defaultContainerVariants, item: defaultItemVariants }\n\n  return (\n    <AnimatePresence mode=\"popLayout\">\n      <MotionComponent\n        variants={finalVariants.container as Variants}\n        initial=\"hidden\"\n        whileInView={startOnView ? \"show\" : undefined}\n        animate={startOnView ? undefined : \"show\"}\n        exit=\"exit\"\n        className={cn(\"whitespace-pre-wrap\", className)}\n        viewport={{ once }}\n        aria-label={accessible ? children : undefined}\n        {...props}\n      >\n        {accessible && <span className=\"sr-only\">{children}</span>}\n        {segments.map((segment, i) => (\n          <motion.span\n            key={`${by}-${segment}-${i}`}\n            variants={finalVariants.item}\n            custom={i * staggerTimings[by]}\n            className={cn(\n              by === \"line\" ? \"block\" : \"inline-block whitespace-pre\",\n              by === \"character\" && \"\",\n              segmentClassName\n            )}\n            aria-hidden={accessible ? true : undefined}\n          >\n            {segment}\n          </motion.span>\n        ))}\n      </MotionComponent>\n    </AnimatePresence>\n  )\n}\n\n// Export the memoized version\nexport const TextAnimate = memo(TextAnimateBase)\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "text-cursor",
      "type": "component",
      "description": "Text elements that trail behind the mouse cursor.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/text-cursor.tsx",
          "content": "import React, { useState, useEffect, useRef } from 'react';\nimport { motion, AnimatePresence } from 'motion/react';\n\ninterface TextCursorProps {\n  text: string;\n  spacing?: number;\n  followMouseDirection?: boolean;\n  randomFloat?: boolean;\n  exitDuration?: number;\n  removalInterval?: number;\n  maxPoints?: number;\n}\n\ninterface TrailItem {\n  id: number;\n  x: number;\n  y: number;\n  angle: number;\n  randomX?: number;\n  randomY?: number;\n  randomRotate?: number;\n}\n\nconst TextCursor: React.FC<TextCursorProps> = ({\n  text = '',\n  spacing = 100,\n  followMouseDirection = true,\n  randomFloat = true,\n  exitDuration = 0.5,\n  removalInterval = 30,\n  maxPoints = 5\n}) => {\n  const [trail, setTrail] = useState<TrailItem[]>([]);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const lastMoveTimeRef = useRef<number>(Date.now());\n  const idCounter = useRef<number>(0);\n\n  const handleMouseMove = (e: MouseEvent) => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const mouseY = e.clientY - rect.top;\n\n    setTrail(prev => {\n      let newTrail = [...prev];\n      if (newTrail.length === 0) {\n        newTrail.push({\n          id: idCounter.current++,\n          x: mouseX,\n          y: mouseY,\n          angle: 0,\n          ...(randomFloat && {\n            randomX: Math.random() * 10 - 5,\n            randomY: Math.random() * 10 - 5,\n            randomRotate: Math.random() * 10 - 5\n          })\n        });\n      } else {\n        const last = newTrail[newTrail.length - 1];\n        const dx = mouseX - last.x;\n        const dy = mouseY - last.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance >= spacing) {\n          let rawAngle = (Math.atan2(dy, dx) * 180) / Math.PI;\n\n          rawAngle = ((rawAngle + 180) % 360) - 180;\n\n          const computedAngle = followMouseDirection ? rawAngle : 0;\n          const steps = Math.floor(distance / spacing);\n          for (let i = 1; i <= steps; i++) {\n            const t = (spacing * i) / distance;\n            const newX = last.x + dx * t;\n            const newY = last.y + dy * t;\n            newTrail.push({\n              id: idCounter.current++,\n              x: newX,\n              y: newY,\n              angle: computedAngle,\n              ...(randomFloat && {\n                randomX: Math.random() * 10 - 5,\n                randomY: Math.random() * 10 - 5,\n                randomRotate: Math.random() * 10 - 5\n              })\n            });\n          }\n        }\n      }\n      if (newTrail.length > maxPoints) {\n        newTrail = newTrail.slice(newTrail.length - maxPoints);\n      }\n      return newTrail;\n    });\n    lastMoveTimeRef.current = Date.now();\n  };\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    container.addEventListener('mousemove', handleMouseMove);\n    return () => {\n      container.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, [containerRef.current]);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (Date.now() - lastMoveTimeRef.current > 100) {\n        setTrail(prev => (prev.length > 0 ? prev.slice(1) : prev));\n      }\n    }, removalInterval);\n    return () => clearInterval(interval);\n  }, [removalInterval]);\n\n  return (\n    <div ref={containerRef} className=\"w-full h-full relative\">\n      <div className=\"absolute inset-0 pointer-events-none\">\n        <AnimatePresence>\n          {trail.map(item => (\n            <motion.div\n              key={item.id}\n              initial={{ opacity: 0, scale: 1, rotate: item.angle }}\n              animate={{\n                opacity: 1,\n                scale: 1,\n                x: randomFloat ? [0, item.randomX || 0, 0] : 0,\n                y: randomFloat ? [0, item.randomY || 0, 0] : 0,\n                rotate: randomFloat ? [item.angle, item.angle + (item.randomRotate || 0), item.angle] : item.angle\n              }}\n              exit={{ opacity: 0, scale: 0 }}\n              transition={{\n                opacity: { duration: exitDuration, ease: 'easeOut' },\n\n                ...(randomFloat && {\n                  x: {\n                    duration: 2,\n                    ease: 'easeInOut',\n                    repeat: Infinity,\n                    repeatType: 'mirror'\n                  },\n                  y: {\n                    duration: 2,\n                    ease: 'easeInOut',\n                    repeat: Infinity,\n                    repeatType: 'mirror'\n                  },\n                  rotate: {\n                    duration: 2,\n                    ease: 'easeInOut',\n                    repeat: Infinity,\n                    repeatType: 'mirror'\n                  }\n                })\n              }}\n              className=\"absolute select-none whitespace-nowrap text-3xl\"\n              style={{ left: item.x, top: item.y }}\n            >\n              {text}\n            </motion.div>\n          ))}\n        </AnimatePresence>\n      </div>\n    </div>\n  );\n};\n\nexport default TextCursor;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import TextCursor from \"./component\";\n\nexport default function TextCursorExample() {\n  return (\n    <div className=\"relative w-full h-[400px]\">\n      <TextCursor text=\"Hello\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "text-pressure",
      "type": "component",
      "description": "Variable font text that reacts to mouse proximity with pressure.",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/text-pressure.tsx",
          "content": "// Component ported from https://codepen.io/JuanFuentes/full/rgXKGQ\n\nimport { useEffect, useRef, useState, useMemo, useCallback } from 'react';\n\ninterface TextPressureProps {\n  text?: string;\n  fontFamily?: string;\n  fontUrl?: string;\n  width?: boolean;\n  weight?: boolean;\n  italic?: boolean;\n  alpha?: boolean;\n  flex?: boolean;\n  stroke?: boolean;\n  scale?: boolean;\n  textColor?: string;\n  strokeColor?: string;\n  strokeWidth?: number;\n  className?: string;\n  minFontSize?: number;\n}\n\nconst dist = (a: { x: number; y: number }, b: { x: number; y: number }) => {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nconst getAttr = (distance: number, maxDist: number, minVal: number, maxVal: number) => {\n  const val = maxVal - Math.abs((maxVal * distance) / maxDist);\n  return Math.max(minVal, val + minVal);\n};\n\nconst debounce = (func: (...args: any[]) => void, delay: number) => {\n  let timeoutId: ReturnType<typeof setTimeout>;\n  return (...args: any[]) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n};\n\nconst TextPressure: React.FC<TextPressureProps> = ({\n  text = 'Compressa',\n  fontFamily = 'Compressa VF',\n  fontUrl = 'https://res.cloudinary.com/dr6lvwubh/raw/upload/v1529908256/CompressaPRO-GX.woff2',\n  width = true,\n  weight = true,\n  italic = true,\n  alpha = false,\n  flex = true,\n  stroke = false,\n  scale = false,\n  textColor = '#FFFFFF',\n  strokeColor = '#FF0000',\n  strokeWidth = 2,\n  className = '',\n  minFontSize = 24\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const titleRef = useRef<HTMLHeadingElement | null>(null);\n  const spansRef = useRef<(HTMLSpanElement | null)[]>([]);\n\n  const mouseRef = useRef({ x: 0, y: 0 });\n  const cursorRef = useRef({ x: 0, y: 0 });\n\n  const [fontSize, setFontSize] = useState(minFontSize);\n  const [scaleY, setScaleY] = useState(1);\n  const [lineHeight, setLineHeight] = useState(1);\n\n  const chars = text.split('');\n\n  useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      cursorRef.current.x = e.clientX;\n      cursorRef.current.y = e.clientY;\n    };\n    const handleTouchMove = (e: TouchEvent) => {\n      const t = e.touches[0];\n      cursorRef.current.x = t.clientX;\n      cursorRef.current.y = t.clientY;\n    };\n\n    window.addEventListener('mousemove', handleMouseMove);\n    window.addEventListener('touchmove', handleTouchMove, { passive: true });\n\n    if (containerRef.current) {\n      const { left, top, width, height } = containerRef.current.getBoundingClientRect();\n      mouseRef.current.x = left + width / 2;\n      mouseRef.current.y = top + height / 2;\n      cursorRef.current.x = mouseRef.current.x;\n      cursorRef.current.y = mouseRef.current.y;\n    }\n\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove);\n      window.removeEventListener('touchmove', handleTouchMove);\n    };\n  }, []);\n\n  const setSize = useCallback(() => {\n    if (!containerRef.current || !titleRef.current) return;\n\n    const { width: containerW, height: containerH } = containerRef.current.getBoundingClientRect();\n\n    let newFontSize = containerW / (chars.length / 2);\n    newFontSize = Math.max(newFontSize, minFontSize);\n\n    setFontSize(newFontSize);\n    setScaleY(1);\n    setLineHeight(1);\n\n    requestAnimationFrame(() => {\n      if (!titleRef.current) return;\n      const textRect = titleRef.current.getBoundingClientRect();\n\n      if (scale && textRect.height > 0) {\n        const yRatio = containerH / textRect.height;\n        setScaleY(yRatio);\n        setLineHeight(yRatio);\n      }\n    });\n  }, [chars.length, minFontSize, scale]);\n\n  useEffect(() => {\n    const debouncedSetSize = debounce(setSize, 100);\n    debouncedSetSize();\n    window.addEventListener('resize', debouncedSetSize);\n    return () => window.removeEventListener('resize', debouncedSetSize);\n  }, [setSize]);\n\n  useEffect(() => {\n    let rafId: number;\n    const animate = () => {\n      mouseRef.current.x += (cursorRef.current.x - mouseRef.current.x) / 15;\n      mouseRef.current.y += (cursorRef.current.y - mouseRef.current.y) / 15;\n\n      if (titleRef.current) {\n        const titleRect = titleRef.current.getBoundingClientRect();\n        const maxDist = titleRect.width / 2;\n\n        spansRef.current.forEach(span => {\n          if (!span) return;\n\n          const rect = span.getBoundingClientRect();\n          const charCenter = {\n            x: rect.x + rect.width / 2,\n            y: rect.y + rect.height / 2\n          };\n\n          const d = dist(mouseRef.current, charCenter);\n\n          const wdth = width ? Math.floor(getAttr(d, maxDist, 5, 200)) : 100;\n          const wght = weight ? Math.floor(getAttr(d, maxDist, 100, 900)) : 400;\n          const italVal = italic ? getAttr(d, maxDist, 0, 1).toFixed(2) : '0';\n          const alphaVal = alpha ? getAttr(d, maxDist, 0, 1).toFixed(2) : '1';\n\n          const newFontVariationSettings = `'wght' ${wght}, 'wdth' ${wdth}, 'ital' ${italVal}`;\n\n          if (span.style.fontVariationSettings !== newFontVariationSettings) {\n            span.style.fontVariationSettings = newFontVariationSettings;\n          }\n          if (alpha && span.style.opacity !== alphaVal) {\n            span.style.opacity = alphaVal;\n          }\n        });\n      }\n\n      rafId = requestAnimationFrame(animate);\n    };\n\n    animate();\n    return () => cancelAnimationFrame(rafId);\n  }, [width, weight, italic, alpha]);\n\n  const styleElement = useMemo(() => {\n    return (\n      <style>{`\n        @font-face {\n          font-family: '${fontFamily}';\n          src: url('${fontUrl}');\n          font-style: normal;\n        }\n        .stroke span {\n          position: relative;\n          color: ${textColor};\n        }\n        .stroke span::after {\n          content: attr(data-char);\n          position: absolute;\n          left: 0;\n          top: 0;\n          color: transparent;\n          z-index: -1;\n          -webkit-text-stroke-width: ${strokeWidth}px;\n          -webkit-text-stroke-color: ${strokeColor};\n        }\n      `}</style>\n    );\n  }, [fontFamily, fontUrl, stroke, textColor, strokeColor, strokeWidth]);\n\n  return (\n    <div ref={containerRef} className=\"relative w-full h-full overflow-hidden bg-transparent\">\n      {styleElement}\n      <h1\n        ref={titleRef}\n        className={`text-pressure-title ${className} ${\n          flex ? 'flex justify-between' : ''\n        } ${stroke ? 'stroke' : ''} uppercase text-center`}\n        style={{\n          fontFamily,\n          fontSize: fontSize,\n          lineHeight,\n          transform: `scale(1, ${scaleY})`,\n          transformOrigin: 'center top',\n          margin: 0,\n          fontWeight: 100,\n          color: stroke ? undefined : textColor\n        }}\n      >\n        {chars.map((char, i) => (\n          <span\n            key={i}\n            ref={el => {\n              spansRef.current[i] = el;\n            }}\n            data-char={char}\n            className=\"inline-block\"\n          >\n            {char}\n          </span>\n        ))}\n      </h1>\n    </div>\n  );\n};\n\nexport default TextPressure;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import TextPressure from \"./component\";\n\nexport default function TextPressureExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8 w-full h-[200px]\">\n      <TextPressure text=\"Hello World\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "text-reveal",
      "type": "component",
      "description": "Fade in text as you scroll down the page.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/text-reveal.tsx",
          "content": "\"use client\"\n\nimport { ComponentPropsWithoutRef, FC, ReactNode, useRef } from \"react\"\nimport { motion, MotionValue, useScroll, useTransform } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface TextRevealProps extends ComponentPropsWithoutRef<\"div\"> {\n  children: string\n}\n\nexport const TextReveal: FC<TextRevealProps> = ({ children, className }) => {\n  const targetRef = useRef<HTMLDivElement | null>(null)\n  const { scrollYProgress } = useScroll({\n    target: targetRef,\n  })\n\n  if (typeof children !== \"string\") {\n    throw new Error(\"TextReveal: children must be a string\")\n  }\n\n  const words = children.split(\" \")\n\n  return (\n    <div ref={targetRef} className={cn(\"relative z-0 h-[200vh]\", className)}>\n      <div\n        className={\n          \"sticky top-0 mx-auto flex h-[50%] max-w-4xl items-center bg-transparent px-[1rem] py-[5rem]\"\n        }\n      >\n        <span\n          ref={targetRef}\n          className={\n            \"flex flex-wrap p-5 text-2xl font-bold text-black/20 md:p-8 md:text-3xl lg:p-10 lg:text-4xl xl:text-5xl dark:text-white/20\"\n          }\n        >\n          {words.map((word, i) => {\n            const start = i / words.length\n            const end = start + 1 / words.length\n            return (\n              <Word key={i} progress={scrollYProgress} range={[start, end]}>\n                {word}\n              </Word>\n            )\n          })}\n        </span>\n      </div>\n    </div>\n  )\n}\n\ninterface WordProps {\n  children: ReactNode\n  progress: MotionValue<number>\n  range: [number, number]\n}\n\nconst Word: FC<WordProps> = ({ children, progress, range }) => {\n  const opacity = useTransform(progress, range, [0, 1])\n  return (\n    <span className=\"xl:lg-3 relative mx-1 lg:mx-1.5\">\n      <span className=\"absolute opacity-30\">{children}</span>\n      <motion.span\n        style={{ opacity: opacity }}\n        className={\"text-black dark:text-white\"}\n      >\n        {children}\n      </motion.span>\n    </span>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "text-type",
      "type": "component",
      "description": "Typewriter effect that types and deletes text with a blinking cursor.",
      "category": "text",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/text-type.tsx",
          "content": "'use client';\n\nimport { ElementType, useEffect, useRef, useState, createElement, useMemo, useCallback } from 'react';\nimport { gsap } from 'gsap';\n\ninterface TextTypeProps {\n  className?: string;\n  showCursor?: boolean;\n  hideCursorWhileTyping?: boolean;\n  cursorCharacter?: string | React.ReactNode;\n  cursorBlinkDuration?: number;\n  cursorClassName?: string;\n  text: string | string[];\n  as?: ElementType;\n  typingSpeed?: number;\n  initialDelay?: number;\n  pauseDuration?: number;\n  deletingSpeed?: number;\n  loop?: boolean;\n  textColors?: string[];\n  variableSpeed?: { min: number; max: number };\n  onSentenceComplete?: (sentence: string, index: number) => void;\n  startOnVisible?: boolean;\n  reverseMode?: boolean;\n}\n\nconst TextType = ({\n  text,\n  as: Component = 'div',\n  typingSpeed = 50,\n  initialDelay = 0,\n  pauseDuration = 2000,\n  deletingSpeed = 30,\n  loop = true,\n  className = '',\n  showCursor = true,\n  hideCursorWhileTyping = false,\n  cursorCharacter = '|',\n  cursorClassName = '',\n  cursorBlinkDuration = 0.5,\n  textColors = [],\n  variableSpeed,\n  onSentenceComplete,\n  startOnVisible = false,\n  reverseMode = false,\n  ...props\n}: TextTypeProps & React.HTMLAttributes<HTMLElement>) => {\n  const [displayedText, setDisplayedText] = useState('');\n  const [currentCharIndex, setCurrentCharIndex] = useState(0);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [currentTextIndex, setCurrentTextIndex] = useState(0);\n  const [isVisible, setIsVisible] = useState(!startOnVisible);\n  const cursorRef = useRef<HTMLSpanElement>(null);\n  const containerRef = useRef<HTMLElement>(null);\n\n  const textArray = useMemo(() => (Array.isArray(text) ? text : [text]), [text]);\n\n  const getRandomSpeed = useCallback(() => {\n    if (!variableSpeed) return typingSpeed;\n    const { min, max } = variableSpeed;\n    return Math.random() * (max - min) + min;\n  }, [variableSpeed, typingSpeed]);\n\n  const getCurrentTextColor = () => {\n    if (textColors.length === 0) return 'inherit';\n    return textColors[currentTextIndex % textColors.length];\n  };\n\n  useEffect(() => {\n    if (!startOnVisible || !containerRef.current) return;\n\n    const observer = new IntersectionObserver(\n      entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            setIsVisible(true);\n          }\n        });\n      },\n      { threshold: 0.1 }\n    );\n\n    observer.observe(containerRef.current);\n    return () => observer.disconnect();\n  }, [startOnVisible]);\n\n  useEffect(() => {\n    if (showCursor && cursorRef.current) {\n      gsap.set(cursorRef.current, { opacity: 1 });\n      gsap.to(cursorRef.current, {\n        opacity: 0,\n        duration: cursorBlinkDuration,\n        repeat: -1,\n        yoyo: true,\n        ease: 'power2.inOut'\n      });\n    }\n  }, [showCursor, cursorBlinkDuration]);\n\n  useEffect(() => {\n    if (!isVisible) return;\n\n    let timeout: ReturnType<typeof setTimeout>;\n\n    const currentText = textArray[currentTextIndex];\n    const processedText = reverseMode ? currentText.split('').reverse().join('') : currentText;\n\n    const executeTypingAnimation = () => {\n      if (isDeleting) {\n        if (displayedText === '') {\n          setIsDeleting(false);\n          if (currentTextIndex === textArray.length - 1 && !loop) {\n            return;\n          }\n\n          if (onSentenceComplete) {\n            onSentenceComplete(textArray[currentTextIndex], currentTextIndex);\n          }\n\n          setCurrentTextIndex(prev => (prev + 1) % textArray.length);\n          setCurrentCharIndex(0);\n          timeout = setTimeout(() => {}, pauseDuration);\n        } else {\n          timeout = setTimeout(() => {\n            setDisplayedText(prev => prev.slice(0, -1));\n          }, deletingSpeed);\n        }\n      } else {\n        if (currentCharIndex < processedText.length) {\n          timeout = setTimeout(\n            () => {\n              setDisplayedText(prev => prev + processedText[currentCharIndex]);\n              setCurrentCharIndex(prev => prev + 1);\n            },\n            variableSpeed ? getRandomSpeed() : typingSpeed\n          );\n        } else if (textArray.length >= 1) {\n          if (!loop && currentTextIndex === textArray.length - 1) return;\n          timeout = setTimeout(() => {\n            setIsDeleting(true);\n          }, pauseDuration);\n        }\n      }\n    };\n\n    if (currentCharIndex === 0 && !isDeleting && displayedText === '') {\n      timeout = setTimeout(executeTypingAnimation, initialDelay);\n    } else {\n      executeTypingAnimation();\n    }\n\n    return () => clearTimeout(timeout);\n  }, [\n    currentCharIndex,\n    displayedText,\n    isDeleting,\n    typingSpeed,\n    deletingSpeed,\n    pauseDuration,\n    textArray,\n    currentTextIndex,\n    loop,\n    initialDelay,\n    isVisible,\n    reverseMode,\n    variableSpeed,\n    onSentenceComplete\n  ]);\n\n  const shouldHideCursor =\n    hideCursorWhileTyping && (currentCharIndex < textArray[currentTextIndex].length || isDeleting);\n\n  return createElement(\n    Component,\n    {\n      ref: containerRef,\n      className: `inline-block whitespace-pre-wrap tracking-tight ${className}`,\n      ...props\n    },\n    <span className=\"inline\" style={{ color: getCurrentTextColor() || 'inherit' }}>\n      {displayedText}\n    </span>,\n    showCursor && (\n      <span\n        ref={cursorRef}\n        className={`ml-1 inline-block opacity-100 ${shouldHideCursor ? 'hidden' : ''} ${cursorClassName}`}\n      >\n        {cursorCharacter}\n      </span>\n    )\n  );\n};\n\nexport default TextType;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import TextType from \"./component\";\n\nexport default function TextTypeExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8 text-2xl\">\n      <TextType text={[\"Hello World\", \"Welcome to Vritti\", \"React Bits\"]} />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "true-focus",
      "type": "component",
      "description": "Text with an animated focus border that highlights words sequentially.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/true-focus.tsx",
          "content": "import { useEffect, useRef, useState } from 'react';\nimport { motion } from 'motion/react';\n\ninterface TrueFocusProps {\n  sentence?: string;\n  separator?: string;\n  manualMode?: boolean;\n  blurAmount?: number;\n  borderColor?: string;\n  glowColor?: string;\n  animationDuration?: number;\n  pauseBetweenAnimations?: number;\n}\n\ninterface FocusRect {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nconst TrueFocus: React.FC<TrueFocusProps> = ({\n  sentence = 'True Focus',\n  separator = ' ',\n  manualMode = false,\n  blurAmount = 5,\n  borderColor = 'green',\n  glowColor = 'rgba(0, 255, 0, 0.6)',\n  animationDuration = 0.5,\n  pauseBetweenAnimations = 1\n}) => {\n  const words = sentence.split(separator);\n  const [currentIndex, setCurrentIndex] = useState<number>(0);\n  const [lastActiveIndex, setLastActiveIndex] = useState<number | null>(null);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const wordRefs = useRef<(HTMLSpanElement | null)[]>([]);\n  const [focusRect, setFocusRect] = useState<FocusRect>({ x: 0, y: 0, width: 0, height: 0 });\n\n  useEffect(() => {\n    if (!manualMode) {\n      const interval = setInterval(\n        () => {\n          setCurrentIndex(prev => (prev + 1) % words.length);\n        },\n        (animationDuration + pauseBetweenAnimations) * 1000\n      );\n\n      return () => clearInterval(interval);\n    }\n  }, [manualMode, animationDuration, pauseBetweenAnimations, words.length]);\n\n  useEffect(() => {\n    if (currentIndex === null || currentIndex === -1) return;\n    if (!wordRefs.current[currentIndex] || !containerRef.current) return;\n\n    const parentRect = containerRef.current.getBoundingClientRect();\n    const activeRect = wordRefs.current[currentIndex]!.getBoundingClientRect();\n\n    setFocusRect({\n      x: activeRect.left - parentRect.left,\n      y: activeRect.top - parentRect.top,\n      width: activeRect.width,\n      height: activeRect.height\n    });\n  }, [currentIndex, words.length]);\n\n  const handleMouseEnter = (index: number) => {\n    if (manualMode) {\n      setLastActiveIndex(index);\n      setCurrentIndex(index);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (manualMode) {\n      setCurrentIndex(lastActiveIndex!);\n    }\n  };\n\n  return (\n    <div\n      className=\"relative flex gap-4 justify-center items-center flex-wrap\"\n      ref={containerRef}\n      style={{ outline: 'none', userSelect: 'none' }}\n    >\n      {words.map((word, index) => {\n        const isActive = index === currentIndex;\n        return (\n          <span\n            key={index}\n            ref={el => {\n              wordRefs.current[index] = el;\n            }}\n            className=\"relative text-[3rem] font-black cursor-pointer\"\n            style={\n              {\n                filter: manualMode\n                  ? isActive\n                    ? `blur(0px)`\n                    : `blur(${blurAmount}px)`\n                  : isActive\n                    ? `blur(0px)`\n                    : `blur(${blurAmount}px)`,\n                transition: `filter ${animationDuration}s ease`,\n                outline: 'none',\n                userSelect: 'none'\n              } as React.CSSProperties\n            }\n            onMouseEnter={() => handleMouseEnter(index)}\n            onMouseLeave={handleMouseLeave}\n          >\n            {word}\n          </span>\n        );\n      })}\n\n      <motion.div\n        className=\"absolute top-0 left-0 pointer-events-none box-border border-0\"\n        animate={{\n          x: focusRect.x,\n          y: focusRect.y,\n          width: focusRect.width,\n          height: focusRect.height,\n          opacity: currentIndex >= 0 ? 1 : 0\n        }}\n        transition={{\n          duration: animationDuration\n        }}\n        style={\n          {\n            '--border-color': borderColor,\n            '--glow-color': glowColor\n          } as React.CSSProperties\n        }\n      >\n        <span\n          className=\"absolute w-4 h-4 border-[3px] rounded-[3px] top-[-10px] left-[-10px] border-r-0 border-b-0\"\n          style={{\n            borderColor: 'var(--border-color)',\n            filter: 'drop-shadow(0 0 4px var(--border-color))'\n          }}\n        ></span>\n        <span\n          className=\"absolute w-4 h-4 border-[3px] rounded-[3px] top-[-10px] right-[-10px] border-l-0 border-b-0\"\n          style={{\n            borderColor: 'var(--border-color)',\n            filter: 'drop-shadow(0 0 4px var(--border-color))'\n          }}\n        ></span>\n        <span\n          className=\"absolute w-4 h-4 border-[3px] rounded-[3px] bottom-[-10px] left-[-10px] border-r-0 border-t-0\"\n          style={{\n            borderColor: 'var(--border-color)',\n            filter: 'drop-shadow(0 0 4px var(--border-color))'\n          }}\n        ></span>\n        <span\n          className=\"absolute w-4 h-4 border-[3px] rounded-[3px] bottom-[-10px] right-[-10px] border-l-0 border-t-0\"\n          style={{\n            borderColor: 'var(--border-color)',\n            filter: 'drop-shadow(0 0 4px var(--border-color))'\n          }}\n        ></span>\n      </motion.div>\n    </div>\n  );\n};\n\nexport default TrueFocus;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import TrueFocus from \"./component\";\n\nexport default function TrueFocusExample() {\n  return (\n    <div className=\"flex items-center justify-center p-8\">\n      <TrueFocus sentence=\"Hello World\" />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "typing-animation",
      "type": "component",
      "description": "Characters appearing in typed animation",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/typing-animation.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useMemo, useRef, useState } from \"react\"\nimport { motion, MotionProps, useInView } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface TypingAnimationProps extends MotionProps {\n  children?: string\n  words?: string[]\n  className?: string\n  duration?: number\n  typeSpeed?: number\n  deleteSpeed?: number\n  delay?: number\n  pauseDelay?: number\n  loop?: boolean\n  as?: React.ElementType\n  startOnView?: boolean\n  showCursor?: boolean\n  blinkCursor?: boolean\n  cursorStyle?: \"line\" | \"block\" | \"underscore\"\n}\n\nexport function TypingAnimation({\n  children,\n  words,\n  className,\n  duration = 100,\n  typeSpeed,\n  deleteSpeed,\n  delay = 0,\n  pauseDelay = 1000,\n  loop = false,\n  as: Component = \"span\",\n  startOnView = true,\n  showCursor = true,\n  blinkCursor = true,\n  cursorStyle = \"line\",\n  ...props\n}: TypingAnimationProps) {\n  const MotionComponent = motion.create(Component, {\n    forwardMotionProps: true,\n  })\n\n  const [displayedText, setDisplayedText] = useState<string>(\"\")\n  const [currentWordIndex, setCurrentWordIndex] = useState(0)\n  const [currentCharIndex, setCurrentCharIndex] = useState(0)\n  const [phase, setPhase] = useState<\"typing\" | \"pause\" | \"deleting\">(\"typing\")\n  const elementRef = useRef<HTMLElement | null>(null)\n  const isInView = useInView(elementRef as React.RefObject<Element>, {\n    amount: 0.3,\n    once: true,\n  })\n\n  const wordsToAnimate = useMemo(\n    () => words || (children ? [children] : []),\n    [words, children]\n  )\n  const hasMultipleWords = wordsToAnimate.length > 1\n\n  const typingSpeed = typeSpeed || duration\n  const deletingSpeed = deleteSpeed || typingSpeed / 2\n\n  const shouldStart = startOnView ? isInView : true\n\n  useEffect(() => {\n    if (!shouldStart || wordsToAnimate.length === 0) return\n\n    const timeoutDelay =\n      delay > 0 && displayedText === \"\"\n        ? delay\n        : phase === \"typing\"\n          ? typingSpeed\n          : phase === \"deleting\"\n            ? deletingSpeed\n            : pauseDelay\n\n    const timeout = setTimeout(() => {\n      const currentWord = wordsToAnimate[currentWordIndex] || \"\"\n      const graphemes = Array.from(currentWord)\n\n      switch (phase) {\n        case \"typing\":\n          if (currentCharIndex < graphemes.length) {\n            setDisplayedText(graphemes.slice(0, currentCharIndex + 1).join(\"\"))\n            setCurrentCharIndex(currentCharIndex + 1)\n          } else {\n            if (hasMultipleWords || loop) {\n              const isLastWord = currentWordIndex === wordsToAnimate.length - 1\n              if (!isLastWord || loop) {\n                setPhase(\"pause\")\n              }\n            }\n          }\n          break\n\n        case \"pause\":\n          setPhase(\"deleting\")\n          break\n\n        case \"deleting\":\n          if (currentCharIndex > 0) {\n            setDisplayedText(graphemes.slice(0, currentCharIndex - 1).join(\"\"))\n            setCurrentCharIndex(currentCharIndex - 1)\n          } else {\n            const nextIndex = (currentWordIndex + 1) % wordsToAnimate.length\n            setCurrentWordIndex(nextIndex)\n            setPhase(\"typing\")\n          }\n          break\n      }\n    }, timeoutDelay)\n\n    return () => clearTimeout(timeout)\n  }, [\n    shouldStart,\n    phase,\n    currentCharIndex,\n    currentWordIndex,\n    displayedText,\n    wordsToAnimate,\n    hasMultipleWords,\n    loop,\n    typingSpeed,\n    deletingSpeed,\n    pauseDelay,\n    delay,\n  ])\n\n  const currentWordGraphemes = Array.from(\n    wordsToAnimate[currentWordIndex] || \"\"\n  )\n  const isComplete =\n    !loop &&\n    currentWordIndex === wordsToAnimate.length - 1 &&\n    currentCharIndex >= currentWordGraphemes.length &&\n    phase !== \"deleting\"\n\n  const shouldShowCursor =\n    showCursor &&\n    !isComplete &&\n    (hasMultipleWords || loop || currentCharIndex < currentWordGraphemes.length)\n\n  const getCursorChar = () => {\n    switch (cursorStyle) {\n      case \"block\":\n        return \"\"\n      case \"underscore\":\n        return \"_\"\n      case \"line\":\n      default:\n        return \"|\"\n    }\n  }\n\n  return (\n    <MotionComponent\n      ref={elementRef}\n      className={cn(\"leading-[5rem] tracking-[-0.02em]\", className)}\n      {...props}\n    >\n      {displayedText}\n      {shouldShowCursor && (\n        <span\n          className={cn(\"inline-block\", blinkCursor && \"animate-blink-cursor\")}\n        >\n          {getCursorChar()}\n        </span>\n      )}\n    </MotionComponent>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "variable-proximity",
      "type": "component",
      "description": "Variable font text that changes based on mouse proximity.",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/variable-proximity.tsx",
          "content": "import { forwardRef, useMemo, useRef, useEffect, MutableRefObject, CSSProperties, HTMLAttributes } from 'react';\nimport { motion } from 'motion/react';\n\nfunction useAnimationFrame(callback: () => void) {\n  useEffect(() => {\n    let frameId: number;\n    const loop = () => {\n      callback();\n      frameId = requestAnimationFrame(loop);\n    };\n    frameId = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(frameId);\n  }, [callback]);\n}\n\nfunction useMousePositionRef(containerRef: MutableRefObject<HTMLElement | null>) {\n  const positionRef = useRef({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const updatePosition = (x: number, y: number) => {\n      if (containerRef?.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        positionRef.current = { x: x - rect.left, y: y - rect.top };\n      } else {\n        positionRef.current = { x, y };\n      }\n    };\n\n    const handleMouseMove = (ev: MouseEvent) => updatePosition(ev.clientX, ev.clientY);\n    const handleTouchMove = (ev: TouchEvent) => {\n      const touch = ev.touches[0];\n      updatePosition(touch.clientX, touch.clientY);\n    };\n\n    window.addEventListener('mousemove', handleMouseMove);\n    window.addEventListener('touchmove', handleTouchMove);\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove);\n      window.removeEventListener('touchmove', handleTouchMove);\n    };\n  }, [containerRef]);\n\n  return positionRef;\n}\n\ninterface VariableProximityProps extends HTMLAttributes<HTMLSpanElement> {\n  label: string;\n  fromFontVariationSettings: string;\n  toFontVariationSettings: string;\n  containerRef: MutableRefObject<HTMLElement | null>;\n  radius?: number;\n  falloff?: 'linear' | 'exponential' | 'gaussian';\n  className?: string;\n  onClick?: () => void;\n  style?: CSSProperties;\n}\n\nconst VariableProximity = forwardRef<HTMLSpanElement, VariableProximityProps>((props, ref) => {\n  const {\n    label,\n    fromFontVariationSettings,\n    toFontVariationSettings,\n    containerRef,\n    radius = 50,\n    falloff = 'linear',\n    className = '',\n    onClick,\n    style,\n    ...restProps\n  } = props;\n\n  const letterRefs = useRef<(HTMLSpanElement | null)[]>([]);\n  const interpolatedSettingsRef = useRef<string[]>([]);\n  const mousePositionRef = useMousePositionRef(containerRef);\n  const lastPositionRef = useRef<{ x: number | null; y: number | null }>({ x: null, y: null });\n\n  const parsedSettings = useMemo(() => {\n    const parseSettings = (settingsStr: string) =>\n      new Map(\n        settingsStr\n          .split(',')\n          .map(s => s.trim())\n          .map(s => {\n            const [name, value] = s.split(' ');\n            return [name.replace(/['\"]/g, ''), parseFloat(value)];\n          })\n      );\n\n    const fromSettings = parseSettings(fromFontVariationSettings);\n    const toSettings = parseSettings(toFontVariationSettings);\n\n    return Array.from(fromSettings.entries()).map(([axis, fromValue]) => ({\n      axis,\n      fromValue,\n      toValue: toSettings.get(axis) ?? fromValue\n    }));\n  }, [fromFontVariationSettings, toFontVariationSettings]);\n\n  const calculateDistance = (x1: number, y1: number, x2: number, y2: number) =>\n    Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n\n  const calculateFalloff = (distance: number) => {\n    const norm = Math.min(Math.max(1 - distance / radius, 0), 1);\n    switch (falloff) {\n      case 'exponential':\n        return norm ** 2;\n      case 'gaussian':\n        return Math.exp(-((distance / (radius / 2)) ** 2) / 2);\n      case 'linear':\n      default:\n        return norm;\n    }\n  };\n\n  useAnimationFrame(() => {\n    if (!containerRef?.current) return;\n    const { x, y } = mousePositionRef.current;\n    if (lastPositionRef.current.x === x && lastPositionRef.current.y === y) {\n      return;\n    }\n    lastPositionRef.current = { x, y };\n    const containerRect = containerRef.current.getBoundingClientRect();\n\n    letterRefs.current.forEach((letterRef, index) => {\n      if (!letterRef) return;\n\n      const rect = letterRef.getBoundingClientRect();\n      const letterCenterX = rect.left + rect.width / 2 - containerRect.left;\n      const letterCenterY = rect.top + rect.height / 2 - containerRect.top;\n\n      const distance = calculateDistance(\n        mousePositionRef.current.x,\n        mousePositionRef.current.y,\n        letterCenterX,\n        letterCenterY\n      );\n\n      if (distance >= radius) {\n        letterRef.style.fontVariationSettings = fromFontVariationSettings;\n        return;\n      }\n\n      const falloffValue = calculateFalloff(distance);\n      const newSettings = parsedSettings\n        .map(({ axis, fromValue, toValue }) => {\n          const interpolatedValue = fromValue + (toValue - fromValue) * falloffValue;\n          return `'${axis}' ${interpolatedValue}`;\n        })\n        .join(', ');\n\n      interpolatedSettingsRef.current[index] = newSettings;\n      letterRef.style.fontVariationSettings = newSettings;\n    });\n  });\n\n  const words = label.split(' ');\n  let letterIndex = 0;\n\n  return (\n    <span\n      ref={ref}\n      onClick={onClick}\n      style={{\n        display: 'inline',\n        fontFamily: '\"Roboto Flex\", sans-serif',\n        ...style\n      }}\n      className={className}\n      {...restProps}\n    >\n      {words.map((word, wordIndex) => (\n        <span key={wordIndex} className=\"inline-block whitespace-nowrap\">\n          {word.split('').map(letter => {\n            const currentLetterIndex = letterIndex++;\n            return (\n              <motion.span\n                key={currentLetterIndex}\n                ref={el => {\n                  letterRefs.current[currentLetterIndex] = el;\n                }}\n                style={{\n                  display: 'inline-block',\n                  fontVariationSettings: interpolatedSettingsRef.current[currentLetterIndex]\n                }}\n                aria-hidden=\"true\"\n              >\n                {letter}\n              </motion.span>\n            );\n          })}\n          {wordIndex < words.length - 1 && <span className=\"inline-block\">&nbsp;</span>}\n        </span>\n      ))}\n      <span className=\"sr-only\">{label}</span>\n    </span>\n  );\n});\n\nVariableProximity.displayName = 'VariableProximity';\nexport default VariableProximity;\n",
          "type": "component"
        }
      ],
      "meta": {
        "_exampleContent": "import VariableProximity from \"./component\";\nimport { useRef } from \"react\";\n\nexport default function VariableProximityExample() {\n  const containerRef = useRef(null);\n\n  return (\n    <div ref={containerRef} className=\"flex items-center justify-center p-8\">\n      <VariableProximity\n        label=\"Hello World\"\n        fromFontVariationSettings=\"'wght' 400\"\n        toFontVariationSettings=\"'wght' 900\"\n        containerRef={containerRef}\n      />\n    </div>\n  );\n}\n"
      }
    },
    {
      "name": "video-text",
      "type": "component",
      "description": "A component that displays text with a video playing in the background.",
      "category": "text",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/video-text.tsx",
          "content": "\"use client\"\n\nimport React, { ElementType, ReactNode, useEffect, useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface VideoTextProps {\n  /**\n   * The video source URL\n   */\n  src: string\n  /**\n   * Additional className for the container\n   */\n  className?: string\n  /**\n   * Whether to autoplay the video\n   */\n  autoPlay?: boolean\n  /**\n   * Whether to mute the video\n   */\n  muted?: boolean\n  /**\n   * Whether to loop the video\n   */\n  loop?: boolean\n  /**\n   * Whether to preload the video\n   */\n  preload?: \"auto\" | \"metadata\" | \"none\"\n  /**\n   * The content to display (will have the video \"inside\" it)\n   */\n  children: ReactNode\n  /**\n   * Font size for the text mask (in viewport width units)\n   * @default 10\n   */\n  fontSize?: string | number\n  /**\n   * Font weight for the text mask\n   * @default \"bold\"\n   */\n  fontWeight?: string | number\n  /**\n   * Text anchor for the text mask\n   * @default \"middle\"\n   */\n  textAnchor?: string\n  /**\n   * Dominant baseline for the text mask\n   * @default \"middle\"\n   */\n  dominantBaseline?: string\n  /**\n   * Font family for the text mask\n   * @default \"sans-serif\"\n   */\n  fontFamily?: string\n  /**\n   * The element type to render for the text\n   * @default \"div\"\n   */\n  as?: ElementType\n}\n\nexport function VideoText({\n  src,\n  children,\n  className = \"\",\n  autoPlay = true,\n  muted = true,\n  loop = true,\n  preload = \"auto\",\n  fontSize = 20,\n  fontWeight = \"bold\",\n  textAnchor = \"middle\",\n  dominantBaseline = \"middle\",\n  fontFamily = \"sans-serif\",\n  as: Component = \"div\",\n}: VideoTextProps) {\n  const [svgMask, setSvgMask] = useState(\"\")\n  const content = React.Children.toArray(children).join(\"\")\n\n  useEffect(() => {\n    const updateSvgMask = () => {\n      const responsiveFontSize =\n        typeof fontSize === \"number\" ? `${fontSize}vw` : fontSize\n      const newSvgMask = `<svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%'><text x='50%' y='50%' font-size='${responsiveFontSize}' font-weight='${fontWeight}' text-anchor='${textAnchor}' dominant-baseline='${dominantBaseline}' font-family='${fontFamily}'>${content}</text></svg>`\n      setSvgMask(newSvgMask)\n    }\n\n    updateSvgMask()\n    window.addEventListener(\"resize\", updateSvgMask)\n    return () => window.removeEventListener(\"resize\", updateSvgMask)\n  }, [content, fontSize, fontWeight, textAnchor, dominantBaseline, fontFamily])\n\n  const dataUrlMask = `url(\"data:image/svg+xml,${encodeURIComponent(svgMask)}\")`\n\n  const Wrapper = Component as any\n  return (\n    <Wrapper className={cn(`relative size-full`, className)}>\n      {/* Create a container that masks the video to only show within text */}\n      <div\n        className=\"absolute inset-0 flex items-center justify-center\"\n        style={{\n          maskImage: dataUrlMask,\n          WebkitMaskImage: dataUrlMask,\n          maskSize: \"contain\",\n          WebkitMaskSize: \"contain\",\n          maskRepeat: \"no-repeat\",\n          WebkitMaskRepeat: \"no-repeat\",\n          maskPosition: \"center\",\n          WebkitMaskPosition: \"center\",\n        }}\n      >\n        <video\n          className=\"h-full w-full object-cover\"\n          autoPlay={autoPlay}\n          muted={muted}\n          loop={loop}\n          preload={preload}\n          playsInline\n        >\n          <source src={src} />\n          Your browser does not support the video tag.\n        </video>\n      </div>\n\n      {/* Add a backup text element for SEO/accessibility */}\n      <span className=\"sr-only\">{content}</span>\n    </Wrapper>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "word-rotate",
      "type": "component",
      "description": "A vertical rotation of words",
      "category": "text",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/word-rotate.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useState } from \"react\"\nimport { AnimatePresence, motion, MotionProps } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface WordRotateProps {\n  words: string[]\n  duration?: number\n  motionProps?: MotionProps\n  className?: string\n}\n\nexport function WordRotate({\n  words,\n  duration = 2500,\n  motionProps = {\n    initial: { opacity: 0, y: -50 },\n    animate: { opacity: 1, y: 0 },\n    exit: { opacity: 0, y: 50 },\n    transition: { duration: 0.25, ease: \"easeOut\" },\n  },\n  className,\n}: WordRotateProps) {\n  const [index, setIndex] = useState(0)\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setIndex((prevIndex) => (prevIndex + 1) % words.length)\n    }, duration)\n\n    // Clean up interval on unmount\n    return () => clearInterval(interval)\n  }, [words, duration])\n\n  return (\n    <div className=\"overflow-hidden py-2\">\n      <AnimatePresence mode=\"wait\">\n        <motion.h1\n          key={words[index]}\n          className={cn(className)}\n          {...motionProps}\n        >\n          {words[index]}\n        </motion.h1>\n      </AnimatePresence>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "text",
          "animation"
        ]
      }
    },
    {
      "name": "interactive-hover-button",
      "type": "component",
      "description": "A buttons interactive hover button component",
      "category": "buttons",
      "dependencies": [
        "lucide-react"
      ],
      "files": [
        {
          "path": "components/ui/interactive-hover-button.tsx",
          "content": "import { ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport function InteractiveHoverButton({\n  children,\n  className,\n  ...props\n}: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n  return (\n    <button\n      className={cn(\n        \"group bg-background relative w-auto cursor-pointer overflow-hidden rounded-full border p-2 px-6 text-center font-semibold\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"flex items-center gap-2\">\n        <div className=\"bg-primary h-2 w-2 rounded-full transition-all duration-300 group-hover:scale-[100.8]\"></div>\n        <span className=\"inline-block transition-all duration-300 group-hover:translate-x-12 group-hover:opacity-0\">\n          {children}\n        </span>\n      </div>\n      <div className=\"text-primary-foreground absolute top-0 z-10 flex h-full w-full translate-x-12 items-center justify-center gap-2 opacity-0 transition-all duration-300 group-hover:-translate-x-5 group-hover:opacity-100\">\n        <span>{children}</span>\n        <ArrowRight />\n      </div>\n    </button>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "buttons"
        ]
      }
    },
    {
      "name": "pulsating-button",
      "type": "component",
      "description": "A buttons pulsating button component",
      "category": "buttons",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/pulsating-button.tsx",
          "content": "import React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface PulsatingButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  pulseColor?: string\n  duration?: string\n}\n\nexport const PulsatingButton = React.forwardRef<\n  HTMLButtonElement,\n  PulsatingButtonProps\n>(\n  (\n    {\n      className,\n      children,\n      pulseColor = \"#808080\",\n      duration = \"1.5s\",\n      ...props\n    },\n    ref\n  ) => {\n    return (\n      <button\n        ref={ref}\n        className={cn(\n          \"bg-primary text-primary-foreground relative flex cursor-pointer items-center justify-center rounded-lg px-4 py-2 text-center\",\n          className\n        )}\n        style={\n          {\n            \"--pulse-color\": pulseColor,\n            \"--duration\": duration,\n          } as React.CSSProperties\n        }\n        {...props}\n      >\n        <div className=\"relative z-10\">{children}</div>\n        <div className=\"absolute top-1/2 left-1/2 size-full -translate-x-1/2 -translate-y-1/2 animate-pulse rounded-lg bg-inherit\" />\n      </button>\n    )\n  }\n)\n\nPulsatingButton.displayName = \"PulsatingButton\"\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "buttons"
        ]
      }
    },
    {
      "name": "rainbow-button",
      "type": "component",
      "description": "A buttons rainbow button component",
      "category": "buttons",
      "dependencies": [
        "@radix-ui/react-slot",
        "class-variance-authority"
      ],
      "files": [
        {
          "path": "components/ui/rainbow-button.tsx",
          "content": "import React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst rainbowButtonVariants = cva(\n  cn(\n    \"relative cursor-pointer group transition-all animate-rainbow\",\n    \"inline-flex items-center justify-center gap-2 shrink-0\",\n    \"rounded-sm outline-none focus-visible:ring-[3px] aria-invalid:border-destructive\",\n    \"text-sm font-medium whitespace-nowrap\",\n    \"disabled:pointer-events-none disabled:opacity-50\",\n    \"[&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0\"\n  ),\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-0 bg-[linear-gradient(#121213,#121213),linear-gradient(#121213_50%,rgba(18,18,19,0.6)_80%,rgba(18,18,19,0)),linear-gradient(90deg,var(--color-1),var(--color-5),var(--color-3),var(--color-4),var(--color-2))] bg-[length:200%] text-primary-foreground [background-clip:padding-box,border-box,border-box] [background-origin:border-box] [border:calc(0.125rem)_solid_transparent] before:absolute before:bottom-[-20%] before:left-1/2 before:z-0 before:h-1/5 before:w-3/5 before:-translate-x-1/2 before:animate-rainbow before:bg-[linear-gradient(90deg,var(--color-1),var(--color-5),var(--color-3),var(--color-4),var(--color-2))] before:[filter:blur(0.75rem)] dark:bg-[linear-gradient(#fff,#fff),linear-gradient(#fff_50%,rgba(255,255,255,0.6)_80%,rgba(0,0,0,0)),linear-gradient(90deg,var(--color-1),var(--color-5),var(--color-3),var(--color-4),var(--color-2))]\",\n        outline:\n          \"border border-input border-b-transparent bg-[linear-gradient(#ffffff,#ffffff),linear-gradient(#ffffff_50%,rgba(18,18,19,0.6)_80%,rgba(18,18,19,0)),linear-gradient(90deg,var(--color-1),var(--color-5),var(--color-3),var(--color-4),var(--color-2))] bg-[length:200%] text-accent-foreground [background-clip:padding-box,border-box,border-box] [background-origin:border-box] before:absolute before:bottom-[-20%] before:left-1/2 before:z-0 before:h-1/5 before:w-3/5 before:-translate-x-1/2 before:animate-rainbow before:bg-[linear-gradient(90deg,var(--color-1),var(--color-5),var(--color-3),var(--color-4),var(--color-2))] before:[filter:blur(0.75rem)] dark:bg-[linear-gradient(#0a0a0a,#0a0a0a),linear-gradient(#0a0a0a_50%,rgba(255,255,255,0.6)_80%,rgba(0,0,0,0)),linear-gradient(90deg,var(--color-1),var(--color-5),var(--color-3),var(--color-4),var(--color-2))]\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2\",\n        sm: \"h-8 rounded-xl px-3 text-xs\",\n        lg: \"h-11 rounded-xl px-8\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\ninterface RainbowButtonProps\n  extends\n    React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof rainbowButtonVariants> {\n  asChild?: boolean\n}\n\nconst RainbowButton = React.forwardRef<HTMLButtonElement, RainbowButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        data-slot=\"button\"\n        className={cn(rainbowButtonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\n\nRainbowButton.displayName = \"RainbowButton\"\n\nexport { RainbowButton, rainbowButtonVariants, type RainbowButtonProps }\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "buttons"
        ]
      }
    },
    {
      "name": "ripple-button",
      "type": "component",
      "description": "A buttons ripple button component",
      "category": "buttons",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/ripple-button.tsx",
          "content": "\"use client\"\n\nimport React, { MouseEvent, useEffect, useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface RippleButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  rippleColor?: string\n  duration?: string\n}\n\nexport const RippleButton = React.forwardRef<\n  HTMLButtonElement,\n  RippleButtonProps\n>(\n  (\n    {\n      className,\n      children,\n      rippleColor = \"#ffffff\",\n      duration = \"600ms\",\n      onClick,\n      ...props\n    },\n    ref\n  ) => {\n    const [buttonRipples, setButtonRipples] = useState<\n      Array<{ x: number; y: number; size: number; key: number }>\n    >([])\n\n    const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n      createRipple(event)\n      onClick?.(event)\n    }\n\n    const createRipple = (event: MouseEvent<HTMLButtonElement>) => {\n      const button = event.currentTarget\n      const rect = button.getBoundingClientRect()\n      const size = Math.max(rect.width, rect.height)\n      const x = event.clientX - rect.left - size / 2\n      const y = event.clientY - rect.top - size / 2\n\n      const newRipple = { x, y, size, key: Date.now() }\n      setButtonRipples((prevRipples) => [...prevRipples, newRipple])\n    }\n\n    useEffect(() => {\n      if (buttonRipples.length > 0) {\n        const lastRipple = buttonRipples[buttonRipples.length - 1]\n        const timeout = setTimeout(() => {\n          setButtonRipples((prevRipples) =>\n            prevRipples.filter((ripple) => ripple.key !== lastRipple.key)\n          )\n        }, parseInt(duration))\n        return () => clearTimeout(timeout)\n      }\n    }, [buttonRipples, duration])\n\n    return (\n      <button\n        className={cn(\n          \"bg-background text-primary relative flex cursor-pointer items-center justify-center overflow-hidden rounded-lg border-2 px-4 py-2 text-center\",\n          className\n        )}\n        onClick={handleClick}\n        ref={ref}\n        {...props}\n      >\n        <div className=\"relative z-10\">{children}</div>\n        <span className=\"pointer-events-none absolute inset-0\">\n          {buttonRipples.map((ripple) => (\n            <span\n              className=\"animate-rippling bg-background absolute rounded-full opacity-30\"\n              key={ripple.key}\n              style={{\n                width: `${ripple.size}px`,\n                height: `${ripple.size}px`,\n                top: `${ripple.y}px`,\n                left: `${ripple.x}px`,\n                backgroundColor: rippleColor,\n                transform: `scale(0)`,\n              }}\n            />\n          ))}\n        </span>\n      </button>\n    )\n  }\n)\n\nRippleButton.displayName = \"RippleButton\"\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "buttons"
        ]
      }
    },
    {
      "name": "shimmer-button",
      "type": "component",
      "description": "A button with a shimmering light which travels around the perimeter.",
      "category": "buttons",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/shimmer-button.tsx",
          "content": "import React, { ComponentPropsWithoutRef, CSSProperties } from 'react';\n\nimport { cn } from '@/lib/utils';\n\nexport interface ShimmerButtonProps extends ComponentPropsWithoutRef<'button'> {\n  shimmerColor?: string;\n  shimmerSize?: string;\n  borderRadius?: string;\n  shimmerDuration?: string;\n  background?: string;\n  className?: string;\n  children?: React.ReactNode;\n}\n\nexport const ShimmerButton = React.forwardRef<HTMLButtonElement, ShimmerButtonProps>(\n  (\n    {\n      shimmerColor = '#ffffff',\n      shimmerSize = '0.05em',\n      shimmerDuration = '3s',\n      borderRadius = '100px',\n      background = 'rgba(0, 0, 0, 1)',\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    return (\n      <button\n        style={\n          {\n            '--spread': '90deg',\n            '--shimmer-color': shimmerColor,\n            '--radius': borderRadius,\n            '--speed': shimmerDuration,\n            '--cut': shimmerSize,\n            '--bg': background,\n          } as CSSProperties\n        }\n        className={cn(\n          'group relative z-0 flex cursor-pointer items-center justify-center overflow-hidden [border-radius:var(--radius)] border border-white/10 px-6 py-3 whitespace-nowrap text-white [background:var(--bg)]',\n          'transform-gpu transition-transform duration-300 ease-in-out active:translate-y-px',\n          className\n        )}\n        ref={ref}\n        {...props}\n      >\n        {/* spark container */}\n        <div\n          className={cn(\n            '-z-30 blur-[2px]',\n            '[container-type:size] absolute inset-0 overflow-visible'\n          )}\n        >\n          {/* spark */}\n          <div className=\"animate-shimmer-slide absolute inset-0 [aspect-ratio:1] h-[100cqh] [border-radius:0] [mask:none]\">\n            {/* spark before */}\n            <div className=\"animate-spin-around absolute -inset-full w-auto [translate:0_0] rotate-0 [background:conic-gradient(from_calc(270deg-(var(--spread)*0.5)),transparent_0,var(--shimmer-color)_var(--spread),transparent_var(--spread))]\" />\n          </div>\n        </div>\n        {children}\n\n        {/* Highlight */}\n        <div\n          className={cn(\n            'absolute inset-0 size-full',\n\n            'rounded-2xl px-4 py-1.5 text-sm font-medium shadow-[inset_0_-8px_10px_#ffffff1f]',\n\n            // transition\n            'transform-gpu transition-all duration-300 ease-in-out',\n\n            // on hover\n            'group-hover:shadow-[inset_0_-6px_10px_#ffffff3f]',\n\n            // on click\n            'group-active:shadow-[inset_0_-10px_10px_#ffffff3f]'\n          )}\n        />\n\n        {/* backdrop */}\n        <div\n          className={cn(\n            'absolute [inset:var(--cut)] -z-20 [border-radius:var(--radius)] [background:var(--bg)]'\n          )}\n        />\n      </button>\n    );\n  }\n);\n\nShimmerButton.displayName = 'ShimmerButton';\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "button",
          "shimmer",
          "animation",
          "interactive"
        ],
        "featured": true
      }
    },
    {
      "name": "shiny-button",
      "type": "component",
      "description": "A buttons shiny button component",
      "category": "buttons",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/shiny-button.tsx",
          "content": "\"use client\"\n\nimport React from \"react\"\nimport { motion, type MotionProps } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst animationProps: MotionProps = {\n  initial: { \"--x\": \"100%\", scale: 0.8 },\n  animate: { \"--x\": \"-100%\", scale: 1 },\n  whileTap: { scale: 0.95 },\n  transition: {\n    repeat: Infinity,\n    repeatType: \"loop\",\n    repeatDelay: 1,\n    type: \"spring\",\n    stiffness: 20,\n    damping: 15,\n    mass: 2,\n    scale: {\n      type: \"spring\",\n      stiffness: 200,\n      damping: 5,\n      mass: 0.5,\n    },\n  },\n}\n\ninterface ShinyButtonProps\n  extends\n    Omit<React.HTMLAttributes<HTMLElement>, keyof MotionProps>,\n    MotionProps {\n  children: React.ReactNode\n  className?: string\n}\n\nexport const ShinyButton = React.forwardRef<\n  HTMLButtonElement,\n  ShinyButtonProps\n>(({ children, className, ...props }, ref) => {\n  return (\n    <motion.button\n      ref={ref}\n      className={cn(\n        \"relative cursor-pointer rounded-lg border px-6 py-2 font-medium backdrop-blur-xl transition-shadow duration-300 ease-in-out hover:shadow dark:bg-[radial-gradient(circle_at_50%_0%,var(--primary)/10%_0%,transparent_60%)] dark:hover:shadow-[0_0_20px_var(--primary)/10%]\",\n        className\n      )}\n      {...animationProps}\n      {...props}\n    >\n      <span\n        className=\"relative block size-full text-sm tracking-wide text-[rgb(0,0,0,65%)] uppercase dark:font-light dark:text-[rgb(255,255,255,90%)]\"\n        style={{\n          maskImage:\n            \"linear-gradient(-75deg,var(--primary) calc(var(--x) + 20%),transparent calc(var(--x) + 30%),var(--primary) calc(var(--x) + 100%))\",\n        }}\n      >\n        {children}\n      </span>\n      <span\n        style={{\n          mask: \"linear-gradient(rgb(0,0,0), rgb(0,0,0)) content-box exclude,linear-gradient(rgb(0,0,0), rgb(0,0,0))\",\n          WebkitMask:\n            \"linear-gradient(rgb(0,0,0), rgb(0,0,0)) content-box exclude,linear-gradient(rgb(0,0,0), rgb(0,0,0))\",\n          backgroundImage:\n            \"linear-gradient(-75deg,var(--primary)/10% calc(var(--x)+20%),var(--primary)/50% calc(var(--x)+25%),var(--primary)/10% calc(var(--x)+100%))\",\n        }}\n        className=\"absolute inset-0 z-10 block rounded-[inherit] p-px\"\n      />\n    </motion.button>\n  )\n})\n\nShinyButton.displayName = \"ShinyButton\"\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "buttons"
        ]
      }
    },
    {
      "name": "bento-grid",
      "type": "component",
      "description": "Bento grid is a layout used to showcase the features of a product.",
      "category": "layouts",
      "dependencies": [
        "@radix-ui/react-icons"
      ],
      "files": [
        {
          "path": "components/ui/bento-grid.tsx",
          "content": "import { ComponentPropsWithoutRef, ReactNode } from \"react\"\nimport { ArrowRightIcon } from \"@radix-ui/react-icons\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ninterface BentoGridProps extends ComponentPropsWithoutRef<\"div\"> {\n  children: ReactNode\n  className?: string\n}\n\ninterface BentoCardProps extends ComponentPropsWithoutRef<\"div\"> {\n  name: string\n  className: string\n  background: ReactNode\n  Icon: React.ElementType\n  description: string\n  href: string\n  cta: string\n}\n\nconst BentoGrid = ({ children, className, ...props }: BentoGridProps) => {\n  return (\n    <div\n      className={cn(\n        \"grid w-full auto-rows-[22rem] grid-cols-3 gap-4\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n\nconst BentoCard = ({\n  name,\n  className,\n  background,\n  Icon,\n  description,\n  href,\n  cta,\n  ...props\n}: BentoCardProps) => (\n  <div\n    key={name}\n    className={cn(\n      \"group relative col-span-3 flex flex-col justify-between overflow-hidden rounded-xl\",\n      // light styles\n      \"bg-background [box-shadow:0_0_0_1px_rgba(0,0,0,.03),0_2px_4px_rgba(0,0,0,.05),0_12px_24px_rgba(0,0,0,.05)]\",\n      // dark styles\n      \"dark:bg-background transform-gpu dark:[box-shadow:0_-20px_80px_-20px_#ffffff1f_inset] dark:[border:1px_solid_rgba(255,255,255,.1)]\",\n      className\n    )}\n    {...props}\n  >\n    <div>{background}</div>\n    <div className=\"p-4\">\n      <div className=\"pointer-events-none z-10 flex transform-gpu flex-col gap-1 transition-all duration-300 lg:group-hover:-translate-y-10\">\n        {/* @ts-expect-error - ElementType className prop */}\n        <Icon className=\"h-12 w-12 origin-left transform-gpu text-neutral-700 transition-all duration-300 ease-in-out group-hover:scale-75\" />\n        <h3 className=\"text-xl font-semibold text-neutral-700 dark:text-neutral-300\">\n          {name}\n        </h3>\n        <p className=\"max-w-lg text-neutral-400\">{description}</p>\n      </div>\n\n      <div\n        className={cn(\n          \"pointer-events-none flex w-full translate-y-0 transform-gpu flex-row items-center transition-all duration-300 group-hover:translate-y-0 group-hover:opacity-100 lg:hidden\"\n        )}\n      >\n        <Button\n          variant=\"link\"\n          asChild\n          size=\"sm\"\n          className=\"pointer-events-auto p-0\"\n        >\n          <a href={href}>\n            {cta}\n            <ArrowRightIcon className=\"ms-2 h-4 w-4 rtl:rotate-180\" />\n          </a>\n        </Button>\n      </div>\n    </div>\n\n    <div\n      className={cn(\n        \"pointer-events-none absolute bottom-0 hidden w-full translate-y-10 transform-gpu flex-row items-center p-4 opacity-0 transition-all duration-300 group-hover:translate-y-0 group-hover:opacity-100 lg:flex\"\n      )}\n    >\n      <Button\n        variant=\"link\"\n        asChild\n        size=\"sm\"\n        className=\"pointer-events-auto p-0\"\n      >\n        <a href={href}>\n          {cta}\n          <ArrowRightIcon className=\"ms-2 h-4 w-4 rtl:rotate-180\" />\n        </a>\n      </Button>\n    </div>\n\n    <div className=\"pointer-events-none absolute inset-0 transform-gpu transition-all duration-300 group-hover:bg-black/[.03] group-hover:dark:bg-neutral-800/10\" />\n  </div>\n)\n\nexport { BentoCard, BentoGrid }\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "bounce-cards",
      "type": "component",
      "description": "A layouts bounce cards component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/bounce-cards.tsx",
          "content": "import { useEffect, useRef } from 'react';\nimport { gsap } from 'gsap';\n\ninterface BounceCardsProps {\n  className?: string;\n  images?: string[];\n  containerWidth?: number;\n  containerHeight?: number;\n  animationDelay?: number;\n  animationStagger?: number;\n  easeType?: string;\n  transformStyles?: string[];\n  enableHover?: boolean;\n}\n\nexport default function BounceCards({\n  className = '',\n  images = [],\n  containerWidth = 400,\n  containerHeight = 400,\n  animationDelay = 0.5,\n  animationStagger = 0.06,\n  easeType = 'elastic.out(1, 0.8)',\n  transformStyles = [\n    'rotate(10deg) translate(-170px)',\n    'rotate(5deg) translate(-85px)',\n    'rotate(-3deg)',\n    'rotate(-10deg) translate(85px)',\n    'rotate(2deg) translate(170px)'\n  ],\n  enableHover = false\n}: BounceCardsProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  useEffect(() => {\n    const ctx = gsap.context(() => {\n      gsap.fromTo(\n        '.card',\n        { scale: 0 },\n        {\n          scale: 1,\n          stagger: animationStagger,\n          ease: easeType,\n          delay: animationDelay\n        }\n      );\n    }, containerRef);\n    return () => ctx.revert();\n  }, [animationDelay, animationStagger, easeType]);\n\n  const getNoRotationTransform = (transformStr: string): string => {\n    const hasRotate = /rotate\\([\\s\\S]*?\\)/.test(transformStr);\n    if (hasRotate) {\n      return transformStr.replace(/rotate\\([\\s\\S]*?\\)/, 'rotate(0deg)');\n    } else if (transformStr === 'none') {\n      return 'rotate(0deg)';\n    } else {\n      return `${transformStr} rotate(0deg)`;\n    }\n  };\n\n  const getPushedTransform = (baseTransform: string, offsetX: number): string => {\n    const translateRegex = /translate\\(([-0-9.]+)px\\)/;\n    const match = baseTransform.match(translateRegex);\n    if (match) {\n      const currentX = parseFloat(match[1]);\n      const newX = currentX + offsetX;\n      return baseTransform.replace(translateRegex, `translate(${newX}px)`);\n    } else {\n      return baseTransform === 'none' ? `translate(${offsetX}px)` : `${baseTransform} translate(${offsetX}px)`;\n    }\n  };\n\n  const pushSiblings = (hoveredIdx: number) => {\n    const q = gsap.utils.selector(containerRef);\n    if (!enableHover || !containerRef.current) return;\n\n    images.forEach((_, i) => {\n      const selector = q(`.card-${i}`);\n      gsap.killTweensOf(selector);\n\n      const baseTransform = transformStyles[i] || 'none';\n\n      if (i === hoveredIdx) {\n        const noRotation = getNoRotationTransform(baseTransform);\n        gsap.to(selector, {\n          transform: noRotation,\n          duration: 0.4,\n          ease: 'back.out(1.4)',\n          overwrite: 'auto'\n        });\n      } else {\n        const offsetX = i < hoveredIdx ? -160 : 160;\n        const pushedTransform = getPushedTransform(baseTransform, offsetX);\n\n        const distance = Math.abs(hoveredIdx - i);\n        const delay = distance * 0.05;\n\n        gsap.to(selector, {\n          transform: pushedTransform,\n          duration: 0.4,\n          ease: 'back.out(1.4)',\n          delay,\n          overwrite: 'auto'\n        });\n      }\n    });\n  };\n\n  const resetSiblings = () => {\n    if (!enableHover || !containerRef.current) return;\n    const q = gsap.utils.selector(containerRef);\n\n    images.forEach((_, i) => {\n      const selector = q(`.card-${i}`);\n      gsap.killTweensOf(selector);\n\n      const baseTransform = transformStyles[i] || 'none';\n      gsap.to(selector, {\n        transform: baseTransform,\n        duration: 0.4,\n        ease: 'back.out(1.4)',\n        overwrite: 'auto'\n      });\n    });\n  };\n\n  return (\n    <div\n      className={`relative flex items-center justify-center ${className}`}\n      ref={containerRef}\n      style={{\n        width: containerWidth,\n        height: containerHeight\n      }}\n    >\n      {images.map((src, idx) => (\n        <div\n          key={idx}\n          className={`card card-${idx} absolute w-[200px] aspect-square border-8 border-white rounded-[30px] overflow-hidden`}\n          style={{\n            boxShadow: '0 4px 10px rgba(0, 0, 0, 0.2)',\n            transform: transformStyles[idx] || 'none'\n          }}\n          onMouseEnter={() => pushSiblings(idx)}\n          onMouseLeave={resetSiblings}\n        >\n          <img className=\"w-full h-full object-cover\" src={src} alt={`card-${idx}`} />\n        </div>\n      ))}\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "bubble-menu",
      "type": "component",
      "description": "A layouts bubble menu component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/bubble-menu.tsx",
          "content": "import type { CSSProperties, ReactNode } from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { gsap } from 'gsap';\n\ntype MenuItem = {\n  label: string;\n  href: string;\n  ariaLabel?: string;\n  rotation?: number;\n  hoverStyles?: {\n    bgColor?: string;\n    textColor?: string;\n  };\n};\n\nexport type BubbleMenuProps = {\n  logo: ReactNode | string;\n  onMenuClick?: (open: boolean) => void;\n  className?: string;\n  style?: CSSProperties;\n  menuAriaLabel?: string;\n  menuBg?: string;\n  menuContentColor?: string;\n  useFixedPosition?: boolean;\n  items?: MenuItem[];\n  animationEase?: string;\n  animationDuration?: number;\n  staggerDelay?: number;\n};\n\nconst DEFAULT_ITEMS: MenuItem[] = [\n  {\n    label: 'home',\n    href: '#',\n    ariaLabel: 'Home',\n    rotation: -8,\n    hoverStyles: { bgColor: '#3b82f6', textColor: '#ffffff' }\n  },\n  {\n    label: 'about',\n    href: '#',\n    ariaLabel: 'About',\n    rotation: 8,\n    hoverStyles: { bgColor: '#10b981', textColor: '#ffffff' }\n  },\n  {\n    label: 'projects',\n    href: '#',\n    ariaLabel: 'Documentation',\n    rotation: 8,\n    hoverStyles: { bgColor: '#f59e0b', textColor: '#ffffff' }\n  },\n  {\n    label: 'blog',\n    href: '#',\n    ariaLabel: 'Blog',\n    rotation: 8,\n    hoverStyles: { bgColor: '#ef4444', textColor: '#ffffff' }\n  },\n  {\n    label: 'contact',\n    href: '#',\n    ariaLabel: 'Contact',\n    rotation: -8,\n    hoverStyles: { bgColor: '#8b5cf6', textColor: '#ffffff' }\n  }\n];\n\nexport default function BubbleMenu({\n  logo,\n  onMenuClick,\n  className,\n  style,\n  menuAriaLabel = 'Toggle menu',\n  menuBg = '#fff',\n  menuContentColor = '#111',\n  useFixedPosition = false,\n  items,\n  animationEase = 'back.out(1.5)',\n  animationDuration = 0.5,\n  staggerDelay = 0.12\n}: BubbleMenuProps) {\n  const [isMenuOpen, setIsMenuOpen] = useState(false);\n  const [showOverlay, setShowOverlay] = useState(false);\n\n  const overlayRef = useRef<HTMLDivElement>(null);\n  const bubblesRef = useRef<HTMLAnchorElement[]>([]);\n  const labelRefs = useRef<HTMLSpanElement[]>([]);\n\n  const menuItems = items?.length ? items : DEFAULT_ITEMS;\n\n  const containerClassName = [\n    'bubble-menu',\n    useFixedPosition ? 'fixed' : 'absolute',\n    'left-0 right-0 top-8',\n    'flex items-center justify-between',\n    'gap-4 px-8',\n    'pointer-events-none',\n    'z-[1001]',\n    className\n  ]\n    .filter(Boolean)\n    .join(' ');\n\n  const handleToggle = () => {\n    const nextState = !isMenuOpen;\n    if (nextState) setShowOverlay(true);\n    setIsMenuOpen(nextState);\n    onMenuClick?.(nextState);\n  };\n\n  useEffect(() => {\n    const overlay = overlayRef.current;\n    const bubbles = bubblesRef.current.filter(Boolean);\n    const labels = labelRefs.current.filter(Boolean);\n    if (!overlay || !bubbles.length) return;\n\n    if (isMenuOpen) {\n      gsap.set(overlay, { display: 'flex' });\n      gsap.killTweensOf([...bubbles, ...labels]);\n      gsap.set(bubbles, { scale: 0, transformOrigin: '50% 50%' });\n      gsap.set(labels, { y: 24, autoAlpha: 0 });\n\n      bubbles.forEach((bubble, i) => {\n        const delay = i * staggerDelay + gsap.utils.random(-0.05, 0.05);\n        const tl = gsap.timeline({ delay });\n        tl.to(bubble, {\n          scale: 1,\n          duration: animationDuration,\n          ease: animationEase\n        });\n        if (labels[i]) {\n          tl.to(\n            labels[i],\n            {\n              y: 0,\n              autoAlpha: 1,\n              duration: animationDuration,\n              ease: 'power3.out'\n            },\n            '-=' + animationDuration * 0.9\n          );\n        }\n      });\n    } else if (showOverlay) {\n      gsap.killTweensOf([...bubbles, ...labels]);\n      gsap.to(labels, {\n        y: 24,\n        autoAlpha: 0,\n        duration: 0.2,\n        ease: 'power3.in'\n      });\n      gsap.to(bubbles, {\n        scale: 0,\n        duration: 0.2,\n        ease: 'power3.in',\n        onComplete: () => {\n          gsap.set(overlay, { display: 'none' });\n          setShowOverlay(false);\n        }\n      });\n    }\n  }, [isMenuOpen, showOverlay, animationEase, animationDuration, staggerDelay]);\n\n  useEffect(() => {\n    const handleResize = () => {\n      if (isMenuOpen) {\n        const bubbles = bubblesRef.current.filter(Boolean);\n        const isDesktop = window.innerWidth >= 900;\n        bubbles.forEach((bubble, i) => {\n          const item = menuItems[i];\n          if (bubble && item) {\n            const rotation = isDesktop ? (item.rotation ?? 0) : 0;\n            gsap.set(bubble, { rotation });\n          }\n        });\n      }\n    };\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [isMenuOpen, menuItems]);\n\n  return (\n    <>\n      {/* Workaround for silly Tailwind capabilities */}\n      <style>{`\n        .bubble-menu .menu-line {\n          transition: transform 0.3s ease, opacity 0.3s ease;\n          transform-origin: center;\n        }\n        .bubble-menu-items .pill-list .pill-col:nth-child(4):nth-last-child(2) {\n          margin-left: calc(100% / 6);\n        }\n        .bubble-menu-items .pill-list .pill-col:nth-child(4):last-child {\n          margin-left: calc(100% / 3);\n        }\n        @media (min-width: 900px) {\n          .bubble-menu-items .pill-link {\n            transform: rotate(var(--item-rot));\n          }\n          .bubble-menu-items .pill-link:hover {\n            transform: rotate(var(--item-rot)) scale(1.06);\n            background: var(--hover-bg) !important;\n            color: var(--hover-color) !important;\n          }\n          .bubble-menu-items .pill-link:active {\n            transform: rotate(var(--item-rot)) scale(.94);\n          }\n        }\n        @media (max-width: 899px) {\n          .bubble-menu-items {\n            padding-top: 120px;\n            align-items: flex-start;\n          }\n          .bubble-menu-items .pill-list {\n            row-gap: 16px;\n          }\n          .bubble-menu-items .pill-list .pill-col {\n            flex: 0 0 100% !important;\n            margin-left: 0 !important;\n            overflow: visible;\n          }\n          .bubble-menu-items .pill-link {\n            font-size: clamp(1.2rem, 3vw, 4rem);\n            padding: clamp(1rem, 2vw, 2rem) 0;\n            min-height: 80px !important;\n          }\n          .bubble-menu-items .pill-link:hover {\n            transform: scale(1.06);\n            background: var(--hover-bg);\n            color: var(--hover-color);\n          }\n          .bubble-menu-items .pill-link:active {\n            transform: scale(.94);\n          }\n        }\n      `}</style>\n\n      <nav className={containerClassName} style={style} aria-label=\"Main navigation\">\n        <div\n          className={[\n            'bubble logo-bubble',\n            'inline-flex items-center justify-center',\n            'rounded-full',\n            'bg-white',\n            'shadow-[0_4px_16px_rgba(0,0,0,0.12)]',\n            'pointer-events-auto',\n            'h-12 md:h-14',\n            'px-4 md:px-8',\n            'gap-2',\n            'will-change-transform'\n          ].join(' ')}\n          aria-label=\"Logo\"\n          style={{\n            background: menuBg,\n            minHeight: '48px',\n            borderRadius: '9999px'\n          }}\n        >\n          <span\n            className={['logo-content', 'inline-flex items-center justify-center', 'w-[120px] h-full'].join(' ')}\n            style={\n              {\n                ['--logo-max-height']: '60%',\n                ['--logo-max-width']: '100%'\n              } as CSSProperties\n            }\n          >\n            {typeof logo === 'string' ? (\n              <img src={logo} alt=\"Logo\" className=\"bubble-logo max-h-[60%] max-w-full object-contain block\" />\n            ) : (\n              logo\n            )}\n          </span>\n        </div>\n\n        <button\n          type=\"button\"\n          className={[\n            'bubble toggle-bubble menu-btn',\n            isMenuOpen ? 'open' : '',\n            'inline-flex flex-col items-center justify-center',\n            'rounded-full',\n            'bg-white',\n            'shadow-[0_4px_16px_rgba(0,0,0,0.12)]',\n            'pointer-events-auto',\n            'w-12 h-12 md:w-14 md:h-14',\n            'border-0 cursor-pointer p-0',\n            'will-change-transform'\n          ].join(' ')}\n          onClick={handleToggle}\n          aria-label={menuAriaLabel}\n          aria-pressed={isMenuOpen}\n          style={{ background: menuBg }}\n        >\n          <span\n            className=\"menu-line block mx-auto rounded-[2px]\"\n            style={{\n              width: 26,\n              height: 2,\n              background: menuContentColor,\n              transform: isMenuOpen ? 'translateY(4px) rotate(45deg)' : 'none'\n            }}\n          />\n          <span\n            className=\"menu-line short block mx-auto rounded-[2px]\"\n            style={{\n              marginTop: '6px',\n              width: 26,\n              height: 2,\n              background: menuContentColor,\n              transform: isMenuOpen ? 'translateY(-4px) rotate(-45deg)' : 'none'\n            }}\n          />\n        </button>\n      </nav>\n\n      {showOverlay && (\n        <div\n          ref={overlayRef}\n          className={[\n            'bubble-menu-items',\n            useFixedPosition ? 'fixed' : 'absolute',\n            'inset-0',\n            'flex items-center justify-center',\n            'pointer-events-none',\n            'z-[1000]'\n          ].join(' ')}\n          aria-hidden={!isMenuOpen}\n        >\n          <ul\n            className={[\n              'pill-list',\n              'list-none m-0 px-6',\n              'w-full max-w-[1600px] mx-auto',\n              'flex flex-wrap',\n              'gap-x-0 gap-y-1',\n              'pointer-events-auto'\n            ].join(' ')}\n            role=\"menu\"\n            aria-label=\"Menu links\"\n          >\n            {menuItems.map((item, idx) => (\n              <li\n                key={idx}\n                role=\"none\"\n                className={[\n                  'pill-col',\n                  'flex justify-center items-stretch',\n                  '[flex:0_0_calc(100%/3)]',\n                  'box-border'\n                ].join(' ')}\n              >\n                <a\n                  role=\"menuitem\"\n                  href={item.href}\n                  aria-label={item.ariaLabel || item.label}\n                  className={[\n                    'pill-link',\n                    'w-full',\n                    'rounded-[999px]',\n                    'no-underline',\n                    'bg-white',\n                    'text-inherit',\n                    'shadow-[0_4px_14px_rgba(0,0,0,0.10)]',\n                    'flex items-center justify-center',\n                    'relative',\n                    'transition-[background,color] duration-300 ease-in-out',\n                    'box-border',\n                    'whitespace-nowrap overflow-hidden'\n                  ].join(' ')}\n                  style={\n                    {\n                      ['--item-rot']: `${item.rotation ?? 0}deg`,\n                      ['--pill-bg']: menuBg,\n                      ['--pill-color']: menuContentColor,\n                      ['--hover-bg']: item.hoverStyles?.bgColor || '#f3f4f6',\n                      ['--hover-color']: item.hoverStyles?.textColor || menuContentColor,\n                      background: 'var(--pill-bg)',\n                      color: 'var(--pill-color)',\n                      minHeight: 'var(--pill-min-h, 160px)',\n                      padding: 'clamp(1.5rem, 3vw, 8rem) 0',\n                      fontSize: 'clamp(1.5rem, 4vw, 4rem)',\n                      fontWeight: 400,\n                      lineHeight: 0,\n                      willChange: 'transform',\n                      height: 10\n                    } as CSSProperties\n                  }\n                  ref={el => {\n                    if (el) bubblesRef.current[idx] = el;\n                  }}\n                >\n                  <span\n                    className=\"pill-label inline-block\"\n                    style={{\n                      willChange: 'transform, opacity',\n                      height: '1.2em',\n                      lineHeight: 1.2\n                    }}\n                    ref={el => {\n                      if (el) labelRefs.current[idx] = el;\n                    }}\n                  >\n                    {item.label}\n                  </span>\n                </a>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "card-nav",
      "type": "component",
      "description": "A layouts card nav component",
      "category": "layouts",
      "dependencies": [
        "gsap",
        "react-icons"
      ],
      "files": [
        {
          "path": "components/ui/card-nav.tsx",
          "content": "import React, { useLayoutEffect, useRef, useState } from 'react';\nimport { gsap } from 'gsap';\n// use your own icon import if react-icons is not available\nimport { GoArrowUpRight } from 'react-icons/go';\n\ntype CardNavLink = {\n  label: string;\n  href: string;\n  ariaLabel: string;\n};\n\nexport type CardNavItem = {\n  label: string;\n  bgColor: string;\n  textColor: string;\n  links: CardNavLink[];\n};\n\nexport interface CardNavProps {\n  logo: string;\n  logoAlt?: string;\n  items: CardNavItem[];\n  className?: string;\n  ease?: string;\n  baseColor?: string;\n  menuColor?: string;\n  buttonBgColor?: string;\n  buttonTextColor?: string;\n}\n\nconst CardNav: React.FC<CardNavProps> = ({\n  logo,\n  logoAlt = 'Logo',\n  items,\n  className = '',\n  ease = 'power3.out',\n  baseColor = '#fff',\n  menuColor,\n  buttonBgColor,\n  buttonTextColor\n}) => {\n  const [isHamburgerOpen, setIsHamburgerOpen] = useState(false);\n  const [isExpanded, setIsExpanded] = useState(false);\n  const navRef = useRef<HTMLDivElement | null>(null);\n  const cardsRef = useRef<HTMLDivElement[]>([]);\n  const tlRef = useRef<gsap.core.Timeline | null>(null);\n\n  const calculateHeight = () => {\n    const navEl = navRef.current;\n    if (!navEl) return 260;\n\n    const isMobile = window.matchMedia('(max-width: 768px)').matches;\n    if (isMobile) {\n      const contentEl = navEl.querySelector('.card-nav-content') as HTMLElement;\n      if (contentEl) {\n        const wasVisible = contentEl.style.visibility;\n        const wasPointerEvents = contentEl.style.pointerEvents;\n        const wasPosition = contentEl.style.position;\n        const wasHeight = contentEl.style.height;\n\n        contentEl.style.visibility = 'visible';\n        contentEl.style.pointerEvents = 'auto';\n        contentEl.style.position = 'static';\n        contentEl.style.height = 'auto';\n\n        contentEl.offsetHeight;\n\n        const topBar = 60;\n        const padding = 16;\n        const contentHeight = contentEl.scrollHeight;\n\n        contentEl.style.visibility = wasVisible;\n        contentEl.style.pointerEvents = wasPointerEvents;\n        contentEl.style.position = wasPosition;\n        contentEl.style.height = wasHeight;\n\n        return topBar + contentHeight + padding;\n      }\n    }\n    return 260;\n  };\n\n  const createTimeline = () => {\n    const navEl = navRef.current;\n    if (!navEl) return null;\n\n    gsap.set(navEl, { height: 60, overflow: 'hidden' });\n    gsap.set(cardsRef.current, { y: 50, opacity: 0 });\n\n    const tl = gsap.timeline({ paused: true });\n\n    tl.to(navEl, {\n      height: calculateHeight,\n      duration: 0.4,\n      ease\n    });\n\n    tl.to(cardsRef.current, { y: 0, opacity: 1, duration: 0.4, ease, stagger: 0.08 }, '-=0.1');\n\n    return tl;\n  };\n\n  useLayoutEffect(() => {\n    const tl = createTimeline();\n    tlRef.current = tl;\n\n    return () => {\n      tl?.kill();\n      tlRef.current = null;\n    };\n  }, [ease, items]);\n\n  useLayoutEffect(() => {\n    const handleResize = () => {\n      if (!tlRef.current) return;\n\n      if (isExpanded) {\n        const newHeight = calculateHeight();\n        gsap.set(navRef.current, { height: newHeight });\n\n        tlRef.current.kill();\n        const newTl = createTimeline();\n        if (newTl) {\n          newTl.progress(1);\n          tlRef.current = newTl;\n        }\n      } else {\n        tlRef.current.kill();\n        const newTl = createTimeline();\n        if (newTl) {\n          tlRef.current = newTl;\n        }\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [isExpanded]);\n\n  const toggleMenu = () => {\n    const tl = tlRef.current;\n    if (!tl) return;\n    if (!isExpanded) {\n      setIsHamburgerOpen(true);\n      setIsExpanded(true);\n      tl.play(0);\n    } else {\n      setIsHamburgerOpen(false);\n      tl.eventCallback('onReverseComplete', () => setIsExpanded(false));\n      tl.reverse();\n    }\n  };\n\n  const setCardRef = (i: number) => (el: HTMLDivElement | null) => {\n    if (el) cardsRef.current[i] = el;\n  };\n\n  return (\n    <div\n      className={`card-nav-container absolute left-1/2 -translate-x-1/2 w-[90%] max-w-[800px] z-[99] top-[1.2em] md:top-[2em] ${className}`}\n    >\n      <nav\n        ref={navRef}\n        className={`card-nav ${isExpanded ? 'open' : ''} block h-[60px] p-0 rounded-xl shadow-md relative overflow-hidden will-change-[height]`}\n        style={{ backgroundColor: baseColor }}\n      >\n        <div className=\"card-nav-top absolute inset-x-0 top-0 h-[60px] flex items-center justify-between p-2 pl-[1.1rem] z-[2]\">\n          <div\n            className={`hamburger-menu ${isHamburgerOpen ? 'open' : ''} group h-full flex flex-col items-center justify-center cursor-pointer gap-[6px] order-2 md:order-none`}\n            onClick={toggleMenu}\n            role=\"button\"\n            aria-label={isExpanded ? 'Close menu' : 'Open menu'}\n            tabIndex={0}\n            style={{ color: menuColor || '#000' }}\n          >\n            <div\n              className={`hamburger-line w-[30px] h-[2px] bg-current transition-[transform,opacity,margin] duration-300 ease-linear [transform-origin:50%_50%] ${\n                isHamburgerOpen ? 'translate-y-[4px] rotate-45' : ''\n              } group-hover:opacity-75`}\n            />\n            <div\n              className={`hamburger-line w-[30px] h-[2px] bg-current transition-[transform,opacity,margin] duration-300 ease-linear [transform-origin:50%_50%] ${\n                isHamburgerOpen ? '-translate-y-[4px] -rotate-45' : ''\n              } group-hover:opacity-75`}\n            />\n          </div>\n\n          <div className=\"logo-container flex items-center md:absolute md:left-1/2 md:top-1/2 md:-translate-x-1/2 md:-translate-y-1/2 order-1 md:order-none\">\n            <img src={logo} alt={logoAlt} className=\"logo h-[28px]\" />\n          </div>\n\n          <button\n            type=\"button\"\n            className=\"card-nav-cta-button hidden md:inline-flex border-0 rounded-[calc(0.75rem-0.2rem)] px-4 items-center h-full font-medium cursor-pointer transition-colors duration-300\"\n            style={{ backgroundColor: buttonBgColor, color: buttonTextColor }}\n          >\n            Get Started\n          </button>\n        </div>\n\n        <div\n          className={`card-nav-content absolute left-0 right-0 top-[60px] bottom-0 p-2 flex flex-col items-stretch gap-2 justify-start z-[1] ${\n            isExpanded ? 'visible pointer-events-auto' : 'invisible pointer-events-none'\n          } md:flex-row md:items-end md:gap-[12px]`}\n          aria-hidden={!isExpanded}\n        >\n          {(items || []).slice(0, 3).map((item, idx) => (\n            <div\n              key={`${item.label}-${idx}`}\n              className=\"nav-card select-none relative flex flex-col gap-2 p-[12px_16px] rounded-[calc(0.75rem-0.2rem)] min-w-0 flex-[1_1_auto] h-auto min-h-[60px] md:h-full md:min-h-0 md:flex-[1_1_0%]\"\n              ref={setCardRef(idx)}\n              style={{ backgroundColor: item.bgColor, color: item.textColor }}\n            >\n              <div className=\"nav-card-label font-normal tracking-[-0.5px] text-[18px] md:text-[22px]\">\n                {item.label}\n              </div>\n              <div className=\"nav-card-links mt-auto flex flex-col gap-[2px]\">\n                {item.links?.map((lnk, i) => (\n                  <a\n                    key={`${lnk.label}-${i}`}\n                    className=\"nav-card-link inline-flex items-center gap-[6px] no-underline cursor-pointer transition-opacity duration-300 hover:opacity-75 text-[15px] md:text-[16px]\"\n                    href={lnk.href}\n                    aria-label={lnk.ariaLabel}\n                  >\n                    <GoArrowUpRight className=\"nav-card-link-icon shrink-0\" aria-hidden=\"true\" />\n                    {lnk.label}\n                  </a>\n                ))}\n              </div>\n            </div>\n          ))}\n        </div>\n      </nav>\n    </div>\n  );\n};\n\nexport default CardNav;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "card-swap",
      "type": "component",
      "description": "A layouts card swap component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/card-swap.tsx",
          "content": "import React, {\n  Children,\n  cloneElement,\n  forwardRef,\n  isValidElement,\n  ReactElement,\n  ReactNode,\n  RefObject,\n  useEffect,\n  useMemo,\n  useRef\n} from 'react';\nimport gsap from 'gsap';\n\nexport interface CardSwapProps {\n  width?: number | string;\n  height?: number | string;\n  cardDistance?: number;\n  verticalDistance?: number;\n  delay?: number;\n  pauseOnHover?: boolean;\n  onCardClick?: (idx: number) => void;\n  skewAmount?: number;\n  easing?: 'linear' | 'elastic';\n  children: ReactNode;\n}\n\nexport interface CardProps extends React.HTMLAttributes<HTMLDivElement> {\n  customClass?: string;\n}\n\nexport const Card = forwardRef<HTMLDivElement, CardProps>(({ customClass, ...rest }, ref) => (\n  <div\n    ref={ref}\n    {...rest}\n    className={`absolute top-1/2 left-1/2 rounded-xl border border-white bg-black [transform-style:preserve-3d] [will-change:transform] [backface-visibility:hidden] ${customClass ?? ''} ${rest.className ?? ''}`.trim()}\n  />\n));\nCard.displayName = 'Card';\n\ntype CardRef = RefObject<HTMLDivElement | null>;\ninterface Slot {\n  x: number;\n  y: number;\n  z: number;\n  zIndex: number;\n}\n\nconst makeSlot = (i: number, distX: number, distY: number, total: number): Slot => ({\n  x: i * distX,\n  y: -i * distY,\n  z: -i * distX * 1.5,\n  zIndex: total - i\n});\n\nconst placeNow = (el: HTMLElement, slot: Slot, skew: number) =>\n  gsap.set(el, {\n    x: slot.x,\n    y: slot.y,\n    z: slot.z,\n    xPercent: -50,\n    yPercent: -50,\n    skewY: skew,\n    transformOrigin: 'center center',\n    zIndex: slot.zIndex,\n    force3D: true\n  });\n\nconst CardSwap: React.FC<CardSwapProps> = ({\n  width = 500,\n  height = 400,\n  cardDistance = 60,\n  verticalDistance = 70,\n  delay = 5000,\n  pauseOnHover = false,\n  onCardClick,\n  skewAmount = 6,\n  easing = 'elastic',\n  children\n}) => {\n  const config =\n    easing === 'elastic'\n      ? {\n          ease: 'elastic.out(0.6,0.9)',\n          durDrop: 2,\n          durMove: 2,\n          durReturn: 2,\n          promoteOverlap: 0.9,\n          returnDelay: 0.05\n        }\n      : {\n          ease: 'power1.inOut',\n          durDrop: 0.8,\n          durMove: 0.8,\n          durReturn: 0.8,\n          promoteOverlap: 0.45,\n          returnDelay: 0.2\n        };\n\n  const childArr = useMemo(() => Children.toArray(children) as ReactElement<CardProps>[], [children]);\n  const refs = useMemo<CardRef[]>(() => childArr.map(() => React.createRef<HTMLDivElement>()), [childArr.length]);\n\n  const order = useRef<number[]>(Array.from({ length: childArr.length }, (_, i) => i));\n\n  const tlRef = useRef<gsap.core.Timeline | null>(null);\n  const intervalRef = useRef<number>(0);\n  const container = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const total = refs.length;\n    refs.forEach((r, i) => placeNow(r.current!, makeSlot(i, cardDistance, verticalDistance, total), skewAmount));\n\n    const swap = () => {\n      if (order.current.length < 2) return;\n\n      const [front, ...rest] = order.current;\n      const elFront = refs[front].current!;\n      const tl = gsap.timeline();\n      tlRef.current = tl;\n\n      tl.to(elFront, {\n        y: '+=500',\n        duration: config.durDrop,\n        ease: config.ease\n      });\n\n      tl.addLabel('promote', `-=${config.durDrop * config.promoteOverlap}`);\n      rest.forEach((idx, i) => {\n        const el = refs[idx].current!;\n        const slot = makeSlot(i, cardDistance, verticalDistance, refs.length);\n        tl.set(el, { zIndex: slot.zIndex }, 'promote');\n        tl.to(\n          el,\n          {\n            x: slot.x,\n            y: slot.y,\n            z: slot.z,\n            duration: config.durMove,\n            ease: config.ease\n          },\n          `promote+=${i * 0.15}`\n        );\n      });\n\n      const backSlot = makeSlot(refs.length - 1, cardDistance, verticalDistance, refs.length);\n      tl.addLabel('return', `promote+=${config.durMove * config.returnDelay}`);\n      tl.call(\n        () => {\n          gsap.set(elFront, { zIndex: backSlot.zIndex });\n        },\n        undefined,\n        'return'\n      );\n      tl.to(\n        elFront,\n        {\n          x: backSlot.x,\n          y: backSlot.y,\n          z: backSlot.z,\n          duration: config.durReturn,\n          ease: config.ease\n        },\n        'return'\n      );\n\n      tl.call(() => {\n        order.current = [...rest, front];\n      });\n    };\n\n    swap();\n    intervalRef.current = window.setInterval(swap, delay);\n\n    if (pauseOnHover) {\n      const node = container.current!;\n      const pause = () => {\n        tlRef.current?.pause();\n        clearInterval(intervalRef.current);\n      };\n      const resume = () => {\n        tlRef.current?.play();\n        intervalRef.current = window.setInterval(swap, delay);\n      };\n      node.addEventListener('mouseenter', pause);\n      node.addEventListener('mouseleave', resume);\n      return () => {\n        node.removeEventListener('mouseenter', pause);\n        node.removeEventListener('mouseleave', resume);\n        clearInterval(intervalRef.current);\n      };\n    }\n    return () => clearInterval(intervalRef.current);\n  }, [cardDistance, verticalDistance, delay, pauseOnHover, skewAmount, easing]);\n\n  const rendered = childArr.map((child, i) =>\n    isValidElement<CardProps>(child)\n      ? cloneElement(child, {\n          key: i,\n          ref: refs[i],\n          style: { width, height, ...(child.props.style ?? {}) },\n          onClick: e => {\n            child.props.onClick?.(e as React.MouseEvent<HTMLDivElement>);\n            onCardClick?.(i);\n          }\n        } as CardProps & React.RefAttributes<HTMLDivElement>)\n      : child\n  );\n\n  return (\n    <div\n      ref={container}\n      className=\"absolute bottom-0 right-0 transform translate-x-[5%] translate-y-[20%] origin-bottom-right perspective-[900px] overflow-visible max-[768px]:translate-x-[25%] max-[768px]:translate-y-[25%] max-[768px]:scale-[0.75] max-[480px]:translate-x-[25%] max-[480px]:translate-y-[25%] max-[480px]:scale-[0.55]\"\n      style={{ width, height }}\n    >\n      {rendered}\n    </div>\n  );\n};\n\nexport default CardSwap;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "carousel",
      "type": "component",
      "description": "A layouts carousel component",
      "category": "layouts",
      "dependencies": [
        "motion",
        "react-icons"
      ],
      "files": [
        {
          "path": "components/ui/carousel.tsx",
          "content": "import { useEffect, useMemo, useRef, useState } from 'react';\nimport { motion, PanInfo, useMotionValue, useTransform } from 'motion/react';\nimport React, { JSX } from 'react';\n\n// replace icons with your own if needed\nimport { FiCircle, FiCode, FiFileText, FiLayers, FiLayout } from 'react-icons/fi';\nexport interface CarouselItem {\n  title: string;\n  description: string;\n  id: number;\n  icon: React.ReactNode;\n}\n\nexport interface CarouselProps {\n  items?: CarouselItem[];\n  baseWidth?: number;\n  autoplay?: boolean;\n  autoplayDelay?: number;\n  pauseOnHover?: boolean;\n  loop?: boolean;\n  round?: boolean;\n}\n\nconst DEFAULT_ITEMS: CarouselItem[] = [\n  {\n    title: 'Text Animations',\n    description: 'Cool text animations for your projects.',\n    id: 1,\n    icon: <FiFileText className=\"h-[16px] w-[16px] text-white\" />\n  },\n  {\n    title: 'Animations',\n    description: 'Smooth animations for your projects.',\n    id: 2,\n    icon: <FiCircle className=\"h-[16px] w-[16px] text-white\" />\n  },\n  {\n    title: 'Components',\n    description: 'Reusable components for your projects.',\n    id: 3,\n    icon: <FiLayers className=\"h-[16px] w-[16px] text-white\" />\n  },\n  {\n    title: 'Backgrounds',\n    description: 'Beautiful backgrounds and patterns for your projects.',\n    id: 4,\n    icon: <FiLayout className=\"h-[16px] w-[16px] text-white\" />\n  },\n  {\n    title: 'Common UI',\n    description: 'Common UI components are coming soon!',\n    id: 5,\n    icon: <FiCode className=\"h-[16px] w-[16px] text-white\" />\n  }\n];\n\nconst DRAG_BUFFER = 0;\nconst VELOCITY_THRESHOLD = 500;\nconst GAP = 16;\nconst SPRING_OPTIONS = { type: 'spring' as const, stiffness: 300, damping: 30 };\n\ninterface CarouselItemProps {\n  item: CarouselItem;\n  index: number;\n  itemWidth: number;\n  round: boolean;\n  trackItemOffset: number;\n  x: any;\n  transition: any;\n}\n\nfunction CarouselItem({ item, index, itemWidth, round, trackItemOffset, x, transition }: CarouselItemProps) {\n  const range = [-(index + 1) * trackItemOffset, -index * trackItemOffset, -(index - 1) * trackItemOffset];\n  const outputRange = [90, 0, -90];\n  const rotateY = useTransform(x, range, outputRange, { clamp: false });\n\n  return (\n    <motion.div\n      key={`${item?.id ?? index}-${index}`}\n      className={`relative shrink-0 flex flex-col ${\n        round\n          ? 'items-center justify-center text-center bg-[#060010] border-0'\n          : 'items-start justify-between bg-[#222] border border-[#222] rounded-[12px]'\n      } overflow-hidden cursor-grab active:cursor-grabbing`}\n      style={{\n        width: itemWidth,\n        height: round ? itemWidth : '100%',\n        rotateY: rotateY,\n        ...(round && { borderRadius: '50%' })\n      }}\n      transition={transition}\n    >\n      <div className={`${round ? 'p-0 m-0' : 'mb-4 p-5'}`}>\n        <span className=\"flex h-[28px] w-[28px] items-center justify-center rounded-full bg-[#060010]\">\n          {item.icon}\n        </span>\n      </div>\n      <div className=\"p-5\">\n        <div className=\"mb-1 font-black text-lg text-white\">{item.title}</div>\n        <p className=\"text-sm text-white\">{item.description}</p>\n      </div>\n    </motion.div>\n  );\n}\n\nexport default function Carousel({\n  items = DEFAULT_ITEMS,\n  baseWidth = 300,\n  autoplay = false,\n  autoplayDelay = 3000,\n  pauseOnHover = false,\n  loop = false,\n  round = false\n}: CarouselProps): JSX.Element {\n  const containerPadding = 16;\n  const itemWidth = baseWidth - containerPadding * 2;\n  const trackItemOffset = itemWidth + GAP;\n  const itemsForRender = useMemo(() => {\n    if (!loop) return items;\n    if (items.length === 0) return [];\n    return [items[items.length - 1], ...items, items[0]];\n  }, [items, loop]);\n\n  const [position, setPosition] = useState<number>(loop ? 1 : 0);\n  const x = useMotionValue(0);\n  const [isHovered, setIsHovered] = useState<boolean>(false);\n  const [isJumping, setIsJumping] = useState<boolean>(false);\n  const [isAnimating, setIsAnimating] = useState<boolean>(false);\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  useEffect(() => {\n    if (pauseOnHover && containerRef.current) {\n      const container = containerRef.current;\n      const handleMouseEnter = () => setIsHovered(true);\n      const handleMouseLeave = () => setIsHovered(false);\n      container.addEventListener('mouseenter', handleMouseEnter);\n      container.addEventListener('mouseleave', handleMouseLeave);\n      return () => {\n        container.removeEventListener('mouseenter', handleMouseEnter);\n        container.removeEventListener('mouseleave', handleMouseLeave);\n      };\n    }\n  }, [pauseOnHover]);\n\n  useEffect(() => {\n    if (!autoplay || itemsForRender.length <= 1) return undefined;\n    if (pauseOnHover && isHovered) return undefined;\n\n    const timer = setInterval(() => {\n      setPosition(prev => Math.min(prev + 1, itemsForRender.length - 1));\n    }, autoplayDelay);\n\n    return () => clearInterval(timer);\n  }, [autoplay, autoplayDelay, isHovered, pauseOnHover, itemsForRender.length]);\n\n  useEffect(() => {\n    const startingPosition = loop ? 1 : 0;\n    setPosition(startingPosition);\n    x.set(-startingPosition * trackItemOffset);\n  }, [items.length, loop, trackItemOffset, x]);\n\n  useEffect(() => {\n    if (!loop && position > itemsForRender.length - 1) {\n      setPosition(Math.max(0, itemsForRender.length - 1));\n    }\n  }, [itemsForRender.length, loop, position]);\n\n  const effectiveTransition = isJumping ? { duration: 0 } : SPRING_OPTIONS;\n\n  const handleAnimationStart = () => {\n    setIsAnimating(true);\n  };\n\n  const handleAnimationComplete = () => {\n    if (!loop || itemsForRender.length <= 1) {\n      setIsAnimating(false);\n      return;\n    }\n    const lastCloneIndex = itemsForRender.length - 1;\n\n    if (position === lastCloneIndex) {\n      setIsJumping(true);\n      const target = 1;\n      setPosition(target);\n      x.set(-target * trackItemOffset);\n      requestAnimationFrame(() => {\n        setIsJumping(false);\n        setIsAnimating(false);\n      });\n      return;\n    }\n\n    if (position === 0) {\n      setIsJumping(true);\n      const target = items.length;\n      setPosition(target);\n      x.set(-target * trackItemOffset);\n      requestAnimationFrame(() => {\n        setIsJumping(false);\n        setIsAnimating(false);\n      });\n      return;\n    }\n\n    setIsAnimating(false);\n  };\n\n  const handleDragEnd = (_: MouseEvent | TouchEvent | PointerEvent, info: PanInfo): void => {\n    const { offset, velocity } = info;\n    const direction =\n      offset.x < -DRAG_BUFFER || velocity.x < -VELOCITY_THRESHOLD\n        ? 1\n        : offset.x > DRAG_BUFFER || velocity.x > VELOCITY_THRESHOLD\n          ? -1\n          : 0;\n\n    if (direction === 0) return;\n\n    setPosition(prev => {\n      const next = prev + direction;\n      const max = itemsForRender.length - 1;\n      return Math.max(0, Math.min(next, max));\n    });\n  };\n\n  const dragProps = loop\n    ? {}\n    : {\n        dragConstraints: {\n          left: -trackItemOffset * Math.max(itemsForRender.length - 1, 0),\n          right: 0\n        }\n      };\n\n  const activeIndex =\n    items.length === 0 ? 0 : loop ? (position - 1 + items.length) % items.length : Math.min(position, items.length - 1);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`relative overflow-hidden p-4 ${\n        round ? 'rounded-full border border-white' : 'rounded-[24px] border border-[#222]'\n      }`}\n      style={{\n        width: `${baseWidth}px`,\n        ...(round && { height: `${baseWidth}px` })\n      }}\n    >\n      <motion.div\n        className=\"flex\"\n        drag={isAnimating ? false : 'x'}\n        {...dragProps}\n        style={{\n          width: itemWidth,\n          gap: `${GAP}px`,\n          perspective: 1000,\n          perspectiveOrigin: `${position * trackItemOffset + itemWidth / 2}px 50%`,\n          x\n        }}\n        onDragEnd={handleDragEnd}\n        animate={{ x: -(position * trackItemOffset) }}\n        transition={effectiveTransition}\n        onAnimationStart={handleAnimationStart}\n        onAnimationComplete={handleAnimationComplete}\n      >\n        {itemsForRender.map((item, index) => (\n          <CarouselItem\n            key={`${item?.id ?? index}-${index}`}\n            item={item}\n            index={index}\n            itemWidth={itemWidth}\n            round={round}\n            trackItemOffset={trackItemOffset}\n            x={x}\n            transition={effectiveTransition}\n          />\n        ))}\n      </motion.div>\n      <div className={`flex w-full justify-center ${round ? 'absolute z-20 bottom-12 left-1/2 -translate-x-1/2' : ''}`}>\n        <div className=\"mt-4 flex w-[150px] justify-between px-8\">\n          {items.map((_, index) => (\n            <motion.div\n              key={index}\n              className={`h-2 w-2 rounded-full cursor-pointer transition-colors duration-150 ${\n                activeIndex === index\n                  ? round\n                    ? 'bg-white'\n                    : 'bg-[#333333]'\n                  : round\n                    ? 'bg-[#555]'\n                    : 'bg-[rgba(51,51,51,0.4)]'\n              }`}\n              animate={{\n                scale: activeIndex === index ? 1.2 : 1\n              }}\n              onClick={() => setPosition(loop ? index + 1 : index)}\n              transition={{ duration: 0.15 }}\n            />\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "chroma-grid",
      "type": "component",
      "description": "A layouts chroma grid component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/chroma-grid.tsx",
          "content": "import React, { useRef, useEffect } from 'react';\nimport { gsap } from 'gsap';\n\nexport interface ChromaItem {\n  image: string;\n  title: string;\n  subtitle: string;\n  handle?: string;\n  location?: string;\n  borderColor?: string;\n  gradient?: string;\n  url?: string;\n}\n\nexport interface ChromaGridProps {\n  items?: ChromaItem[];\n  className?: string;\n  radius?: number;\n  damping?: number;\n  fadeOut?: number;\n  ease?: string;\n}\n\ntype SetterFn = (v: number | string) => void;\n\nconst ChromaGrid: React.FC<ChromaGridProps> = ({\n  items,\n  className = '',\n  radius = 300,\n  damping = 0.45,\n  fadeOut = 0.6,\n  ease = 'power3.out'\n}) => {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const fadeRef = useRef<HTMLDivElement>(null);\n  const setX = useRef<SetterFn | null>(null);\n  const setY = useRef<SetterFn | null>(null);\n  const pos = useRef({ x: 0, y: 0 });\n\n  const demo: ChromaItem[] = [\n    {\n      image: 'https://i.pravatar.cc/300?img=8',\n      title: 'Alex Rivera',\n      subtitle: 'Full Stack Developer',\n      handle: '@alexrivera',\n      borderColor: '#4F46E5',\n      gradient: 'linear-gradient(145deg,#4F46E5,#000)',\n      url: 'https://github.com/'\n    },\n    {\n      image: 'https://i.pravatar.cc/300?img=11',\n      title: 'Jordan Chen',\n      subtitle: 'DevOps Engineer',\n      handle: '@jordanchen',\n      borderColor: '#10B981',\n      gradient: 'linear-gradient(210deg,#10B981,#000)',\n      url: 'https://linkedin.com/in/'\n    },\n    {\n      image: 'https://i.pravatar.cc/300?img=3',\n      title: 'Morgan Blake',\n      subtitle: 'UI/UX Designer',\n      handle: '@morganblake',\n      borderColor: '#F59E0B',\n      gradient: 'linear-gradient(165deg,#F59E0B,#000)',\n      url: 'https://dribbble.com/'\n    },\n    {\n      image: 'https://i.pravatar.cc/300?img=16',\n      title: 'Casey Park',\n      subtitle: 'Data Scientist',\n      handle: '@caseypark',\n      borderColor: '#EF4444',\n      gradient: 'linear-gradient(195deg,#EF4444,#000)',\n      url: 'https://kaggle.com/'\n    },\n    {\n      image: 'https://i.pravatar.cc/300?img=25',\n      title: 'Sam Kim',\n      subtitle: 'Mobile Developer',\n      handle: '@thesamkim',\n      borderColor: '#8B5CF6',\n      gradient: 'linear-gradient(225deg,#8B5CF6,#000)',\n      url: 'https://github.com/'\n    },\n    {\n      image: 'https://i.pravatar.cc/300?img=60',\n      title: 'Tyler Rodriguez',\n      subtitle: 'Cloud Architect',\n      handle: '@tylerrod',\n      borderColor: '#06B6D4',\n      gradient: 'linear-gradient(135deg,#06B6D4,#000)',\n      url: 'https://aws.amazon.com/'\n    }\n  ];\n\n  const data = items?.length ? items : demo;\n\n  useEffect(() => {\n    const el = rootRef.current;\n    if (!el) return;\n    setX.current = gsap.quickSetter(el, '--x', 'px') as SetterFn;\n    setY.current = gsap.quickSetter(el, '--y', 'px') as SetterFn;\n    const { width, height } = el.getBoundingClientRect();\n    pos.current = { x: width / 2, y: height / 2 };\n    setX.current(pos.current.x);\n    setY.current(pos.current.y);\n  }, []);\n\n  const moveTo = (x: number, y: number) => {\n    gsap.to(pos.current, {\n      x,\n      y,\n      duration: damping,\n      ease,\n      onUpdate: () => {\n        setX.current?.(pos.current.x);\n        setY.current?.(pos.current.y);\n      },\n      overwrite: true\n    });\n  };\n\n  const handleMove = (e: React.PointerEvent) => {\n    const r = rootRef.current!.getBoundingClientRect();\n    moveTo(e.clientX - r.left, e.clientY - r.top);\n    gsap.to(fadeRef.current, { opacity: 0, duration: 0.25, overwrite: true });\n  };\n\n  const handleLeave = () => {\n    gsap.to(fadeRef.current, {\n      opacity: 1,\n      duration: fadeOut,\n      overwrite: true\n    });\n  };\n\n  const handleCardClick = (url?: string) => {\n    if (url) window.open(url, '_blank', 'noopener,noreferrer');\n  };\n\n  const handleCardMove: React.MouseEventHandler<HTMLElement> = e => {\n    const c = e.currentTarget as HTMLElement;\n    const rect = c.getBoundingClientRect();\n    c.style.setProperty('--mouse-x', `${e.clientX - rect.left}px`);\n    c.style.setProperty('--mouse-y', `${e.clientY - rect.top}px`);\n  };\n\n  return (\n    <div\n      ref={rootRef}\n      onPointerMove={handleMove}\n      onPointerLeave={handleLeave}\n      className={`relative w-full h-full flex flex-wrap justify-center items-start gap-3 ${className}`}\n      style={\n        {\n          '--r': `${radius}px`,\n          '--x': '50%',\n          '--y': '50%'\n        } as React.CSSProperties\n      }\n    >\n      {data.map((c, i) => (\n        <article\n          key={i}\n          onMouseMove={handleCardMove}\n          onClick={() => handleCardClick(c.url)}\n          className=\"group relative flex flex-col w-[300px] rounded-[20px] overflow-hidden border-2 border-transparent transition-colors duration-300 cursor-pointer\"\n          style={\n            {\n              '--card-border': c.borderColor || 'transparent',\n              background: c.gradient,\n              '--spotlight-color': 'rgba(255,255,255,0.3)'\n            } as React.CSSProperties\n          }\n        >\n          <div\n            className=\"absolute inset-0 pointer-events-none transition-opacity duration-500 z-20 opacity-0 group-hover:opacity-100\"\n            style={{\n              background:\n                'radial-gradient(circle at var(--mouse-x) var(--mouse-y), var(--spotlight-color), transparent 70%)'\n            }}\n          />\n          <div className=\"relative z-10 flex-1 p-[10px] box-border\">\n            <img src={c.image} alt={c.title} loading=\"lazy\" className=\"w-full h-full object-cover rounded-[10px]\" />\n          </div>\n          <footer className=\"relative z-10 p-3 text-white font-sans grid grid-cols-[1fr_auto] gap-x-3 gap-y-1\">\n            <h3 className=\"m-0 text-[1.05rem] font-semibold\">{c.title}</h3>\n            {c.handle && <span className=\"text-[0.95rem] opacity-80 text-right\">{c.handle}</span>}\n            <p className=\"m-0 text-[0.85rem] opacity-85\">{c.subtitle}</p>\n            {c.location && <span className=\"text-[0.85rem] opacity-85 text-right\">{c.location}</span>}\n          </footer>\n        </article>\n      ))}\n      <div\n        className=\"absolute inset-0 pointer-events-none z-30\"\n        style={{\n          backdropFilter: 'grayscale(1) brightness(0.78)',\n          WebkitBackdropFilter: 'grayscale(1) brightness(0.78)',\n          background: 'rgba(0,0,0,0.001)',\n          maskImage:\n            'radial-gradient(circle var(--r) at var(--x) var(--y),transparent 0%,transparent 15%,rgba(0,0,0,0.10) 30%,rgba(0,0,0,0.22)45%,rgba(0,0,0,0.35)60%,rgba(0,0,0,0.50)75%,rgba(0,0,0,0.68)88%,white 100%)',\n          WebkitMaskImage:\n            'radial-gradient(circle var(--r) at var(--x) var(--y),transparent 0%,transparent 15%,rgba(0,0,0,0.10) 30%,rgba(0,0,0,0.22)45%,rgba(0,0,0,0.35)60%,rgba(0,0,0,0.50)75%,rgba(0,0,0,0.68)88%,white 100%)'\n        }}\n      />\n      <div\n        ref={fadeRef}\n        className=\"absolute inset-0 pointer-events-none transition-opacity duration-[250ms] z-40\"\n        style={{\n          backdropFilter: 'grayscale(1) brightness(0.78)',\n          WebkitBackdropFilter: 'grayscale(1) brightness(0.78)',\n          background: 'rgba(0,0,0,0.001)',\n          maskImage:\n            'radial-gradient(circle var(--r) at var(--x) var(--y),white 0%,white 15%,rgba(255,255,255,0.90)30%,rgba(255,255,255,0.78)45%,rgba(255,255,255,0.65)60%,rgba(255,255,255,0.50)75%,rgba(255,255,255,0.32)88%,transparent 100%)',\n          WebkitMaskImage:\n            'radial-gradient(circle var(--r) at var(--x) var(--y),white 0%,white 15%,rgba(255,255,255,0.90)30%,rgba(255,255,255,0.78)45%,rgba(255,255,255,0.65)60%,rgba(255,255,255,0.50)75%,rgba(255,255,255,0.32)88%,transparent 100%)',\n          opacity: 1\n        }}\n      />\n    </div>\n  );\n};\n\nexport default ChromaGrid;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "circular-gallery",
      "type": "component",
      "description": "A layouts circular gallery component",
      "category": "layouts",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/circular-gallery.tsx",
          "content": "import { Camera, Mesh, Plane, Program, Renderer, Texture, Transform } from 'ogl';\nimport { useEffect, useRef } from 'react';\n\ntype GL = Renderer['gl'];\n\nfunction debounce<T extends (...args: any[]) => void>(func: T, wait: number) {\n  let timeout: number;\n  return function (this: any, ...args: Parameters<T>) {\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout(() => func.apply(this, args), wait);\n  };\n}\n\nfunction lerp(p1: number, p2: number, t: number): number {\n  return p1 + (p2 - p1) * t;\n}\n\nfunction autoBind(instance: any): void {\n  const proto = Object.getPrototypeOf(instance);\n  Object.getOwnPropertyNames(proto).forEach(key => {\n    if (key !== 'constructor' && typeof instance[key] === 'function') {\n      instance[key] = instance[key].bind(instance);\n    }\n  });\n}\n\nfunction getFontSize(font: string): number {\n  const match = font.match(/(\\d+)px/);\n  return match ? parseInt(match[1], 10) : 30;\n}\n\nfunction createTextTexture(\n  gl: GL,\n  text: string,\n  font: string = 'bold 30px monospace',\n  color: string = 'black'\n): { texture: Texture; width: number; height: number } {\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  if (!context) throw new Error('Could not get 2d context');\n\n  context.font = font;\n  const metrics = context.measureText(text);\n  const textWidth = Math.ceil(metrics.width);\n  const fontSize = getFontSize(font);\n  const textHeight = Math.ceil(fontSize * 1.2);\n\n  canvas.width = textWidth + 20;\n  canvas.height = textHeight + 20;\n\n  context.font = font;\n  context.fillStyle = color;\n  context.textBaseline = 'middle';\n  context.textAlign = 'center';\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.fillText(text, canvas.width / 2, canvas.height / 2);\n\n  const texture = new Texture(gl, { generateMipmaps: false });\n  texture.image = canvas;\n  return { texture, width: canvas.width, height: canvas.height };\n}\n\ninterface TitleProps {\n  gl: GL;\n  plane: Mesh;\n  renderer: Renderer;\n  text: string;\n  textColor?: string;\n  font?: string;\n}\n\nclass Title {\n  gl: GL;\n  plane: Mesh;\n  renderer: Renderer;\n  text: string;\n  textColor: string;\n  font: string;\n  mesh!: Mesh;\n\n  constructor({ gl, plane, renderer, text, textColor = '#545050', font = '30px sans-serif' }: TitleProps) {\n    autoBind(this);\n    this.gl = gl;\n    this.plane = plane;\n    this.renderer = renderer;\n    this.text = text;\n    this.textColor = textColor;\n    this.font = font;\n    this.createMesh();\n  }\n\n  createMesh() {\n    const { texture, width, height } = createTextTexture(this.gl, this.text, this.font, this.textColor);\n    const geometry = new Plane(this.gl);\n    const program = new Program(this.gl, {\n      vertex: `\n        attribute vec3 position;\n        attribute vec2 uv;\n        uniform mat4 modelViewMatrix;\n        uniform mat4 projectionMatrix;\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragment: `\n        precision highp float;\n        uniform sampler2D tMap;\n        varying vec2 vUv;\n        void main() {\n          vec4 color = texture2D(tMap, vUv);\n          if (color.a < 0.1) discard;\n          gl_FragColor = color;\n        }\n      `,\n      uniforms: { tMap: { value: texture } },\n      transparent: true\n    });\n    this.mesh = new Mesh(this.gl, { geometry, program });\n    const aspect = width / height;\n    const textHeightScaled = this.plane.scale.y * 0.15;\n    const textWidthScaled = textHeightScaled * aspect;\n    this.mesh.scale.set(textWidthScaled, textHeightScaled, 1);\n    this.mesh.position.y = -this.plane.scale.y * 0.5 - textHeightScaled * 0.5 - 0.05;\n    this.mesh.setParent(this.plane);\n  }\n}\n\ninterface ScreenSize {\n  width: number;\n  height: number;\n}\n\ninterface Viewport {\n  width: number;\n  height: number;\n}\n\ninterface MediaProps {\n  geometry: Plane;\n  gl: GL;\n  image: string;\n  index: number;\n  length: number;\n  renderer: Renderer;\n  scene: Transform;\n  screen: ScreenSize;\n  text: string;\n  viewport: Viewport;\n  bend: number;\n  textColor: string;\n  borderRadius?: number;\n  font?: string;\n}\n\nclass Media {\n  extra: number = 0;\n  geometry: Plane;\n  gl: GL;\n  image: string;\n  index: number;\n  length: number;\n  renderer: Renderer;\n  scene: Transform;\n  screen: ScreenSize;\n  text: string;\n  viewport: Viewport;\n  bend: number;\n  textColor: string;\n  borderRadius: number;\n  font?: string;\n  program!: Program;\n  plane!: Mesh;\n  title!: Title;\n  scale!: number;\n  padding!: number;\n  width!: number;\n  widthTotal!: number;\n  x!: number;\n  speed: number = 0;\n  isBefore: boolean = false;\n  isAfter: boolean = false;\n\n  constructor({\n    geometry,\n    gl,\n    image,\n    index,\n    length,\n    renderer,\n    scene,\n    screen,\n    text,\n    viewport,\n    bend,\n    textColor,\n    borderRadius = 0,\n    font\n  }: MediaProps) {\n    this.geometry = geometry;\n    this.gl = gl;\n    this.image = image;\n    this.index = index;\n    this.length = length;\n    this.renderer = renderer;\n    this.scene = scene;\n    this.screen = screen;\n    this.text = text;\n    this.viewport = viewport;\n    this.bend = bend;\n    this.textColor = textColor;\n    this.borderRadius = borderRadius;\n    this.font = font;\n    this.createShader();\n    this.createMesh();\n    this.createTitle();\n    this.onResize();\n  }\n\n  createShader() {\n    const texture = new Texture(this.gl, {\n      generateMipmaps: true\n    });\n    this.program = new Program(this.gl, {\n      depthTest: false,\n      depthWrite: false,\n      vertex: `\n        precision highp float;\n        attribute vec3 position;\n        attribute vec2 uv;\n        uniform mat4 modelViewMatrix;\n        uniform mat4 projectionMatrix;\n        uniform float uTime;\n        uniform float uSpeed;\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          vec3 p = position;\n          p.z = (sin(p.x * 4.0 + uTime) * 1.5 + cos(p.y * 2.0 + uTime) * 1.5) * (0.1 + uSpeed * 0.5);\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n        }\n      `,\n      fragment: `\n        precision highp float;\n        uniform vec2 uImageSizes;\n        uniform vec2 uPlaneSizes;\n        uniform sampler2D tMap;\n        uniform float uBorderRadius;\n        varying vec2 vUv;\n        \n        float roundedBoxSDF(vec2 p, vec2 b, float r) {\n          vec2 d = abs(p) - b;\n          return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0) - r;\n        }\n        \n        void main() {\n          vec2 ratio = vec2(\n            min((uPlaneSizes.x / uPlaneSizes.y) / (uImageSizes.x / uImageSizes.y), 1.0),\n            min((uPlaneSizes.y / uPlaneSizes.x) / (uImageSizes.y / uImageSizes.x), 1.0)\n          );\n          vec2 uv = vec2(\n            vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n            vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n          );\n          vec4 color = texture2D(tMap, uv);\n          \n          float d = roundedBoxSDF(vUv - 0.5, vec2(0.5 - uBorderRadius), uBorderRadius);\n          \n          // Smooth antialiasing for edges\n          float edgeSmooth = 0.002;\n          float alpha = 1.0 - smoothstep(-edgeSmooth, edgeSmooth, d);\n          \n          gl_FragColor = vec4(color.rgb, alpha);\n        }\n      `,\n      uniforms: {\n        tMap: { value: texture },\n        uPlaneSizes: { value: [0, 0] },\n        uImageSizes: { value: [0, 0] },\n        uSpeed: { value: 0 },\n        uTime: { value: 100 * Math.random() },\n        uBorderRadius: { value: this.borderRadius }\n      },\n      transparent: true\n    });\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.src = this.image;\n    img.onload = () => {\n      texture.image = img;\n      this.program.uniforms.uImageSizes.value = [img.naturalWidth, img.naturalHeight];\n    };\n  }\n\n  createMesh() {\n    this.plane = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program: this.program\n    });\n    this.plane.setParent(this.scene);\n  }\n\n  createTitle() {\n    this.title = new Title({\n      gl: this.gl,\n      plane: this.plane,\n      renderer: this.renderer,\n      text: this.text,\n      textColor: this.textColor,\n      font: this.font\n    });\n  }\n\n  update(scroll: { current: number; last: number }, direction: 'right' | 'left') {\n    this.plane.position.x = this.x - scroll.current - this.extra;\n\n    const x = this.plane.position.x;\n    const H = this.viewport.width / 2;\n\n    if (this.bend === 0) {\n      this.plane.position.y = 0;\n      this.plane.rotation.z = 0;\n    } else {\n      const B_abs = Math.abs(this.bend);\n      const R = (H * H + B_abs * B_abs) / (2 * B_abs);\n      const effectiveX = Math.min(Math.abs(x), H);\n\n      const arc = R - Math.sqrt(R * R - effectiveX * effectiveX);\n      if (this.bend > 0) {\n        this.plane.position.y = -arc;\n        this.plane.rotation.z = -Math.sign(x) * Math.asin(effectiveX / R);\n      } else {\n        this.plane.position.y = arc;\n        this.plane.rotation.z = Math.sign(x) * Math.asin(effectiveX / R);\n      }\n    }\n\n    this.speed = scroll.current - scroll.last;\n    this.program.uniforms.uTime.value += 0.04;\n    this.program.uniforms.uSpeed.value = this.speed;\n\n    const planeOffset = this.plane.scale.x / 2;\n    const viewportOffset = this.viewport.width / 2;\n    this.isBefore = this.plane.position.x + planeOffset < -viewportOffset;\n    this.isAfter = this.plane.position.x - planeOffset > viewportOffset;\n    if (direction === 'right' && this.isBefore) {\n      this.extra -= this.widthTotal;\n      this.isBefore = this.isAfter = false;\n    }\n    if (direction === 'left' && this.isAfter) {\n      this.extra += this.widthTotal;\n      this.isBefore = this.isAfter = false;\n    }\n  }\n\n  onResize({ screen, viewport }: { screen?: ScreenSize; viewport?: Viewport } = {}) {\n    if (screen) this.screen = screen;\n    if (viewport) {\n      this.viewport = viewport;\n      if (this.plane.program.uniforms.uViewportSizes) {\n        this.plane.program.uniforms.uViewportSizes.value = [this.viewport.width, this.viewport.height];\n      }\n    }\n    this.scale = this.screen.height / 1500;\n    this.plane.scale.y = (this.viewport.height * (900 * this.scale)) / this.screen.height;\n    this.plane.scale.x = (this.viewport.width * (700 * this.scale)) / this.screen.width;\n    this.plane.program.uniforms.uPlaneSizes.value = [this.plane.scale.x, this.plane.scale.y];\n    this.padding = 2;\n    this.width = this.plane.scale.x + this.padding;\n    this.widthTotal = this.width * this.length;\n    this.x = this.width * this.index;\n  }\n}\n\ninterface AppConfig {\n  items?: { image: string; text: string }[];\n  bend?: number;\n  textColor?: string;\n  borderRadius?: number;\n  font?: string;\n  scrollSpeed?: number;\n  scrollEase?: number;\n}\n\nclass App {\n  container: HTMLElement;\n  scrollSpeed: number;\n  scroll: {\n    ease: number;\n    current: number;\n    target: number;\n    last: number;\n    position?: number;\n  };\n  onCheckDebounce: (...args: any[]) => void;\n  renderer!: Renderer;\n  gl!: GL;\n  camera!: Camera;\n  scene!: Transform;\n  planeGeometry!: Plane;\n  medias: Media[] = [];\n  mediasImages: { image: string; text: string }[] = [];\n  screen!: { width: number; height: number };\n  viewport!: { width: number; height: number };\n  raf: number = 0;\n\n  boundOnResize!: () => void;\n  boundOnWheel!: (e: Event) => void;\n  boundOnTouchDown!: (e: MouseEvent | TouchEvent) => void;\n  boundOnTouchMove!: (e: MouseEvent | TouchEvent) => void;\n  boundOnTouchUp!: () => void;\n\n  isDown: boolean = false;\n  start: number = 0;\n\n  constructor(\n    container: HTMLElement,\n    {\n      items,\n      bend = 1,\n      textColor = '#ffffff',\n      borderRadius = 0,\n      font = 'bold 30px Figtree',\n      scrollSpeed = 2,\n      scrollEase = 0.05\n    }: AppConfig\n  ) {\n    document.documentElement.classList.remove('no-js');\n    this.container = container;\n    this.scrollSpeed = scrollSpeed;\n    this.scroll = { ease: scrollEase, current: 0, target: 0, last: 0 };\n    this.onCheckDebounce = debounce(this.onCheck.bind(this), 200);\n    this.createRenderer();\n    this.createCamera();\n    this.createScene();\n    this.onResize();\n    this.createGeometry();\n    this.createMedias(items, bend, textColor, borderRadius, font);\n    this.update();\n    this.addEventListeners();\n  }\n\n  createRenderer() {\n    this.renderer = new Renderer({\n      alpha: true,\n      antialias: true,\n      dpr: Math.min(window.devicePixelRatio || 1, 2)\n    });\n    this.gl = this.renderer.gl;\n    this.gl.clearColor(0, 0, 0, 0);\n    this.container.appendChild(this.renderer.gl.canvas as HTMLCanvasElement);\n  }\n\n  createCamera() {\n    this.camera = new Camera(this.gl);\n    this.camera.fov = 45;\n    this.camera.position.z = 20;\n  }\n\n  createScene() {\n    this.scene = new Transform();\n  }\n\n  createGeometry() {\n    this.planeGeometry = new Plane(this.gl, {\n      heightSegments: 50,\n      widthSegments: 100\n    });\n  }\n\n  createMedias(\n    items: { image: string; text: string }[] | undefined,\n    bend: number = 1,\n    textColor: string,\n    borderRadius: number,\n    font: string\n  ) {\n    const defaultItems = [\n      {\n        image: `https://picsum.photos/seed/1/800/600?grayscale`,\n        text: 'Bridge'\n      },\n      {\n        image: `https://picsum.photos/seed/2/800/600?grayscale`,\n        text: 'Desk Setup'\n      },\n      {\n        image: `https://picsum.photos/seed/3/800/600?grayscale`,\n        text: 'Waterfall'\n      },\n      {\n        image: `https://picsum.photos/seed/4/800/600?grayscale`,\n        text: 'Strawberries'\n      },\n      {\n        image: `https://picsum.photos/seed/5/800/600?grayscale`,\n        text: 'Deep Diving'\n      },\n      {\n        image: `https://picsum.photos/seed/16/800/600?grayscale`,\n        text: 'Train Track'\n      },\n      {\n        image: `https://picsum.photos/seed/17/800/600?grayscale`,\n        text: 'Santorini'\n      },\n      {\n        image: `https://picsum.photos/seed/8/800/600?grayscale`,\n        text: 'Blurry Lights'\n      },\n      {\n        image: `https://picsum.photos/seed/9/800/600?grayscale`,\n        text: 'New York'\n      },\n      {\n        image: `https://picsum.photos/seed/10/800/600?grayscale`,\n        text: 'Good Boy'\n      },\n      {\n        image: `https://picsum.photos/seed/21/800/600?grayscale`,\n        text: 'Coastline'\n      },\n      {\n        image: `https://picsum.photos/seed/12/800/600?grayscale`,\n        text: 'Palm Trees'\n      }\n    ];\n    const galleryItems = items && items.length ? items : defaultItems;\n    this.mediasImages = galleryItems.concat(galleryItems);\n    this.medias = this.mediasImages.map((data, index) => {\n      return new Media({\n        geometry: this.planeGeometry,\n        gl: this.gl,\n        image: data.image,\n        index,\n        length: this.mediasImages.length,\n        renderer: this.renderer,\n        scene: this.scene,\n        screen: this.screen,\n        text: data.text,\n        viewport: this.viewport,\n        bend,\n        textColor,\n        borderRadius,\n        font\n      });\n    });\n  }\n\n  onTouchDown(e: MouseEvent | TouchEvent) {\n    this.isDown = true;\n    this.scroll.position = this.scroll.current;\n    this.start = 'touches' in e ? e.touches[0].clientX : e.clientX;\n  }\n\n  onTouchMove(e: MouseEvent | TouchEvent) {\n    if (!this.isDown) return;\n    const x = 'touches' in e ? e.touches[0].clientX : e.clientX;\n    const distance = (this.start - x) * (this.scrollSpeed * 0.025);\n    this.scroll.target = (this.scroll.position ?? 0) + distance;\n  }\n\n  onTouchUp() {\n    this.isDown = false;\n    this.onCheck();\n  }\n\n  onWheel(e: Event) {\n    const wheelEvent = e as WheelEvent;\n    const delta = wheelEvent.deltaY || (wheelEvent as any).wheelDelta || (wheelEvent as any).detail;\n    this.scroll.target += (delta > 0 ? this.scrollSpeed : -this.scrollSpeed) * 0.2;\n    this.onCheckDebounce();\n  }\n\n  onCheck() {\n    if (!this.medias || !this.medias[0]) return;\n    const width = this.medias[0].width;\n    const itemIndex = Math.round(Math.abs(this.scroll.target) / width);\n    const item = width * itemIndex;\n    this.scroll.target = this.scroll.target < 0 ? -item : item;\n  }\n\n  onResize() {\n    this.screen = {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight\n    };\n    this.renderer.setSize(this.screen.width, this.screen.height);\n    this.camera.perspective({\n      aspect: this.screen.width / this.screen.height\n    });\n    const fov = (this.camera.fov * Math.PI) / 180;\n    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;\n    const width = height * this.camera.aspect;\n    this.viewport = { width, height };\n    if (this.medias) {\n      this.medias.forEach(media => media.onResize({ screen: this.screen, viewport: this.viewport }));\n    }\n  }\n\n  update() {\n    this.scroll.current = lerp(this.scroll.current, this.scroll.target, this.scroll.ease);\n    const direction = this.scroll.current > this.scroll.last ? 'right' : 'left';\n    if (this.medias) {\n      this.medias.forEach(media => media.update(this.scroll, direction));\n    }\n    this.renderer.render({ scene: this.scene, camera: this.camera });\n    this.scroll.last = this.scroll.current;\n    this.raf = window.requestAnimationFrame(this.update.bind(this));\n  }\n\n  addEventListeners() {\n    this.boundOnResize = this.onResize.bind(this);\n    this.boundOnWheel = this.onWheel.bind(this);\n    this.boundOnTouchDown = this.onTouchDown.bind(this);\n    this.boundOnTouchMove = this.onTouchMove.bind(this);\n    this.boundOnTouchUp = this.onTouchUp.bind(this);\n    window.addEventListener('resize', this.boundOnResize);\n    window.addEventListener('mousewheel', this.boundOnWheel);\n    window.addEventListener('wheel', this.boundOnWheel);\n    window.addEventListener('mousedown', this.boundOnTouchDown);\n    window.addEventListener('mousemove', this.boundOnTouchMove);\n    window.addEventListener('mouseup', this.boundOnTouchUp);\n    window.addEventListener('touchstart', this.boundOnTouchDown);\n    window.addEventListener('touchmove', this.boundOnTouchMove);\n    window.addEventListener('touchend', this.boundOnTouchUp);\n  }\n\n  destroy() {\n    window.cancelAnimationFrame(this.raf);\n    window.removeEventListener('resize', this.boundOnResize);\n    window.removeEventListener('mousewheel', this.boundOnWheel);\n    window.removeEventListener('wheel', this.boundOnWheel);\n    window.removeEventListener('mousedown', this.boundOnTouchDown);\n    window.removeEventListener('mousemove', this.boundOnTouchMove);\n    window.removeEventListener('mouseup', this.boundOnTouchUp);\n    window.removeEventListener('touchstart', this.boundOnTouchDown);\n    window.removeEventListener('touchmove', this.boundOnTouchMove);\n    window.removeEventListener('touchend', this.boundOnTouchUp);\n    if (this.renderer && this.renderer.gl && this.renderer.gl.canvas.parentNode) {\n      this.renderer.gl.canvas.parentNode.removeChild(this.renderer.gl.canvas as HTMLCanvasElement);\n    }\n  }\n}\n\ninterface CircularGalleryProps {\n  items?: { image: string; text: string }[];\n  bend?: number;\n  textColor?: string;\n  borderRadius?: number;\n  font?: string;\n  scrollSpeed?: number;\n  scrollEase?: number;\n}\n\nexport default function CircularGallery({\n  items,\n  bend = 3,\n  textColor = '#ffffff',\n  borderRadius = 0.05,\n  font = 'bold 30px Figtree',\n  scrollSpeed = 2,\n  scrollEase = 0.05\n}: CircularGalleryProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const app = new App(containerRef.current, {\n      items,\n      bend,\n      textColor,\n      borderRadius,\n      font,\n      scrollSpeed,\n      scrollEase\n    });\n    return () => {\n      app.destroy();\n    };\n  }, [items, bend, textColor, borderRadius, font, scrollSpeed, scrollEase]);\n  return <div className=\"w-full h-full overflow-hidden cursor-grab active:cursor-grabbing\" ref={containerRef} />;\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "counter",
      "type": "component",
      "description": "A layouts counter component",
      "category": "layouts",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/counter.tsx",
          "content": "import { MotionValue, motion, useSpring, useTransform } from 'motion/react';\nimport type React from 'react';\nimport { useEffect } from 'react';\n\ntype PlaceValue = number | '.';\n\ninterface NumberProps {\n  mv: MotionValue<number>;\n  number: number;\n  height: number;\n}\n\nfunction Number({ mv, number, height }: NumberProps) {\n  const y = useTransform(mv, latest => {\n    const placeValue = latest % 10;\n    const offset = (10 + number - placeValue) % 10;\n    let memo = offset * height;\n    if (offset > 5) {\n      memo -= 10 * height;\n    }\n    return memo;\n  });\n\n  const baseStyle: React.CSSProperties = {\n    position: 'absolute',\n    inset: 0,\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center'\n  };\n\n  return <motion.span style={{ ...baseStyle, y }}>{number}</motion.span>;\n}\n\ninterface DigitProps {\n  place: PlaceValue;\n  value: number;\n  height: number;\n  digitStyle?: React.CSSProperties;\n}\n\nfunction Digit({ place, value, height, digitStyle }: DigitProps) {\n  // Decimal point digit\n  if (place === '.') {\n    return (\n      <span\n        className=\"relative inline-flex items-center justify-center\"\n        style={{ height, width: 'fit-content', ...digitStyle }}\n      >\n        .\n      </span>\n    );\n  }\n\n  // Numeric digit\n  const valueRoundedToPlace = Math.floor(value / place);\n  const animatedValue = useSpring(valueRoundedToPlace);\n\n  useEffect(() => {\n    animatedValue.set(valueRoundedToPlace);\n  }, [animatedValue, valueRoundedToPlace]);\n\n  const defaultStyle: React.CSSProperties = {\n    height,\n    position: 'relative',\n    width: '1ch',\n    fontVariantNumeric: 'tabular-nums'\n  };\n\n  return (\n    <span className=\"relative inline-flex overflow-hidden\" style={{ ...defaultStyle, ...digitStyle }}>\n      {Array.from({ length: 10 }, (_, i) => (\n        <Number key={i} mv={animatedValue} number={i} height={height} />\n      ))}\n    </span>\n  );\n}\n\ninterface CounterProps {\n  value: number;\n  fontSize?: number;\n  padding?: number;\n  /**\n   * An array of place values that determines which digit positions\n   * should be displayed. For decimal places, use \".\" to represent\n   * the decimal point. Leave this prop empty to enable automatic\n   * detection based on the current value.\n   */\n  places?: PlaceValue[];\n  gap?: number;\n  borderRadius?: number;\n  horizontalPadding?: number;\n  textColor?: string;\n  fontWeight?: React.CSSProperties['fontWeight'];\n  containerStyle?: React.CSSProperties;\n  counterStyle?: React.CSSProperties;\n  digitStyle?: React.CSSProperties;\n  gradientHeight?: number;\n  gradientFrom?: string;\n  gradientTo?: string;\n  topGradientStyle?: React.CSSProperties;\n  bottomGradientStyle?: React.CSSProperties;\n}\n\nexport default function Counter({\n  value,\n  fontSize = 100,\n  padding = 0,\n  places = [...value.toString()].map((ch, i, a) => {\n    if (ch === '.') {\n      return '.';\n    }\n\n    const dotIndex = a.indexOf('.');\n    const isInteger = dotIndex === -1;\n\n    const exponent = isInteger ? a.length - i - 1 : i < dotIndex ? dotIndex - i - 1 : -(i - dotIndex);\n\n    return 10 ** exponent;\n  }),\n  gap = 8,\n  borderRadius = 4,\n  horizontalPadding = 8,\n  textColor = 'inherit',\n  fontWeight = 'inherit',\n  containerStyle,\n  counterStyle,\n  digitStyle,\n  gradientHeight = 16,\n  gradientFrom = 'black',\n  gradientTo = 'transparent',\n  topGradientStyle,\n  bottomGradientStyle\n}: CounterProps) {\n  const height = fontSize + padding;\n\n  const defaultContainerStyle: React.CSSProperties = {\n    position: 'relative',\n    display: 'inline-block'\n  };\n\n  const defaultCounterStyle: React.CSSProperties = {\n    fontSize,\n    display: 'flex',\n    gap,\n    overflow: 'hidden',\n    borderRadius,\n    paddingLeft: horizontalPadding,\n    paddingRight: horizontalPadding,\n    lineHeight: 1,\n    color: textColor,\n    fontWeight\n  };\n\n  const gradientContainerStyle: React.CSSProperties = {\n    pointerEvents: 'none',\n    position: 'absolute',\n    inset: 0,\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'space-between'\n  };\n\n  const defaultTopGradientStyle: React.CSSProperties = {\n    height: gradientHeight,\n    background: `linear-gradient(to bottom, ${gradientFrom}, ${gradientTo})`\n  };\n\n  const defaultBottomGradientStyle: React.CSSProperties = {\n    height: gradientHeight,\n    background: `linear-gradient(to top, ${gradientFrom}, ${gradientTo})`\n  };\n\n  return (\n    <span style={{ ...defaultContainerStyle, ...containerStyle }}>\n      <span style={{ ...defaultCounterStyle, ...counterStyle }}>\n        {places.map(place => (\n          <Digit key={place} place={place} value={value} height={height} digitStyle={digitStyle} />\n        ))}\n      </span>\n      <span style={gradientContainerStyle}>\n        <span style={topGradientStyle ?? defaultTopGradientStyle} />\n        <span style={bottomGradientStyle ?? defaultBottomGradientStyle} />\n      </span>\n    </span>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "decay-card",
      "type": "component",
      "description": "A layouts decay card component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/decay-card.tsx",
          "content": "import React, { useEffect, useRef, ReactNode } from 'react';\nimport { gsap } from 'gsap';\n\ninterface DecayCardProps {\n  width?: number;\n  height?: number;\n  image?: string;\n  children?: ReactNode;\n}\n\nconst DecayCard: React.FC<DecayCardProps> = ({\n  width = 300,\n  height = 400,\n  image = 'https://picsum.photos/300/400?grayscale',\n  children\n}) => {\n  const svgRef = useRef<HTMLDivElement | null>(null);\n  const displacementMapRef = useRef<SVGFEDisplacementMapElement | null>(null);\n  const cursor = useRef<{ x: number; y: number }>({\n    x: window.innerWidth / 2,\n    y: window.innerHeight / 2\n  });\n  const cachedCursor = useRef<{ x: number; y: number }>({ ...cursor.current });\n  const winsize = useRef<{ width: number; height: number }>({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  useEffect(() => {\n    const lerp = (a: number, b: number, n: number): number => (1 - n) * a + n * b;\n    const map = (x: number, a: number, b: number, c: number, d: number): number => ((x - a) * (d - c)) / (b - a) + c;\n    const distance = (x1: number, x2: number, y1: number, y2: number): number => Math.hypot(x1 - x2, y1 - y2);\n\n    const handleResize = (): void => {\n      winsize.current = {\n        width: window.innerWidth,\n        height: window.innerHeight\n      };\n    };\n\n    const handleMouseMove = (ev: MouseEvent): void => {\n      cursor.current = { x: ev.clientX, y: ev.clientY };\n    };\n\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('mousemove', handleMouseMove);\n\n    const imgValues = {\n      imgTransforms: { x: 0, y: 0, rz: 0 },\n      displacementScale: 0\n    };\n\n    const render = () => {\n      let targetX = lerp(imgValues.imgTransforms.x, map(cursor.current.x, 0, winsize.current.width, -120, 120), 0.1);\n      let targetY = lerp(imgValues.imgTransforms.y, map(cursor.current.y, 0, winsize.current.height, -120, 120), 0.1);\n      let targetRz = lerp(imgValues.imgTransforms.rz, map(cursor.current.x, 0, winsize.current.width, -10, 10), 0.1);\n\n      const bound = 50;\n      if (targetX > bound) targetX = bound + (targetX - bound) * 0.2;\n      if (targetX < -bound) targetX = -bound + (targetX + bound) * 0.2;\n      if (targetY > bound) targetY = bound + (targetY - bound) * 0.2;\n      if (targetY < -bound) targetY = -bound + (targetY + bound) * 0.2;\n\n      imgValues.imgTransforms.x = targetX;\n      imgValues.imgTransforms.y = targetY;\n      imgValues.imgTransforms.rz = targetRz;\n\n      if (svgRef.current) {\n        gsap.set(svgRef.current, {\n          x: imgValues.imgTransforms.x,\n          y: imgValues.imgTransforms.y,\n          rotateZ: imgValues.imgTransforms.rz\n        });\n      }\n\n      const cursorTravelledDistance = distance(\n        cachedCursor.current.x,\n        cursor.current.x,\n        cachedCursor.current.y,\n        cursor.current.y\n      );\n      imgValues.displacementScale = lerp(\n        imgValues.displacementScale,\n        map(cursorTravelledDistance, 0, 200, 0, 400),\n        0.06\n      );\n\n      if (displacementMapRef.current) {\n        gsap.set(displacementMapRef.current, {\n          attr: { scale: imgValues.displacementScale }\n        });\n      }\n\n      cachedCursor.current = { ...cursor.current };\n\n      requestAnimationFrame(render);\n    };\n\n    render();\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n\n  return (\n    <div ref={svgRef} className=\"relative\" style={{ width: `${width}px`, height: `${height}px` }}>\n      <svg\n        viewBox=\"-60 -75 720 900\"\n        preserveAspectRatio=\"xMidYMid slice\"\n        className=\"relative w-full h-full block [will-change:transform]\"\n      >\n        <filter id=\"imgFilter\">\n          <feTurbulence\n            type=\"turbulence\"\n            baseFrequency=\"0.015\"\n            numOctaves=\"5\"\n            seed=\"4\"\n            stitchTiles=\"stitch\"\n            x=\"0%\"\n            y=\"0%\"\n            width=\"100%\"\n            height=\"100%\"\n            result=\"turbulence1\"\n          />\n          <feDisplacementMap\n            ref={displacementMapRef}\n            in=\"SourceGraphic\"\n            in2=\"turbulence1\"\n            scale=\"0\"\n            xChannelSelector=\"R\"\n            yChannelSelector=\"B\"\n            x=\"0%\"\n            y=\"0%\"\n            width=\"100%\"\n            height=\"100%\"\n            result=\"displacementMap3\"\n          />\n        </filter>\n        <g>\n          <image\n            href={image}\n            x=\"0\"\n            y=\"0\"\n            width=\"600\"\n            height=\"750\"\n            filter=\"url(#imgFilter)\"\n            preserveAspectRatio=\"xMidYMid slice\"\n          />\n        </g>\n      </svg>\n      <div className=\"absolute bottom-[1.2em] left-[1em] tracking-[-0.5px] font-black text-[2.5rem] leading-[1.5em] first-line:text-[6rem]\">\n        {children}\n      </div>\n    </div>\n  );\n};\n\nexport default DecayCard;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "dock",
      "type": "component",
      "description": "An implementation of the MacOS dock using react + tailwindcss + motion",
      "category": "layouts",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/dock.tsx",
          "content": "\"use client\"\n\nimport React, { PropsWithChildren, useRef } from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport {\n  motion,\n  MotionValue,\n  useMotionValue,\n  useSpring,\n  useTransform,\n} from \"motion/react\"\nimport type { MotionProps } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface DockProps extends VariantProps<typeof dockVariants> {\n  className?: string\n  iconSize?: number\n  iconMagnification?: number\n  disableMagnification?: boolean\n  iconDistance?: number\n  direction?: \"top\" | \"middle\" | \"bottom\"\n  children: React.ReactNode\n}\n\nconst DEFAULT_SIZE = 40\nconst DEFAULT_MAGNIFICATION = 60\nconst DEFAULT_DISTANCE = 140\nconst DEFAULT_DISABLEMAGNIFICATION = false\n\nconst dockVariants = cva(\n  \"supports-backdrop-blur:bg-white/10 supports-backdrop-blur:dark:bg-black/10 mx-auto mt-8 flex h-[58px] w-max items-center justify-center gap-2 rounded-2xl border p-2 backdrop-blur-md\"\n)\n\nconst Dock = React.forwardRef<HTMLDivElement, DockProps>(\n  (\n    {\n      className,\n      children,\n      iconSize = DEFAULT_SIZE,\n      iconMagnification = DEFAULT_MAGNIFICATION,\n      disableMagnification = DEFAULT_DISABLEMAGNIFICATION,\n      iconDistance = DEFAULT_DISTANCE,\n      direction = \"middle\",\n      ...props\n    },\n    ref\n  ) => {\n    const mouseX = useMotionValue(Infinity)\n\n    const renderChildren = () => {\n      return React.Children.map(children, (child) => {\n        if (\n          React.isValidElement<DockIconProps>(child) &&\n          child.type === DockIcon\n        ) {\n          return React.cloneElement(child, {\n            ...child.props,\n            mouseX: mouseX,\n            size: iconSize,\n            magnification: iconMagnification,\n            disableMagnification: disableMagnification,\n            distance: iconDistance,\n          })\n        }\n        return child\n      })\n    }\n\n    return (\n      <motion.div\n        ref={ref}\n        onMouseMove={(e) => mouseX.set(e.pageX)}\n        onMouseLeave={() => mouseX.set(Infinity)}\n        {...props}\n        className={cn(dockVariants({ className }), {\n          \"items-start\": direction === \"top\",\n          \"items-center\": direction === \"middle\",\n          \"items-end\": direction === \"bottom\",\n        })}\n      >\n        {renderChildren()}\n      </motion.div>\n    )\n  }\n)\n\nDock.displayName = \"Dock\"\n\nexport interface DockIconProps extends Omit<\n  MotionProps & React.HTMLAttributes<HTMLDivElement>,\n  \"children\"\n> {\n  size?: number\n  magnification?: number\n  disableMagnification?: boolean\n  distance?: number\n  mouseX?: MotionValue<number>\n  className?: string\n  children?: React.ReactNode\n  props?: PropsWithChildren\n}\n\nconst DockIcon = ({\n  size = DEFAULT_SIZE,\n  magnification = DEFAULT_MAGNIFICATION,\n  disableMagnification,\n  distance = DEFAULT_DISTANCE,\n  mouseX,\n  className,\n  children,\n  ...props\n}: DockIconProps) => {\n  const ref = useRef<HTMLDivElement>(null)\n  const padding = Math.max(6, size * 0.2)\n  const defaultMouseX = useMotionValue(Infinity)\n\n  const distanceCalc = useTransform(mouseX ?? defaultMouseX, (val: number) => {\n    const bounds = ref.current?.getBoundingClientRect() ?? { x: 0, width: 0 }\n    return val - bounds.x - bounds.width / 2\n  })\n\n  const targetSize = disableMagnification ? size : magnification\n\n  const sizeTransform = useTransform(\n    distanceCalc,\n    [-distance, 0, distance],\n    [size, targetSize, size]\n  )\n\n  const scaleSize = useSpring(sizeTransform, {\n    mass: 0.1,\n    stiffness: 150,\n    damping: 12,\n  })\n\n  return (\n    <motion.div\n      ref={ref}\n      style={{ width: scaleSize, height: scaleSize, padding }}\n      className={cn(\n        \"flex aspect-square cursor-pointer items-center justify-center rounded-full\",\n        disableMagnification && \"hover:bg-muted-foreground transition-colors\",\n        className\n      )}\n      {...props}\n    >\n      <div>{children}</div>\n    </motion.div>\n  )\n}\n\nDockIcon.displayName = \"DockIcon\"\n\nexport { Dock, DockIcon, dockVariants }\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "dome-gallery",
      "type": "component",
      "description": "A layouts dome gallery component",
      "category": "layouts",
      "dependencies": [
        "@use-gesture/react"
      ],
      "files": [
        {
          "path": "components/ui/dome-gallery.tsx",
          "content": "import { useEffect, useMemo, useRef, useCallback } from 'react';\nimport { useGesture } from '@use-gesture/react';\n\ntype ImageItem = string | { src: string; alt?: string };\n\ntype DomeGalleryProps = {\n  images?: ImageItem[];\n  fit?: number;\n  fitBasis?: 'auto' | 'min' | 'max' | 'width' | 'height';\n  minRadius?: number;\n  maxRadius?: number;\n  padFactor?: number;\n  overlayBlurColor?: string;\n  maxVerticalRotationDeg?: number;\n  dragSensitivity?: number;\n  enlargeTransitionMs?: number;\n  segments?: number;\n  dragDampening?: number;\n  openedImageWidth?: string;\n  openedImageHeight?: string;\n  imageBorderRadius?: string;\n  openedImageBorderRadius?: string;\n  grayscale?: boolean;\n};\n\ntype ItemDef = {\n  src: string;\n  alt: string;\n  x: number;\n  y: number;\n  sizeX: number;\n  sizeY: number;\n};\n\nconst DEFAULT_IMAGES: ImageItem[] = [\n  {\n    src: 'https://images.unsplash.com/photo-1755331039789-7e5680e26e8f?q=80&w=774&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n    alt: 'Abstract art'\n  },\n  {\n    src: 'https://images.unsplash.com/photo-1755569309049-98410b94f66d?q=80&w=772&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n    alt: 'Modern sculpture'\n  },\n  {\n    src: 'https://images.unsplash.com/photo-1755497595318-7e5e3523854f?q=80&w=774&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n    alt: 'Digital artwork'\n  },\n  {\n    src: 'https://images.unsplash.com/photo-1755353985163-c2a0fe5ac3d8?q=80&w=774&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n    alt: 'Contemporary art'\n  },\n  {\n    src: 'https://images.unsplash.com/photo-1745965976680-d00be7dc0377?q=80&w=774&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n    alt: 'Geometric pattern'\n  },\n  {\n    src: 'https://images.unsplash.com/photo-1752588975228-21f44630bb3c?q=80&w=774&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n    alt: 'Textured surface'\n  },\n  {\n    src: 'https://pbs.twimg.com/media/Gyla7NnXMAAXSo_?format=jpg&name=large',\n    alt: 'Social media image'\n  }\n];\n\nconst DEFAULTS = {\n  maxVerticalRotationDeg: 5,\n  dragSensitivity: 20,\n  enlargeTransitionMs: 300,\n  segments: 35\n};\n\nconst clamp = (v: number, min: number, max: number) => Math.min(Math.max(v, min), max);\nconst normalizeAngle = (d: number) => ((d % 360) + 360) % 360;\nconst wrapAngleSigned = (deg: number) => {\n  const a = (((deg + 180) % 360) + 360) % 360;\n  return a - 180;\n};\nconst getDataNumber = (el: HTMLElement, name: string, fallback: number) => {\n  const attr = el.dataset[name] ?? el.getAttribute(`data-${name}`);\n  const n = attr == null ? NaN : parseFloat(attr);\n  return Number.isFinite(n) ? n : fallback;\n};\n\nfunction buildItems(pool: ImageItem[], seg: number): ItemDef[] {\n  const xCols = Array.from({ length: seg }, (_, i) => -37 + i * 2);\n  const evenYs = [-4, -2, 0, 2, 4];\n  const oddYs = [-3, -1, 1, 3, 5];\n\n  const coords = xCols.flatMap((x, c) => {\n    const ys = c % 2 === 0 ? evenYs : oddYs;\n    return ys.map(y => ({ x, y, sizeX: 2, sizeY: 2 }));\n  });\n\n  const totalSlots = coords.length;\n  if (pool.length === 0) {\n    return coords.map(c => ({ ...c, src: '', alt: '' }));\n  }\n  if (pool.length > totalSlots) {\n    console.warn(\n      `[DomeGallery] Provided image count (${pool.length}) exceeds available tiles (${totalSlots}). Some images will not be shown.`\n    );\n  }\n\n  const normalizedImages = pool.map(image => {\n    if (typeof image === 'string') {\n      return { src: image, alt: '' };\n    }\n    return { src: image.src || '', alt: image.alt || '' };\n  });\n\n  const usedImages = Array.from({ length: totalSlots }, (_, i) => normalizedImages[i % normalizedImages.length]);\n\n  for (let i = 1; i < usedImages.length; i++) {\n    if (usedImages[i].src === usedImages[i - 1].src) {\n      for (let j = i + 1; j < usedImages.length; j++) {\n        if (usedImages[j].src !== usedImages[i].src) {\n          const tmp = usedImages[i];\n          usedImages[i] = usedImages[j];\n          usedImages[j] = tmp;\n          break;\n        }\n      }\n    }\n  }\n\n  return coords.map((c, i) => ({\n    ...c,\n    src: usedImages[i].src,\n    alt: usedImages[i].alt\n  }));\n}\n\nfunction computeItemBaseRotation(offsetX: number, offsetY: number, sizeX: number, sizeY: number, segments: number) {\n  const unit = 360 / segments / 2;\n  const rotateY = unit * (offsetX + (sizeX - 1) / 2);\n  const rotateX = unit * (offsetY - (sizeY - 1) / 2);\n  return { rotateX, rotateY };\n}\n\nexport default function DomeGallery({\n  images = DEFAULT_IMAGES,\n  fit = 0.5,\n  fitBasis = 'auto',\n  minRadius = 600,\n  maxRadius = Infinity,\n  padFactor = 0.25,\n  overlayBlurColor = '#060010',\n  maxVerticalRotationDeg = DEFAULTS.maxVerticalRotationDeg,\n  dragSensitivity = DEFAULTS.dragSensitivity,\n  enlargeTransitionMs = DEFAULTS.enlargeTransitionMs,\n  segments = DEFAULTS.segments,\n  dragDampening = 2,\n  openedImageWidth = '400px',\n  openedImageHeight = '400px',\n  imageBorderRadius = '30px',\n  openedImageBorderRadius = '30px',\n  grayscale = true\n}: DomeGalleryProps) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const mainRef = useRef<HTMLDivElement>(null);\n  const sphereRef = useRef<HTMLDivElement>(null);\n  const frameRef = useRef<HTMLDivElement>(null);\n  const viewerRef = useRef<HTMLDivElement>(null);\n  const scrimRef = useRef<HTMLDivElement>(null);\n  const focusedElRef = useRef<HTMLElement | null>(null);\n  const originalTilePositionRef = useRef<{\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } | null>(null);\n\n  const rotationRef = useRef({ x: 0, y: 0 });\n  const startRotRef = useRef({ x: 0, y: 0 });\n  const startPosRef = useRef<{ x: number; y: number } | null>(null);\n  const draggingRef = useRef(false);\n  const cancelTapRef = useRef(false);\n  const movedRef = useRef(false);\n  const inertiaRAF = useRef<number | null>(null);\n  const pointerTypeRef = useRef<'mouse' | 'pen' | 'touch'>('mouse');\n  const tapTargetRef = useRef<HTMLElement | null>(null);\n  const openingRef = useRef(false);\n  const openStartedAtRef = useRef(0);\n  const lastDragEndAt = useRef(0);\n\n  const scrollLockedRef = useRef(false);\n  const lockScroll = useCallback(() => {\n    if (scrollLockedRef.current) return;\n    scrollLockedRef.current = true;\n    document.body.classList.add('dg-scroll-lock');\n  }, []);\n  const unlockScroll = useCallback(() => {\n    if (!scrollLockedRef.current) return;\n    if (rootRef.current?.getAttribute('data-enlarging') === 'true') return;\n    scrollLockedRef.current = false;\n    document.body.classList.remove('dg-scroll-lock');\n  }, []);\n\n  const items = useMemo(() => buildItems(images, segments), [images, segments]);\n\n  const applyTransform = (xDeg: number, yDeg: number) => {\n    const el = sphereRef.current;\n    if (el) {\n      el.style.transform = `translateZ(calc(var(--radius) * -1)) rotateX(${xDeg}deg) rotateY(${yDeg}deg)`;\n    }\n  };\n\n  const lockedRadiusRef = useRef<number | null>(null);\n\n  useEffect(() => {\n    const root = rootRef.current;\n    if (!root) return;\n    const ro = new ResizeObserver(entries => {\n      const cr = entries[0].contentRect;\n      const w = Math.max(1, cr.width),\n        h = Math.max(1, cr.height);\n      const minDim = Math.min(w, h),\n        maxDim = Math.max(w, h),\n        aspect = w / h;\n      let basis: number;\n      switch (fitBasis) {\n        case 'min':\n          basis = minDim;\n          break;\n        case 'max':\n          basis = maxDim;\n          break;\n        case 'width':\n          basis = w;\n          break;\n        case 'height':\n          basis = h;\n          break;\n        default:\n          basis = aspect >= 1.3 ? w : minDim;\n      }\n      let radius = basis * fit;\n      const heightGuard = h * 1.35;\n      radius = Math.min(radius, heightGuard);\n      radius = clamp(radius, minRadius, maxRadius);\n      lockedRadiusRef.current = Math.round(radius);\n\n      const viewerPad = Math.max(8, Math.round(minDim * padFactor));\n      root.style.setProperty('--radius', `${lockedRadiusRef.current}px`);\n      root.style.setProperty('--viewer-pad', `${viewerPad}px`);\n      root.style.setProperty('--overlay-blur-color', overlayBlurColor);\n      root.style.setProperty('--tile-radius', imageBorderRadius);\n      root.style.setProperty('--enlarge-radius', openedImageBorderRadius);\n      root.style.setProperty('--image-filter', grayscale ? 'grayscale(1)' : 'none');\n      applyTransform(rotationRef.current.x, rotationRef.current.y);\n\n      const enlargedOverlay = viewerRef.current?.querySelector('.enlarge') as HTMLElement;\n      if (enlargedOverlay && frameRef.current && mainRef.current) {\n        const frameR = frameRef.current.getBoundingClientRect();\n        const mainR = mainRef.current.getBoundingClientRect();\n\n        const hasCustomSize = openedImageWidth && openedImageHeight;\n        if (hasCustomSize) {\n          const tempDiv = document.createElement('div');\n          tempDiv.style.cssText = `position: absolute; width: ${openedImageWidth}; height: ${openedImageHeight}; visibility: hidden;`;\n          document.body.appendChild(tempDiv);\n          const tempRect = tempDiv.getBoundingClientRect();\n          document.body.removeChild(tempDiv);\n\n          const centeredLeft = frameR.left - mainR.left + (frameR.width - tempRect.width) / 2;\n          const centeredTop = frameR.top - mainR.top + (frameR.height - tempRect.height) / 2;\n\n          enlargedOverlay.style.left = `${centeredLeft}px`;\n          enlargedOverlay.style.top = `${centeredTop}px`;\n        } else {\n          enlargedOverlay.style.left = `${frameR.left - mainR.left}px`;\n          enlargedOverlay.style.top = `${frameR.top - mainR.top}px`;\n          enlargedOverlay.style.width = `${frameR.width}px`;\n          enlargedOverlay.style.height = `${frameR.height}px`;\n        }\n      }\n    });\n    ro.observe(root);\n    return () => ro.disconnect();\n  }, [\n    fit,\n    fitBasis,\n    minRadius,\n    maxRadius,\n    padFactor,\n    overlayBlurColor,\n    grayscale,\n    imageBorderRadius,\n    openedImageBorderRadius,\n    openedImageWidth,\n    openedImageHeight\n  ]);\n\n  useEffect(() => {\n    applyTransform(rotationRef.current.x, rotationRef.current.y);\n  }, []);\n\n  const stopInertia = useCallback(() => {\n    if (inertiaRAF.current) {\n      cancelAnimationFrame(inertiaRAF.current);\n      inertiaRAF.current = null;\n    }\n  }, []);\n\n  const startInertia = useCallback(\n    (vx: number, vy: number) => {\n      const MAX_V = 1.4;\n      let vX = clamp(vx, -MAX_V, MAX_V) * 80;\n      let vY = clamp(vy, -MAX_V, MAX_V) * 80;\n      let frames = 0;\n      const d = clamp(dragDampening ?? 0.6, 0, 1);\n      const frictionMul = 0.94 + 0.055 * d;\n      const stopThreshold = 0.015 - 0.01 * d;\n      const maxFrames = Math.round(90 + 270 * d);\n      const step = () => {\n        vX *= frictionMul;\n        vY *= frictionMul;\n        if (Math.abs(vX) < stopThreshold && Math.abs(vY) < stopThreshold) {\n          inertiaRAF.current = null;\n          return;\n        }\n        if (++frames > maxFrames) {\n          inertiaRAF.current = null;\n          return;\n        }\n        const nextX = clamp(rotationRef.current.x - vY / 200, -maxVerticalRotationDeg, maxVerticalRotationDeg);\n        const nextY = wrapAngleSigned(rotationRef.current.y + vX / 200);\n        rotationRef.current = { x: nextX, y: nextY };\n        applyTransform(nextX, nextY);\n        inertiaRAF.current = requestAnimationFrame(step);\n      };\n      stopInertia();\n      inertiaRAF.current = requestAnimationFrame(step);\n    },\n    [dragDampening, maxVerticalRotationDeg, stopInertia]\n  );\n\n  useGesture(\n    {\n      onDragStart: ({ event }) => {\n        if (focusedElRef.current) return;\n        stopInertia();\n\n        const evt = event as PointerEvent;\n        pointerTypeRef.current = (evt.pointerType as any) || 'mouse';\n        if (pointerTypeRef.current === 'touch') evt.preventDefault();\n        if (pointerTypeRef.current === 'touch') lockScroll();\n        draggingRef.current = true;\n        cancelTapRef.current = false;\n        movedRef.current = false;\n        startRotRef.current = { ...rotationRef.current };\n        startPosRef.current = { x: evt.clientX, y: evt.clientY };\n        const potential = (evt.target as Element).closest?.('.item__image') as HTMLElement | null;\n        tapTargetRef.current = potential || null;\n      },\n      onDrag: ({ event, last, velocity: velArr = [0, 0], direction: dirArr = [0, 0], movement }) => {\n        if (focusedElRef.current || !draggingRef.current || !startPosRef.current) return;\n\n        const evt = event as PointerEvent;\n        if (pointerTypeRef.current === 'touch') evt.preventDefault();\n\n        const dxTotal = evt.clientX - startPosRef.current.x;\n        const dyTotal = evt.clientY - startPosRef.current.y;\n\n        if (!movedRef.current) {\n          const dist2 = dxTotal * dxTotal + dyTotal * dyTotal;\n          if (dist2 > 16) movedRef.current = true;\n        }\n\n        const nextX = clamp(\n          startRotRef.current.x - dyTotal / dragSensitivity,\n          -maxVerticalRotationDeg,\n          maxVerticalRotationDeg\n        );\n        const nextY = startRotRef.current.y + dxTotal / dragSensitivity;\n\n        const cur = rotationRef.current;\n        if (cur.x !== nextX || cur.y !== nextY) {\n          rotationRef.current = { x: nextX, y: nextY };\n          applyTransform(nextX, nextY);\n        }\n\n        if (last) {\n          draggingRef.current = false;\n          let isTap = false;\n\n          if (startPosRef.current) {\n            const dx = evt.clientX - startPosRef.current.x;\n            const dy = evt.clientY - startPosRef.current.y;\n            const dist2 = dx * dx + dy * dy;\n            const TAP_THRESH_PX = pointerTypeRef.current === 'touch' ? 10 : 6;\n            if (dist2 <= TAP_THRESH_PX * TAP_THRESH_PX) {\n              isTap = true;\n            }\n          }\n\n          let [vMagX, vMagY] = velArr;\n          const [dirX, dirY] = dirArr;\n          let vx = vMagX * dirX;\n          let vy = vMagY * dirY;\n\n          if (!isTap && Math.abs(vx) < 0.001 && Math.abs(vy) < 0.001 && Array.isArray(movement)) {\n            const [mx, my] = movement;\n            vx = (mx / dragSensitivity) * 0.02;\n            vy = (my / dragSensitivity) * 0.02;\n          }\n\n          if (!isTap && (Math.abs(vx) > 0.005 || Math.abs(vy) > 0.005)) {\n            startInertia(vx, vy);\n          }\n          startPosRef.current = null;\n          cancelTapRef.current = !isTap;\n\n          if (isTap && tapTargetRef.current && !focusedElRef.current) {\n            openItemFromElement(tapTargetRef.current);\n          }\n          tapTargetRef.current = null;\n\n          if (cancelTapRef.current) setTimeout(() => (cancelTapRef.current = false), 120);\n          if (pointerTypeRef.current === 'touch') unlockScroll();\n          if (movedRef.current) lastDragEndAt.current = performance.now();\n          movedRef.current = false;\n        }\n      }\n    },\n    { target: mainRef, eventOptions: { passive: false } }\n  );\n\n  useEffect(() => {\n    const scrim = scrimRef.current;\n    if (!scrim) return;\n\n    const close = () => {\n      if (performance.now() - openStartedAtRef.current < 250) return;\n      const el = focusedElRef.current;\n      if (!el) return;\n      const parent = el.parentElement as HTMLElement;\n      const overlay = viewerRef.current?.querySelector('.enlarge') as HTMLElement | null;\n      if (!overlay) return;\n\n      const refDiv = parent.querySelector('.item__image--reference') as HTMLElement | null;\n\n      const originalPos = originalTilePositionRef.current;\n      if (!originalPos) {\n        overlay.remove();\n        if (refDiv) refDiv.remove();\n        parent.style.setProperty('--rot-y-delta', `0deg`);\n        parent.style.setProperty('--rot-x-delta', `0deg`);\n        el.style.visibility = '';\n        (el.style as any).zIndex = 0;\n        focusedElRef.current = null;\n        rootRef.current?.removeAttribute('data-enlarging');\n        openingRef.current = false;\n        return;\n      }\n\n      const currentRect = overlay.getBoundingClientRect();\n      const rootRect = rootRef.current!.getBoundingClientRect();\n\n      const originalPosRelativeToRoot = {\n        left: originalPos.left - rootRect.left,\n        top: originalPos.top - rootRect.top,\n        width: originalPos.width,\n        height: originalPos.height\n      };\n\n      const overlayRelativeToRoot = {\n        left: currentRect.left - rootRect.left,\n        top: currentRect.top - rootRect.top,\n        width: currentRect.width,\n        height: currentRect.height\n      };\n\n      const animatingOverlay = document.createElement('div');\n      animatingOverlay.className = 'enlarge-closing';\n      animatingOverlay.style.cssText = `\n        position: absolute;\n        left: ${overlayRelativeToRoot.left}px;\n        top: ${overlayRelativeToRoot.top}px;\n        width: ${overlayRelativeToRoot.width}px;\n        height: ${overlayRelativeToRoot.height}px;\n        z-index: 9999;\n        border-radius: ${openedImageBorderRadius};\n        overflow: hidden;\n        box-shadow: 0 10px 30px rgba(0,0,0,.35);\n        transition: all ${enlargeTransitionMs}ms ease-out;\n        pointer-events: none;\n        margin: 0;\n        transform: none;\n        filter: ${grayscale ? 'grayscale(1)' : 'none'};\n      `;\n\n      const originalImg = overlay.querySelector('img');\n      if (originalImg) {\n        const img = originalImg.cloneNode() as HTMLImageElement;\n        img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';\n        animatingOverlay.appendChild(img);\n      }\n\n      overlay.remove();\n      rootRef.current!.appendChild(animatingOverlay);\n\n      void animatingOverlay.getBoundingClientRect();\n\n      requestAnimationFrame(() => {\n        animatingOverlay.style.left = originalPosRelativeToRoot.left + 'px';\n        animatingOverlay.style.top = originalPosRelativeToRoot.top + 'px';\n        animatingOverlay.style.width = originalPosRelativeToRoot.width + 'px';\n        animatingOverlay.style.height = originalPosRelativeToRoot.height + 'px';\n        animatingOverlay.style.opacity = '0';\n      });\n\n      const cleanup = () => {\n        animatingOverlay.remove();\n        originalTilePositionRef.current = null;\n\n        if (refDiv) refDiv.remove();\n        parent.style.transition = 'none';\n        el.style.transition = 'none';\n\n        parent.style.setProperty('--rot-y-delta', `0deg`);\n        parent.style.setProperty('--rot-x-delta', `0deg`);\n\n        requestAnimationFrame(() => {\n          el.style.visibility = '';\n          el.style.opacity = '0';\n          (el.style as any).zIndex = 0;\n          focusedElRef.current = null;\n          rootRef.current?.removeAttribute('data-enlarging');\n\n          requestAnimationFrame(() => {\n            parent.style.transition = '';\n            el.style.transition = 'opacity 300ms ease-out';\n\n            requestAnimationFrame(() => {\n              el.style.opacity = '1';\n              setTimeout(() => {\n                el.style.transition = '';\n                el.style.opacity = '';\n                openingRef.current = false;\n                if (!draggingRef.current && rootRef.current?.getAttribute('data-enlarging') !== 'true') {\n                  document.body.classList.remove('dg-scroll-lock');\n                }\n              }, 300);\n            });\n          });\n        });\n      };\n\n      animatingOverlay.addEventListener('transitionend', cleanup, {\n        once: true\n      });\n    };\n\n    scrim.addEventListener('click', close);\n    const onKey = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') close();\n    };\n    window.addEventListener('keydown', onKey);\n\n    return () => {\n      scrim.removeEventListener('click', close);\n      window.removeEventListener('keydown', onKey);\n    };\n  }, [enlargeTransitionMs, openedImageBorderRadius, grayscale]);\n\n  const openItemFromElement = (el: HTMLElement) => {\n    if (openingRef.current) return;\n    openingRef.current = true;\n    openStartedAtRef.current = performance.now();\n    lockScroll();\n    const parent = el.parentElement as HTMLElement;\n    focusedElRef.current = el;\n    el.setAttribute('data-focused', 'true');\n    const offsetX = getDataNumber(parent, 'offsetX', 0);\n    const offsetY = getDataNumber(parent, 'offsetY', 0);\n    const sizeX = getDataNumber(parent, 'sizeX', 2);\n    const sizeY = getDataNumber(parent, 'sizeY', 2);\n    const parentRot = computeItemBaseRotation(offsetX, offsetY, sizeX, sizeY, segments);\n    const parentY = normalizeAngle(parentRot.rotateY);\n    const globalY = normalizeAngle(rotationRef.current.y);\n    let rotY = -(parentY + globalY) % 360;\n    if (rotY < -180) rotY += 360;\n    const rotX = -parentRot.rotateX - rotationRef.current.x;\n    parent.style.setProperty('--rot-y-delta', `${rotY}deg`);\n    parent.style.setProperty('--rot-x-delta', `${rotX}deg`);\n    const refDiv = document.createElement('div');\n    refDiv.className = 'item__image item__image--reference opacity-0';\n    refDiv.style.transform = `rotateX(${-parentRot.rotateX}deg) rotateY(${-parentRot.rotateY}deg)`;\n    parent.appendChild(refDiv);\n\n    void refDiv.offsetHeight;\n\n    const tileR = refDiv.getBoundingClientRect();\n    const mainR = mainRef.current?.getBoundingClientRect();\n    const frameR = frameRef.current?.getBoundingClientRect();\n\n    if (!mainR || !frameR || tileR.width <= 0 || tileR.height <= 0) {\n      openingRef.current = false;\n      focusedElRef.current = null;\n      parent.removeChild(refDiv);\n      unlockScroll();\n      return;\n    }\n\n    originalTilePositionRef.current = {\n      left: tileR.left,\n      top: tileR.top,\n      width: tileR.width,\n      height: tileR.height\n    };\n    el.style.visibility = 'hidden';\n    (el.style as any).zIndex = 0;\n    const overlay = document.createElement('div');\n    overlay.className = 'enlarge';\n    overlay.style.cssText = `position:absolute; left:${frameR.left - mainR.left}px; top:${frameR.top - mainR.top}px; width:${frameR.width}px; height:${frameR.height}px; opacity:0; z-index:30; will-change:transform,opacity; transform-origin:top left; transition:transform ${enlargeTransitionMs}ms ease, opacity ${enlargeTransitionMs}ms ease; border-radius:${openedImageBorderRadius}; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.35);`;\n    const rawSrc = parent.dataset.src || (el.querySelector('img') as HTMLImageElement)?.src || '';\n    const rawAlt = parent.dataset.alt || (el.querySelector('img') as HTMLImageElement)?.alt || '';\n    const img = document.createElement('img');\n    img.src = rawSrc;\n    img.alt = rawAlt;\n    img.style.cssText = `width:100%; height:100%; object-fit:cover; filter:${grayscale ? 'grayscale(1)' : 'none'};`;\n    overlay.appendChild(img);\n    viewerRef.current!.appendChild(overlay);\n    const tx0 = tileR.left - frameR.left;\n    const ty0 = tileR.top - frameR.top;\n    const sx0 = tileR.width / frameR.width;\n    const sy0 = tileR.height / frameR.height;\n\n    const validSx0 = isFinite(sx0) && sx0 > 0 ? sx0 : 1;\n    const validSy0 = isFinite(sy0) && sy0 > 0 ? sy0 : 1;\n\n    overlay.style.transform = `translate(${tx0}px, ${ty0}px) scale(${validSx0}, ${validSy0})`;\n    setTimeout(() => {\n      if (!overlay.parentElement) return;\n      overlay.style.opacity = '1';\n      overlay.style.transform = 'translate(0px, 0px) scale(1, 1)';\n      rootRef.current?.setAttribute('data-enlarging', 'true');\n    }, 16);\n    const wantsResize = openedImageWidth || openedImageHeight;\n    if (wantsResize) {\n      const onFirstEnd = (ev: TransitionEvent) => {\n        if (ev.propertyName !== 'transform') return;\n        overlay.removeEventListener('transitionend', onFirstEnd);\n        const prevTransition = overlay.style.transition;\n        overlay.style.transition = 'none';\n        const tempWidth = openedImageWidth || `${frameR.width}px`;\n        const tempHeight = openedImageHeight || `${frameR.height}px`;\n        overlay.style.width = tempWidth;\n        overlay.style.height = tempHeight;\n        const newRect = overlay.getBoundingClientRect();\n        overlay.style.width = frameR.width + 'px';\n        overlay.style.height = frameR.height + 'px';\n        void overlay.offsetWidth;\n        overlay.style.transition = `left ${enlargeTransitionMs}ms ease, top ${enlargeTransitionMs}ms ease, width ${enlargeTransitionMs}ms ease, height ${enlargeTransitionMs}ms ease`;\n        const centeredLeft = frameR.left - mainR.left + (frameR.width - newRect.width) / 2;\n        const centeredTop = frameR.top - mainR.top + (frameR.height - newRect.height) / 2;\n        requestAnimationFrame(() => {\n          overlay.style.left = `${centeredLeft}px`;\n          overlay.style.top = `${centeredTop}px`;\n          overlay.style.width = tempWidth;\n          overlay.style.height = tempHeight;\n        });\n        const cleanupSecond = () => {\n          overlay.removeEventListener('transitionend', cleanupSecond);\n          overlay.style.transition = prevTransition;\n        };\n        overlay.addEventListener('transitionend', cleanupSecond, {\n          once: true\n        });\n      };\n      overlay.addEventListener('transitionend', onFirstEnd);\n    }\n  };\n\n  useEffect(() => {\n    return () => {\n      document.body.classList.remove('dg-scroll-lock');\n    };\n  }, []);\n\n  const cssStyles = `\n    .sphere-root {\n      --radius: 520px;\n      --viewer-pad: 72px;\n      --circ: calc(var(--radius) * 3.14);\n      --rot-y: calc((360deg / var(--segments-x)) / 2);\n      --rot-x: calc((360deg / var(--segments-y)) / 2);\n      --item-width: calc(var(--circ) / var(--segments-x));\n      --item-height: calc(var(--circ) / var(--segments-y));\n    }\n    \n    .sphere-root * { box-sizing: border-box; }\n    .sphere, .sphere-item, .item__image { transform-style: preserve-3d; }\n    \n    .stage {\n      width: 100%;\n      height: 100%;\n      display: grid;\n      place-items: center;\n      position: absolute;\n      inset: 0;\n      margin: auto;\n      perspective: calc(var(--radius) * 2);\n      perspective-origin: 50% 50%;\n    }\n    \n    .sphere {\n      transform: translateZ(calc(var(--radius) * -1));\n      will-change: transform;\n      position: absolute;\n    }\n    \n    .sphere-item {\n      width: calc(var(--item-width) * var(--item-size-x));\n      height: calc(var(--item-height) * var(--item-size-y));\n      position: absolute;\n      top: -999px;\n      bottom: -999px;\n      left: -999px;\n      right: -999px;\n      margin: auto;\n      transform-origin: 50% 50%;\n      backface-visibility: hidden;\n      transition: transform 300ms;\n      transform: rotateY(calc(var(--rot-y) * (var(--offset-x) + ((var(--item-size-x) - 1) / 2)) + var(--rot-y-delta, 0deg))) \n                 rotateX(calc(var(--rot-x) * (var(--offset-y) - ((var(--item-size-y) - 1) / 2)) + var(--rot-x-delta, 0deg))) \n                 translateZ(var(--radius));\n    }\n    \n    .sphere-root[data-enlarging=\"true\"] .scrim {\n      opacity: 1 !important;\n      pointer-events: all !important;\n    }\n    \n    @media (max-aspect-ratio: 1/1) {\n      .viewer-frame {\n        height: auto !important;\n        width: 100% !important;\n      }\n    }\n    \n    // body.dg-scroll-lock {\n    //   position: fixed !important;\n    //   top: 0;\n    //   left: 0;\n    //   width: 100% !important;\n    //   height: 100% !important;\n    //   overflow: hidden !important;\n    //   touch-action: none !important;\n    //   overscroll-behavior: contain !important;\n    // }\n    .item__image {\n      position: absolute;\n      inset: 10px;\n      border-radius: var(--tile-radius, 12px);\n      overflow: hidden;\n      cursor: pointer;\n      backface-visibility: hidden;\n      -webkit-backface-visibility: hidden;\n      transition: transform 300ms;\n      pointer-events: auto;\n      -webkit-transform: translateZ(0);\n      transform: translateZ(0);\n    }\n    .item__image--reference {\n      position: absolute;\n      inset: 10px;\n      pointer-events: none;\n    }\n  `;\n\n  return (\n    <>\n      <style dangerouslySetInnerHTML={{ __html: cssStyles }} />\n      <div\n        ref={rootRef}\n        className=\"sphere-root relative w-full h-full\"\n        style={\n          {\n            ['--segments-x' as any]: segments,\n            ['--segments-y' as any]: segments,\n            ['--overlay-blur-color' as any]: overlayBlurColor,\n            ['--tile-radius' as any]: imageBorderRadius,\n            ['--enlarge-radius' as any]: openedImageBorderRadius,\n            ['--image-filter' as any]: grayscale ? 'grayscale(1)' : 'none'\n          } as React.CSSProperties\n        }\n      >\n        <main\n          ref={mainRef}\n          className=\"absolute inset-0 grid place-items-center overflow-hidden select-none bg-transparent\"\n          style={{\n            touchAction: 'none',\n            WebkitUserSelect: 'none'\n          }}\n        >\n          <div className=\"stage\">\n            <div ref={sphereRef} className=\"sphere\">\n              {items.map((it, i) => (\n                <div\n                  key={`${it.x},${it.y},${i}`}\n                  className=\"sphere-item absolute m-auto\"\n                  data-src={it.src}\n                  data-alt={it.alt}\n                  data-offset-x={it.x}\n                  data-offset-y={it.y}\n                  data-size-x={it.sizeX}\n                  data-size-y={it.sizeY}\n                  style={\n                    {\n                      ['--offset-x' as any]: it.x,\n                      ['--offset-y' as any]: it.y,\n                      ['--item-size-x' as any]: it.sizeX,\n                      ['--item-size-y' as any]: it.sizeY,\n                      top: '-999px',\n                      bottom: '-999px',\n                      left: '-999px',\n                      right: '-999px'\n                    } as React.CSSProperties\n                  }\n                >\n                  <div\n                    className=\"item__image absolute block overflow-hidden cursor-pointer bg-gray-200 transition-transform duration-300\"\n                    role=\"button\"\n                    tabIndex={0}\n                    aria-label={it.alt || 'Open image'}\n                    onClick={e => {\n                      if (draggingRef.current) return;\n                      if (movedRef.current) return;\n                      if (performance.now() - lastDragEndAt.current < 80) return;\n                      if (openingRef.current) return;\n                      openItemFromElement(e.currentTarget as HTMLElement);\n                    }}\n                    onPointerUp={e => {\n                      if ((e.nativeEvent as PointerEvent).pointerType !== 'touch') return;\n                      if (draggingRef.current) return;\n                      if (movedRef.current) return;\n                      if (performance.now() - lastDragEndAt.current < 80) return;\n                      if (openingRef.current) return;\n                      openItemFromElement(e.currentTarget as HTMLElement);\n                    }}\n                    style={{\n                      inset: '10px',\n                      borderRadius: `var(--tile-radius, ${imageBorderRadius})`,\n                      backfaceVisibility: 'hidden'\n                    }}\n                  >\n                    <img\n                      src={it.src}\n                      draggable={false}\n                      alt={it.alt}\n                      className=\"w-full h-full object-cover pointer-events-none\"\n                      style={{\n                        backfaceVisibility: 'hidden',\n                        filter: `var(--image-filter, ${grayscale ? 'grayscale(1)' : 'none'})`\n                      }}\n                    />\n                  </div>\n                </div>\n              ))}\n            </div>\n          </div>\n\n          <div\n            className=\"absolute inset-0 m-auto z-[3] pointer-events-none\"\n            style={{\n              backgroundImage: `radial-gradient(rgba(235, 235, 235, 0) 65%, var(--overlay-blur-color, ${overlayBlurColor}) 100%)`\n            }}\n          />\n\n          <div\n            className=\"absolute inset-0 m-auto z-[3] pointer-events-none\"\n            style={{\n              WebkitMaskImage: `radial-gradient(rgba(235, 235, 235, 0) 70%, var(--overlay-blur-color, ${overlayBlurColor}) 90%)`,\n              maskImage: `radial-gradient(rgba(235, 235, 235, 0) 70%, var(--overlay-blur-color, ${overlayBlurColor}) 90%)`,\n              backdropFilter: 'blur(3px)'\n            }}\n          />\n\n          <div\n            className=\"absolute left-0 right-0 top-0 h-[120px] z-[5] pointer-events-none rotate-180\"\n            style={{\n              background: `linear-gradient(to bottom, transparent, var(--overlay-blur-color, ${overlayBlurColor}))`\n            }}\n          />\n          <div\n            className=\"absolute left-0 right-0 bottom-0 h-[120px] z-[5] pointer-events-none\"\n            style={{\n              background: `linear-gradient(to bottom, transparent, var(--overlay-blur-color, ${overlayBlurColor}))`\n            }}\n          />\n\n          <div\n            ref={viewerRef}\n            className=\"absolute inset-0 z-20 pointer-events-none flex items-center justify-center\"\n            style={{ padding: 'var(--viewer-pad)' }}\n          >\n            <div\n              ref={scrimRef}\n              className=\"scrim absolute inset-0 z-10 pointer-events-none opacity-0 transition-opacity duration-500\"\n              style={{\n                background: 'rgba(0, 0, 0, 0.4)',\n                backdropFilter: 'blur(3px)'\n              }}\n            />\n            <div\n              ref={frameRef}\n              className=\"viewer-frame h-full aspect-square flex\"\n              style={{\n                borderRadius: `var(--enlarge-radius, ${openedImageBorderRadius})`\n              }}\n            />\n          </div>\n        </main>\n      </div>\n    </>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "elastic-slider",
      "type": "component",
      "description": "A layouts elastic slider component",
      "category": "layouts",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/elastic-slider.tsx",
          "content": "import React, { useEffect, useRef, useState } from 'react';\nimport { animate, motion, useMotionValue, useMotionValueEvent, useTransform } from 'motion/react';\n\nconst MAX_OVERFLOW = 50;\n\ninterface ElasticSliderProps {\n  defaultValue?: number;\n  startingValue?: number;\n  maxValue?: number;\n  className?: string;\n  isStepped?: boolean;\n  stepSize?: number;\n  leftIcon?: React.ReactNode;\n  rightIcon?: React.ReactNode;\n}\n\nconst ElasticSlider: React.FC<ElasticSliderProps> = ({\n  defaultValue = 50,\n  startingValue = 0,\n  maxValue = 100,\n  className = '',\n  isStepped = false,\n  stepSize = 1,\n  leftIcon = <>-</>,\n  rightIcon = <>+</>\n}) => {\n  return (\n    <div className={`flex flex-col items-center justify-center gap-4 w-48 ${className}`}>\n      <Slider\n        defaultValue={defaultValue}\n        startingValue={startingValue}\n        maxValue={maxValue}\n        isStepped={isStepped}\n        stepSize={stepSize}\n        leftIcon={leftIcon}\n        rightIcon={rightIcon}\n      />\n    </div>\n  );\n};\n\ninterface SliderProps {\n  defaultValue: number;\n  startingValue: number;\n  maxValue: number;\n  isStepped: boolean;\n  stepSize: number;\n  leftIcon: React.ReactNode;\n  rightIcon: React.ReactNode;\n}\n\nconst Slider: React.FC<SliderProps> = ({\n  defaultValue,\n  startingValue,\n  maxValue,\n  isStepped,\n  stepSize,\n  leftIcon,\n  rightIcon\n}) => {\n  const [value, setValue] = useState<number>(defaultValue);\n  const sliderRef = useRef<HTMLDivElement>(null);\n  const [region, setRegion] = useState<'left' | 'middle' | 'right'>('middle');\n  const clientX = useMotionValue(0);\n  const overflow = useMotionValue(0);\n  const scale = useMotionValue(1);\n\n  useEffect(() => {\n    setValue(defaultValue);\n  }, [defaultValue]);\n\n  useMotionValueEvent(clientX, 'change', (latest: number) => {\n    if (sliderRef.current) {\n      const { left, right } = sliderRef.current.getBoundingClientRect();\n      let newValue: number;\n      if (latest < left) {\n        setRegion('left');\n        newValue = left - latest;\n      } else if (latest > right) {\n        setRegion('right');\n        newValue = latest - right;\n      } else {\n        setRegion('middle');\n        newValue = 0;\n      }\n      overflow.jump(decay(newValue, MAX_OVERFLOW));\n    }\n  });\n\n  const handlePointerMove = (e: React.PointerEvent<HTMLDivElement>) => {\n    if (e.buttons > 0 && sliderRef.current) {\n      const { left, width } = sliderRef.current.getBoundingClientRect();\n      let newValue = startingValue + ((e.clientX - left) / width) * (maxValue - startingValue);\n      if (isStepped) {\n        newValue = Math.round(newValue / stepSize) * stepSize;\n      }\n      newValue = Math.min(Math.max(newValue, startingValue), maxValue);\n      setValue(newValue);\n      clientX.jump(e.clientX);\n    }\n  };\n\n  const handlePointerDown = (e: React.PointerEvent<HTMLDivElement>) => {\n    handlePointerMove(e);\n    e.currentTarget.setPointerCapture(e.pointerId);\n  };\n\n  const handlePointerUp = () => {\n    animate(overflow, 0, { type: 'spring', bounce: 0.5 });\n  };\n\n  const getRangePercentage = (): number => {\n    const totalRange = maxValue - startingValue;\n    if (totalRange === 0) return 0;\n    return ((value - startingValue) / totalRange) * 100;\n  };\n\n  return (\n    <>\n      <motion.div\n        onHoverStart={() => animate(scale, 1.2)}\n        onHoverEnd={() => animate(scale, 1)}\n        onTouchStart={() => animate(scale, 1.2)}\n        onTouchEnd={() => animate(scale, 1)}\n        style={{\n          scale,\n          opacity: useTransform(scale, [1, 1.2], [0.7, 1])\n        }}\n        className=\"flex w-full touch-none select-none items-center justify-center gap-4\"\n      >\n        <motion.div\n          animate={{\n            scale: region === 'left' ? [1, 1.4, 1] : 1,\n            transition: { duration: 0.25 }\n          }}\n          style={{\n            x: useTransform(() => (region === 'left' ? -overflow.get() / scale.get() : 0))\n          }}\n        >\n          {leftIcon}\n        </motion.div>\n\n        <div\n          ref={sliderRef}\n          className=\"relative flex w-full max-w-xs flex-grow cursor-grab touch-none select-none items-center py-4\"\n          onPointerMove={handlePointerMove}\n          onPointerDown={handlePointerDown}\n          onPointerUp={handlePointerUp}\n        >\n          <motion.div\n            style={{\n              scaleX: useTransform(() => {\n                if (sliderRef.current) {\n                  const { width } = sliderRef.current.getBoundingClientRect();\n                  return 1 + overflow.get() / width;\n                }\n                return 1;\n              }),\n              scaleY: useTransform(overflow, [0, MAX_OVERFLOW], [1, 0.8]),\n              transformOrigin: useTransform(() => {\n                if (sliderRef.current) {\n                  const { left, width } = sliderRef.current.getBoundingClientRect();\n                  return clientX.get() < left + width / 2 ? 'right' : 'left';\n                }\n                return 'center';\n              }),\n              height: useTransform(scale, [1, 1.2], [6, 12]),\n              marginTop: useTransform(scale, [1, 1.2], [0, -3]),\n              marginBottom: useTransform(scale, [1, 1.2], [0, -3])\n            }}\n            className=\"flex flex-grow\"\n          >\n            <div className=\"relative h-full flex-grow overflow-hidden rounded-full bg-gray-400\">\n              <div className=\"absolute h-full bg-gray-500 rounded-full\" style={{ width: `${getRangePercentage()}%` }} />\n            </div>\n          </motion.div>\n        </div>\n\n        <motion.div\n          animate={{\n            scale: region === 'right' ? [1, 1.4, 1] : 1,\n            transition: { duration: 0.25 }\n          }}\n          style={{\n            x: useTransform(() => (region === 'right' ? overflow.get() / scale.get() : 0))\n          }}\n        >\n          {rightIcon}\n        </motion.div>\n      </motion.div>\n      <p className=\"absolute text-gray-400 transform -translate-y-4 text-xs font-medium tracking-wide\">\n        {Math.round(value)}\n      </p>\n    </>\n  );\n};\n\nfunction decay(value: number, max: number): number {\n  if (max === 0) {\n    return 0;\n  }\n  const entry = value / max;\n  const sigmoid = 2 * (1 / (1 + Math.exp(-entry)) - 0.5);\n  return sigmoid * max;\n}\n\nexport default ElasticSlider;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "flowing-menu",
      "type": "component",
      "description": "A layouts flowing menu component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/flowing-menu.tsx",
          "content": "import React, { useRef, useEffect, useState } from 'react';\nimport { gsap } from 'gsap';\n\ninterface MenuItemData {\n  link: string;\n  text: string;\n  image: string;\n}\n\ninterface FlowingMenuProps {\n  items?: MenuItemData[];\n  speed?: number;\n  textColor?: string;\n  bgColor?: string;\n  marqueeBgColor?: string;\n  marqueeTextColor?: string;\n  borderColor?: string;\n}\n\ninterface MenuItemProps extends MenuItemData {\n  speed: number;\n  textColor: string;\n  marqueeBgColor: string;\n  marqueeTextColor: string;\n  borderColor: string;\n  isFirst: boolean;\n}\n\nconst FlowingMenu: React.FC<FlowingMenuProps> = ({\n  items = [],\n  speed = 15,\n  textColor = '#fff',\n  bgColor = '#060010',\n  marqueeBgColor = '#fff',\n  marqueeTextColor = '#060010',\n  borderColor = '#fff'\n}) => {\n  return (\n    <div className=\"w-full h-full overflow-hidden\" style={{ backgroundColor: bgColor }}>\n      <nav className=\"flex flex-col h-full m-0 p-0\">\n        {items.map((item, idx) => (\n          <MenuItem\n            key={idx}\n            {...item}\n            speed={speed}\n            textColor={textColor}\n            marqueeBgColor={marqueeBgColor}\n            marqueeTextColor={marqueeTextColor}\n            borderColor={borderColor}\n            isFirst={idx === 0}\n          />\n        ))}\n      </nav>\n    </div>\n  );\n};\n\nconst MenuItem: React.FC<MenuItemProps> = ({\n  link,\n  text,\n  image,\n  speed,\n  textColor,\n  marqueeBgColor,\n  marqueeTextColor,\n  borderColor,\n  isFirst\n}) => {\n  const itemRef = useRef<HTMLDivElement>(null);\n  const marqueeRef = useRef<HTMLDivElement>(null);\n  const marqueeInnerRef = useRef<HTMLDivElement>(null);\n  const animationRef = useRef<gsap.core.Tween | null>(null);\n  const [repetitions, setRepetitions] = useState(4);\n\n  const animationDefaults = { duration: 0.6, ease: 'expo' };\n\n  const findClosestEdge = (mouseX: number, mouseY: number, width: number, height: number): 'top' | 'bottom' => {\n    const topEdgeDist = Math.pow(mouseX - width / 2, 2) + Math.pow(mouseY, 2);\n    const bottomEdgeDist = Math.pow(mouseX - width / 2, 2) + Math.pow(mouseY - height, 2);\n    return topEdgeDist < bottomEdgeDist ? 'top' : 'bottom';\n  };\n\n  useEffect(() => {\n    const calculateRepetitions = () => {\n      if (!marqueeInnerRef.current) return;\n      const marqueeContent = marqueeInnerRef.current.querySelector('.marquee-part') as HTMLElement;\n      if (!marqueeContent) return;\n      const contentWidth = marqueeContent.offsetWidth;\n      const viewportWidth = window.innerWidth;\n      const needed = Math.ceil(viewportWidth / contentWidth) + 2;\n      setRepetitions(Math.max(4, needed));\n    };\n\n    calculateRepetitions();\n    window.addEventListener('resize', calculateRepetitions);\n    return () => window.removeEventListener('resize', calculateRepetitions);\n  }, [text, image]);\n\n  useEffect(() => {\n    const setupMarquee = () => {\n      if (!marqueeInnerRef.current) return;\n      const marqueeContent = marqueeInnerRef.current.querySelector('.marquee-part') as HTMLElement;\n      if (!marqueeContent) return;\n      const contentWidth = marqueeContent.offsetWidth;\n      if (contentWidth === 0) return;\n\n      if (animationRef.current) {\n        animationRef.current.kill();\n      }\n\n      animationRef.current = gsap.to(marqueeInnerRef.current, {\n        x: -contentWidth,\n        duration: speed,\n        ease: 'none',\n        repeat: -1\n      });\n    };\n\n    const timer = setTimeout(setupMarquee, 50);\n    return () => {\n      clearTimeout(timer);\n      if (animationRef.current) {\n        animationRef.current.kill();\n      }\n    };\n  }, [text, image, repetitions, speed]);\n\n  const handleMouseEnter = (ev: React.MouseEvent<HTMLAnchorElement>) => {\n    if (!itemRef.current || !marqueeRef.current || !marqueeInnerRef.current) return;\n    const rect = itemRef.current.getBoundingClientRect();\n    const edge = findClosestEdge(ev.clientX - rect.left, ev.clientY - rect.top, rect.width, rect.height);\n\n    gsap\n      .timeline({ defaults: animationDefaults })\n      .set(marqueeRef.current, { y: edge === 'top' ? '-101%' : '101%' }, 0)\n      .set(marqueeInnerRef.current, { y: edge === 'top' ? '101%' : '-101%' }, 0)\n      .to([marqueeRef.current, marqueeInnerRef.current], { y: '0%' }, 0);\n  };\n\n  const handleMouseLeave = (ev: React.MouseEvent<HTMLAnchorElement>) => {\n    if (!itemRef.current || !marqueeRef.current || !marqueeInnerRef.current) return;\n    const rect = itemRef.current.getBoundingClientRect();\n    const edge = findClosestEdge(ev.clientX - rect.left, ev.clientY - rect.top, rect.width, rect.height);\n\n    gsap\n      .timeline({ defaults: animationDefaults })\n      .to(marqueeRef.current, { y: edge === 'top' ? '-101%' : '101%' }, 0)\n      .to(marqueeInnerRef.current, { y: edge === 'top' ? '101%' : '-101%' }, 0);\n  };\n\n  return (\n    <div\n      className=\"flex-1 relative overflow-hidden text-center\"\n      ref={itemRef}\n      style={{ borderTop: isFirst ? 'none' : `1px solid ${borderColor}` }}\n    >\n      <a\n        className=\"flex items-center justify-center h-full relative cursor-pointer uppercase no-underline font-semibold text-[4vh]\"\n        href={link}\n        onMouseEnter={handleMouseEnter}\n        onMouseLeave={handleMouseLeave}\n        style={{ color: textColor }}\n      >\n        {text}\n      </a>\n      <div\n        className=\"absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none translate-y-[101%]\"\n        ref={marqueeRef}\n        style={{ backgroundColor: marqueeBgColor }}\n      >\n        <div className=\"h-full w-fit flex\" ref={marqueeInnerRef}>\n          {[...Array(repetitions)].map((_, idx) => (\n            <div className=\"marquee-part flex items-center flex-shrink-0\" key={idx} style={{ color: marqueeTextColor }}>\n              <span className=\"whitespace-nowrap uppercase font-normal text-[4vh] leading-[1] px-[1vw]\">{text}</span>\n              <div\n                className=\"w-[200px] h-[7vh] my-[2em] mx-[2vw] py-[1em] rounded-[50px] bg-cover bg-center\"\n                style={{ backgroundImage: `url(${image})` }}\n              />\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default FlowingMenu;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "fluid-glass",
      "type": "component",
      "description": "A layouts fluid glass component",
      "category": "layouts",
      "dependencies": [
        "three",
        "@react-three/fiber",
        "@react-three/drei",
        "maath"
      ],
      "files": [
        {
          "path": "components/ui/fluid-glass.tsx",
          "content": "/* eslint-disable react/no-unknown-property */\nimport * as THREE from 'three';\nimport { useRef, useState, useEffect, memo, ReactNode } from 'react';\nimport { Canvas, createPortal, useFrame, useThree, ThreeElements } from '@react-three/fiber';\nimport {\n  useFBO,\n  useGLTF,\n  useScroll,\n  Image,\n  Scroll,\n  Preload,\n  ScrollControls,\n  MeshTransmissionMaterial,\n  Text\n} from '@react-three/drei';\nimport { easing } from 'maath';\n\ntype Mode = 'lens' | 'bar' | 'cube';\n\ninterface NavItem {\n  label: string;\n  link: string;\n}\n\ntype ModeProps = Record<string, unknown>;\n\ninterface FluidGlassProps {\n  mode?: Mode;\n  lensProps?: ModeProps;\n  barProps?: ModeProps;\n  cubeProps?: ModeProps;\n}\n\nexport default function FluidGlass({ mode = 'lens', lensProps = {}, barProps = {}, cubeProps = {} }: FluidGlassProps) {\n  const Wrapper = mode === 'bar' ? Bar : mode === 'cube' ? Cube : Lens;\n  const rawOverrides = mode === 'bar' ? barProps : mode === 'cube' ? cubeProps : lensProps;\n\n  const {\n    navItems = [\n      { label: 'Home', link: '' },\n      { label: 'About', link: '' },\n      { label: 'Contact', link: '' }\n    ],\n    ...modeProps\n  } = rawOverrides;\n\n  return (\n    <Canvas camera={{ position: [0, 0, 20], fov: 15 }} gl={{ alpha: true }}>\n      <ScrollControls damping={0.2} pages={3} distance={0.4}>\n        {mode === 'bar' && <NavItems items={navItems as NavItem[]} />}\n        <Wrapper modeProps={modeProps}>\n          <Scroll>\n            <Typography />\n            <Images />\n          </Scroll>\n          <Scroll html />\n          <Preload />\n        </Wrapper>\n      </ScrollControls>\n    </Canvas>\n  );\n}\n\ntype MeshProps = ThreeElements['mesh'];\n\ninterface ModeWrapperProps extends MeshProps {\n  children?: ReactNode;\n  glb: string;\n  geometryKey: string;\n  lockToBottom?: boolean;\n  followPointer?: boolean;\n  modeProps?: ModeProps;\n}\n\ninterface ZoomMaterial extends THREE.Material {\n  zoom: number;\n}\n\ninterface ZoomMesh extends THREE.Mesh<THREE.BufferGeometry, ZoomMaterial> {}\n\ntype ZoomGroup = THREE.Group & { children: ZoomMesh[] };\n\nconst ModeWrapper = memo(function ModeWrapper({\n  children,\n  glb,\n  geometryKey,\n  lockToBottom = false,\n  followPointer = true,\n  modeProps = {},\n  ...props\n}: ModeWrapperProps) {\n  const ref = useRef<THREE.Mesh>(null!);\n  const { nodes } = useGLTF(glb);\n  const buffer = useFBO();\n  const { viewport: vp } = useThree();\n  const [scene] = useState<THREE.Scene>(() => new THREE.Scene());\n  const geoWidthRef = useRef<number>(1);\n\n  useEffect(() => {\n    const geo = (nodes[geometryKey] as THREE.Mesh)?.geometry;\n    geo.computeBoundingBox();\n    geoWidthRef.current = geo.boundingBox!.max.x - geo.boundingBox!.min.x || 1;\n  }, [nodes, geometryKey]);\n\n  useFrame((state, delta) => {\n    const { gl, viewport, pointer, camera } = state;\n    const v = viewport.getCurrentViewport(camera, [0, 0, 15]);\n\n    const destX = followPointer ? (pointer.x * v.width) / 2 : 0;\n    const destY = lockToBottom ? -v.height / 2 + 0.2 : followPointer ? (pointer.y * v.height) / 2 : 0;\n    easing.damp3(ref.current.position, [destX, destY, 15], 0.15, delta);\n\n    if ((modeProps as { scale?: number }).scale == null) {\n      const maxWorld = v.width * 0.9;\n      const desired = maxWorld / geoWidthRef.current;\n      ref.current.scale.setScalar(Math.min(0.15, desired));\n    }\n\n    gl.setRenderTarget(buffer);\n    gl.render(scene, camera);\n    gl.setRenderTarget(null);\n    gl.setClearColor(0x5227ff, 1);\n  });\n\n  const { scale, ior, thickness, anisotropy, chromaticAberration, ...extraMat } = modeProps as {\n    scale?: number;\n    ior?: number;\n    thickness?: number;\n    anisotropy?: number;\n    chromaticAberration?: number;\n    [key: string]: unknown;\n  };\n\n  return (\n    <>\n      {createPortal(children, scene)}\n      <mesh scale={[vp.width, vp.height, 1]}>\n        <planeGeometry />\n        <meshBasicMaterial map={buffer.texture} transparent />\n      </mesh>\n      <mesh\n        ref={ref}\n        scale={scale ?? 0.15}\n        rotation-x={Math.PI / 2}\n        geometry={(nodes[geometryKey] as THREE.Mesh)?.geometry}\n        {...props}\n      >\n        <MeshTransmissionMaterial\n          buffer={buffer.texture}\n          ior={ior ?? 1.15}\n          thickness={thickness ?? 5}\n          anisotropy={anisotropy ?? 0.01}\n          chromaticAberration={chromaticAberration ?? 0.1}\n          {...(typeof extraMat === 'object' && extraMat !== null ? extraMat : {})}\n        />\n      </mesh>\n    </>\n  );\n});\n\nfunction Lens({ modeProps, ...p }: { modeProps?: ModeProps } & MeshProps) {\n  return <ModeWrapper glb=\"/assets/3d/lens.glb\" geometryKey=\"Cylinder\" followPointer modeProps={modeProps} {...p} />;\n}\n\nfunction Cube({ modeProps, ...p }: { modeProps?: ModeProps } & MeshProps) {\n  return <ModeWrapper glb=\"/assets/3d/cube.glb\" geometryKey=\"Cube\" followPointer modeProps={modeProps} {...p} />;\n}\n\nfunction Bar({ modeProps = {}, ...p }: { modeProps?: ModeProps } & MeshProps) {\n  const defaultMat = {\n    transmission: 1,\n    roughness: 0,\n    thickness: 10,\n    ior: 1.15,\n    color: '#ffffff',\n    attenuationColor: '#ffffff',\n    attenuationDistance: 0.25\n  };\n\n  return (\n    <ModeWrapper\n      glb=\"/assets/3d/bar.glb\"\n      geometryKey=\"Cube\"\n      lockToBottom\n      followPointer={false}\n      modeProps={{ ...defaultMat, ...modeProps }}\n      {...p}\n    />\n  );\n}\n\nfunction NavItems({ items }: { items: NavItem[] }) {\n  const group = useRef<THREE.Group>(null!);\n  const { viewport, camera } = useThree();\n\n  const DEVICE = {\n    mobile: { max: 639, spacing: 0.2, fontSize: 0.035 },\n    tablet: { max: 1023, spacing: 0.24, fontSize: 0.045 },\n    desktop: { max: Infinity, spacing: 0.3, fontSize: 0.045 }\n  };\n  const getDevice = () => {\n    const w = window.innerWidth;\n    return w <= DEVICE.mobile.max ? 'mobile' : w <= DEVICE.tablet.max ? 'tablet' : 'desktop';\n  };\n\n  const [device, setDevice] = useState<keyof typeof DEVICE>(getDevice());\n\n  useEffect(() => {\n    const onResize = () => setDevice(getDevice());\n    window.addEventListener('resize', onResize);\n    return () => window.removeEventListener('resize', onResize);\n  }, []);\n\n  const { spacing, fontSize } = DEVICE[device];\n\n  useFrame(() => {\n    if (!group.current) return;\n    const v = viewport.getCurrentViewport(camera, [0, 0, 15]);\n    group.current.position.set(0, -v.height / 2 + 0.2, 15.1);\n\n    group.current.children.forEach((child, i) => {\n      child.position.x = (i - (items.length - 1) / 2) * spacing;\n    });\n  });\n\n  const handleNavigate = (link: string) => {\n    if (!link) return;\n    link.startsWith('#') ? (window.location.hash = link) : (window.location.href = link);\n  };\n\n  return (\n    <group ref={group} renderOrder={10}>\n      {items.map(({ label, link }) => (\n        <Text\n          key={label}\n          fontSize={fontSize}\n          color=\"white\"\n          anchorX=\"center\"\n          anchorY=\"middle\"\n          outlineWidth={0}\n          outlineBlur=\"20%\"\n          outlineColor=\"#000\"\n          outlineOpacity={0.5}\n          renderOrder={10}\n          onClick={e => {\n            e.stopPropagation();\n            handleNavigate(link);\n          }}\n          onPointerOver={() => (document.body.style.cursor = 'pointer')}\n          onPointerOut={() => (document.body.style.cursor = 'auto')}\n        >\n          {label}\n        </Text>\n      ))}\n    </group>\n  );\n}\n\nfunction Images() {\n  const group = useRef<ZoomGroup>(null!);\n  const data = useScroll();\n  const { height } = useThree(s => s.viewport);\n\n  useFrame(() => {\n    group.current.children[0].material.zoom = 1 + data.range(0, 1 / 3) / 3;\n    group.current.children[1].material.zoom = 1 + data.range(0, 1 / 3) / 3;\n    group.current.children[2].material.zoom = 1 + data.range(1.15 / 3, 1 / 3) / 2;\n    group.current.children[3].material.zoom = 1 + data.range(1.15 / 3, 1 / 3) / 2;\n    group.current.children[4].material.zoom = 1 + data.range(1.15 / 3, 1 / 3) / 2;\n  });\n\n  return (\n    <group ref={group}>\n      <Image position={[-2, 0, 0]} scale={[3, height / 1.1]} url=\"/assets/demo/cs1.webp\" />\n      <Image position={[2, 0, 3]} scale={3} url=\"/assets/demo/cs2.webp\" />\n      <Image position={[-2.05, -height, 6]} scale={[1, 3]} url=\"/assets/demo/cs3.webp\" />\n      <Image position={[-0.6, -height, 9]} scale={[1, 2]} url=\"/assets/demo/cs1.webp\" />\n      <Image position={[0.75, -height, 10.5]} scale={1.5} url=\"/assets/demo/cs2.webp\" />\n    </group>\n  );\n}\n\nfunction Typography() {\n  const DEVICE = {\n    mobile: { fontSize: 0.2 },\n    tablet: { fontSize: 0.4 },\n    desktop: { fontSize: 0.6 }\n  };\n  const getDevice = () => {\n    const w = window.innerWidth;\n    return w <= 639 ? 'mobile' : w <= 1023 ? 'tablet' : 'desktop';\n  };\n\n  const [device, setDevice] = useState<keyof typeof DEVICE>(getDevice());\n\n  useEffect(() => {\n    const onResize = () => setDevice(getDevice());\n    window.addEventListener('resize', onResize);\n    return () => window.removeEventListener('resize', onResize);\n  }, []);\n\n  const { fontSize } = DEVICE[device];\n\n  return (\n    <Text\n      position={[0, 0, 12]}\n      fontSize={fontSize}\n      letterSpacing={-0.05}\n      outlineWidth={0}\n      outlineBlur=\"20%\"\n      outlineColor=\"#000\"\n      outlineOpacity={0.5}\n      color=\"white\"\n      anchorX=\"center\"\n      anchorY=\"middle\"\n    >\n      React Bits\n    </Text>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "flying-posters",
      "type": "component",
      "description": "A layouts flying posters component",
      "category": "layouts",
      "dependencies": [
        "ogl"
      ],
      "files": [
        {
          "path": "components/ui/flying-posters.tsx",
          "content": "import { useRef, useEffect } from 'react';\nimport { Renderer, Camera, Transform, Plane, Program, Mesh, Texture, type OGLRenderingContext } from 'ogl';\n\ntype GL = OGLRenderingContext;\ntype OGLProgram = Program;\ntype OGLMesh = Mesh;\ntype OGLTransform = Transform;\ntype OGLPlane = Plane;\n\ninterface ScreenSize {\n  width: number;\n  height: number;\n}\n\ninterface ViewportSize {\n  width: number;\n  height: number;\n}\n\ninterface ScrollState {\n  position?: number;\n  ease: number;\n  current: number;\n  target: number;\n  last: number;\n}\n\ninterface AutoBindOptions {\n  include?: Array<string | RegExp>;\n  exclude?: Array<string | RegExp>;\n}\n\ninterface MediaParams {\n  gl: GL;\n  geometry: OGLPlane;\n  scene: OGLTransform;\n  screen: ScreenSize;\n  viewport: ViewportSize;\n  image: string;\n  length: number;\n  index: number;\n  planeWidth: number;\n  planeHeight: number;\n  distortion: number;\n}\n\ninterface CanvasParams {\n  container: HTMLElement;\n  canvas: HTMLCanvasElement;\n  items: string[];\n  planeWidth: number;\n  planeHeight: number;\n  distortion: number;\n  scrollEase: number;\n  cameraFov: number;\n  cameraZ: number;\n}\n\nconst vertexShader = `\nprecision highp float;\n\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nuniform float uPosition;\nuniform float uTime;\nuniform float uSpeed;\nuniform vec3 distortionAxis;\nuniform vec3 rotationAxis;\nuniform float uDistortion;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nfloat PI = 3.141592653589793238;\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(\n      oc * axis.x * axis.x + c,         oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n      oc * axis.x * axis.y + axis.z * s,oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n      oc * axis.z * axis.x - axis.y * s,oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n      0.0,                              0.0,                                0.0,                                1.0\n    );\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n  mat4 m = rotationMatrix(axis, angle);\n  return (m * vec4(v, 1.0)).xyz;\n}\n\nfloat qinticInOut(float t) {\n  return t < 0.5\n    ? 16.0 * pow(t, 5.0)\n    : -0.5 * abs(pow(2.0 * t - 2.0, 5.0)) + 1.0;\n}\n\nvoid main() {\n  vUv = uv;\n  \n  float norm = 0.5;\n  vec3 newpos = position;\n  float offset = (dot(distortionAxis, position) + norm / 2.) / norm;\n  float localprogress = clamp(\n    (fract(uPosition * 5.0 * 0.01) - 0.01 * uDistortion * offset) / (1. - 0.01 * uDistortion),\n    0.,\n    2.\n  );\n  localprogress = qinticInOut(localprogress) * PI;\n  newpos = rotate(newpos, rotationAxis, localprogress);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newpos, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\nuniform vec2 uImageSize;\nuniform vec2 uPlaneSize;\nuniform sampler2D tMap;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 imageSize = uImageSize;\n  vec2 planeSize = uPlaneSize;\n\n  float imageAspect = imageSize.x / imageSize.y;\n  float planeAspect = planeSize.x / planeSize.y;\n  vec2 scale = vec2(1.0, 1.0);\n\n  if (planeAspect > imageAspect) {\n      scale.x = imageAspect / planeAspect;\n  } else {\n      scale.y = planeAspect / imageAspect;\n  }\n\n  vec2 uv = vUv * scale + (1.0 - scale) * 0.5;\n\n  gl_FragColor = texture2D(tMap, uv);\n}\n`;\n\nfunction AutoBind(self: any, { include, exclude }: AutoBindOptions = {}) {\n  const getAllProperties = (object: any): Set<[any, string | symbol]> => {\n    const properties = new Set<[any, string | symbol]>();\n    do {\n      for (const key of Reflect.ownKeys(object)) {\n        properties.add([object, key]);\n      }\n    } while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);\n    return properties;\n  };\n\n  const filter = (key: string | symbol) => {\n    const match = (pattern: string | RegExp) =>\n      typeof pattern === 'string' ? key === pattern : (pattern as RegExp).test(key.toString());\n\n    if (include) return include.some(match);\n    if (exclude) return !exclude.some(match);\n    return true;\n  };\n\n  for (const [object, key] of getAllProperties(self.constructor.prototype)) {\n    if (key === 'constructor' || !filter(key)) continue;\n    const descriptor = Reflect.getOwnPropertyDescriptor(object, key);\n    if (descriptor && typeof descriptor.value === 'function') {\n      self[key] = self[key].bind(self);\n    }\n  }\n  return self;\n}\n\nfunction lerp(p1: number, p2: number, t: number): number {\n  return p1 + (p2 - p1) * t;\n}\n\nfunction map(num: number, min1: number, max1: number, min2: number, max2: number, round = false): number {\n  const num1 = (num - min1) / (max1 - min1);\n  const num2 = num1 * (max2 - min2) + min2;\n  return round ? Math.round(num2) : num2;\n}\n\nclass Media {\n  gl: GL;\n  geometry: OGLPlane;\n  scene: OGLTransform;\n  screen: ScreenSize;\n  viewport: ViewportSize;\n  image: string;\n  length: number;\n  index: number;\n  planeWidth: number;\n  planeHeight: number;\n  distortion: number;\n\n  program!: OGLProgram;\n  plane!: OGLMesh;\n  extra = 0;\n  padding = 0;\n  height = 0;\n  heightTotal = 0;\n  y = 0;\n\n  constructor({\n    gl,\n    geometry,\n    scene,\n    screen,\n    viewport,\n    image,\n    length,\n    index,\n    planeWidth,\n    planeHeight,\n    distortion\n  }: MediaParams) {\n    this.gl = gl;\n    this.geometry = geometry;\n    this.scene = scene;\n    this.screen = screen;\n    this.viewport = viewport;\n    this.image = image;\n    this.length = length;\n    this.index = index;\n    this.planeWidth = planeWidth;\n    this.planeHeight = planeHeight;\n    this.distortion = distortion;\n\n    this.createShader();\n    this.createMesh();\n    this.onResize();\n  }\n\n  createShader() {\n    const texture = new Texture(this.gl, { generateMipmaps: false });\n    this.program = new Program(this.gl, {\n      depthTest: false,\n      depthWrite: false,\n      fragment: fragmentShader,\n      vertex: vertexShader,\n      uniforms: {\n        tMap: { value: texture },\n        uPosition: { value: 0 },\n        uPlaneSize: { value: [0, 0] },\n        uImageSize: { value: [0, 0] },\n        uSpeed: { value: 0 },\n        rotationAxis: { value: [0, 1, 0] },\n        distortionAxis: { value: [1, 1, 0] },\n        uDistortion: { value: this.distortion },\n        uViewportSize: { value: [this.viewport.width, this.viewport.height] },\n        uTime: { value: 0 }\n      },\n      cullFace: false\n    });\n\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.src = this.image;\n    img.onload = () => {\n      texture.image = img;\n      this.program.uniforms.uImageSize.value = [img.naturalWidth, img.naturalHeight];\n    };\n  }\n\n  createMesh() {\n    this.plane = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program: this.program\n    });\n    this.plane.setParent(this.scene);\n  }\n\n  setScale() {\n    this.plane.scale.x = (this.viewport.width * this.planeWidth) / this.screen.width;\n    this.plane.scale.y = (this.viewport.height * this.planeHeight) / this.screen.height;\n    this.plane.position.x = 0;\n    this.program.uniforms.uPlaneSize.value = [this.plane.scale.x, this.plane.scale.y];\n  }\n\n  onResize({ screen, viewport }: { screen?: ScreenSize; viewport?: ViewportSize } = {}) {\n    if (screen) this.screen = screen;\n    if (viewport) {\n      this.viewport = viewport;\n      this.program.uniforms.uViewportSize.value = [viewport.width, viewport.height];\n    }\n    this.setScale();\n\n    this.padding = 5;\n    this.height = this.plane.scale.y + this.padding;\n    this.heightTotal = this.height * this.length;\n    this.y = -this.heightTotal / 2 + (this.index + 0.5) * this.height;\n  }\n\n  update(scroll: ScrollState) {\n    this.plane.position.y = this.y - scroll.current - this.extra;\n    const position = map(this.plane.position.y, -this.viewport.height, this.viewport.height, 5, 15);\n\n    this.program.uniforms.uPosition.value = position;\n    this.program.uniforms.uTime.value += 0.04;\n    this.program.uniforms.uSpeed.value = scroll.current;\n\n    const planeHeight = this.plane.scale.y;\n    const viewportHeight = this.viewport.height;\n    const topEdge = this.plane.position.y + planeHeight / 2;\n    const bottomEdge = this.plane.position.y - planeHeight / 2;\n\n    if (topEdge < -viewportHeight / 2) {\n      this.extra -= this.heightTotal;\n    } else if (bottomEdge > viewportHeight / 2) {\n      this.extra += this.heightTotal;\n    }\n  }\n}\n\nclass Canvas {\n  container: HTMLElement;\n  canvas: HTMLCanvasElement;\n  items: string[];\n  planeWidth: number;\n  planeHeight: number;\n  distortion: number;\n  scroll: ScrollState;\n  cameraFov: number;\n  cameraZ: number;\n\n  renderer!: Renderer;\n  gl!: GL;\n  camera!: Camera;\n  scene!: OGLTransform;\n  planeGeometry!: OGLPlane;\n  medias!: Media[];\n  screen!: ScreenSize;\n  viewport!: ViewportSize;\n  isDown = false;\n  start = 0;\n  loaded = 0;\n\n  constructor({\n    container,\n    canvas,\n    items,\n    planeWidth,\n    planeHeight,\n    distortion,\n    scrollEase,\n    cameraFov,\n    cameraZ\n  }: CanvasParams) {\n    this.container = container;\n    this.canvas = canvas;\n    this.items = items;\n    this.planeWidth = planeWidth;\n    this.planeHeight = planeHeight;\n    this.distortion = distortion;\n    this.scroll = {\n      ease: scrollEase,\n      current: 0,\n      target: 0,\n      last: 0\n    };\n    this.cameraFov = cameraFov;\n    this.cameraZ = cameraZ;\n\n    AutoBind(this);\n    this.createRenderer();\n    this.createCamera();\n    this.createScene();\n    this.onResize();\n    this.createGeometry();\n    this.createMedias();\n    this.update();\n    this.addEventListeners();\n    this.createPreloader();\n  }\n\n  createRenderer() {\n    this.renderer = new Renderer({\n      canvas: this.canvas,\n      alpha: true,\n      antialias: true,\n      dpr: Math.min(window.devicePixelRatio, 2)\n    });\n    this.gl = this.renderer.gl;\n  }\n\n  createCamera() {\n    this.camera = new Camera(this.gl);\n    this.camera.fov = this.cameraFov;\n    this.camera.position.z = this.cameraZ;\n  }\n\n  createScene() {\n    this.scene = new Transform();\n  }\n\n  createGeometry() {\n    this.planeGeometry = new Plane(this.gl, {\n      heightSegments: 1,\n      widthSegments: 100\n    });\n  }\n\n  createMedias() {\n    this.medias = this.items.map(\n      (image, index) =>\n        new Media({\n          gl: this.gl,\n          geometry: this.planeGeometry,\n          scene: this.scene,\n          screen: this.screen,\n          viewport: this.viewport,\n          image,\n          length: this.items.length,\n          index,\n          planeWidth: this.planeWidth,\n          planeHeight: this.planeHeight,\n          distortion: this.distortion\n        })\n    );\n  }\n\n  createPreloader() {\n    this.loaded = 0;\n    this.items.forEach(src => {\n      const image = new Image();\n      image.crossOrigin = 'anonymous';\n      image.src = src;\n      image.onload = () => {\n        if (++this.loaded === this.items.length) {\n          document.documentElement.classList.remove('loading');\n          document.documentElement.classList.add('loaded');\n        }\n      };\n    });\n  }\n\n  onResize() {\n    const rect = this.container.getBoundingClientRect();\n    this.screen = { width: rect.width, height: rect.height };\n    this.renderer.setSize(this.screen.width, this.screen.height);\n\n    this.camera.perspective({\n      aspect: this.gl.canvas.width / this.gl.canvas.height\n    });\n\n    const fov = (this.camera.fov * Math.PI) / 180;\n    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;\n    const width = height * this.camera.aspect;\n    this.viewport = { width, height };\n\n    this.medias?.forEach(media => media.onResize({ screen: this.screen, viewport: this.viewport }));\n  }\n\n  onTouchDown(e: MouseEvent | TouchEvent) {\n    this.isDown = true;\n    this.scroll.position = this.scroll.current;\n    this.start = e instanceof TouchEvent ? e.touches[0].clientY : e.clientY;\n  }\n\n  onTouchMove(e: MouseEvent | TouchEvent) {\n    if (!this.isDown || !this.scroll.position) return;\n    const y = e instanceof TouchEvent ? e.touches[0].clientY : e.clientY;\n    const distance = (this.start - y) * 0.1;\n    this.scroll.target = this.scroll.position + distance;\n  }\n\n  onTouchUp() {\n    this.isDown = false;\n  }\n\n  onWheel(e: WheelEvent) {\n    this.scroll.target += e.deltaY * 0.005;\n  }\n\n  update() {\n    this.scroll.current = lerp(this.scroll.current, this.scroll.target, this.scroll.ease);\n    this.medias?.forEach(media => media.update(this.scroll));\n    this.renderer.render({ scene: this.scene, camera: this.camera });\n    this.scroll.last = this.scroll.current;\n    requestAnimationFrame(this.update);\n  }\n\n  addEventListeners() {\n    window.addEventListener('resize', this.onResize);\n    window.addEventListener('wheel', this.onWheel);\n    window.addEventListener('mousedown', this.onTouchDown);\n    window.addEventListener('mousemove', this.onTouchMove);\n    window.addEventListener('mouseup', this.onTouchUp);\n    window.addEventListener('touchstart', this.onTouchDown as EventListener);\n    window.addEventListener('touchmove', this.onTouchMove as EventListener);\n    window.addEventListener('touchend', this.onTouchUp as EventListener);\n  }\n\n  destroy() {\n    window.removeEventListener('resize', this.onResize);\n    window.removeEventListener('wheel', this.onWheel);\n    window.removeEventListener('mousedown', this.onTouchDown);\n    window.removeEventListener('mousemove', this.onTouchMove);\n    window.removeEventListener('mouseup', this.onTouchUp);\n    window.removeEventListener('touchstart', this.onTouchDown as EventListener);\n    window.removeEventListener('touchmove', this.onTouchMove as EventListener);\n    window.removeEventListener('touchend', this.onTouchUp as EventListener);\n  }\n}\n\ninterface FlyingPostersProps extends React.HTMLAttributes<HTMLDivElement> {\n  items?: string[];\n  planeWidth?: number;\n  planeHeight?: number;\n  distortion?: number;\n  scrollEase?: number;\n  cameraFov?: number;\n  cameraZ?: number;\n}\n\nexport default function FlyingPosters({\n  items = [],\n  planeWidth = 320,\n  planeHeight = 320,\n  distortion = 3,\n  scrollEase = 0.01,\n  cameraFov = 45,\n  cameraZ = 20,\n  className,\n  ...props\n}: FlyingPostersProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const instanceRef = useRef<Canvas | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current || !canvasRef.current) return;\n\n    instanceRef.current = new Canvas({\n      container: containerRef.current,\n      canvas: canvasRef.current,\n      items,\n      planeWidth,\n      planeHeight,\n      distortion,\n      scrollEase,\n      cameraFov,\n      cameraZ\n    });\n\n    return () => {\n      instanceRef.current?.destroy();\n      instanceRef.current = null;\n    };\n  }, [items, planeWidth, planeHeight, distortion, scrollEase, cameraFov, cameraZ]);\n\n  useEffect(() => {\n    if (!canvasRef.current) return;\n\n    const canvasEl = canvasRef.current;\n\n    const handleWheel = (e: WheelEvent) => {\n      e.preventDefault();\n      if (instanceRef.current) {\n        instanceRef.current.onWheel(e);\n      }\n    };\n\n    const handleTouchMove = (e: TouchEvent) => {\n      e.preventDefault();\n    };\n\n    canvasEl.addEventListener('wheel', handleWheel, { passive: false });\n    canvasEl.addEventListener('touchmove', handleTouchMove, { passive: false });\n\n    return () => {\n      canvasEl.removeEventListener('wheel', handleWheel);\n      canvasEl.removeEventListener('touchmove', handleTouchMove);\n    };\n  }, []);\n\n  return (\n    <div ref={containerRef} className={`w-full h-full overflow-hidden relative z-2 ${className}`} {...props}>\n      <canvas ref={canvasRef} className=\"block w-full h-full\" />\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "folder",
      "type": "component",
      "description": "A layouts folder component",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/folder.tsx",
          "content": "import React, { useState } from 'react';\n\ninterface FolderProps {\n  color?: string;\n  size?: number;\n  items?: React.ReactNode[];\n  className?: string;\n}\n\nconst darkenColor = (hex: string, percent: number): string => {\n  let color = hex.startsWith('#') ? hex.slice(1) : hex;\n  if (color.length === 3) {\n    color = color\n      .split('')\n      .map(c => c + c)\n      .join('');\n  }\n  const num = parseInt(color, 16);\n  let r = (num >> 16) & 0xff;\n  let g = (num >> 8) & 0xff;\n  let b = num & 0xff;\n  r = Math.max(0, Math.min(255, Math.floor(r * (1 - percent))));\n  g = Math.max(0, Math.min(255, Math.floor(g * (1 - percent))));\n  b = Math.max(0, Math.min(255, Math.floor(b * (1 - percent))));\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();\n};\n\nconst Folder: React.FC<FolderProps> = ({ color = '#5227FF', size = 1, items = [], className = '' }) => {\n  const maxItems = 3;\n  const papers = items.slice(0, maxItems);\n  while (papers.length < maxItems) {\n    papers.push(null);\n  }\n\n  const [open, setOpen] = useState(false);\n  const [paperOffsets, setPaperOffsets] = useState<{ x: number; y: number }[]>(\n    Array.from({ length: maxItems }, () => ({ x: 0, y: 0 }))\n  );\n\n  const folderBackColor = darkenColor(color, 0.08);\n  const paper1 = darkenColor('#ffffff', 0.1);\n  const paper2 = darkenColor('#ffffff', 0.05);\n  const paper3 = '#ffffff';\n\n  const handleClick = () => {\n    setOpen(prev => !prev);\n    if (open) {\n      setPaperOffsets(Array.from({ length: maxItems }, () => ({ x: 0, y: 0 })));\n    }\n  };\n\n  const handlePaperMouseMove = (e: React.MouseEvent<HTMLDivElement, MouseEvent>, index: number) => {\n    if (!open) return;\n    const rect = e.currentTarget.getBoundingClientRect();\n    const centerX = rect.left + rect.width / 2;\n    const centerY = rect.top + rect.height / 2;\n    const offsetX = (e.clientX - centerX) * 0.15;\n    const offsetY = (e.clientY - centerY) * 0.15;\n    setPaperOffsets(prev => {\n      const newOffsets = [...prev];\n      newOffsets[index] = { x: offsetX, y: offsetY };\n      return newOffsets;\n    });\n  };\n\n  const handlePaperMouseLeave = (e: React.MouseEvent<HTMLDivElement, MouseEvent>, index: number) => {\n    setPaperOffsets(prev => {\n      const newOffsets = [...prev];\n      newOffsets[index] = { x: 0, y: 0 };\n      return newOffsets;\n    });\n  };\n\n  const folderStyle: React.CSSProperties = {\n    '--folder-color': color,\n    '--folder-back-color': folderBackColor,\n    '--paper-1': paper1,\n    '--paper-2': paper2,\n    '--paper-3': paper3\n  } as React.CSSProperties;\n\n  const scaleStyle = { transform: `scale(${size})` };\n\n  const getOpenTransform = (index: number) => {\n    if (index === 0) return 'translate(-120%, -70%) rotate(-15deg)';\n    if (index === 1) return 'translate(10%, -70%) rotate(15deg)';\n    if (index === 2) return 'translate(-50%, -100%) rotate(5deg)';\n    return '';\n  };\n\n  return (\n    <div style={scaleStyle} className={className}>\n      <div\n        className={`group relative transition-all duration-200 ease-in cursor-pointer ${\n          !open ? 'hover:-translate-y-2' : ''\n        }`}\n        style={{\n          ...folderStyle,\n          transform: open ? 'translateY(-8px)' : undefined\n        }}\n        onClick={handleClick}\n      >\n        <div\n          className=\"relative w-[100px] h-[80px] rounded-tl-0 rounded-tr-[10px] rounded-br-[10px] rounded-bl-[10px]\"\n          style={{ backgroundColor: folderBackColor }}\n        >\n          <span\n            className=\"absolute z-0 bottom-[98%] left-0 w-[30px] h-[10px] rounded-tl-[5px] rounded-tr-[5px] rounded-bl-0 rounded-br-0\"\n            style={{ backgroundColor: folderBackColor }}\n          ></span>\n          {papers.map((item, i) => {\n            let sizeClasses = '';\n            if (i === 0) sizeClasses = open ? 'w-[70%] h-[80%]' : 'w-[70%] h-[80%]';\n            if (i === 1) sizeClasses = open ? 'w-[80%] h-[80%]' : 'w-[80%] h-[70%]';\n            if (i === 2) sizeClasses = open ? 'w-[90%] h-[80%]' : 'w-[90%] h-[60%]';\n\n            const transformStyle = open\n              ? `${getOpenTransform(i)} translate(${paperOffsets[i].x}px, ${paperOffsets[i].y}px)`\n              : undefined;\n\n            return (\n              <div\n                key={i}\n                onMouseMove={e => handlePaperMouseMove(e, i)}\n                onMouseLeave={e => handlePaperMouseLeave(e, i)}\n                className={`absolute z-20 bottom-[10%] left-1/2 transition-all duration-300 ease-in-out ${\n                  !open ? 'transform -translate-x-1/2 translate-y-[10%] group-hover:translate-y-0' : 'hover:scale-110'\n                } ${sizeClasses}`}\n                style={{\n                  ...(!open ? {} : { transform: transformStyle }),\n                  backgroundColor: i === 0 ? paper1 : i === 1 ? paper2 : paper3,\n                  borderRadius: '10px'\n                }}\n              >\n                {item}\n              </div>\n            );\n          })}\n          <div\n            className={`absolute z-30 w-full h-full origin-bottom transition-all duration-300 ease-in-out ${\n              !open ? 'group-hover:[transform:skew(15deg)_scaleY(0.6)]' : ''\n            }`}\n            style={{\n              backgroundColor: color,\n              borderRadius: '5px 10px 10px 10px',\n              ...(open && { transform: 'skew(15deg) scaleY(0.6)' })\n            }}\n          ></div>\n          <div\n            className={`absolute z-30 w-full h-full origin-bottom transition-all duration-300 ease-in-out ${\n              !open ? 'group-hover:[transform:skew(-15deg)_scaleY(0.6)]' : ''\n            }`}\n            style={{\n              backgroundColor: color,\n              borderRadius: '5px 10px 10px 10px',\n              ...(open && { transform: 'skew(-15deg) scaleY(0.6)' })\n            }}\n          ></div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Folder;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "glass-icons",
      "type": "component",
      "description": "A layouts glass icons component",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/glass-icons.tsx",
          "content": "import React from 'react';\n\nexport interface GlassIconsItem {\n  icon: React.ReactElement;\n  color: string;\n  label: string;\n  customClass?: string;\n}\n\nexport interface GlassIconsProps {\n  items: GlassIconsItem[];\n  className?: string;\n}\n\nconst gradientMapping: Record<string, string> = {\n  blue: 'linear-gradient(hsl(223, 90%, 50%), hsl(208, 90%, 50%))',\n  purple: 'linear-gradient(hsl(283, 90%, 50%), hsl(268, 90%, 50%))',\n  red: 'linear-gradient(hsl(3, 90%, 50%), hsl(348, 90%, 50%))',\n  indigo: 'linear-gradient(hsl(253, 90%, 50%), hsl(238, 90%, 50%))',\n  orange: 'linear-gradient(hsl(43, 90%, 50%), hsl(28, 90%, 50%))',\n  green: 'linear-gradient(hsl(123, 90%, 40%), hsl(108, 90%, 40%))'\n};\n\nconst GlassIcons: React.FC<GlassIconsProps> = ({ items, className }) => {\n  const getBackgroundStyle = (color: string): React.CSSProperties => {\n    if (gradientMapping[color]) {\n      return { background: gradientMapping[color] };\n    }\n    return { background: color };\n  };\n\n  return (\n    <div className={`grid gap-[5em] grid-cols-2 md:grid-cols-3 mx-auto py-[3em] overflow-visible ${className || ''}`}>\n      {items.map((item, index) => (\n        <button\n          key={index}\n          type=\"button\"\n          aria-label={item.label}\n          className={`relative bg-transparent outline-none border-none cursor-pointer w-[4.5em] h-[4.5em] [perspective:24em] [transform-style:preserve-3d] [-webkit-tap-highlight-color:transparent] group ${\n            item.customClass || ''\n          }`}\n        >\n          <span\n            className=\"absolute top-0 left-0 w-full h-full rounded-[1.25em] block transition-[opacity,transform] duration-300 ease-[cubic-bezier(0.83,0,0.17,1)] origin-[100%_100%] rotate-[15deg] [will-change:transform] group-hover:[transform:rotate(25deg)_translate3d(-0.5em,-0.5em,0.5em)]\"\n            style={{\n              ...getBackgroundStyle(item.color),\n              boxShadow: '0.5em -0.5em 0.75em hsla(223, 10%, 10%, 0.15)'\n            }}\n          ></span>\n\n          <span\n            className=\"absolute top-0 left-0 w-full h-full rounded-[1.25em] bg-[hsla(0,0%,100%,0.15)] transition-[opacity,transform] duration-300 ease-[cubic-bezier(0.83,0,0.17,1)] origin-[80%_50%] flex backdrop-blur-[0.75em] [-webkit-backdrop-filter:blur(0.75em)] [-moz-backdrop-filter:blur(0.75em)] [will-change:transform] transform group-hover:[transform:translate3d(0,0,2em)]\"\n            style={{\n              boxShadow: '0 0 0 0.1em hsla(0, 0%, 100%, 0.3) inset'\n            }}\n          >\n            <span className=\"m-auto w-[1.5em] h-[1.5em] flex items-center justify-center\" aria-hidden=\"true\">\n              {item.icon}\n            </span>\n          </span>\n\n          <span className=\"absolute top-full left-0 right-0 text-center whitespace-nowrap leading-[2] text-base opacity-0 transition-[opacity,transform] duration-300 ease-[cubic-bezier(0.83,0,0.17,1)] translate-y-0 group-hover:opacity-100 group-hover:[transform:translateY(20%)]\">\n            {item.label}\n          </span>\n        </button>\n      ))}\n    </div>\n  );\n};\n\nexport default GlassIcons;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "glass-surface",
      "type": "component",
      "description": "A layouts glass surface component",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/glass-surface.tsx",
          "content": "import React, { useEffect, useRef, useState, useId } from 'react';\n\nexport interface GlassSurfaceProps {\n  children?: React.ReactNode;\n  width?: number | string;\n  height?: number | string;\n  borderRadius?: number;\n  borderWidth?: number;\n  brightness?: number;\n  opacity?: number;\n  blur?: number;\n  displace?: number;\n  backgroundOpacity?: number;\n  saturation?: number;\n  distortionScale?: number;\n  redOffset?: number;\n  greenOffset?: number;\n  blueOffset?: number;\n  xChannel?: 'R' | 'G' | 'B';\n  yChannel?: 'R' | 'G' | 'B';\n  mixBlendMode?:\n    | 'normal'\n    | 'multiply'\n    | 'screen'\n    | 'overlay'\n    | 'darken'\n    | 'lighten'\n    | 'color-dodge'\n    | 'color-burn'\n    | 'hard-light'\n    | 'soft-light'\n    | 'difference'\n    | 'exclusion'\n    | 'hue'\n    | 'saturation'\n    | 'color'\n    | 'luminosity'\n    | 'plus-darker'\n    | 'plus-lighter';\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst useDarkMode = () => {\n  const [isDark, setIsDark] = useState(false);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    setIsDark(mediaQuery.matches);\n\n    const handler = (e: MediaQueryListEvent) => setIsDark(e.matches);\n    mediaQuery.addEventListener('change', handler);\n    return () => mediaQuery.removeEventListener('change', handler);\n  }, []);\n\n  return isDark;\n};\n\nconst GlassSurface: React.FC<GlassSurfaceProps> = ({\n  children,\n  width = 200,\n  height = 80,\n  borderRadius = 20,\n  borderWidth = 0.07,\n  brightness = 50,\n  opacity = 0.93,\n  blur = 11,\n  displace = 0,\n  backgroundOpacity = 0,\n  saturation = 1,\n  distortionScale = -180,\n  redOffset = 0,\n  greenOffset = 10,\n  blueOffset = 20,\n  xChannel = 'R',\n  yChannel = 'G',\n  mixBlendMode = 'difference',\n  className = '',\n  style = {}\n}) => {\n  const uniqueId = useId().replace(/:/g, '-');\n  const filterId = `glass-filter-${uniqueId}`;\n  const redGradId = `red-grad-${uniqueId}`;\n  const blueGradId = `blue-grad-${uniqueId}`;\n\n  const [svgSupported, setSvgSupported] = useState<boolean>(false);\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const feImageRef = useRef<SVGFEImageElement>(null);\n  const redChannelRef = useRef<SVGFEDisplacementMapElement>(null);\n  const greenChannelRef = useRef<SVGFEDisplacementMapElement>(null);\n  const blueChannelRef = useRef<SVGFEDisplacementMapElement>(null);\n  const gaussianBlurRef = useRef<SVGFEGaussianBlurElement>(null);\n\n  const isDarkMode = useDarkMode();\n\n  const generateDisplacementMap = () => {\n    const rect = containerRef.current?.getBoundingClientRect();\n    const actualWidth = rect?.width || 400;\n    const actualHeight = rect?.height || 200;\n    const edgeSize = Math.min(actualWidth, actualHeight) * (borderWidth * 0.5);\n\n    const svgContent = `\n      <svg viewBox=\"0 0 ${actualWidth} ${actualHeight}\" xmlns=\"http://www.w3.org/2000/svg\">\n        <defs>\n          <linearGradient id=\"${redGradId}\" x1=\"100%\" y1=\"0%\" x2=\"0%\" y2=\"0%\">\n            <stop offset=\"0%\" stop-color=\"#0000\"/>\n            <stop offset=\"100%\" stop-color=\"red\"/>\n          </linearGradient>\n          <linearGradient id=\"${blueGradId}\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n            <stop offset=\"0%\" stop-color=\"#0000\"/>\n            <stop offset=\"100%\" stop-color=\"blue\"/>\n          </linearGradient>\n        </defs>\n        <rect x=\"0\" y=\"0\" width=\"${actualWidth}\" height=\"${actualHeight}\" fill=\"black\"></rect>\n        <rect x=\"0\" y=\"0\" width=\"${actualWidth}\" height=\"${actualHeight}\" rx=\"${borderRadius}\" fill=\"url(#${redGradId})\" />\n        <rect x=\"0\" y=\"0\" width=\"${actualWidth}\" height=\"${actualHeight}\" rx=\"${borderRadius}\" fill=\"url(#${blueGradId})\" style=\"mix-blend-mode: ${mixBlendMode}\" />\n        <rect x=\"${edgeSize}\" y=\"${edgeSize}\" width=\"${actualWidth - edgeSize * 2}\" height=\"${actualHeight - edgeSize * 2}\" rx=\"${borderRadius}\" fill=\"hsl(0 0% ${brightness}% / ${opacity})\" style=\"filter:blur(${blur}px)\" />\n      </svg>\n    `;\n\n    return `data:image/svg+xml,${encodeURIComponent(svgContent)}`;\n  };\n\n  const updateDisplacementMap = () => {\n    feImageRef.current?.setAttribute('href', generateDisplacementMap());\n  };\n\n  useEffect(() => {\n    updateDisplacementMap();\n    [\n      { ref: redChannelRef, offset: redOffset },\n      { ref: greenChannelRef, offset: greenOffset },\n      { ref: blueChannelRef, offset: blueOffset }\n    ].forEach(({ ref, offset }) => {\n      if (ref.current) {\n        ref.current.setAttribute('scale', (distortionScale + offset).toString());\n        ref.current.setAttribute('xChannelSelector', xChannel);\n        ref.current.setAttribute('yChannelSelector', yChannel);\n      }\n    });\n\n    gaussianBlurRef.current?.setAttribute('stdDeviation', displace.toString());\n  }, [\n    width,\n    height,\n    borderRadius,\n    borderWidth,\n    brightness,\n    opacity,\n    blur,\n    displace,\n    distortionScale,\n    redOffset,\n    greenOffset,\n    blueOffset,\n    xChannel,\n    yChannel,\n    mixBlendMode\n  ]);\n\n  useEffect(() => {\n    setSvgSupported(supportsSVGFilters());\n  }, []);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const resizeObserver = new ResizeObserver(() => {\n      setTimeout(updateDisplacementMap, 0);\n    });\n\n    resizeObserver.observe(containerRef.current);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const resizeObserver = new ResizeObserver(() => {\n      setTimeout(updateDisplacementMap, 0);\n    });\n\n    resizeObserver.observe(containerRef.current);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  useEffect(() => {\n    setTimeout(updateDisplacementMap, 0);\n  }, [width, height]);\n\n  const supportsSVGFilters = () => {\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\n      return false;\n    }\n\n    const isWebkit = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);\n    const isFirefox = /Firefox/.test(navigator.userAgent);\n\n    if (isWebkit || isFirefox) {\n      return false;\n    }\n\n    const div = document.createElement('div');\n    div.style.backdropFilter = `url(#${filterId})`;\n\n    return div.style.backdropFilter !== '';\n  };\n\n  const supportsBackdropFilter = () => {\n    if (typeof window === 'undefined') return false;\n    return CSS.supports('backdrop-filter', 'blur(10px)');\n  };\n\n  const getContainerStyles = (): React.CSSProperties => {\n    const baseStyles: React.CSSProperties = {\n      ...style,\n      width: typeof width === 'number' ? `${width}px` : width,\n      height: typeof height === 'number' ? `${height}px` : height,\n      borderRadius: `${borderRadius}px`,\n      '--glass-frost': backgroundOpacity,\n      '--glass-saturation': saturation\n    } as React.CSSProperties;\n\n    const backdropFilterSupported = supportsBackdropFilter();\n\n    if (svgSupported) {\n      return {\n        ...baseStyles,\n        background: isDarkMode ? `hsl(0 0% 0% / ${backgroundOpacity})` : `hsl(0 0% 100% / ${backgroundOpacity})`,\n        backdropFilter: `url(#${filterId}) saturate(${saturation})`,\n        boxShadow: isDarkMode\n          ? `0 0 2px 1px color-mix(in oklch, white, transparent 65%) inset,\n             0 0 10px 4px color-mix(in oklch, white, transparent 85%) inset,\n             0px 4px 16px rgba(17, 17, 26, 0.05),\n             0px 8px 24px rgba(17, 17, 26, 0.05),\n             0px 16px 56px rgba(17, 17, 26, 0.05),\n             0px 4px 16px rgba(17, 17, 26, 0.05) inset,\n             0px 8px 24px rgba(17, 17, 26, 0.05) inset,\n             0px 16px 56px rgba(17, 17, 26, 0.05) inset`\n          : `0 0 2px 1px color-mix(in oklch, black, transparent 85%) inset,\n             0 0 10px 4px color-mix(in oklch, black, transparent 90%) inset,\n             0px 4px 16px rgba(17, 17, 26, 0.05),\n             0px 8px 24px rgba(17, 17, 26, 0.05),\n             0px 16px 56px rgba(17, 17, 26, 0.05),\n             0px 4px 16px rgba(17, 17, 26, 0.05) inset,\n             0px 8px 24px rgba(17, 17, 26, 0.05) inset,\n             0px 16px 56px rgba(17, 17, 26, 0.05) inset`\n      };\n    } else {\n      if (isDarkMode) {\n        if (!backdropFilterSupported) {\n          return {\n            ...baseStyles,\n            background: 'rgba(0, 0, 0, 0.4)',\n            border: '1px solid rgba(255, 255, 255, 0.2)',\n            boxShadow: `inset 0 1px 0 0 rgba(255, 255, 255, 0.2),\n                        inset 0 -1px 0 0 rgba(255, 255, 255, 0.1)`\n          };\n        } else {\n          return {\n            ...baseStyles,\n            background: 'rgba(255, 255, 255, 0.1)',\n            backdropFilter: 'blur(12px) saturate(1.8) brightness(1.2)',\n            WebkitBackdropFilter: 'blur(12px) saturate(1.8) brightness(1.2)',\n            border: '1px solid rgba(255, 255, 255, 0.2)',\n            boxShadow: `inset 0 1px 0 0 rgba(255, 255, 255, 0.2),\n                        inset 0 -1px 0 0 rgba(255, 255, 255, 0.1)`\n          };\n        }\n      } else {\n        if (!backdropFilterSupported) {\n          return {\n            ...baseStyles,\n            background: 'rgba(255, 255, 255, 0.4)',\n            border: '1px solid rgba(255, 255, 255, 0.3)',\n            boxShadow: `inset 0 1px 0 0 rgba(255, 255, 255, 0.5),\n                        inset 0 -1px 0 0 rgba(255, 255, 255, 0.3)`\n          };\n        } else {\n          return {\n            ...baseStyles,\n            background: 'rgba(255, 255, 255, 0.25)',\n            backdropFilter: 'blur(12px) saturate(1.8) brightness(1.1)',\n            WebkitBackdropFilter: 'blur(12px) saturate(1.8) brightness(1.1)',\n            border: '1px solid rgba(255, 255, 255, 0.3)',\n            boxShadow: `0 8px 32px 0 rgba(31, 38, 135, 0.2),\n                        0 2px 16px 0 rgba(31, 38, 135, 0.1),\n                        inset 0 1px 0 0 rgba(255, 255, 255, 0.4),\n                        inset 0 -1px 0 0 rgba(255, 255, 255, 0.2)`\n          };\n        }\n      }\n    }\n  };\n\n  const glassSurfaceClasses =\n    'relative flex items-center justify-center overflow-hidden transition-opacity duration-[260ms] ease-out';\n\n  const focusVisibleClasses = isDarkMode\n    ? 'focus-visible:outline-2 focus-visible:outline-[#0A84FF] focus-visible:outline-offset-2'\n    : 'focus-visible:outline-2 focus-visible:outline-[#007AFF] focus-visible:outline-offset-2';\n\n  return (\n    <div\n      ref={containerRef}\n      className={`${glassSurfaceClasses} ${focusVisibleClasses} ${className}`}\n      style={getContainerStyles()}\n    >\n      <svg\n        className=\"w-full h-full pointer-events-none absolute inset-0 opacity-0 -z-10\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n      >\n        <defs>\n          <filter id={filterId} colorInterpolationFilters=\"sRGB\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\">\n            <feImage ref={feImageRef} x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" preserveAspectRatio=\"none\" result=\"map\" />\n\n            <feDisplacementMap ref={redChannelRef} in=\"SourceGraphic\" in2=\"map\" id=\"redchannel\" result=\"dispRed\" />\n            <feColorMatrix\n              in=\"dispRed\"\n              type=\"matrix\"\n              values=\"1 0 0 0 0\n                      0 0 0 0 0\n                      0 0 0 0 0\n                      0 0 0 1 0\"\n              result=\"red\"\n            />\n\n            <feDisplacementMap\n              ref={greenChannelRef}\n              in=\"SourceGraphic\"\n              in2=\"map\"\n              id=\"greenchannel\"\n              result=\"dispGreen\"\n            />\n            <feColorMatrix\n              in=\"dispGreen\"\n              type=\"matrix\"\n              values=\"0 0 0 0 0\n                      0 1 0 0 0\n                      0 0 0 0 0\n                      0 0 0 1 0\"\n              result=\"green\"\n            />\n\n            <feDisplacementMap ref={blueChannelRef} in=\"SourceGraphic\" in2=\"map\" id=\"bluechannel\" result=\"dispBlue\" />\n            <feColorMatrix\n              in=\"dispBlue\"\n              type=\"matrix\"\n              values=\"0 0 0 0 0\n                      0 0 0 0 0\n                      0 0 1 0 0\n                      0 0 0 1 0\"\n              result=\"blue\"\n            />\n\n            <feBlend in=\"red\" in2=\"green\" mode=\"screen\" result=\"rg\" />\n            <feBlend in=\"rg\" in2=\"blue\" mode=\"screen\" result=\"output\" />\n            <feGaussianBlur ref={gaussianBlurRef} in=\"output\" stdDeviation=\"0.7\" />\n          </filter>\n        </defs>\n      </svg>\n\n      <div className=\"w-full h-full flex items-center justify-center p-2 rounded-[inherit] relative z-10\">\n        {children}\n      </div>\n    </div>\n  );\n};\n\nexport default GlassSurface;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "gooey-nav",
      "type": "component",
      "description": "A layouts gooey nav component",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/gooey-nav.tsx",
          "content": "import React, { useRef, useEffect, useState } from 'react';\n\ninterface GooeyNavItem {\n  label: string;\n  href: string;\n}\n\nexport interface GooeyNavProps {\n  items: GooeyNavItem[];\n  animationTime?: number;\n  particleCount?: number;\n  particleDistances?: [number, number];\n  particleR?: number;\n  timeVariance?: number;\n  colors?: number[];\n  initialActiveIndex?: number;\n}\n\nconst GooeyNav: React.FC<GooeyNavProps> = ({\n  items,\n  animationTime = 600,\n  particleCount = 15,\n  particleDistances = [90, 10],\n  particleR = 100,\n  timeVariance = 300,\n  colors = [1, 2, 3, 1, 2, 3, 1, 4],\n  initialActiveIndex = 0\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const navRef = useRef<HTMLUListElement>(null);\n  const filterRef = useRef<HTMLSpanElement>(null);\n  const textRef = useRef<HTMLSpanElement>(null);\n  const [activeIndex, setActiveIndex] = useState<number>(initialActiveIndex);\n\n  const noise = (n = 1) => n / 2 - Math.random() * n;\n  const getXY = (distance: number, pointIndex: number, totalPoints: number): [number, number] => {\n    const angle = ((360 + noise(8)) / totalPoints) * pointIndex * (Math.PI / 180);\n    return [distance * Math.cos(angle), distance * Math.sin(angle)];\n  };\n  const createParticle = (i: number, t: number, d: [number, number], r: number) => {\n    let rotate = noise(r / 10);\n    return {\n      start: getXY(d[0], particleCount - i, particleCount),\n      end: getXY(d[1] + noise(7), particleCount - i, particleCount),\n      time: t,\n      scale: 1 + noise(0.2),\n      color: colors[Math.floor(Math.random() * colors.length)],\n      rotate: rotate > 0 ? (rotate + r / 20) * 10 : (rotate - r / 20) * 10\n    };\n  };\n  const makeParticles = (element: HTMLElement) => {\n    const d: [number, number] = particleDistances;\n    const r = particleR;\n    const bubbleTime = animationTime * 2 + timeVariance;\n    element.style.setProperty('--time', `${bubbleTime}ms`);\n    for (let i = 0; i < particleCount; i++) {\n      const t = animationTime * 2 + noise(timeVariance * 2);\n      const p = createParticle(i, t, d, r);\n      element.classList.remove('active');\n      setTimeout(() => {\n        const particle = document.createElement('span');\n        const point = document.createElement('span');\n        particle.classList.add('particle');\n        particle.style.setProperty('--start-x', `${p.start[0]}px`);\n        particle.style.setProperty('--start-y', `${p.start[1]}px`);\n        particle.style.setProperty('--end-x', `${p.end[0]}px`);\n        particle.style.setProperty('--end-y', `${p.end[1]}px`);\n        particle.style.setProperty('--time', `${p.time}ms`);\n        particle.style.setProperty('--scale', `${p.scale}`);\n        particle.style.setProperty('--color', `var(--color-${p.color}, white)`);\n        particle.style.setProperty('--rotate', `${p.rotate}deg`);\n        point.classList.add('point');\n        particle.appendChild(point);\n        element.appendChild(particle);\n        requestAnimationFrame(() => {\n          element.classList.add('active');\n        });\n        setTimeout(() => {\n          try {\n            element.removeChild(particle);\n          } catch {}\n        }, t);\n      }, 30);\n    }\n  };\n  const updateEffectPosition = (element: HTMLElement) => {\n    if (!containerRef.current || !filterRef.current || !textRef.current) return;\n    const containerRect = containerRef.current.getBoundingClientRect();\n    const pos = element.getBoundingClientRect();\n    const styles = {\n      left: `${pos.x - containerRect.x}px`,\n      top: `${pos.y - containerRect.y}px`,\n      width: `${pos.width}px`,\n      height: `${pos.height}px`\n    };\n    Object.assign(filterRef.current.style, styles);\n    Object.assign(textRef.current.style, styles);\n    textRef.current.innerText = element.innerText;\n  };\n  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>, index: number) => {\n    const liEl = e.currentTarget;\n    if (activeIndex === index) return;\n    setActiveIndex(index);\n    updateEffectPosition(liEl);\n    if (filterRef.current) {\n      const particles = filterRef.current.querySelectorAll('.particle');\n      particles.forEach(p => filterRef.current!.removeChild(p));\n    }\n    if (textRef.current) {\n      textRef.current.classList.remove('active');\n      void textRef.current.offsetWidth;\n      textRef.current.classList.add('active');\n    }\n    if (filterRef.current) {\n      makeParticles(filterRef.current);\n    }\n  };\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLAnchorElement>, index: number) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      const liEl = e.currentTarget.parentElement;\n      if (liEl) {\n        handleClick(\n          {\n            currentTarget: liEl\n          } as React.MouseEvent<HTMLAnchorElement>,\n          index\n        );\n      }\n    }\n  };\n  useEffect(() => {\n    if (!navRef.current || !containerRef.current) return;\n    const activeLi = navRef.current.querySelectorAll('li')[activeIndex] as HTMLElement;\n    if (activeLi) {\n      updateEffectPosition(activeLi);\n      textRef.current?.classList.add('active');\n    }\n    const resizeObserver = new ResizeObserver(() => {\n      const currentActiveLi = navRef.current?.querySelectorAll('li')[activeIndex] as HTMLElement;\n      if (currentActiveLi) {\n        updateEffectPosition(currentActiveLi);\n      }\n    });\n    resizeObserver.observe(containerRef.current);\n    return () => resizeObserver.disconnect();\n  }, [activeIndex]);\n\n  return (\n    <>\n      {/* This effect is quite difficult to recreate faithfully using Tailwind, so a style tag is a necessary workaround */}\n      <style>\n        {`\n          :root {\n            --linear-ease: linear(0, 0.068, 0.19 2.7%, 0.804 8.1%, 1.037, 1.199 13.2%, 1.245, 1.27 15.8%, 1.274, 1.272 17.4%, 1.249 19.1%, 0.996 28%, 0.949, 0.928 33.3%, 0.926, 0.933 36.8%, 1.001 45.6%, 1.013, 1.019 50.8%, 1.018 54.4%, 1 63.1%, 0.995 68%, 1.001 85%, 1);\n          }\n          .effect {\n            position: absolute;\n            opacity: 1;\n            pointer-events: none;\n            display: grid;\n            place-items: center;\n            z-index: 1;\n          }\n          .effect.text {\n            color: white;\n            transition: color 0.3s ease;\n          }\n          .effect.text.active {\n            color: black;\n          }\n          .effect.filter {\n            filter: blur(7px) contrast(100) blur(0);\n            mix-blend-mode: lighten;\n          }\n          .effect.filter::before {\n            content: \"\";\n            position: absolute;\n            inset: -75px;\n            z-index: -2;\n            background: black;\n          }\n          .effect.filter::after {\n            content: \"\";\n            position: absolute;\n            inset: 0;\n            background: white;\n            transform: scale(0);\n            opacity: 0;\n            z-index: -1;\n            border-radius: 9999px;\n          }\n          .effect.active::after {\n            animation: pill 0.3s ease both;\n          }\n          @keyframes pill {\n            to {\n              transform: scale(1);\n              opacity: 1;\n            }\n          }\n          .particle,\n          .point {\n            display: block;\n            opacity: 0;\n            width: 20px;\n            height: 20px;\n            border-radius: 9999px;\n            transform-origin: center;\n          }\n          .particle {\n            --time: 5s;\n            position: absolute;\n            top: calc(50% - 8px);\n            left: calc(50% - 8px);\n            animation: particle calc(var(--time)) ease 1 -350ms;\n          }\n          .point {\n            background: var(--color);\n            opacity: 1;\n            animation: point calc(var(--time)) ease 1 -350ms;\n          }\n          @keyframes particle {\n            0% {\n              transform: rotate(0deg) translate(calc(var(--start-x)), calc(var(--start-y)));\n              opacity: 1;\n              animation-timing-function: cubic-bezier(0.55, 0, 1, 0.45);\n            }\n            70% {\n              transform: rotate(calc(var(--rotate) * 0.5)) translate(calc(var(--end-x) * 1.2), calc(var(--end-y) * 1.2));\n              opacity: 1;\n              animation-timing-function: ease;\n            }\n            85% {\n              transform: rotate(calc(var(--rotate) * 0.66)) translate(calc(var(--end-x)), calc(var(--end-y)));\n              opacity: 1;\n            }\n            100% {\n              transform: rotate(calc(var(--rotate) * 1.2)) translate(calc(var(--end-x) * 0.5), calc(var(--end-y) * 0.5));\n              opacity: 1;\n            }\n          }\n          @keyframes point {\n            0% {\n              transform: scale(0);\n              opacity: 0;\n              animation-timing-function: cubic-bezier(0.55, 0, 1, 0.45);\n            }\n            25% {\n              transform: scale(calc(var(--scale) * 0.25));\n            }\n            38% {\n              opacity: 1;\n            }\n            65% {\n              transform: scale(var(--scale));\n              opacity: 1;\n              animation-timing-function: ease;\n            }\n            85% {\n              transform: scale(var(--scale));\n              opacity: 1;\n            }\n            100% {\n              transform: scale(0);\n              opacity: 0;\n            }\n          }\n          li.active {\n            color: black;\n            text-shadow: none;\n          }\n          li.active::after {\n            opacity: 1;\n            transform: scale(1);\n          }\n          li::after {\n            content: \"\";\n            position: absolute;\n            inset: 0;\n            border-radius: 8px;\n            background: white;\n            opacity: 0;\n            transform: scale(0);\n            transition: all 0.3s ease;\n            z-index: -1;\n          }\n        `}\n      </style>\n      <div className=\"relative\" ref={containerRef}>\n        <nav className=\"flex relative\" style={{ transform: 'translate3d(0,0,0.01px)' }}>\n          <ul\n            ref={navRef}\n            className=\"flex gap-8 list-none p-0 px-4 m-0 relative z-[3]\"\n            style={{\n              color: 'white',\n              textShadow: '0 1px 1px hsl(205deg 30% 10% / 0.2)'\n            }}\n          >\n            {items.map((item, index) => (\n              <li\n                key={index}\n                className={`rounded-full relative cursor-pointer transition-[background-color_color_box-shadow] duration-300 ease shadow-[0_0_0.5px_1.5px_transparent] text-white ${\n                  activeIndex === index ? 'active' : ''\n                }`}\n              >\n                <a\n                  href={item.href}\n                  onClick={e => handleClick(e, index)}\n                  onKeyDown={e => handleKeyDown(e, index)}\n                  className=\"outline-none py-[0.6em] px-[1em] inline-block\"\n                >\n                  {item.label}\n                </a>\n              </li>\n            ))}\n          </ul>\n        </nav>\n        <span className=\"effect filter\" ref={filterRef} />\n        <span className=\"effect text\" ref={textRef} />\n      </div>\n    </>\n  );\n};\n\nexport default GooeyNav;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "infinite-menu",
      "type": "component",
      "description": "A layouts infinite menu component",
      "category": "layouts",
      "dependencies": [
        "gl-matrix"
      ],
      "files": [
        {
          "path": "components/ui/infinite-menu.tsx",
          "content": "import { FC, useRef, useState, useEffect, MutableRefObject } from 'react';\nimport { mat4, quat, vec2, vec3 } from 'gl-matrix';\n\nconst discVertShaderSource = `#version 300 es\n\nuniform mat4 uWorldMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform vec3 uCameraPosition;\nuniform vec4 uRotationAxisVelocity;\n\nin vec3 aModelPosition;\nin vec3 aModelNormal;\nin vec2 aModelUvs;\nin mat4 aInstanceMatrix;\n\nout vec2 vUvs;\nout float vAlpha;\nflat out int vInstanceId;\n\n#define PI 3.141593\n\nvoid main() {\n    vec4 worldPosition = uWorldMatrix * aInstanceMatrix * vec4(aModelPosition, 1.);\n\n    vec3 centerPos = (uWorldMatrix * aInstanceMatrix * vec4(0., 0., 0., 1.)).xyz;\n    float radius = length(centerPos.xyz);\n\n    if (gl_VertexID > 0) {\n        vec3 rotationAxis = uRotationAxisVelocity.xyz;\n        float rotationVelocity = min(.15, uRotationAxisVelocity.w * 15.);\n        vec3 stretchDir = normalize(cross(centerPos, rotationAxis));\n        vec3 relativeVertexPos = normalize(worldPosition.xyz - centerPos);\n        float strength = dot(stretchDir, relativeVertexPos);\n        float invAbsStrength = min(0., abs(strength) - 1.);\n        strength = rotationVelocity * sign(strength) * abs(invAbsStrength * invAbsStrength * invAbsStrength + 1.);\n        worldPosition.xyz += stretchDir * strength;\n    }\n\n    worldPosition.xyz = radius * normalize(worldPosition.xyz);\n\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\n\n    vAlpha = smoothstep(0.5, 1., normalize(worldPosition.xyz).z) * .9 + .1;\n    vUvs = aModelUvs;\n    vInstanceId = gl_InstanceID;\n}\n`;\n\nconst discFragShaderSource = `#version 300 es\nprecision highp float;\n\nuniform sampler2D uTex;\nuniform int uItemCount;\nuniform int uAtlasSize;\n\nout vec4 outColor;\n\nin vec2 vUvs;\nin float vAlpha;\nflat in int vInstanceId;\n\nvoid main() {\n    int itemIndex = vInstanceId % uItemCount;\n    int cellsPerRow = uAtlasSize;\n    int cellX = itemIndex % cellsPerRow;\n    int cellY = itemIndex / cellsPerRow;\n    vec2 cellSize = vec2(1.0) / vec2(float(cellsPerRow));\n    vec2 cellOffset = vec2(float(cellX), float(cellY)) * cellSize;\n\n    ivec2 texSize = textureSize(uTex, 0);\n    float imageAspect = float(texSize.x) / float(texSize.y);\n    float containerAspect = 1.0;\n    \n    float scale = max(imageAspect / containerAspect, \n                     containerAspect / imageAspect);\n    \n    vec2 st = vec2(vUvs.x, 1.0 - vUvs.y);\n    st = (st - 0.5) * scale + 0.5;\n    \n    st = clamp(st, 0.0, 1.0);\n    st = st * cellSize + cellOffset;\n    \n    outColor = texture(uTex, st);\n    outColor.a *= vAlpha;\n}\n`;\n\nclass Face {\n  public a: number;\n  public b: number;\n  public c: number;\n\n  constructor(a: number, b: number, c: number) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n}\n\nclass Vertex {\n  public position: vec3;\n  public normal: vec3;\n  public uv: vec2;\n\n  constructor(x: number, y: number, z: number) {\n    this.position = vec3.fromValues(x, y, z);\n    this.normal = vec3.create();\n    this.uv = vec2.create();\n  }\n}\n\nclass Geometry {\n  public vertices: Vertex[];\n  public faces: Face[];\n\n  constructor() {\n    this.vertices = [];\n    this.faces = [];\n  }\n\n  public addVertex(...args: number[]): this {\n    for (let i = 0; i < args.length; i += 3) {\n      this.vertices.push(new Vertex(args[i], args[i + 1], args[i + 2]));\n    }\n    return this;\n  }\n\n  public addFace(...args: number[]): this {\n    for (let i = 0; i < args.length; i += 3) {\n      this.faces.push(new Face(args[i], args[i + 1], args[i + 2]));\n    }\n    return this;\n  }\n\n  public get lastVertex(): Vertex {\n    return this.vertices[this.vertices.length - 1];\n  }\n\n  public subdivide(divisions = 1): this {\n    const midPointCache: Record<string, number> = {};\n    let f = this.faces;\n\n    for (let div = 0; div < divisions; ++div) {\n      const newFaces = new Array<Face>(f.length * 4);\n\n      f.forEach((face, ndx) => {\n        const mAB = this.getMidPoint(face.a, face.b, midPointCache);\n        const mBC = this.getMidPoint(face.b, face.c, midPointCache);\n        const mCA = this.getMidPoint(face.c, face.a, midPointCache);\n\n        const i = ndx * 4;\n        newFaces[i + 0] = new Face(face.a, mAB, mCA);\n        newFaces[i + 1] = new Face(face.b, mBC, mAB);\n        newFaces[i + 2] = new Face(face.c, mCA, mBC);\n        newFaces[i + 3] = new Face(mAB, mBC, mCA);\n      });\n\n      f = newFaces;\n    }\n\n    this.faces = f;\n    return this;\n  }\n\n  public spherize(radius = 1): this {\n    this.vertices.forEach(vertex => {\n      vec3.normalize(vertex.normal, vertex.position);\n      vec3.scale(vertex.position, vertex.normal, radius);\n    });\n    return this;\n  }\n\n  public get data(): {\n    vertices: Float32Array;\n    indices: Uint16Array;\n    normals: Float32Array;\n    uvs: Float32Array;\n  } {\n    return {\n      vertices: this.vertexData,\n      indices: this.indexData,\n      normals: this.normalData,\n      uvs: this.uvData\n    };\n  }\n\n  public get vertexData(): Float32Array {\n    return new Float32Array(this.vertices.flatMap(v => Array.from(v.position)));\n  }\n\n  public get normalData(): Float32Array {\n    return new Float32Array(this.vertices.flatMap(v => Array.from(v.normal)));\n  }\n\n  public get uvData(): Float32Array {\n    return new Float32Array(this.vertices.flatMap(v => Array.from(v.uv)));\n  }\n\n  public get indexData(): Uint16Array {\n    return new Uint16Array(this.faces.flatMap(f => [f.a, f.b, f.c]));\n  }\n\n  public getMidPoint(ndxA: number, ndxB: number, cache: Record<string, number>): number {\n    const cacheKey = ndxA < ndxB ? `k_${ndxB}_${ndxA}` : `k_${ndxA}_${ndxB}`;\n    if (Object.prototype.hasOwnProperty.call(cache, cacheKey)) {\n      return cache[cacheKey];\n    }\n    const a = this.vertices[ndxA].position;\n    const b = this.vertices[ndxB].position;\n    const ndx = this.vertices.length;\n    cache[cacheKey] = ndx;\n    this.addVertex((a[0] + b[0]) * 0.5, (a[1] + b[1]) * 0.5, (a[2] + b[2]) * 0.5);\n    return ndx;\n  }\n}\n\nclass IcosahedronGeometry extends Geometry {\n  constructor() {\n    super();\n    const t = Math.sqrt(5) * 0.5 + 0.5;\n    this.addVertex(\n      -1,\n      t,\n      0,\n      1,\n      t,\n      0,\n      -1,\n      -t,\n      0,\n      1,\n      -t,\n      0,\n      0,\n      -1,\n      t,\n      0,\n      1,\n      t,\n      0,\n      -1,\n      -t,\n      0,\n      1,\n      -t,\n      t,\n      0,\n      -1,\n      t,\n      0,\n      1,\n      -t,\n      0,\n      -1,\n      -t,\n      0,\n      1\n    ).addFace(\n      0,\n      11,\n      5,\n      0,\n      5,\n      1,\n      0,\n      1,\n      7,\n      0,\n      7,\n      10,\n      0,\n      10,\n      11,\n      1,\n      5,\n      9,\n      5,\n      11,\n      4,\n      11,\n      10,\n      2,\n      10,\n      7,\n      6,\n      7,\n      1,\n      8,\n      3,\n      9,\n      4,\n      3,\n      4,\n      2,\n      3,\n      2,\n      6,\n      3,\n      6,\n      8,\n      3,\n      8,\n      9,\n      4,\n      9,\n      5,\n      2,\n      4,\n      11,\n      6,\n      2,\n      10,\n      8,\n      6,\n      7,\n      9,\n      8,\n      1\n    );\n  }\n}\n\nclass DiscGeometry extends Geometry {\n  constructor(steps = 4, radius = 1) {\n    super();\n    const safeSteps = Math.max(4, steps);\n    const alpha = (2 * Math.PI) / safeSteps;\n\n    this.addVertex(0, 0, 0);\n    this.lastVertex.uv[0] = 0.5;\n    this.lastVertex.uv[1] = 0.5;\n\n    for (let i = 0; i < safeSteps; ++i) {\n      const x = Math.cos(alpha * i);\n      const y = Math.sin(alpha * i);\n      this.addVertex(radius * x, radius * y, 0);\n      this.lastVertex.uv[0] = x * 0.5 + 0.5;\n      this.lastVertex.uv[1] = y * 0.5 + 0.5;\n\n      if (i > 0) {\n        this.addFace(0, i, i + 1);\n      }\n    }\n    this.addFace(0, safeSteps, 1);\n  }\n}\n\nfunction createShader(gl: WebGL2RenderingContext, type: number, source: string): WebGLShader | null {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (success) {\n    return shader;\n  }\n\n  console.error(gl.getShaderInfoLog(shader));\n  gl.deleteShader(shader);\n  return null;\n}\n\nfunction createProgram(\n  gl: WebGL2RenderingContext,\n  shaderSources: [string, string],\n  transformFeedbackVaryings?: string[] | null,\n  attribLocations?: Record<string, number>\n): WebGLProgram | null {\n  const program = gl.createProgram();\n  if (!program) return null;\n\n  [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((type, ndx) => {\n    const shader = createShader(gl, type, shaderSources[ndx]);\n    if (shader) {\n      gl.attachShader(program, shader);\n    }\n  });\n\n  if (transformFeedbackVaryings) {\n    gl.transformFeedbackVaryings(program, transformFeedbackVaryings, gl.SEPARATE_ATTRIBS);\n  }\n\n  if (attribLocations) {\n    for (const attrib in attribLocations) {\n      if (Object.prototype.hasOwnProperty.call(attribLocations, attrib)) {\n        gl.bindAttribLocation(program, attribLocations[attrib], attrib);\n      }\n    }\n  }\n\n  gl.linkProgram(program);\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (success) {\n    return program;\n  }\n\n  console.error(gl.getProgramInfoLog(program));\n  gl.deleteProgram(program);\n  return null;\n}\n\nfunction makeVertexArray(\n  gl: WebGL2RenderingContext,\n  bufLocNumElmPairs: Array<[WebGLBuffer, number, number]>,\n  indices?: Uint16Array\n): WebGLVertexArrayObject | null {\n  const va = gl.createVertexArray();\n  if (!va) return null;\n\n  gl.bindVertexArray(va);\n\n  for (const [buffer, loc, numElem] of bufLocNumElmPairs) {\n    if (loc === -1) continue;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.enableVertexAttribArray(loc);\n    gl.vertexAttribPointer(loc, numElem, gl.FLOAT, false, 0, 0);\n  }\n\n  if (indices) {\n    const indexBuffer = gl.createBuffer();\n    if (indexBuffer) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n    }\n  }\n\n  gl.bindVertexArray(null);\n  return va;\n}\n\nfunction resizeCanvasToDisplaySize(canvas: HTMLCanvasElement): boolean {\n  const dpr = Math.min(2, window.devicePixelRatio || 1);\n  const displayWidth = Math.round(canvas.clientWidth * dpr);\n  const displayHeight = Math.round(canvas.clientHeight * dpr);\n  const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;\n  if (needResize) {\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n  return needResize;\n}\n\nfunction makeBuffer(gl: WebGL2RenderingContext, sizeOrData: number | ArrayBufferView, usage: number): WebGLBuffer {\n  const buf = gl.createBuffer();\n  if (!buf) {\n    throw new Error('Failed to create WebGL buffer.');\n  }\n  gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\n  if (typeof sizeOrData === 'number') {\n    gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);\n  } else {\n    gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);\n  }\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  return buf;\n}\n\nfunction createAndSetupTexture(\n  gl: WebGL2RenderingContext,\n  minFilter: number,\n  magFilter: number,\n  wrapS: number,\n  wrapT: number\n): WebGLTexture {\n  const texture = gl.createTexture();\n  if (!texture) {\n    throw new Error('Failed to create WebGL texture.');\n  }\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n  return texture;\n}\n\ntype UpdateCallback = (deltaTime: number) => void;\n\nclass ArcballControl {\n  private canvas: HTMLCanvasElement;\n  private updateCallback: UpdateCallback;\n\n  public isPointerDown = false;\n  public orientation = quat.create();\n  public pointerRotation = quat.create();\n  public rotationVelocity = 0;\n  public rotationAxis = vec3.fromValues(1, 0, 0);\n\n  public snapDirection = vec3.fromValues(0, 0, -1);\n  public snapTargetDirection: vec3 | null = null;\n\n  private pointerPos = vec2.create();\n  private previousPointerPos = vec2.create();\n  private _rotationVelocity = 0;\n  private _combinedQuat = quat.create();\n\n  private readonly EPSILON = 0.1;\n  private readonly IDENTITY_QUAT = quat.create();\n\n  constructor(canvas: HTMLCanvasElement, updateCallback?: UpdateCallback) {\n    this.canvas = canvas;\n    this.updateCallback = updateCallback || (() => undefined);\n\n    canvas.addEventListener('pointerdown', (e: PointerEvent) => {\n      vec2.set(this.pointerPos, e.clientX, e.clientY);\n      vec2.copy(this.previousPointerPos, this.pointerPos);\n      this.isPointerDown = true;\n    });\n    canvas.addEventListener('pointerup', () => {\n      this.isPointerDown = false;\n    });\n    canvas.addEventListener('pointerleave', () => {\n      this.isPointerDown = false;\n    });\n    canvas.addEventListener('pointermove', (e: PointerEvent) => {\n      if (this.isPointerDown) {\n        vec2.set(this.pointerPos, e.clientX, e.clientY);\n      }\n    });\n    canvas.style.touchAction = 'none';\n  }\n\n  public update(deltaTime: number, targetFrameDuration = 16): void {\n    const timeScale = deltaTime / targetFrameDuration + 0.00001;\n    let angleFactor = timeScale;\n    const snapRotation = quat.create();\n\n    if (this.isPointerDown) {\n      const INTENSITY = 0.3 * timeScale;\n      const ANGLE_AMPLIFICATION = 5 / timeScale;\n      const midPointerPos = vec2.sub(vec2.create(), this.pointerPos, this.previousPointerPos);\n      vec2.scale(midPointerPos, midPointerPos, INTENSITY);\n\n      if (vec2.sqrLen(midPointerPos) > this.EPSILON) {\n        vec2.add(midPointerPos, this.previousPointerPos, midPointerPos);\n\n        const p = this.project(midPointerPos);\n        const q = this.project(this.previousPointerPos);\n        const a = vec3.normalize(vec3.create(), p);\n        const b = vec3.normalize(vec3.create(), q);\n\n        vec2.copy(this.previousPointerPos, midPointerPos);\n\n        angleFactor *= ANGLE_AMPLIFICATION;\n\n        this.quatFromVectors(a, b, this.pointerRotation, angleFactor);\n      } else {\n        quat.slerp(this.pointerRotation, this.pointerRotation, this.IDENTITY_QUAT, INTENSITY);\n      }\n    } else {\n      const INTENSITY = 0.1 * timeScale;\n      quat.slerp(this.pointerRotation, this.pointerRotation, this.IDENTITY_QUAT, INTENSITY);\n\n      if (this.snapTargetDirection) {\n        const SNAPPING_INTENSITY = 0.2;\n        const a = this.snapTargetDirection;\n        const b = this.snapDirection;\n        const sqrDist = vec3.squaredDistance(a, b);\n        const distanceFactor = Math.max(0.1, 1 - sqrDist * 10);\n        angleFactor *= SNAPPING_INTENSITY * distanceFactor;\n        this.quatFromVectors(a, b, snapRotation, angleFactor);\n      }\n    }\n\n    const combinedQuat = quat.multiply(quat.create(), snapRotation, this.pointerRotation);\n    this.orientation = quat.multiply(quat.create(), combinedQuat, this.orientation);\n    quat.normalize(this.orientation, this.orientation);\n\n    const RA_INTENSITY = 0.8 * timeScale;\n    quat.slerp(this._combinedQuat, this._combinedQuat, combinedQuat, RA_INTENSITY);\n    quat.normalize(this._combinedQuat, this._combinedQuat);\n\n    const rad = Math.acos(this._combinedQuat[3]) * 2.0;\n    const s = Math.sin(rad / 2.0);\n    let rv = 0;\n    if (s > 0.000001) {\n      rv = rad / (2 * Math.PI);\n      this.rotationAxis[0] = this._combinedQuat[0] / s;\n      this.rotationAxis[1] = this._combinedQuat[1] / s;\n      this.rotationAxis[2] = this._combinedQuat[2] / s;\n    }\n\n    const RV_INTENSITY = 0.5 * timeScale;\n    this._rotationVelocity += (rv - this._rotationVelocity) * RV_INTENSITY;\n    this.rotationVelocity = this._rotationVelocity / timeScale;\n\n    this.updateCallback(deltaTime);\n  }\n\n  private quatFromVectors(a: vec3, b: vec3, out: quat, angleFactor = 1): { q: quat; axis: vec3; angle: number } {\n    const axis = vec3.cross(vec3.create(), a, b);\n    vec3.normalize(axis, axis);\n    const d = Math.max(-1, Math.min(1, vec3.dot(a, b)));\n    const angle = Math.acos(d) * angleFactor;\n    quat.setAxisAngle(out, axis, angle);\n    return { q: out, axis, angle };\n  }\n\n  private project(pos: vec2): vec3 {\n    const r = 2;\n    const w = this.canvas.clientWidth;\n    const h = this.canvas.clientHeight;\n    const s = Math.max(w, h) - 1;\n\n    const x = (2 * pos[0] - w - 1) / s;\n    const y = (2 * pos[1] - h - 1) / s;\n    let z = 0;\n    const xySq = x * x + y * y;\n    const rSq = r * r;\n\n    if (xySq <= rSq / 2.0) {\n      z = Math.sqrt(rSq - xySq);\n    } else {\n      z = rSq / Math.sqrt(xySq);\n    }\n    return vec3.fromValues(-x, y, z);\n  }\n}\n\ninterface MenuItem {\n  image: string;\n  link: string;\n  title: string;\n  description: string;\n}\n\ntype ActiveItemCallback = (index: number) => void;\ntype MovementChangeCallback = (isMoving: boolean) => void;\ntype InitCallback = (instance: InfiniteGridMenu) => void;\n\ninterface Camera {\n  matrix: mat4;\n  near: number;\n  far: number;\n  fov: number;\n  aspect: number;\n  position: vec3;\n  up: vec3;\n  matrices: {\n    view: mat4;\n    projection: mat4;\n    inversProjection: mat4;\n  };\n}\n\nclass InfiniteGridMenu {\n  private gl: WebGL2RenderingContext | null = null;\n  private discProgram: WebGLProgram | null = null;\n  private discVAO: WebGLVertexArrayObject | null = null;\n  private discBuffers!: {\n    vertices: Float32Array;\n    indices: Uint16Array;\n    normals: Float32Array;\n    uvs: Float32Array;\n  };\n  private icoGeo!: IcosahedronGeometry;\n  private discGeo!: DiscGeometry;\n  private worldMatrix = mat4.create();\n  private tex: WebGLTexture | null = null;\n  private control!: ArcballControl;\n\n  private discLocations!: {\n    aModelPosition: number;\n    aModelUvs: number;\n    aInstanceMatrix: number;\n    uWorldMatrix: WebGLUniformLocation | null;\n    uViewMatrix: WebGLUniformLocation | null;\n    uProjectionMatrix: WebGLUniformLocation | null;\n    uCameraPosition: WebGLUniformLocation | null;\n    uScaleFactor: WebGLUniformLocation | null;\n    uRotationAxisVelocity: WebGLUniformLocation | null;\n    uTex: WebGLUniformLocation | null;\n    uFrames: WebGLUniformLocation | null;\n    uItemCount: WebGLUniformLocation | null;\n    uAtlasSize: WebGLUniformLocation | null;\n  };\n\n  private viewportSize = vec2.create();\n  private drawBufferSize = vec2.create();\n\n  private discInstances!: {\n    matricesArray: Float32Array;\n    matrices: Float32Array[];\n    buffer: WebGLBuffer | null;\n  };\n\n  private instancePositions: vec3[] = [];\n  private DISC_INSTANCE_COUNT = 0;\n  private atlasSize = 1;\n\n  private _time = 0;\n  private _deltaTime = 0;\n  private _deltaFrames = 0;\n  private _frames = 0;\n\n  private movementActive = false;\n\n  private TARGET_FRAME_DURATION = 1000 / 60;\n  private SPHERE_RADIUS = 2;\n\n  public camera: Camera = {\n    matrix: mat4.create(),\n    near: 0.1,\n    far: 40,\n    fov: Math.PI / 4,\n    aspect: 1,\n    position: vec3.fromValues(0, 0, 3),\n    up: vec3.fromValues(0, 1, 0),\n    matrices: {\n      view: mat4.create(),\n      projection: mat4.create(),\n      inversProjection: mat4.create()\n    }\n  };\n\n  public smoothRotationVelocity = 0;\n  public scaleFactor = 1.0;\n\n  constructor(\n    private canvas: HTMLCanvasElement,\n    private items: MenuItem[],\n    private onActiveItemChange: ActiveItemCallback,\n    private onMovementChange: MovementChangeCallback,\n    onInit?: InitCallback,\n    scale: number = 1.0\n  ) {\n    this.scaleFactor = scale;\n    this.camera.position[2] = 3 * scale;\n    this.init(onInit);\n  }\n\n  public resize(): void {\n    const needsResize = resizeCanvasToDisplaySize(this.canvas);\n    if (!this.gl) return;\n    if (needsResize) {\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n    this.updateProjectionMatrix();\n  }\n\n  public run(time = 0): void {\n    this._deltaTime = Math.min(32, time - this._time);\n    this._time = time;\n    this._deltaFrames = this._deltaTime / this.TARGET_FRAME_DURATION;\n    this._frames += this._deltaFrames;\n\n    this.animate(this._deltaTime);\n    this.render();\n\n    requestAnimationFrame(t => this.run(t));\n  }\n\n  private init(onInit?: InitCallback): void {\n    const gl = this.canvas.getContext('webgl2', {\n      antialias: true,\n      alpha: false\n    });\n    if (!gl) {\n      throw new Error('No WebGL 2 context!');\n    }\n    this.gl = gl;\n\n    vec2.set(this.viewportSize, this.canvas.clientWidth, this.canvas.clientHeight);\n    vec2.clone(this.drawBufferSize);\n\n    this.discProgram = createProgram(gl, [discVertShaderSource, discFragShaderSource], null, {\n      aModelPosition: 0,\n      aModelNormal: 1,\n      aModelUvs: 2,\n      aInstanceMatrix: 3\n    });\n\n    this.discLocations = {\n      aModelPosition: gl.getAttribLocation(this.discProgram!, 'aModelPosition'),\n      aModelUvs: gl.getAttribLocation(this.discProgram!, 'aModelUvs'),\n      aInstanceMatrix: gl.getAttribLocation(this.discProgram!, 'aInstanceMatrix'),\n      uWorldMatrix: gl.getUniformLocation(this.discProgram!, 'uWorldMatrix'),\n      uViewMatrix: gl.getUniformLocation(this.discProgram!, 'uViewMatrix'),\n      uProjectionMatrix: gl.getUniformLocation(this.discProgram!, 'uProjectionMatrix'),\n      uCameraPosition: gl.getUniformLocation(this.discProgram!, 'uCameraPosition'),\n      uScaleFactor: gl.getUniformLocation(this.discProgram!, 'uScaleFactor'),\n      uRotationAxisVelocity: gl.getUniformLocation(this.discProgram!, 'uRotationAxisVelocity'),\n      uTex: gl.getUniformLocation(this.discProgram!, 'uTex'),\n      uFrames: gl.getUniformLocation(this.discProgram!, 'uFrames'),\n      uItemCount: gl.getUniformLocation(this.discProgram!, 'uItemCount'),\n      uAtlasSize: gl.getUniformLocation(this.discProgram!, 'uAtlasSize')\n    };\n\n    this.discGeo = new DiscGeometry(56, 1);\n    this.discBuffers = this.discGeo.data;\n    this.discVAO = makeVertexArray(\n      gl,\n      [\n        [makeBuffer(gl, this.discBuffers.vertices, gl.STATIC_DRAW), this.discLocations.aModelPosition, 3],\n        [makeBuffer(gl, this.discBuffers.uvs, gl.STATIC_DRAW), this.discLocations.aModelUvs, 2]\n      ],\n      this.discBuffers.indices\n    );\n\n    this.icoGeo = new IcosahedronGeometry();\n    this.icoGeo.subdivide(1).spherize(this.SPHERE_RADIUS);\n    this.instancePositions = this.icoGeo.vertices.map(v => v.position);\n    this.DISC_INSTANCE_COUNT = this.icoGeo.vertices.length;\n    this.initDiscInstances(this.DISC_INSTANCE_COUNT);\n    this.initTexture();\n    this.control = new ArcballControl(this.canvas, deltaTime => this.onControlUpdate(deltaTime));\n\n    this.updateCameraMatrix();\n    this.updateProjectionMatrix();\n\n    this.resize();\n\n    if (onInit) {\n      onInit(this);\n    }\n  }\n\n  private initTexture(): void {\n    if (!this.gl) return;\n    const gl = this.gl;\n    this.tex = createAndSetupTexture(gl, gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);\n\n    const itemCount = Math.max(1, this.items.length);\n    this.atlasSize = Math.ceil(Math.sqrt(itemCount));\n    const cellSize = 512;\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d')!;\n    canvas.width = this.atlasSize * cellSize;\n    canvas.height = this.atlasSize * cellSize;\n\n    Promise.all(\n      this.items.map(\n        item =>\n          new Promise<HTMLImageElement>(resolve => {\n            const img = new Image();\n            img.crossOrigin = 'anonymous';\n            img.onload = () => resolve(img);\n            img.src = item.image;\n          })\n      )\n    ).then(images => {\n      images.forEach((img, i) => {\n        const x = (i % this.atlasSize) * cellSize;\n        const y = Math.floor(i / this.atlasSize) * cellSize;\n        ctx.drawImage(img, x, y, cellSize, cellSize);\n      });\n\n      gl.bindTexture(gl.TEXTURE_2D, this.tex);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n      gl.generateMipmap(gl.TEXTURE_2D);\n    });\n  }\n\n  private initDiscInstances(count: number): void {\n    if (!this.gl || !this.discVAO) return;\n    const gl = this.gl;\n\n    const matricesArray = new Float32Array(count * 16);\n    const matrices: Float32Array[] = [];\n    for (let i = 0; i < count; ++i) {\n      const instanceMatrixArray = new Float32Array(matricesArray.buffer, i * 16 * 4, 16);\n      mat4.identity(instanceMatrixArray as unknown as mat4);\n      matrices.push(instanceMatrixArray);\n    }\n\n    this.discInstances = {\n      matricesArray,\n      matrices,\n      buffer: gl.createBuffer()\n    };\n\n    gl.bindVertexArray(this.discVAO);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.discInstances.buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.discInstances.matricesArray.byteLength, gl.DYNAMIC_DRAW);\n\n    const mat4AttribSlotCount = 4;\n    const bytesPerMatrix = 16 * 4;\n    for (let j = 0; j < mat4AttribSlotCount; ++j) {\n      const loc = this.discLocations.aInstanceMatrix + j;\n      gl.enableVertexAttribArray(loc);\n      gl.vertexAttribPointer(loc, 4, gl.FLOAT, false, bytesPerMatrix, j * 4 * 4);\n      gl.vertexAttribDivisor(loc, 1);\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindVertexArray(null);\n  }\n\n  private animate(deltaTime: number): void {\n    if (!this.gl) return;\n    this.control.update(deltaTime, this.TARGET_FRAME_DURATION);\n\n    const positions = this.instancePositions.map(p => vec3.transformQuat(vec3.create(), p, this.control.orientation));\n    const scale = 0.25;\n    const SCALE_INTENSITY = 0.6;\n\n    positions.forEach((p, ndx) => {\n      const s = (Math.abs(p[2]) / this.SPHERE_RADIUS) * SCALE_INTENSITY + (1 - SCALE_INTENSITY);\n      const finalScale = s * scale;\n      const matrix = mat4.create();\n\n      mat4.multiply(matrix, matrix, mat4.fromTranslation(mat4.create(), vec3.negate(vec3.create(), p)));\n      mat4.multiply(matrix, matrix, mat4.targetTo(mat4.create(), [0, 0, 0], p, [0, 1, 0]));\n      mat4.multiply(matrix, matrix, mat4.fromScaling(mat4.create(), [finalScale, finalScale, finalScale]));\n      mat4.multiply(matrix, matrix, mat4.fromTranslation(mat4.create(), [0, 0, -this.SPHERE_RADIUS]));\n\n      mat4.copy(this.discInstances.matrices[ndx], matrix);\n    });\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.discInstances.buffer);\n    this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.discInstances.matricesArray);\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n\n    this.smoothRotationVelocity = this.control.rotationVelocity;\n  }\n\n  private render(): void {\n    if (!this.gl || !this.discProgram) return;\n    const gl = this.gl;\n\n    gl.useProgram(this.discProgram);\n    gl.enable(gl.CULL_FACE);\n    gl.enable(gl.DEPTH_TEST);\n\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    gl.uniformMatrix4fv(this.discLocations.uWorldMatrix, false, this.worldMatrix);\n    gl.uniformMatrix4fv(this.discLocations.uViewMatrix, false, this.camera.matrices.view);\n    gl.uniformMatrix4fv(this.discLocations.uProjectionMatrix, false, this.camera.matrices.projection);\n    gl.uniform3f(\n      this.discLocations.uCameraPosition,\n      this.camera.position[0],\n      this.camera.position[1],\n      this.camera.position[2]\n    );\n    gl.uniform4f(\n      this.discLocations.uRotationAxisVelocity,\n      this.control.rotationAxis[0],\n      this.control.rotationAxis[1],\n      this.control.rotationAxis[2],\n      this.smoothRotationVelocity * 1.1\n    );\n\n    gl.uniform1i(this.discLocations.uItemCount, this.items.length);\n    gl.uniform1i(this.discLocations.uAtlasSize, this.atlasSize);\n\n    gl.uniform1f(this.discLocations.uFrames, this._frames);\n    gl.uniform1f(this.discLocations.uScaleFactor, this.scaleFactor);\n\n    gl.uniform1i(this.discLocations.uTex, 0);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.tex);\n\n    gl.bindVertexArray(this.discVAO);\n    gl.drawElementsInstanced(\n      gl.TRIANGLES,\n      this.discBuffers.indices.length,\n      gl.UNSIGNED_SHORT,\n      0,\n      this.DISC_INSTANCE_COUNT\n    );\n    gl.bindVertexArray(null);\n  }\n\n  private updateCameraMatrix(): void {\n    mat4.targetTo(this.camera.matrix, this.camera.position, [0, 0, 0], this.camera.up);\n    mat4.invert(this.camera.matrices.view, this.camera.matrix);\n  }\n\n  private updateProjectionMatrix(): void {\n    if (!this.gl) return;\n    const canvasEl = this.gl.canvas as HTMLCanvasElement;\n    this.camera.aspect = canvasEl.clientWidth / canvasEl.clientHeight;\n    const height = this.SPHERE_RADIUS * 0.35;\n    const distance = this.camera.position[2];\n    if (this.camera.aspect > 1) {\n      this.camera.fov = 2 * Math.atan(height / distance);\n    } else {\n      this.camera.fov = 2 * Math.atan(height / this.camera.aspect / distance);\n    }\n    mat4.perspective(\n      this.camera.matrices.projection,\n      this.camera.fov,\n      this.camera.aspect,\n      this.camera.near,\n      this.camera.far\n    );\n    mat4.invert(this.camera.matrices.inversProjection, this.camera.matrices.projection);\n  }\n\n  private onControlUpdate(deltaTime: number): void {\n    const timeScale = deltaTime / this.TARGET_FRAME_DURATION + 0.0001;\n    let damping = 5 / timeScale;\n    let cameraTargetZ = 3 * this.scaleFactor;\n\n    const isMoving = this.control.isPointerDown || Math.abs(this.smoothRotationVelocity) > 0.01;\n\n    if (isMoving !== this.movementActive) {\n      this.movementActive = isMoving;\n      this.onMovementChange(isMoving);\n    }\n\n    if (!this.control.isPointerDown) {\n      const nearestVertexIndex = this.findNearestVertexIndex();\n      const itemIndex = nearestVertexIndex % Math.max(1, this.items.length);\n      this.onActiveItemChange(itemIndex);\n      const snapDirection = vec3.normalize(vec3.create(), this.getVertexWorldPosition(nearestVertexIndex));\n      this.control.snapTargetDirection = snapDirection;\n    } else {\n      cameraTargetZ += this.control.rotationVelocity * 80 + 2.5;\n      damping = 7 / timeScale;\n    }\n\n    this.camera.position[2] += (cameraTargetZ - this.camera.position[2]) / damping;\n    this.updateCameraMatrix();\n  }\n\n  private findNearestVertexIndex(): number {\n    const n = this.control.snapDirection;\n    const inversOrientation = quat.conjugate(quat.create(), this.control.orientation);\n    const nt = vec3.transformQuat(vec3.create(), n, inversOrientation);\n\n    let maxD = -1;\n    let nearestVertexIndex = 0;\n    for (let i = 0; i < this.instancePositions.length; ++i) {\n      const d = vec3.dot(nt, this.instancePositions[i]);\n      if (d > maxD) {\n        maxD = d;\n        nearestVertexIndex = i;\n      }\n    }\n    return nearestVertexIndex;\n  }\n\n  private getVertexWorldPosition(index: number): vec3 {\n    const nearestVertexPos = this.instancePositions[index];\n    return vec3.transformQuat(vec3.create(), nearestVertexPos, this.control.orientation);\n  }\n}\n\nconst defaultItems: MenuItem[] = [\n  {\n    image: 'https://picsum.photos/900/900?grayscale',\n    link: 'https://google.com/',\n    title: '',\n    description: ''\n  }\n];\n\ninterface InfiniteMenuProps {\n  items?: MenuItem[];\n  scale?: number;\n}\n\nconst InfiniteMenu: FC<InfiniteMenuProps> = ({ items = [], scale = 1.0 }) => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null) as MutableRefObject<HTMLCanvasElement | null>;\n  const [activeItem, setActiveItem] = useState<MenuItem | null>(null);\n  const [isMoving, setIsMoving] = useState<boolean>(false);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    let sketch: InfiniteGridMenu | null = null;\n\n    const handleActiveItem = (index: number) => {\n      if (!items.length) return;\n      const itemIndex = index % items.length;\n      setActiveItem(items[itemIndex]);\n    };\n\n    if (canvas) {\n      sketch = new InfiniteGridMenu(\n        canvas,\n        items.length ? items : defaultItems,\n        handleActiveItem,\n        setIsMoving,\n        sk => sk.run(),\n        scale\n      );\n    }\n\n    const handleResize = () => {\n      if (sketch) {\n        sketch.resize();\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n    handleResize();\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [items, scale]);\n\n  const handleButtonClick = () => {\n    if (!activeItem?.link) return;\n    if (activeItem.link.startsWith('http')) {\n      window.open(activeItem.link, '_blank');\n    } else {\n      console.log('Internal route:', activeItem.link);\n    }\n  };\n\n  return (\n    <div className=\"relative w-full h-full\">\n      <canvas\n        id=\"infinite-grid-menu-canvas\"\n        ref={canvasRef}\n        className=\"cursor-grab w-full h-full overflow-hidden relative outline-none active:cursor-grabbing\"\n      />\n\n      {activeItem && (\n        <>\n          <h2\n            className={`\n          select-none\n          absolute\n          font-black\n          [font-size:4rem]\n          left-[1.6em]\n          top-1/2\n          transform\n          translate-x-[20%]\n          -translate-y-1/2\n          transition-all\n          ease-[cubic-bezier(0.25,0.1,0.25,1.0)]\n          ${\n            isMoving\n              ? 'opacity-0 pointer-events-none duration-[100ms]'\n              : 'opacity-100 pointer-events-auto duration-[500ms]'\n          }\n        `}\n          >\n            {activeItem.title}\n          </h2>\n\n          <p\n            className={`\n          select-none\n          absolute\n          max-w-[10ch]\n          text-[1.5rem]\n          top-1/2\n          right-[1%]\n          transition-all\n          ease-[cubic-bezier(0.25,0.1,0.25,1.0)]\n          ${\n            isMoving\n              ? 'opacity-0 pointer-events-none duration-[100ms] translate-x-[-60%] -translate-y-1/2'\n              : 'opacity-100 pointer-events-auto duration-[500ms] translate-x-[-90%] -translate-y-1/2'\n          }\n        `}\n          >\n            {activeItem.description}\n          </p>\n\n          <div\n            onClick={handleButtonClick}\n            className={`\n          absolute\n          left-1/2\n          z-10\n          w-[60px]\n          h-[60px]\n          grid\n          place-items-center\n          bg-[#00ffff]\n          border-[5px]\n          border-black\n          rounded-full\n          cursor-pointer\n          transition-all\n          ease-[cubic-bezier(0.25,0.1,0.25,1.0)]\n          ${\n            isMoving\n              ? 'bottom-[-80px] opacity-0 pointer-events-none duration-[100ms] scale-0 -translate-x-1/2'\n              : 'bottom-[3.8em] opacity-100 pointer-events-auto duration-[500ms] scale-100 -translate-x-1/2'\n          }\n        `}\n          >\n            <p className=\"select-none relative text-[#060010] top-[2px] text-[26px]\">&#x2197;</p>\n          </div>\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default InfiniteMenu;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "lanyard",
      "type": "component",
      "description": "A layouts lanyard component",
      "category": "layouts",
      "dependencies": [
        "three",
        "@react-three/fiber",
        "@react-three/drei",
        "@react-three/rapier",
        "meshline"
      ],
      "files": [
        {
          "path": "components/ui/lanyard.tsx",
          "content": "/* eslint-disable react/no-unknown-property */\n'use client';\nimport { useEffect, useRef, useState } from 'react';\nimport { Canvas, extend, useFrame } from '@react-three/fiber';\nimport { useGLTF, useTexture, Environment, Lightformer } from '@react-three/drei';\nimport {\n  BallCollider,\n  CuboidCollider,\n  Physics,\n  RigidBody,\n  useRopeJoint,\n  useSphericalJoint,\n  RigidBodyProps\n} from '@react-three/rapier';\nimport { MeshLineGeometry, MeshLineMaterial } from 'meshline';\nimport * as THREE from 'three';\n\ndeclare module '@react-three/fiber' {\n  interface ThreeElements {\n    meshLineGeometry: any;\n    meshLineMaterial: any;\n  }\n}\n\n// replace with your own imports, see the usage snippet for details\nconst cardGLB = '/assets/card.glb';\nconst lanyard = '/assets/lanyard.png';\n\nextend({ MeshLineGeometry, MeshLineMaterial });\n\ninterface LanyardProps {\n  position?: [number, number, number];\n  gravity?: [number, number, number];\n  fov?: number;\n  transparent?: boolean;\n}\n\nexport default function Lanyard({\n  position = [0, 0, 30],\n  gravity = [0, -40, 0],\n  fov = 20,\n  transparent = true\n}: LanyardProps) {\n  const [isMobile, setIsMobile] = useState<boolean>(() => typeof window !== 'undefined' && window.innerWidth < 768);\n\n  useEffect(() => {\n    const handleResize = (): void => setIsMobile(window.innerWidth < 768);\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return (\n    <div className=\"relative z-0 w-full h-screen flex justify-center items-center transform scale-100 origin-center\">\n      <Canvas\n        camera={{ position, fov }}\n        dpr={[1, isMobile ? 1.5 : 2]}\n        gl={{ alpha: transparent }}\n        onCreated={({ gl }) => gl.setClearColor(new THREE.Color(0x000000), transparent ? 0 : 1)}\n      >\n        <ambientLight intensity={Math.PI} />\n        <Physics gravity={gravity} timeStep={isMobile ? 1 / 30 : 1 / 60}>\n          <Band isMobile={isMobile} />\n        </Physics>\n        <Environment blur={0.75}>\n          <Lightformer\n            intensity={2}\n            color=\"white\"\n            position={[0, -1, 5]}\n            rotation={[0, 0, Math.PI / 3]}\n            scale={[100, 0.1, 1]}\n          />\n          <Lightformer\n            intensity={3}\n            color=\"white\"\n            position={[-1, -1, 1]}\n            rotation={[0, 0, Math.PI / 3]}\n            scale={[100, 0.1, 1]}\n          />\n          <Lightformer\n            intensity={3}\n            color=\"white\"\n            position={[1, 1, 1]}\n            rotation={[0, 0, Math.PI / 3]}\n            scale={[100, 0.1, 1]}\n          />\n          <Lightformer\n            intensity={10}\n            color=\"white\"\n            position={[-10, 0, 14]}\n            rotation={[0, Math.PI / 2, Math.PI / 3]}\n            scale={[100, 10, 1]}\n          />\n        </Environment>\n      </Canvas>\n    </div>\n  );\n}\n\ninterface BandProps {\n  maxSpeed?: number;\n  minSpeed?: number;\n  isMobile?: boolean;\n}\n\nfunction Band({ maxSpeed = 50, minSpeed = 0, isMobile = false }: BandProps) {\n  // Using \"any\" for refs since the exact types depend on Rapier's internals\n  const band = useRef<any>(null);\n  const fixed = useRef<any>(null);\n  const j1 = useRef<any>(null);\n  const j2 = useRef<any>(null);\n  const j3 = useRef<any>(null);\n  const card = useRef<any>(null);\n\n  const vec = new THREE.Vector3();\n  const ang = new THREE.Vector3();\n  const rot = new THREE.Vector3();\n  const dir = new THREE.Vector3();\n\n  const segmentProps: any = {\n    type: 'dynamic' as RigidBodyProps['type'],\n    canSleep: true,\n    colliders: false,\n    angularDamping: 4,\n    linearDamping: 4\n  };\n\n  const { nodes, materials } = useGLTF(cardGLB) as any;\n  const texture = useTexture(lanyard);\n  const [curve] = useState(\n    () =>\n      new THREE.CatmullRomCurve3([new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()])\n  );\n  const [dragged, drag] = useState<false | THREE.Vector3>(false);\n  const [hovered, hover] = useState(false);\n\n  useRopeJoint(fixed, j1, [[0, 0, 0], [0, 0, 0], 1]);\n  useRopeJoint(j1, j2, [[0, 0, 0], [0, 0, 0], 1]);\n  useRopeJoint(j2, j3, [[0, 0, 0], [0, 0, 0], 1]);\n  useSphericalJoint(j3, card, [\n    [0, 0, 0],\n    [0, 1.45, 0]\n  ]);\n\n  useEffect(() => {\n    if (hovered) {\n      document.body.style.cursor = dragged ? 'grabbing' : 'grab';\n      return () => {\n        document.body.style.cursor = 'auto';\n      };\n    }\n  }, [hovered, dragged]);\n\n  useFrame((state, delta) => {\n    if (dragged && typeof dragged !== 'boolean') {\n      vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(state.camera);\n      dir.copy(vec).sub(state.camera.position).normalize();\n      vec.add(dir.multiplyScalar(state.camera.position.length()));\n      [card, j1, j2, j3, fixed].forEach(ref => ref.current?.wakeUp());\n      card.current?.setNextKinematicTranslation({\n        x: vec.x - dragged.x,\n        y: vec.y - dragged.y,\n        z: vec.z - dragged.z\n      });\n    }\n    if (fixed.current) {\n      [j1, j2].forEach(ref => {\n        if (!ref.current.lerped) ref.current.lerped = new THREE.Vector3().copy(ref.current.translation());\n        const clampedDistance = Math.max(0.1, Math.min(1, ref.current.lerped.distanceTo(ref.current.translation())));\n        ref.current.lerped.lerp(\n          ref.current.translation(),\n          delta * (minSpeed + clampedDistance * (maxSpeed - minSpeed))\n        );\n      });\n      curve.points[0].copy(j3.current.translation());\n      curve.points[1].copy(j2.current.lerped);\n      curve.points[2].copy(j1.current.lerped);\n      curve.points[3].copy(fixed.current.translation());\n      band.current.geometry.setPoints(curve.getPoints(isMobile ? 16 : 32));\n      ang.copy(card.current.angvel());\n      rot.copy(card.current.rotation());\n      card.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z });\n    }\n  });\n\n  curve.curveType = 'chordal';\n  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\n  return (\n    <>\n      <group position={[0, 4, 0]}>\n        <RigidBody ref={fixed} {...segmentProps} type={'fixed' as RigidBodyProps['type']} />\n        <RigidBody position={[0.5, 0, 0]} ref={j1} {...segmentProps} type={'dynamic' as RigidBodyProps['type']}>\n          <BallCollider args={[0.1]} />\n        </RigidBody>\n        <RigidBody position={[1, 0, 0]} ref={j2} {...segmentProps} type={'dynamic' as RigidBodyProps['type']}>\n          <BallCollider args={[0.1]} />\n        </RigidBody>\n        <RigidBody position={[1.5, 0, 0]} ref={j3} {...segmentProps} type={'dynamic' as RigidBodyProps['type']}>\n          <BallCollider args={[0.1]} />\n        </RigidBody>\n        <RigidBody\n          position={[2, 0, 0]}\n          ref={card}\n          {...segmentProps}\n          type={dragged ? ('kinematicPosition' as RigidBodyProps['type']) : ('dynamic' as RigidBodyProps['type'])}\n        >\n          <CuboidCollider args={[0.8, 1.125, 0.01]} />\n          <group\n            scale={2.25}\n            position={[0, -1.2, -0.05]}\n            onPointerOver={() => hover(true)}\n            onPointerOut={() => hover(false)}\n            onPointerUp={(e: any) => {\n              e.target.releasePointerCapture(e.pointerId);\n              drag(false);\n            }}\n            onPointerDown={(e: any) => {\n              e.target.setPointerCapture(e.pointerId);\n              drag(new THREE.Vector3().copy(e.point).sub(vec.copy(card.current.translation())));\n            }}\n          >\n            <mesh geometry={nodes.card.geometry}>\n              <meshPhysicalMaterial\n                map={materials.base.map}\n                map-anisotropy={16}\n                clearcoat={isMobile ? 0 : 1}\n                clearcoatRoughness={0.15}\n                roughness={0.9}\n                metalness={0.8}\n              />\n            </mesh>\n            <mesh geometry={nodes.clip.geometry} material={materials.metal} material-roughness={0.3} />\n            <mesh geometry={nodes.clamp.geometry} material={materials.metal} />\n          </group>\n        </RigidBody>\n      </group>\n      <mesh ref={band}>\n        <meshLineGeometry />\n        <meshLineMaterial\n          color=\"white\"\n          depthTest={false}\n          resolution={isMobile ? [1000, 2000] : [1000, 1000]}\n          useMap\n          map={texture}\n          repeat={[-4, 1]}\n          lineWidth={1}\n        />\n      </mesh>\n    </>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "magic-bento",
      "type": "component",
      "description": "A layouts magic bento component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/magic-bento.tsx",
          "content": "import React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { gsap } from 'gsap';\n\nexport interface BentoCardProps {\n  color?: string;\n  title?: string;\n  description?: string;\n  label?: string;\n  textAutoHide?: boolean;\n  disableAnimations?: boolean;\n}\n\nexport interface BentoProps {\n  textAutoHide?: boolean;\n  enableStars?: boolean;\n  enableSpotlight?: boolean;\n  enableBorderGlow?: boolean;\n  disableAnimations?: boolean;\n  spotlightRadius?: number;\n  particleCount?: number;\n  enableTilt?: boolean;\n  glowColor?: string;\n  clickEffect?: boolean;\n  enableMagnetism?: boolean;\n}\n\nconst DEFAULT_PARTICLE_COUNT = 12;\nconst DEFAULT_SPOTLIGHT_RADIUS = 300;\nconst DEFAULT_GLOW_COLOR = '132, 0, 255';\nconst MOBILE_BREAKPOINT = 768;\n\nconst cardData: BentoCardProps[] = [\n  {\n    color: '#060010',\n    title: 'Analytics',\n    description: 'Track user behavior',\n    label: 'Insights'\n  },\n  {\n    color: '#060010',\n    title: 'Dashboard',\n    description: 'Centralized data view',\n    label: 'Overview'\n  },\n  {\n    color: '#060010',\n    title: 'Collaboration',\n    description: 'Work together seamlessly',\n    label: 'Teamwork'\n  },\n  {\n    color: '#060010',\n    title: 'Automation',\n    description: 'Streamline workflows',\n    label: 'Efficiency'\n  },\n  {\n    color: '#060010',\n    title: 'Integration',\n    description: 'Connect favorite tools',\n    label: 'Connectivity'\n  },\n  {\n    color: '#060010',\n    title: 'Security',\n    description: 'Enterprise-grade protection',\n    label: 'Protection'\n  }\n];\n\nconst createParticleElement = (x: number, y: number, color: string = DEFAULT_GLOW_COLOR): HTMLDivElement => {\n  const el = document.createElement('div');\n  el.className = 'particle';\n  el.style.cssText = `\n    position: absolute;\n    width: 4px;\n    height: 4px;\n    border-radius: 50%;\n    background: rgba(${color}, 1);\n    box-shadow: 0 0 6px rgba(${color}, 0.6);\n    pointer-events: none;\n    z-index: 100;\n    left: ${x}px;\n    top: ${y}px;\n  `;\n  return el;\n};\n\nconst calculateSpotlightValues = (radius: number) => ({\n  proximity: radius * 0.5,\n  fadeDistance: radius * 0.75\n});\n\nconst updateCardGlowProperties = (card: HTMLElement, mouseX: number, mouseY: number, glow: number, radius: number) => {\n  const rect = card.getBoundingClientRect();\n  const relativeX = ((mouseX - rect.left) / rect.width) * 100;\n  const relativeY = ((mouseY - rect.top) / rect.height) * 100;\n\n  card.style.setProperty('--glow-x', `${relativeX}%`);\n  card.style.setProperty('--glow-y', `${relativeY}%`);\n  card.style.setProperty('--glow-intensity', glow.toString());\n  card.style.setProperty('--glow-radius', `${radius}px`);\n};\n\nconst ParticleCard: React.FC<{\n  children: React.ReactNode;\n  className?: string;\n  disableAnimations?: boolean;\n  style?: React.CSSProperties;\n  particleCount?: number;\n  glowColor?: string;\n  enableTilt?: boolean;\n  clickEffect?: boolean;\n  enableMagnetism?: boolean;\n}> = ({\n  children,\n  className = '',\n  disableAnimations = false,\n  style,\n  particleCount = DEFAULT_PARTICLE_COUNT,\n  glowColor = DEFAULT_GLOW_COLOR,\n  enableTilt = true,\n  clickEffect = false,\n  enableMagnetism = false\n}) => {\n  const cardRef = useRef<HTMLDivElement>(null);\n  const particlesRef = useRef<HTMLDivElement[]>([]);\n  const timeoutsRef = useRef<ReturnType<typeof setTimeout>[]>([]);\n  const isHoveredRef = useRef(false);\n  const memoizedParticles = useRef<HTMLDivElement[]>([]);\n  const particlesInitialized = useRef(false);\n  const magnetismAnimationRef = useRef<gsap.core.Tween | null>(null);\n\n  const initializeParticles = useCallback(() => {\n    if (particlesInitialized.current || !cardRef.current) return;\n\n    const { width, height } = cardRef.current.getBoundingClientRect();\n    memoizedParticles.current = Array.from({ length: particleCount }, () =>\n      createParticleElement(Math.random() * width, Math.random() * height, glowColor)\n    );\n    particlesInitialized.current = true;\n  }, [particleCount, glowColor]);\n\n  const clearAllParticles = useCallback(() => {\n    timeoutsRef.current.forEach(clearTimeout);\n    timeoutsRef.current = [];\n    magnetismAnimationRef.current?.kill();\n\n    particlesRef.current.forEach(particle => {\n      gsap.to(particle, {\n        scale: 0,\n        opacity: 0,\n        duration: 0.3,\n        ease: 'back.in(1.7)',\n        onComplete: () => {\n          particle.parentNode?.removeChild(particle);\n        }\n      });\n    });\n    particlesRef.current = [];\n  }, []);\n\n  const animateParticles = useCallback(() => {\n    if (!cardRef.current || !isHoveredRef.current) return;\n\n    if (!particlesInitialized.current) {\n      initializeParticles();\n    }\n\n    memoizedParticles.current.forEach((particle, index) => {\n      const timeoutId = setTimeout(() => {\n        if (!isHoveredRef.current || !cardRef.current) return;\n\n        const clone = particle.cloneNode(true) as HTMLDivElement;\n        cardRef.current.appendChild(clone);\n        particlesRef.current.push(clone);\n\n        gsap.fromTo(clone, { scale: 0, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.3, ease: 'back.out(1.7)' });\n\n        gsap.to(clone, {\n          x: (Math.random() - 0.5) * 100,\n          y: (Math.random() - 0.5) * 100,\n          rotation: Math.random() * 360,\n          duration: 2 + Math.random() * 2,\n          ease: 'none',\n          repeat: -1,\n          yoyo: true\n        });\n\n        gsap.to(clone, {\n          opacity: 0.3,\n          duration: 1.5,\n          ease: 'power2.inOut',\n          repeat: -1,\n          yoyo: true\n        });\n      }, index * 100);\n\n      timeoutsRef.current.push(timeoutId);\n    });\n  }, [initializeParticles]);\n\n  useEffect(() => {\n    if (disableAnimations || !cardRef.current) return;\n\n    const element = cardRef.current;\n\n    const handleMouseEnter = () => {\n      isHoveredRef.current = true;\n      animateParticles();\n\n      if (enableTilt) {\n        gsap.to(element, {\n          rotateX: 5,\n          rotateY: 5,\n          duration: 0.3,\n          ease: 'power2.out',\n          transformPerspective: 1000\n        });\n      }\n    };\n\n    const handleMouseLeave = () => {\n      isHoveredRef.current = false;\n      clearAllParticles();\n\n      if (enableTilt) {\n        gsap.to(element, {\n          rotateX: 0,\n          rotateY: 0,\n          duration: 0.3,\n          ease: 'power2.out'\n        });\n      }\n\n      if (enableMagnetism) {\n        gsap.to(element, {\n          x: 0,\n          y: 0,\n          duration: 0.3,\n          ease: 'power2.out'\n        });\n      }\n    };\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!enableTilt && !enableMagnetism) return;\n\n      const rect = element.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const centerX = rect.width / 2;\n      const centerY = rect.height / 2;\n\n      if (enableTilt) {\n        const rotateX = ((y - centerY) / centerY) * -10;\n        const rotateY = ((x - centerX) / centerX) * 10;\n\n        gsap.to(element, {\n          rotateX,\n          rotateY,\n          duration: 0.1,\n          ease: 'power2.out',\n          transformPerspective: 1000\n        });\n      }\n\n      if (enableMagnetism) {\n        const magnetX = (x - centerX) * 0.05;\n        const magnetY = (y - centerY) * 0.05;\n\n        magnetismAnimationRef.current = gsap.to(element, {\n          x: magnetX,\n          y: magnetY,\n          duration: 0.3,\n          ease: 'power2.out'\n        });\n      }\n    };\n\n    const handleClick = (e: MouseEvent) => {\n      if (!clickEffect) return;\n\n      const rect = element.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n\n      const maxDistance = Math.max(\n        Math.hypot(x, y),\n        Math.hypot(x - rect.width, y),\n        Math.hypot(x, y - rect.height),\n        Math.hypot(x - rect.width, y - rect.height)\n      );\n\n      const ripple = document.createElement('div');\n      ripple.style.cssText = `\n        position: absolute;\n        width: ${maxDistance * 2}px;\n        height: ${maxDistance * 2}px;\n        border-radius: 50%;\n        background: radial-gradient(circle, rgba(${glowColor}, 0.4) 0%, rgba(${glowColor}, 0.2) 30%, transparent 70%);\n        left: ${x - maxDistance}px;\n        top: ${y - maxDistance}px;\n        pointer-events: none;\n        z-index: 1000;\n      `;\n\n      element.appendChild(ripple);\n\n      gsap.fromTo(\n        ripple,\n        {\n          scale: 0,\n          opacity: 1\n        },\n        {\n          scale: 1,\n          opacity: 0,\n          duration: 0.8,\n          ease: 'power2.out',\n          onComplete: () => ripple.remove()\n        }\n      );\n    };\n\n    element.addEventListener('mouseenter', handleMouseEnter);\n    element.addEventListener('mouseleave', handleMouseLeave);\n    element.addEventListener('mousemove', handleMouseMove);\n    element.addEventListener('click', handleClick);\n\n    return () => {\n      isHoveredRef.current = false;\n      element.removeEventListener('mouseenter', handleMouseEnter);\n      element.removeEventListener('mouseleave', handleMouseLeave);\n      element.removeEventListener('mousemove', handleMouseMove);\n      element.removeEventListener('click', handleClick);\n      clearAllParticles();\n    };\n  }, [animateParticles, clearAllParticles, disableAnimations, enableTilt, enableMagnetism, clickEffect, glowColor]);\n\n  return (\n    <div\n      ref={cardRef}\n      className={`${className} relative overflow-hidden`}\n      style={{ ...style, position: 'relative', overflow: 'hidden' }}\n    >\n      {children}\n    </div>\n  );\n};\n\nconst GlobalSpotlight: React.FC<{\n  gridRef: React.RefObject<HTMLDivElement | null>;\n  disableAnimations?: boolean;\n  enabled?: boolean;\n  spotlightRadius?: number;\n  glowColor?: string;\n}> = ({\n  gridRef,\n  disableAnimations = false,\n  enabled = true,\n  spotlightRadius = DEFAULT_SPOTLIGHT_RADIUS,\n  glowColor = DEFAULT_GLOW_COLOR\n}) => {\n  const spotlightRef = useRef<HTMLDivElement | null>(null);\n  const isInsideSection = useRef(false);\n\n  useEffect(() => {\n    if (disableAnimations || !gridRef?.current || !enabled) return;\n\n    const spotlight = document.createElement('div');\n    spotlight.className = 'global-spotlight';\n    spotlight.style.cssText = `\n      position: fixed;\n      width: 800px;\n      height: 800px;\n      border-radius: 50%;\n      pointer-events: none;\n      background: radial-gradient(circle,\n        rgba(${glowColor}, 0.15) 0%,\n        rgba(${glowColor}, 0.08) 15%,\n        rgba(${glowColor}, 0.04) 25%,\n        rgba(${glowColor}, 0.02) 40%,\n        rgba(${glowColor}, 0.01) 65%,\n        transparent 70%\n      );\n      z-index: 200;\n      opacity: 0;\n      transform: translate(-50%, -50%);\n      mix-blend-mode: screen;\n    `;\n    document.body.appendChild(spotlight);\n    spotlightRef.current = spotlight;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!spotlightRef.current || !gridRef.current) return;\n\n      const section = gridRef.current.closest('.bento-section');\n      const rect = section?.getBoundingClientRect();\n      const mouseInside =\n        rect && e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;\n\n      isInsideSection.current = mouseInside || false;\n      const cards = gridRef.current.querySelectorAll('.card');\n\n      if (!mouseInside) {\n        gsap.to(spotlightRef.current, {\n          opacity: 0,\n          duration: 0.3,\n          ease: 'power2.out'\n        });\n        cards.forEach(card => {\n          (card as HTMLElement).style.setProperty('--glow-intensity', '0');\n        });\n        return;\n      }\n\n      const { proximity, fadeDistance } = calculateSpotlightValues(spotlightRadius);\n      let minDistance = Infinity;\n\n      cards.forEach(card => {\n        const cardElement = card as HTMLElement;\n        const cardRect = cardElement.getBoundingClientRect();\n        const centerX = cardRect.left + cardRect.width / 2;\n        const centerY = cardRect.top + cardRect.height / 2;\n        const distance =\n          Math.hypot(e.clientX - centerX, e.clientY - centerY) - Math.max(cardRect.width, cardRect.height) / 2;\n        const effectiveDistance = Math.max(0, distance);\n\n        minDistance = Math.min(minDistance, effectiveDistance);\n\n        let glowIntensity = 0;\n        if (effectiveDistance <= proximity) {\n          glowIntensity = 1;\n        } else if (effectiveDistance <= fadeDistance) {\n          glowIntensity = (fadeDistance - effectiveDistance) / (fadeDistance - proximity);\n        }\n\n        updateCardGlowProperties(cardElement, e.clientX, e.clientY, glowIntensity, spotlightRadius);\n      });\n\n      gsap.to(spotlightRef.current, {\n        left: e.clientX,\n        top: e.clientY,\n        duration: 0.1,\n        ease: 'power2.out'\n      });\n\n      const targetOpacity =\n        minDistance <= proximity\n          ? 0.8\n          : minDistance <= fadeDistance\n            ? ((fadeDistance - minDistance) / (fadeDistance - proximity)) * 0.8\n            : 0;\n\n      gsap.to(spotlightRef.current, {\n        opacity: targetOpacity,\n        duration: targetOpacity > 0 ? 0.2 : 0.5,\n        ease: 'power2.out'\n      });\n    };\n\n    const handleMouseLeave = () => {\n      isInsideSection.current = false;\n      gridRef.current?.querySelectorAll('.card').forEach(card => {\n        (card as HTMLElement).style.setProperty('--glow-intensity', '0');\n      });\n      if (spotlightRef.current) {\n        gsap.to(spotlightRef.current, {\n          opacity: 0,\n          duration: 0.3,\n          ease: 'power2.out'\n        });\n      }\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseleave', handleMouseLeave);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseleave', handleMouseLeave);\n      spotlightRef.current?.parentNode?.removeChild(spotlightRef.current);\n    };\n  }, [gridRef, disableAnimations, enabled, spotlightRadius, glowColor]);\n\n  return null;\n};\n\nconst BentoCardGrid: React.FC<{\n  children: React.ReactNode;\n  gridRef?: React.RefObject<HTMLDivElement | null>;\n}> = ({ children, gridRef }) => (\n  <div\n    className=\"bento-section grid gap-2 p-3 max-w-[54rem] select-none relative\"\n    style={{ fontSize: 'clamp(1rem, 0.9rem + 0.5vw, 1.5rem)' }}\n    ref={gridRef}\n  >\n    {children}\n  </div>\n);\n\nconst useMobileDetection = () => {\n  const [isMobile, setIsMobile] = useState(false);\n\n  useEffect(() => {\n    const checkMobile = () => setIsMobile(window.innerWidth <= MOBILE_BREAKPOINT);\n\n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n\n  return isMobile;\n};\n\nconst MagicBento: React.FC<BentoProps> = ({\n  textAutoHide = true,\n  enableStars = true,\n  enableSpotlight = true,\n  enableBorderGlow = true,\n  disableAnimations = false,\n  spotlightRadius = DEFAULT_SPOTLIGHT_RADIUS,\n  particleCount = DEFAULT_PARTICLE_COUNT,\n  enableTilt = false,\n  glowColor = DEFAULT_GLOW_COLOR,\n  clickEffect = true,\n  enableMagnetism = true\n}) => {\n  const gridRef = useRef<HTMLDivElement>(null);\n  const isMobile = useMobileDetection();\n  const shouldDisableAnimations = disableAnimations || isMobile;\n\n  return (\n    <>\n      <style>\n        {`\n          .bento-section {\n            --glow-x: 50%;\n            --glow-y: 50%;\n            --glow-intensity: 0;\n            --glow-radius: 200px;\n            --glow-color: ${glowColor};\n            --border-color: #392e4e;\n            --background-dark: #060010;\n            --white: hsl(0, 0%, 100%);\n            --purple-primary: rgba(132, 0, 255, 1);\n            --purple-glow: rgba(132, 0, 255, 0.2);\n            --purple-border: rgba(132, 0, 255, 0.8);\n          }\n          \n          .card-responsive {\n            grid-template-columns: 1fr;\n            width: 90%;\n            margin: 0 auto;\n            padding: 0.5rem;\n          }\n          \n          @media (min-width: 600px) {\n            .card-responsive {\n              grid-template-columns: repeat(2, 1fr);\n            }\n          }\n          \n          @media (min-width: 1024px) {\n            .card-responsive {\n              grid-template-columns: repeat(4, 1fr);\n            }\n            \n            .card-responsive .card:nth-child(3) {\n              grid-column: span 2;\n              grid-row: span 2;\n            }\n            \n            .card-responsive .card:nth-child(4) {\n              grid-column: 1 / span 2;\n              grid-row: 2 / span 2;\n            }\n            \n            .card-responsive .card:nth-child(6) {\n              grid-column: 4;\n              grid-row: 3;\n            }\n          }\n          \n          .card--border-glow::after {\n            content: '';\n            position: absolute;\n            inset: 0;\n            padding: 6px;\n            background: radial-gradient(var(--glow-radius) circle at var(--glow-x) var(--glow-y),\n                rgba(${glowColor}, calc(var(--glow-intensity) * 0.8)) 0%,\n                rgba(${glowColor}, calc(var(--glow-intensity) * 0.4)) 30%,\n                transparent 60%);\n            border-radius: inherit;\n            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);\n            -webkit-mask-composite: xor;\n            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);\n            mask-composite: exclude;\n            pointer-events: none;\n            opacity: 1;\n            transition: opacity 0.3s ease;\n            z-index: 1;\n          }\n          \n          .card--border-glow:hover::after {\n            opacity: 1;\n          }\n          \n          .card--border-glow:hover {\n            box-shadow: 0 4px 20px rgba(46, 24, 78, 0.4), 0 0 30px rgba(${glowColor}, 0.2);\n          }\n          \n          .particle::before {\n            content: '';\n            position: absolute;\n            top: -2px;\n            left: -2px;\n            right: -2px;\n            bottom: -2px;\n            background: rgba(${glowColor}, 0.2);\n            border-radius: 50%;\n            z-index: -1;\n          }\n          \n          .particle-container:hover {\n            box-shadow: 0 4px 20px rgba(46, 24, 78, 0.2), 0 0 30px rgba(${glowColor}, 0.2);\n          }\n          \n          .text-clamp-1 {\n            display: -webkit-box;\n            -webkit-box-orient: vertical;\n            -webkit-line-clamp: 1;\n            line-clamp: 1;\n            overflow: hidden;\n            text-overflow: ellipsis;\n          }\n          \n          .text-clamp-2 {\n            display: -webkit-box;\n            -webkit-box-orient: vertical;\n            -webkit-line-clamp: 2;\n            line-clamp: 2;\n            overflow: hidden;\n            text-overflow: ellipsis;\n          }\n          \n          @media (max-width: 599px) {\n            .card-responsive {\n              grid-template-columns: 1fr;\n              width: 90%;\n              margin: 0 auto;\n              padding: 0.5rem;\n            }\n            \n            .card-responsive .card {\n              width: 100%;\n              min-height: 180px;\n            }\n          }\n        `}\n      </style>\n\n      {enableSpotlight && (\n        <GlobalSpotlight\n          gridRef={gridRef}\n          disableAnimations={shouldDisableAnimations}\n          enabled={enableSpotlight}\n          spotlightRadius={spotlightRadius}\n          glowColor={glowColor}\n        />\n      )}\n\n      <BentoCardGrid gridRef={gridRef}>\n        <div className=\"card-responsive grid gap-2\">\n          {cardData.map((card, index) => {\n            const baseClassName = `card flex flex-col justify-between relative aspect-[4/3] min-h-[200px] w-full max-w-full p-5 rounded-[20px] border border-solid font-light overflow-hidden transition-colors duration-300 ease-in-out hover:-translate-y-0.5 hover:shadow-[0_8px_25px_rgba(0,0,0,0.15)] ${\n              enableBorderGlow ? 'card--border-glow' : ''\n            }`;\n\n            const cardStyle = {\n              backgroundColor: card.color || 'var(--background-dark)',\n              borderColor: 'var(--border-color)',\n              color: 'var(--white)',\n              '--glow-x': '50%',\n              '--glow-y': '50%',\n              '--glow-intensity': '0',\n              '--glow-radius': '200px'\n            } as React.CSSProperties;\n\n            if (enableStars) {\n              return (\n                <ParticleCard\n                  key={index}\n                  className={baseClassName}\n                  style={cardStyle}\n                  disableAnimations={shouldDisableAnimations}\n                  particleCount={particleCount}\n                  glowColor={glowColor}\n                  enableTilt={enableTilt}\n                  clickEffect={clickEffect}\n                  enableMagnetism={enableMagnetism}\n                >\n                  <div className=\"card__header flex justify-between gap-3 relative text-white\">\n                    <span className=\"card__label text-base\">{card.label}</span>\n                  </div>\n                  <div className=\"card__content flex flex-col relative text-white\">\n                    <h3 className={`card__title font-normal text-base m-0 mb-1 ${textAutoHide ? 'text-clamp-1' : ''}`}>\n                      {card.title}\n                    </h3>\n                    <p\n                      className={`card__description text-xs leading-5 opacity-90 ${textAutoHide ? 'text-clamp-2' : ''}`}\n                    >\n                      {card.description}\n                    </p>\n                  </div>\n                </ParticleCard>\n              );\n            }\n\n            return (\n              <div\n                key={index}\n                className={baseClassName}\n                style={cardStyle}\n                ref={el => {\n                  if (!el) return;\n\n                  const handleMouseMove = (e: MouseEvent) => {\n                    if (shouldDisableAnimations) return;\n\n                    const rect = el.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    const centerX = rect.width / 2;\n                    const centerY = rect.height / 2;\n\n                    if (enableTilt) {\n                      const rotateX = ((y - centerY) / centerY) * -10;\n                      const rotateY = ((x - centerX) / centerX) * 10;\n\n                      gsap.to(el, {\n                        rotateX,\n                        rotateY,\n                        duration: 0.1,\n                        ease: 'power2.out',\n                        transformPerspective: 1000\n                      });\n                    }\n\n                    if (enableMagnetism) {\n                      const magnetX = (x - centerX) * 0.05;\n                      const magnetY = (y - centerY) * 0.05;\n\n                      gsap.to(el, {\n                        x: magnetX,\n                        y: magnetY,\n                        duration: 0.3,\n                        ease: 'power2.out'\n                      });\n                    }\n                  };\n\n                  const handleMouseLeave = () => {\n                    if (shouldDisableAnimations) return;\n\n                    if (enableTilt) {\n                      gsap.to(el, {\n                        rotateX: 0,\n                        rotateY: 0,\n                        duration: 0.3,\n                        ease: 'power2.out'\n                      });\n                    }\n\n                    if (enableMagnetism) {\n                      gsap.to(el, {\n                        x: 0,\n                        y: 0,\n                        duration: 0.3,\n                        ease: 'power2.out'\n                      });\n                    }\n                  };\n\n                  const handleClick = (e: MouseEvent) => {\n                    if (!clickEffect || shouldDisableAnimations) return;\n\n                    const rect = el.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n\n                    const maxDistance = Math.max(\n                      Math.hypot(x, y),\n                      Math.hypot(x - rect.width, y),\n                      Math.hypot(x, y - rect.height),\n                      Math.hypot(x - rect.width, y - rect.height)\n                    );\n\n                    const ripple = document.createElement('div');\n                    ripple.style.cssText = `\n                      position: absolute;\n                      width: ${maxDistance * 2}px;\n                      height: ${maxDistance * 2}px;\n                      border-radius: 50%;\n                      background: radial-gradient(circle, rgba(${glowColor}, 0.4) 0%, rgba(${glowColor}, 0.2) 30%, transparent 70%);\n                      left: ${x - maxDistance}px;\n                      top: ${y - maxDistance}px;\n                      pointer-events: none;\n                      z-index: 1000;\n                    `;\n\n                    el.appendChild(ripple);\n\n                    gsap.fromTo(\n                      ripple,\n                      {\n                        scale: 0,\n                        opacity: 1\n                      },\n                      {\n                        scale: 1,\n                        opacity: 0,\n                        duration: 0.8,\n                        ease: 'power2.out',\n                        onComplete: () => ripple.remove()\n                      }\n                    );\n                  };\n\n                  el.addEventListener('mousemove', handleMouseMove);\n                  el.addEventListener('mouseleave', handleMouseLeave);\n                  el.addEventListener('click', handleClick);\n                }}\n              >\n                <div className=\"card__header flex justify-between gap-3 relative text-white\">\n                  <span className=\"card__label text-base\">{card.label}</span>\n                </div>\n                <div className=\"card__content flex flex-col relative text-white\">\n                  <h3 className={`card__title font-normal text-base m-0 mb-1 ${textAutoHide ? 'text-clamp-1' : ''}`}>\n                    {card.title}\n                  </h3>\n                  <p className={`card__description text-xs leading-5 opacity-90 ${textAutoHide ? 'text-clamp-2' : ''}`}>\n                    {card.description}\n                  </p>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </BentoCardGrid>\n    </>\n  );\n};\n\nexport default MagicBento;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "marquee",
      "type": "component",
      "description": "An infinite scrolling component that can be used to display text, images, or videos.",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/marquee.tsx",
          "content": "import { ComponentPropsWithoutRef } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface MarqueeProps extends ComponentPropsWithoutRef<\"div\"> {\n  /**\n   * Optional CSS class name to apply custom styles\n   */\n  className?: string\n  /**\n   * Whether to reverse the animation direction\n   * @default false\n   */\n  reverse?: boolean\n  /**\n   * Whether to pause the animation on hover\n   * @default false\n   */\n  pauseOnHover?: boolean\n  /**\n   * Content to be displayed in the marquee\n   */\n  children: React.ReactNode\n  /**\n   * Whether to animate vertically instead of horizontally\n   * @default false\n   */\n  vertical?: boolean\n  /**\n   * Number of times to repeat the content\n   * @default 4\n   */\n  repeat?: number\n}\n\nexport function Marquee({\n  className,\n  reverse = false,\n  pauseOnHover = false,\n  children,\n  vertical = false,\n  repeat = 4,\n  ...props\n}: MarqueeProps) {\n  return (\n    <div\n      {...props}\n      className={cn(\n        \"group flex [gap:var(--gap)] overflow-hidden p-2 [--duration:40s] [--gap:1rem]\",\n        {\n          \"flex-row\": !vertical,\n          \"flex-col\": vertical,\n        },\n        className\n      )}\n    >\n      {Array(repeat)\n        .fill(0)\n        .map((_, i) => (\n          <div\n            key={i}\n            className={cn(\"flex shrink-0 justify-around [gap:var(--gap)]\", {\n              \"animate-marquee flex-row\": !vertical,\n              \"animate-marquee-vertical flex-col\": vertical,\n              \"group-hover:[animation-play-state:paused]\": pauseOnHover,\n              \"[animation-direction:reverse]\": reverse,\n            })}\n          >\n            {children}\n          </div>\n        ))}\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "masonry",
      "type": "component",
      "description": "A layouts masonry component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/masonry.tsx",
          "content": "import React, { useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport { gsap } from 'gsap';\n\nconst useMedia = (queries: string[], values: number[], defaultValue: number): number => {\n  const get = () => values[queries.findIndex(q => matchMedia(q).matches)] ?? defaultValue;\n\n  const [value, setValue] = useState<number>(get);\n\n  useEffect(() => {\n    const handler = () => setValue(get);\n    queries.forEach(q => matchMedia(q).addEventListener('change', handler));\n    return () => queries.forEach(q => matchMedia(q).removeEventListener('change', handler));\n  }, [queries]);\n\n  return value;\n};\n\nconst useMeasure = <T extends HTMLElement>() => {\n  const ref = useRef<T | null>(null);\n  const [size, setSize] = useState({ width: 0, height: 0 });\n\n  useLayoutEffect(() => {\n    if (!ref.current) return;\n    const ro = new ResizeObserver(([entry]) => {\n      const { width, height } = entry.contentRect;\n      setSize({ width, height });\n    });\n    ro.observe(ref.current);\n    return () => ro.disconnect();\n  }, []);\n\n  return [ref, size] as const;\n};\n\nconst preloadImages = async (urls: string[]): Promise<void> => {\n  await Promise.all(\n    urls.map(\n      src =>\n        new Promise<void>(resolve => {\n          const img = new Image();\n          img.src = src;\n          img.onload = img.onerror = () => resolve();\n        })\n    )\n  );\n};\n\ninterface Item {\n  id: string;\n  img: string;\n  url: string;\n  height: number;\n}\n\ninterface GridItem extends Item {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\ninterface MasonryProps {\n  items: Item[];\n  ease?: string;\n  duration?: number;\n  stagger?: number;\n  animateFrom?: 'bottom' | 'top' | 'left' | 'right' | 'center' | 'random';\n  scaleOnHover?: boolean;\n  hoverScale?: number;\n  blurToFocus?: boolean;\n  colorShiftOnHover?: boolean;\n}\n\nconst Masonry: React.FC<MasonryProps> = ({\n  items,\n  ease = 'power3.out',\n  duration = 0.6,\n  stagger = 0.05,\n  animateFrom = 'bottom',\n  scaleOnHover = true,\n  hoverScale = 0.95,\n  blurToFocus = true,\n  colorShiftOnHover = false\n}) => {\n  const columns = useMedia(\n    ['(min-width:1500px)', '(min-width:1000px)', '(min-width:600px)', '(min-width:400px)'],\n    [5, 4, 3, 2],\n    1\n  );\n\n  const [containerRef, { width }] = useMeasure<HTMLDivElement>();\n  const [imagesReady, setImagesReady] = useState(false);\n\n  const getInitialPosition = (item: GridItem) => {\n    const containerRect = containerRef.current?.getBoundingClientRect();\n    if (!containerRect) return { x: item.x, y: item.y };\n\n    let direction = animateFrom;\n    if (animateFrom === 'random') {\n      const dirs = ['top', 'bottom', 'left', 'right'];\n      direction = dirs[Math.floor(Math.random() * dirs.length)] as typeof animateFrom;\n    }\n\n    switch (direction) {\n      case 'top':\n        return { x: item.x, y: -200 };\n      case 'bottom':\n        return { x: item.x, y: window.innerHeight + 200 };\n      case 'left':\n        return { x: -200, y: item.y };\n      case 'right':\n        return { x: window.innerWidth + 200, y: item.y };\n      case 'center':\n        return {\n          x: containerRect.width / 2 - item.w / 2,\n          y: containerRect.height / 2 - item.h / 2\n        };\n      default:\n        return { x: item.x, y: item.y + 100 };\n    }\n  };\n\n  useEffect(() => {\n    preloadImages(items.map(i => i.img)).then(() => setImagesReady(true));\n  }, [items]);\n\n  const grid = useMemo<GridItem[]>(() => {\n    if (!width) return [];\n    const colHeights = new Array(columns).fill(0);\n    const gap = 16;\n    const totalGaps = (columns - 1) * gap;\n    const columnWidth = (width - totalGaps) / columns;\n\n    return items.map(child => {\n      const col = colHeights.indexOf(Math.min(...colHeights));\n      const x = col * (columnWidth + gap);\n      const height = child.height / 2;\n      const y = colHeights[col];\n\n      colHeights[col] += height + gap;\n      return { ...child, x, y, w: columnWidth, h: height };\n    });\n  }, [columns, items, width]);\n\n  const hasMounted = useRef(false);\n\n  useLayoutEffect(() => {\n    if (!imagesReady) return;\n\n    grid.forEach((item, index) => {\n      const selector = `[data-key=\"${item.id}\"]`;\n      const animProps = { x: item.x, y: item.y, width: item.w, height: item.h };\n\n      if (!hasMounted.current) {\n        const start = getInitialPosition(item);\n        gsap.fromTo(\n          selector,\n          {\n            opacity: 0,\n            x: start.x,\n            y: start.y,\n            width: item.w,\n            height: item.h,\n            ...(blurToFocus && { filter: 'blur(10px)' })\n          },\n          {\n            opacity: 1,\n            ...animProps,\n            ...(blurToFocus && { filter: 'blur(0px)' }),\n            duration: 0.8,\n            ease: 'power3.out',\n            delay: index * stagger\n          }\n        );\n      } else {\n        gsap.to(selector, {\n          ...animProps,\n          duration,\n          ease,\n          overwrite: 'auto'\n        });\n      }\n    });\n\n    hasMounted.current = true;\n  }, [grid, imagesReady, stagger, animateFrom, blurToFocus, duration, ease]);\n\n  const handleMouseEnter = (id: string, element: HTMLElement) => {\n    if (scaleOnHover) {\n      gsap.to(`[data-key=\"${id}\"]`, {\n        scale: hoverScale,\n        duration: 0.3,\n        ease: 'power2.out'\n      });\n    }\n    if (colorShiftOnHover) {\n      const overlay = element.querySelector('.color-overlay') as HTMLElement;\n      if (overlay) gsap.to(overlay, { opacity: 0.3, duration: 0.3 });\n    }\n  };\n\n  const handleMouseLeave = (id: string, element: HTMLElement) => {\n    if (scaleOnHover) {\n      gsap.to(`[data-key=\"${id}\"]`, {\n        scale: 1,\n        duration: 0.3,\n        ease: 'power2.out'\n      });\n    }\n    if (colorShiftOnHover) {\n      const overlay = element.querySelector('.color-overlay') as HTMLElement;\n      if (overlay) gsap.to(overlay, { opacity: 0, duration: 0.3 });\n    }\n  };\n\n  return (\n    <div ref={containerRef} className=\"relative w-full h-full\">\n      {grid.map(item => (\n        <div\n          key={item.id}\n          data-key={item.id}\n          className=\"absolute box-content\"\n          style={{ willChange: 'transform, width, height, opacity' }}\n          onClick={() => window.open(item.url, '_blank', 'noopener')}\n          onMouseEnter={e => handleMouseEnter(item.id, e.currentTarget)}\n          onMouseLeave={e => handleMouseLeave(item.id, e.currentTarget)}\n        >\n          <div\n            className=\"relative w-full h-full bg-cover bg-center rounded-[10px] shadow-[0px_10px_50px_-10px_rgba(0,0,0,0.2)] uppercase text-[10px] leading-[10px]\"\n            style={{ backgroundImage: `url(${item.img})` }}\n          >\n            {colorShiftOnHover && (\n              <div className=\"color-overlay absolute inset-0 rounded-[10px] bg-gradient-to-tr from-pink-500/50 to-sky-500/50 opacity-0 pointer-events-none\" />\n            )}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default Masonry;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "model-viewer",
      "type": "component",
      "description": "A layouts model viewer component",
      "category": "layouts",
      "dependencies": [
        "three",
        "@react-three/fiber",
        "@react-three/drei"
      ],
      "files": [
        {
          "path": "components/ui/model-viewer.tsx",
          "content": "import { FC, Suspense, useRef, useLayoutEffect, useEffect, useMemo } from 'react';\nimport { Canvas, useFrame, useLoader, useThree, invalidate } from '@react-three/fiber';\nimport { OrbitControls, useGLTF, useFBX, useProgress, Html, Environment, ContactShadows } from '@react-three/drei';\n// @ts-expect-error - Three.js example modules\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\nimport * as THREE from 'three';\n\nexport interface ViewerProps {\n  url: string;\n  width?: number | string;\n  height?: number | string;\n  modelXOffset?: number;\n  modelYOffset?: number;\n  defaultRotationX?: number;\n  defaultRotationY?: number;\n  defaultZoom?: number;\n  minZoomDistance?: number;\n  maxZoomDistance?: number;\n  enableMouseParallax?: boolean;\n  enableManualRotation?: boolean;\n  enableHoverRotation?: boolean;\n  enableManualZoom?: boolean;\n  ambientIntensity?: number;\n  keyLightIntensity?: number;\n  fillLightIntensity?: number;\n  rimLightIntensity?: number;\n  environmentPreset?: 'city' | 'sunset' | 'night' | 'dawn' | 'studio' | 'apartment' | 'forest' | 'park' | 'none';\n  autoFrame?: boolean;\n  placeholderSrc?: string;\n  showScreenshotButton?: boolean;\n  fadeIn?: boolean;\n  autoRotate?: boolean;\n  autoRotateSpeed?: number;\n  onModelLoaded?: () => void;\n}\n\nconst isTouch = typeof window !== 'undefined' && ('ontouchstart' in window || navigator.maxTouchPoints > 0);\nconst deg2rad = (d: number) => (d * Math.PI) / 180;\nconst DECIDE = 8; // px before we decide horizontal vs vertical\nconst ROTATE_SPEED = 0.005;\nconst INERTIA = 0.925;\nconst PARALLAX_MAG = 0.05;\nconst PARALLAX_EASE = 0.12;\nconst HOVER_MAG = deg2rad(6);\nconst HOVER_EASE = 0.15;\n\nconst Loader: FC<{ placeholderSrc?: string }> = ({ placeholderSrc }) => {\n  const { progress, active } = useProgress();\n  if (!active && placeholderSrc) return null;\n  return (\n    <Html center>\n      {placeholderSrc ? (\n        <img src={placeholderSrc} width={128} height={128} className=\"blur-lg rounded-lg\" />\n      ) : (\n        `${Math.round(progress)} %`\n      )}\n    </Html>\n  );\n};\n\nconst DesktopControls: FC<{\n  pivot: THREE.Vector3;\n  min: number;\n  max: number;\n  zoomEnabled: boolean;\n}> = ({ pivot, min, max, zoomEnabled }) => {\n  const ref = useRef<any>(null);\n  useFrame(() => ref.current?.target.copy(pivot));\n  return (\n    <OrbitControls\n      ref={ref}\n      makeDefault\n      enablePan={false}\n      enableRotate={false}\n      enableZoom={zoomEnabled}\n      minDistance={min}\n      maxDistance={max}\n    />\n  );\n};\n\ninterface ModelInnerProps {\n  url: string;\n  xOff: number;\n  yOff: number;\n  pivot: THREE.Vector3;\n  initYaw: number;\n  initPitch: number;\n  minZoom: number;\n  maxZoom: number;\n  enableMouseParallax: boolean;\n  enableManualRotation: boolean;\n  enableHoverRotation: boolean;\n  enableManualZoom: boolean;\n  autoFrame: boolean;\n  fadeIn: boolean;\n  autoRotate: boolean;\n  autoRotateSpeed: number;\n  onLoaded?: () => void;\n}\n\nconst ModelInner: FC<ModelInnerProps> = ({\n  url,\n  xOff,\n  yOff,\n  pivot,\n  initYaw,\n  initPitch,\n  minZoom,\n  maxZoom,\n  enableMouseParallax,\n  enableManualRotation,\n  enableHoverRotation,\n  enableManualZoom,\n  autoFrame,\n  fadeIn,\n  autoRotate,\n  autoRotateSpeed,\n  onLoaded\n}) => {\n  const outer = useRef<THREE.Group>(null!);\n  const inner = useRef<THREE.Group>(null!);\n  const { camera, gl } = useThree();\n\n  const vel = useRef({ x: 0, y: 0 });\n  const tPar = useRef({ x: 0, y: 0 });\n  const cPar = useRef({ x: 0, y: 0 });\n  const tHov = useRef({ x: 0, y: 0 });\n  const cHov = useRef({ x: 0, y: 0 });\n\n  const ext = useMemo(() => url.split('.').pop()!.toLowerCase(), [url]);\n  const content = useMemo<THREE.Object3D | null>(() => {\n    if (ext === 'glb' || ext === 'gltf') return useGLTF(url).scene.clone();\n    if (ext === 'fbx') return useFBX(url).clone();\n    if (ext === 'obj') return useLoader(OBJLoader, url).clone();\n    console.error('Unsupported format:', ext);\n    return null;\n  }, [url, ext]);\n\n  const pivotW = useRef(new THREE.Vector3());\n  useLayoutEffect(() => {\n    if (!content) return;\n    const g = inner.current;\n    g.updateWorldMatrix(true, true);\n\n    const sphere = new THREE.Box3().setFromObject(g).getBoundingSphere(new THREE.Sphere());\n    const s = 1 / (sphere.radius * 2);\n    g.position.set(-sphere.center.x, -sphere.center.y, -sphere.center.z);\n    g.scale.setScalar(s);\n\n    g.traverse((o: any) => {\n      if (o.isMesh) {\n        o.castShadow = true;\n        o.receiveShadow = true;\n        if (fadeIn) {\n          o.material.transparent = true;\n          o.material.opacity = 0;\n        }\n      }\n    });\n\n    g.getWorldPosition(pivotW.current);\n    pivot.copy(pivotW.current);\n    outer.current.rotation.set(initPitch, initYaw, 0);\n\n    if (autoFrame && (camera as THREE.PerspectiveCamera).isPerspectiveCamera) {\n      const persp = camera as THREE.PerspectiveCamera;\n      const fitR = sphere.radius * s;\n      const d = (fitR * 1.2) / Math.sin((persp.fov * Math.PI) / 180 / 2);\n      persp.position.set(pivotW.current.x, pivotW.current.y, pivotW.current.z + d);\n      persp.near = d / 10;\n      persp.far = d * 10;\n      persp.updateProjectionMatrix();\n    }\n\n    /* optional fade-in */\n    if (fadeIn) {\n      let t = 0;\n      const id = setInterval(() => {\n        t += 0.05;\n        const v = Math.min(t, 1);\n        g.traverse((o: any) => {\n          if (o.isMesh) o.material.opacity = v;\n        });\n        invalidate();\n        if (v === 1) {\n          clearInterval(id);\n          onLoaded?.();\n        }\n      }, 16);\n      return () => clearInterval(id);\n    } else onLoaded?.();\n  }, [content]);\n\n  useEffect(() => {\n    if (!enableManualRotation || isTouch) return;\n    const el = gl.domElement;\n    let drag = false;\n    let lx = 0,\n      ly = 0;\n    const down = (e: PointerEvent) => {\n      if (e.pointerType !== 'mouse' && e.pointerType !== 'pen') return;\n      drag = true;\n      lx = e.clientX;\n      ly = e.clientY;\n      window.addEventListener('pointerup', up);\n    };\n    const move = (e: PointerEvent) => {\n      if (!drag) return;\n      const dx = e.clientX - lx;\n      const dy = e.clientY - ly;\n      lx = e.clientX;\n      ly = e.clientY;\n      outer.current.rotation.y += dx * ROTATE_SPEED;\n      outer.current.rotation.x += dy * ROTATE_SPEED;\n      vel.current = { x: dx * ROTATE_SPEED, y: dy * ROTATE_SPEED };\n      invalidate();\n    };\n    const up = () => (drag = false);\n    el.addEventListener('pointerdown', down);\n    el.addEventListener('pointermove', move);\n    return () => {\n      el.removeEventListener('pointerdown', down);\n      el.removeEventListener('pointermove', move);\n      window.removeEventListener('pointerup', up);\n    };\n  }, [gl, enableManualRotation]);\n\n  useEffect(() => {\n    if (!isTouch) return;\n    const el = gl.domElement;\n    const pts = new Map<number, { x: number; y: number }>();\n    type Mode = 'idle' | 'decide' | 'rotate' | 'pinch';\n    let mode: Mode = 'idle';\n    let sx = 0,\n      sy = 0,\n      lx = 0,\n      ly = 0,\n      startDist = 0,\n      startZ = 0;\n\n    const down = (e: PointerEvent) => {\n      if (e.pointerType !== 'touch') return;\n      pts.set(e.pointerId, { x: e.clientX, y: e.clientY });\n      if (pts.size === 1) {\n        mode = 'decide';\n        sx = lx = e.clientX;\n        sy = ly = e.clientY;\n      } else if (pts.size === 2 && enableManualZoom) {\n        mode = 'pinch';\n        const [p1, p2] = [...pts.values()];\n        startDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);\n        startZ = camera.position.z;\n        e.preventDefault();\n      }\n      invalidate();\n    };\n\n    const move = (e: PointerEvent) => {\n      const p = pts.get(e.pointerId);\n      if (!p) return;\n      p.x = e.clientX;\n      p.y = e.clientY;\n\n      if (mode === 'decide') {\n        const dx = e.clientX - sx;\n        const dy = e.clientY - sy;\n        if (Math.abs(dx) > DECIDE || Math.abs(dy) > DECIDE) {\n          if (enableManualRotation && Math.abs(dx) > Math.abs(dy)) {\n            mode = 'rotate';\n            el.setPointerCapture(e.pointerId);\n          } else {\n            mode = 'idle';\n            pts.clear();\n          }\n        }\n      }\n\n      if (mode === 'rotate') {\n        e.preventDefault();\n        const dx = e.clientX - lx;\n        const dy = e.clientY - ly;\n        lx = e.clientX;\n        ly = e.clientY;\n        outer.current.rotation.y += dx * ROTATE_SPEED;\n        outer.current.rotation.x += dy * ROTATE_SPEED;\n        vel.current = { x: dx * ROTATE_SPEED, y: dy * ROTATE_SPEED };\n        invalidate();\n      } else if (mode === 'pinch' && pts.size === 2) {\n        e.preventDefault();\n        const [p1, p2] = [...pts.values()];\n        const d = Math.hypot(p1.x - p2.x, p1.y - p2.y);\n        const ratio = startDist / d;\n        camera.position.z = THREE.MathUtils.clamp(startZ * ratio, minZoom, maxZoom);\n        invalidate();\n      }\n    };\n\n    const up = (e: PointerEvent) => {\n      pts.delete(e.pointerId);\n      if (mode === 'rotate' && pts.size === 0) mode = 'idle';\n      if (mode === 'pinch' && pts.size < 2) mode = 'idle';\n    };\n\n    el.addEventListener('pointerdown', down, { passive: true });\n    window.addEventListener('pointermove', move, { passive: false });\n    window.addEventListener('pointerup', up, { passive: true });\n    window.addEventListener('pointercancel', up, { passive: true });\n    return () => {\n      el.removeEventListener('pointerdown', down);\n      window.removeEventListener('pointermove', move);\n      window.removeEventListener('pointerup', up);\n      window.removeEventListener('pointercancel', up);\n    };\n  }, [gl, enableManualRotation, enableManualZoom, minZoom, maxZoom]);\n\n  useEffect(() => {\n    if (isTouch) return;\n    const mm = (e: PointerEvent) => {\n      if (e.pointerType !== 'mouse') return;\n      const nx = (e.clientX / window.innerWidth) * 2 - 1;\n      const ny = (e.clientY / window.innerHeight) * 2 - 1;\n      if (enableMouseParallax) tPar.current = { x: -nx * PARALLAX_MAG, y: -ny * PARALLAX_MAG };\n      if (enableHoverRotation) tHov.current = { x: ny * HOVER_MAG, y: nx * HOVER_MAG };\n      invalidate();\n    };\n    window.addEventListener('pointermove', mm);\n    return () => window.removeEventListener('pointermove', mm);\n  }, [enableMouseParallax, enableHoverRotation]);\n\n  useFrame((_, dt) => {\n    let need = false;\n    cPar.current.x += (tPar.current.x - cPar.current.x) * PARALLAX_EASE;\n    cPar.current.y += (tPar.current.y - cPar.current.y) * PARALLAX_EASE;\n    const phx = cHov.current.x,\n      phy = cHov.current.y;\n    cHov.current.x += (tHov.current.x - cHov.current.x) * HOVER_EASE;\n    cHov.current.y += (tHov.current.y - cHov.current.y) * HOVER_EASE;\n\n    const ndc = pivotW.current.clone().project(camera);\n    ndc.x += xOff + cPar.current.x;\n    ndc.y += yOff + cPar.current.y;\n    outer.current.position.copy(ndc.unproject(camera));\n\n    outer.current.rotation.x += cHov.current.x - phx;\n    outer.current.rotation.y += cHov.current.y - phy;\n\n    if (autoRotate) {\n      outer.current.rotation.y += autoRotateSpeed * dt;\n      need = true;\n    }\n\n    outer.current.rotation.y += vel.current.x;\n    outer.current.rotation.x += vel.current.y;\n    vel.current.x *= INERTIA;\n    vel.current.y *= INERTIA;\n    if (Math.abs(vel.current.x) > 1e-4 || Math.abs(vel.current.y) > 1e-4) need = true;\n\n    if (\n      Math.abs(cPar.current.x - tPar.current.x) > 1e-4 ||\n      Math.abs(cPar.current.y - tPar.current.y) > 1e-4 ||\n      Math.abs(cHov.current.x - tHov.current.x) > 1e-4 ||\n      Math.abs(cHov.current.y - tHov.current.y) > 1e-4\n    )\n      need = true;\n\n    if (need) invalidate();\n  });\n\n  if (!content) return null;\n  return (\n    <group ref={outer}>\n      <group ref={inner}>\n        <primitive object={content} />\n      </group>\n    </group>\n  );\n};\n\nconst ModelViewer: FC<ViewerProps> = ({\n  url,\n  width = 400,\n  height = 400,\n  modelXOffset = 0,\n  modelYOffset = 0,\n  defaultRotationX = -50,\n  defaultRotationY = 20,\n  defaultZoom = 0.5,\n  minZoomDistance = 0.5,\n  maxZoomDistance = 10,\n  enableMouseParallax = true,\n  enableManualRotation = true,\n  enableHoverRotation = true,\n  enableManualZoom = true,\n  ambientIntensity = 0.3,\n  keyLightIntensity = 1,\n  fillLightIntensity = 0.5,\n  rimLightIntensity = 0.8,\n  environmentPreset = 'forest',\n  autoFrame = false,\n  placeholderSrc,\n  showScreenshotButton = true,\n  fadeIn = false,\n  autoRotate = false,\n  autoRotateSpeed = 0.35,\n  onModelLoaded\n}) => {\n  useEffect(() => void useGLTF.preload(url), [url]);\n  const pivot = useRef(new THREE.Vector3()).current;\n  const contactRef = useRef<THREE.Mesh>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer>(null);\n  const sceneRef = useRef<THREE.Scene>(null);\n  const cameraRef = useRef<THREE.Camera>(null);\n\n  const initYaw = deg2rad(defaultRotationX);\n  const initPitch = deg2rad(defaultRotationY);\n  const camZ = Math.min(Math.max(defaultZoom, minZoomDistance), maxZoomDistance);\n\n  const capture = () => {\n    const g = rendererRef.current,\n      s = sceneRef.current,\n      c = cameraRef.current;\n    if (!g || !s || !c) return;\n    g.shadowMap.enabled = false;\n    const tmp: { l: THREE.Light; cast: boolean }[] = [];\n    s.traverse((o: any) => {\n      if (o.isLight && 'castShadow' in o) {\n        tmp.push({ l: o, cast: o.castShadow });\n        o.castShadow = false;\n      }\n    });\n    if (contactRef.current) contactRef.current.visible = false;\n    g.render(s, c);\n    const urlPNG = g.domElement.toDataURL('image/png');\n    const a = document.createElement('a');\n    a.download = 'model.png';\n    a.href = urlPNG;\n    a.click();\n    g.shadowMap.enabled = true;\n    tmp.forEach(({ l, cast }) => (l.castShadow = cast));\n    if (contactRef.current) contactRef.current.visible = true;\n    invalidate();\n  };\n\n  return (\n    <div\n      style={{\n        width,\n        height,\n        touchAction: 'pan-y pinch-zoom'\n      }}\n      className=\"relative\"\n    >\n      {showScreenshotButton && (\n        <button\n          onClick={capture}\n          className=\"absolute top-4 right-4 z-10 cursor-pointer px-4 py-2 border border-white rounded-xl bg-transparent text-white hover:bg-white hover:text-black transition-colors\"\n        >\n          Take Screenshot\n        </button>\n      )}\n\n      <Canvas\n        shadows\n        frameloop=\"demand\"\n        gl={{ preserveDrawingBuffer: true }}\n        onCreated={({ gl, scene, camera }) => {\n          rendererRef.current = gl;\n          sceneRef.current = scene;\n          cameraRef.current = camera;\n          gl.toneMapping = THREE.ACESFilmicToneMapping;\n          gl.outputColorSpace = THREE.SRGBColorSpace;\n        }}\n        camera={{ fov: 50, position: [0, 0, camZ], near: 0.01, far: 100 }}\n        style={{ touchAction: 'pan-y pinch-zoom' }}\n      >\n        {environmentPreset !== 'none' && <Environment preset={environmentPreset as any} background={false} />}\n\n        <ambientLight intensity={ambientIntensity} />\n        <directionalLight position={[5, 5, 5]} intensity={keyLightIntensity} castShadow />\n        <directionalLight position={[-5, 2, 5]} intensity={fillLightIntensity} />\n        <directionalLight position={[0, 4, -5]} intensity={rimLightIntensity} />\n\n        <ContactShadows ref={contactRef as any} position={[0, -0.5, 0]} opacity={0.35} scale={10} blur={2} />\n\n        <Suspense fallback={<Loader placeholderSrc={placeholderSrc} />}>\n          <ModelInner\n            url={url}\n            xOff={modelXOffset}\n            yOff={modelYOffset}\n            pivot={pivot}\n            initYaw={initYaw}\n            initPitch={initPitch}\n            minZoom={minZoomDistance}\n            maxZoom={maxZoomDistance}\n            enableMouseParallax={enableMouseParallax}\n            enableManualRotation={enableManualRotation}\n            enableHoverRotation={enableHoverRotation}\n            enableManualZoom={enableManualZoom}\n            autoFrame={autoFrame}\n            fadeIn={fadeIn}\n            autoRotate={autoRotate}\n            autoRotateSpeed={autoRotateSpeed}\n            onLoaded={onModelLoaded}\n          />\n        </Suspense>\n\n        {!isTouch && (\n          <DesktopControls pivot={pivot} min={minZoomDistance} max={maxZoomDistance} zoomEnabled={enableManualZoom} />\n        )}\n      </Canvas>\n    </div>\n  );\n};\n\nexport default ModelViewer;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "pill-nav",
      "type": "component",
      "description": "A layouts pill nav component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/pill-nav.tsx",
          "content": "import React, { useEffect, useRef, useState } from 'react';\nimport { Link } from 'react-router-dom';\nimport { gsap } from 'gsap';\n\nexport type PillNavItem = {\n  label: string;\n  href: string;\n  ariaLabel?: string;\n};\n\nexport interface PillNavProps {\n  logo: string;\n  logoAlt?: string;\n  items: PillNavItem[];\n  activeHref?: string;\n  className?: string;\n  ease?: string;\n  baseColor?: string;\n  pillColor?: string;\n  hoveredPillTextColor?: string;\n  pillTextColor?: string;\n  onMobileMenuClick?: () => void;\n  initialLoadAnimation?: boolean;\n}\n\nconst PillNav: React.FC<PillNavProps> = ({\n  logo,\n  logoAlt = 'Logo',\n  items,\n  activeHref,\n  className = '',\n  ease = 'power3.easeOut',\n  baseColor = '#fff',\n  pillColor = '#060010',\n  hoveredPillTextColor = '#060010',\n  pillTextColor,\n  onMobileMenuClick,\n  initialLoadAnimation = true\n}) => {\n  const resolvedPillTextColor = pillTextColor ?? baseColor;\n  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);\n  const circleRefs = useRef<Array<HTMLSpanElement | null>>([]);\n  const tlRefs = useRef<Array<gsap.core.Timeline | null>>([]);\n  const activeTweenRefs = useRef<Array<gsap.core.Tween | null>>([]);\n  const logoImgRef = useRef<HTMLImageElement | null>(null);\n  const logoTweenRef = useRef<gsap.core.Tween | null>(null);\n  const hamburgerRef = useRef<HTMLButtonElement | null>(null);\n  const mobileMenuRef = useRef<HTMLDivElement | null>(null);\n  const navItemsRef = useRef<HTMLDivElement | null>(null);\n  const logoRef = useRef<HTMLAnchorElement | HTMLElement | null>(null);\n\n  useEffect(() => {\n    const layout = () => {\n      circleRefs.current.forEach(circle => {\n        if (!circle?.parentElement) return;\n\n        const pill = circle.parentElement as HTMLElement;\n        const rect = pill.getBoundingClientRect();\n        const { width: w, height: h } = rect;\n        const R = ((w * w) / 4 + h * h) / (2 * h);\n        const D = Math.ceil(2 * R) + 2;\n        const delta = Math.ceil(R - Math.sqrt(Math.max(0, R * R - (w * w) / 4))) + 1;\n        const originY = D - delta;\n\n        circle.style.width = `${D}px`;\n        circle.style.height = `${D}px`;\n        circle.style.bottom = `-${delta}px`;\n\n        gsap.set(circle, {\n          xPercent: -50,\n          scale: 0,\n          transformOrigin: `50% ${originY}px`\n        });\n\n        const label = pill.querySelector<HTMLElement>('.pill-label');\n        const white = pill.querySelector<HTMLElement>('.pill-label-hover');\n\n        if (label) gsap.set(label, { y: 0 });\n        if (white) gsap.set(white, { y: h + 12, opacity: 0 });\n\n        const index = circleRefs.current.indexOf(circle);\n        if (index === -1) return;\n\n        tlRefs.current[index]?.kill();\n        const tl = gsap.timeline({ paused: true });\n\n        tl.to(circle, { scale: 1.2, xPercent: -50, duration: 2, ease, overwrite: 'auto' }, 0);\n\n        if (label) {\n          tl.to(label, { y: -(h + 8), duration: 2, ease, overwrite: 'auto' }, 0);\n        }\n\n        if (white) {\n          gsap.set(white, { y: Math.ceil(h + 100), opacity: 0 });\n          tl.to(white, { y: 0, opacity: 1, duration: 2, ease, overwrite: 'auto' }, 0);\n        }\n\n        tlRefs.current[index] = tl;\n      });\n    };\n\n    layout();\n\n    const onResize = () => layout();\n    window.addEventListener('resize', onResize);\n\n    if (document.fonts) {\n      document.fonts.ready.then(layout).catch(() => {});\n    }\n\n    const menu = mobileMenuRef.current;\n    if (menu) {\n      gsap.set(menu, { visibility: 'hidden', opacity: 0, scaleY: 1, y: 0 });\n    }\n\n    if (initialLoadAnimation) {\n      const logo = logoRef.current;\n      const navItems = navItemsRef.current;\n\n      if (logo) {\n        gsap.set(logo, { scale: 0 });\n        gsap.to(logo, {\n          scale: 1,\n          duration: 0.6,\n          ease\n        });\n      }\n\n      if (navItems) {\n        gsap.set(navItems, { width: 0, overflow: 'hidden' });\n        gsap.to(navItems, {\n          width: 'auto',\n          duration: 0.6,\n          ease\n        });\n      }\n    }\n\n    return () => window.removeEventListener('resize', onResize);\n  }, [items, ease, initialLoadAnimation]);\n\n  const handleEnter = (i: number) => {\n    const tl = tlRefs.current[i];\n    if (!tl) return;\n    activeTweenRefs.current[i]?.kill();\n    activeTweenRefs.current[i] = tl.tweenTo(tl.duration(), {\n      duration: 0.3,\n      ease,\n      overwrite: 'auto'\n    });\n  };\n\n  const handleLeave = (i: number) => {\n    const tl = tlRefs.current[i];\n    if (!tl) return;\n    activeTweenRefs.current[i]?.kill();\n    activeTweenRefs.current[i] = tl.tweenTo(0, {\n      duration: 0.2,\n      ease,\n      overwrite: 'auto'\n    });\n  };\n\n  const handleLogoEnter = () => {\n    const img = logoImgRef.current;\n    if (!img) return;\n    logoTweenRef.current?.kill();\n    gsap.set(img, { rotate: 0 });\n    logoTweenRef.current = gsap.to(img, {\n      rotate: 360,\n      duration: 0.2,\n      ease,\n      overwrite: 'auto'\n    });\n  };\n\n  const toggleMobileMenu = () => {\n    const newState = !isMobileMenuOpen;\n    setIsMobileMenuOpen(newState);\n\n    const hamburger = hamburgerRef.current;\n    const menu = mobileMenuRef.current;\n\n    if (hamburger) {\n      const lines = hamburger.querySelectorAll('.hamburger-line');\n      if (newState) {\n        gsap.to(lines[0], { rotation: 45, y: 3, duration: 0.3, ease });\n        gsap.to(lines[1], { rotation: -45, y: -3, duration: 0.3, ease });\n      } else {\n        gsap.to(lines[0], { rotation: 0, y: 0, duration: 0.3, ease });\n        gsap.to(lines[1], { rotation: 0, y: 0, duration: 0.3, ease });\n      }\n    }\n\n    if (menu) {\n      if (newState) {\n        gsap.set(menu, { visibility: 'visible' });\n        gsap.fromTo(\n          menu,\n          { opacity: 0, y: 10, scaleY: 1 },\n          {\n            opacity: 1,\n            y: 0,\n            scaleY: 1,\n            duration: 0.3,\n            ease,\n            transformOrigin: 'top center'\n          }\n        );\n      } else {\n        gsap.to(menu, {\n          opacity: 0,\n          y: 10,\n          scaleY: 1,\n          duration: 0.2,\n          ease,\n          transformOrigin: 'top center',\n          onComplete: () => {\n            gsap.set(menu, { visibility: 'hidden' });\n          }\n        });\n      }\n    }\n\n    onMobileMenuClick?.();\n  };\n\n  const isExternalLink = (href: string) =>\n    href.startsWith('http://') ||\n    href.startsWith('https://') ||\n    href.startsWith('//') ||\n    href.startsWith('mailto:') ||\n    href.startsWith('tel:') ||\n    href.startsWith('#');\n\n  const isRouterLink = (href?: string) => href && !isExternalLink(href);\n\n  const cssVars = {\n    ['--base']: baseColor,\n    ['--pill-bg']: pillColor,\n    ['--hover-text']: hoveredPillTextColor,\n    ['--pill-text']: resolvedPillTextColor,\n    ['--nav-h']: '42px',\n    ['--logo']: '36px',\n    ['--pill-pad-x']: '18px',\n    ['--pill-gap']: '3px'\n  } as React.CSSProperties;\n\n  return (\n    <div className=\"absolute top-[1em] z-[1000] w-full left-0 md:w-auto md:left-auto\">\n      <nav\n        className={`w-full md:w-max flex items-center justify-between md:justify-start box-border px-4 md:px-0 ${className}`}\n        aria-label=\"Primary\"\n        style={cssVars}\n      >\n        {isRouterLink(items?.[0]?.href) ? (\n          <Link\n            to={items[0].href}\n            aria-label=\"Home\"\n            onMouseEnter={handleLogoEnter}\n            role=\"menuitem\"\n            ref={el => {\n              logoRef.current = el;\n            }}\n            className=\"rounded-full p-2 inline-flex items-center justify-center overflow-hidden\"\n            style={{\n              width: 'var(--nav-h)',\n              height: 'var(--nav-h)',\n              background: 'var(--base, #000)'\n            }}\n          >\n            <img src={logo} alt={logoAlt} ref={logoImgRef} className=\"w-full h-full object-cover block\" />\n          </Link>\n        ) : (\n          <a\n            href={items?.[0]?.href || '#'}\n            aria-label=\"Home\"\n            onMouseEnter={handleLogoEnter}\n            ref={el => {\n              logoRef.current = el;\n            }}\n            className=\"rounded-full p-2 inline-flex items-center justify-center overflow-hidden\"\n            style={{\n              width: 'var(--nav-h)',\n              height: 'var(--nav-h)',\n              background: 'var(--base, #000)'\n            }}\n          >\n            <img src={logo} alt={logoAlt} ref={logoImgRef} className=\"w-full h-full object-cover block\" />\n          </a>\n        )}\n\n        <div\n          ref={navItemsRef}\n          className=\"relative items-center rounded-full hidden md:flex ml-2\"\n          style={{\n            height: 'var(--nav-h)',\n            background: 'var(--base, #000)'\n          }}\n        >\n          <ul\n            role=\"menubar\"\n            className=\"list-none flex items-stretch m-0 p-[3px] h-full\"\n            style={{ gap: 'var(--pill-gap)' }}\n          >\n            {items.map((item, i) => {\n              const isActive = activeHref === item.href;\n\n              const pillStyle: React.CSSProperties = {\n                background: 'var(--pill-bg, #fff)',\n                color: 'var(--pill-text, var(--base, #000))',\n                paddingLeft: 'var(--pill-pad-x)',\n                paddingRight: 'var(--pill-pad-x)'\n              };\n\n              const PillContent = (\n                <>\n                  <span\n                    className=\"hover-circle absolute left-1/2 bottom-0 rounded-full z-[1] block pointer-events-none\"\n                    style={{\n                      background: 'var(--base, #000)',\n                      willChange: 'transform'\n                    }}\n                    aria-hidden=\"true\"\n                    ref={el => {\n                      circleRefs.current[i] = el;\n                    }}\n                  />\n                  <span className=\"label-stack relative inline-block leading-[1] z-[2]\">\n                    <span\n                      className=\"pill-label relative z-[2] inline-block leading-[1]\"\n                      style={{ willChange: 'transform' }}\n                    >\n                      {item.label}\n                    </span>\n                    <span\n                      className=\"pill-label-hover absolute left-0 top-0 z-[3] inline-block\"\n                      style={{\n                        color: 'var(--hover-text, #fff)',\n                        willChange: 'transform, opacity'\n                      }}\n                      aria-hidden=\"true\"\n                    >\n                      {item.label}\n                    </span>\n                  </span>\n                  {isActive && (\n                    <span\n                      className=\"absolute left-1/2 -bottom-[6px] -translate-x-1/2 w-3 h-3 rounded-full z-[4]\"\n                      style={{ background: 'var(--base, #000)' }}\n                      aria-hidden=\"true\"\n                    />\n                  )}\n                </>\n              );\n\n              const basePillClasses =\n                'relative overflow-hidden inline-flex items-center justify-center h-full no-underline rounded-full box-border font-semibold text-[16px] leading-[0] uppercase tracking-[0.2px] whitespace-nowrap cursor-pointer px-0';\n\n              return (\n                <li key={item.href} role=\"none\" className=\"flex h-full\">\n                  {isRouterLink(item.href) ? (\n                    <Link\n                      role=\"menuitem\"\n                      to={item.href}\n                      className={basePillClasses}\n                      style={pillStyle}\n                      aria-label={item.ariaLabel || item.label}\n                      onMouseEnter={() => handleEnter(i)}\n                      onMouseLeave={() => handleLeave(i)}\n                    >\n                      {PillContent}\n                    </Link>\n                  ) : (\n                    <a\n                      role=\"menuitem\"\n                      href={item.href}\n                      className={basePillClasses}\n                      style={pillStyle}\n                      aria-label={item.ariaLabel || item.label}\n                      onMouseEnter={() => handleEnter(i)}\n                      onMouseLeave={() => handleLeave(i)}\n                    >\n                      {PillContent}\n                    </a>\n                  )}\n                </li>\n              );\n            })}\n          </ul>\n        </div>\n\n        <button\n          ref={hamburgerRef}\n          onClick={toggleMobileMenu}\n          aria-label=\"Toggle menu\"\n          aria-expanded={isMobileMenuOpen}\n          className=\"md:hidden rounded-full border-0 flex flex-col items-center justify-center gap-1 cursor-pointer p-0 relative\"\n          style={{\n            width: 'var(--nav-h)',\n            height: 'var(--nav-h)',\n            background: 'var(--base, #000)'\n          }}\n        >\n          <span\n            className=\"hamburger-line w-4 h-0.5 rounded origin-center transition-all duration-[10ms] ease-[cubic-bezier(0.25,0.1,0.25,1)]\"\n            style={{ background: 'var(--pill-bg, #fff)' }}\n          />\n          <span\n            className=\"hamburger-line w-4 h-0.5 rounded origin-center transition-all duration-[10ms] ease-[cubic-bezier(0.25,0.1,0.25,1)]\"\n            style={{ background: 'var(--pill-bg, #fff)' }}\n          />\n        </button>\n      </nav>\n\n      <div\n        ref={mobileMenuRef}\n        className=\"md:hidden absolute top-[3em] left-4 right-4 rounded-[27px] shadow-[0_8px_32px_rgba(0,0,0,0.12)] z-[998] origin-top\"\n        style={{\n          ...cssVars,\n          background: 'var(--base, #f0f0f0)'\n        }}\n      >\n        <ul className=\"list-none m-0 p-[3px] flex flex-col gap-[3px]\">\n          {items.map(item => {\n            const defaultStyle: React.CSSProperties = {\n              background: 'var(--pill-bg, #fff)',\n              color: 'var(--pill-text, #fff)'\n            };\n            const hoverIn = (e: React.MouseEvent<HTMLAnchorElement>) => {\n              e.currentTarget.style.background = 'var(--base)';\n              e.currentTarget.style.color = 'var(--hover-text, #fff)';\n            };\n            const hoverOut = (e: React.MouseEvent<HTMLAnchorElement>) => {\n              e.currentTarget.style.background = 'var(--pill-bg, #fff)';\n              e.currentTarget.style.color = 'var(--pill-text, #fff)';\n            };\n\n            const linkClasses =\n              'block py-3 px-4 text-[16px] font-medium rounded-[50px] transition-all duration-200 ease-[cubic-bezier(0.25,0.1,0.25,1)]';\n\n            return (\n              <li key={item.href}>\n                {isRouterLink(item.href) ? (\n                  <Link\n                    to={item.href}\n                    className={linkClasses}\n                    style={defaultStyle}\n                    onMouseEnter={hoverIn}\n                    onMouseLeave={hoverOut}\n                    onClick={() => setIsMobileMenuOpen(false)}\n                  >\n                    {item.label}\n                  </Link>\n                ) : (\n                  <a\n                    href={item.href}\n                    className={linkClasses}\n                    style={defaultStyle}\n                    onMouseEnter={hoverIn}\n                    onMouseLeave={hoverOut}\n                    onClick={() => setIsMobileMenuOpen(false)}\n                  >\n                    {item.label}\n                  </a>\n                )}\n              </li>\n            );\n          })}\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport default PillNav;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "pixel-card",
      "type": "component",
      "description": "A layouts pixel card component",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/pixel-card.tsx",
          "content": "import { useEffect, useRef } from 'react';\nimport { JSX } from 'react';\n\nclass Pixel {\n  width: number;\n  height: number;\n  ctx: CanvasRenderingContext2D;\n  x: number;\n  y: number;\n  color: string;\n  speed: number;\n  size: number;\n  sizeStep: number;\n  minSize: number;\n  maxSizeInteger: number;\n  maxSize: number;\n  delay: number;\n  counter: number;\n  counterStep: number;\n  isIdle: boolean;\n  isReverse: boolean;\n  isShimmer: boolean;\n\n  constructor(\n    canvas: HTMLCanvasElement,\n    context: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    color: string,\n    speed: number,\n    delay: number\n  ) {\n    this.width = canvas.width;\n    this.height = canvas.height;\n    this.ctx = context;\n    this.x = x;\n    this.y = y;\n    this.color = color;\n    this.speed = this.getRandomValue(0.1, 0.9) * speed;\n    this.size = 0;\n    this.sizeStep = Math.random() * 0.4;\n    this.minSize = 0.5;\n    this.maxSizeInteger = 2;\n    this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger);\n    this.delay = delay;\n    this.counter = 0;\n    this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;\n    this.isIdle = false;\n    this.isReverse = false;\n    this.isShimmer = false;\n  }\n\n  getRandomValue(min: number, max: number) {\n    return Math.random() * (max - min) + min;\n  }\n\n  draw() {\n    const centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;\n    this.ctx.fillStyle = this.color;\n    this.ctx.fillRect(this.x + centerOffset, this.y + centerOffset, this.size, this.size);\n  }\n\n  appear() {\n    this.isIdle = false;\n    if (this.counter <= this.delay) {\n      this.counter += this.counterStep;\n      return;\n    }\n    if (this.size >= this.maxSize) {\n      this.isShimmer = true;\n    }\n    if (this.isShimmer) {\n      this.shimmer();\n    } else {\n      this.size += this.sizeStep;\n    }\n    this.draw();\n  }\n\n  disappear() {\n    this.isShimmer = false;\n    this.counter = 0;\n    if (this.size <= 0) {\n      this.isIdle = true;\n      return;\n    } else {\n      this.size -= 0.1;\n    }\n    this.draw();\n  }\n\n  shimmer() {\n    if (this.size >= this.maxSize) {\n      this.isReverse = true;\n    } else if (this.size <= this.minSize) {\n      this.isReverse = false;\n    }\n    if (this.isReverse) {\n      this.size -= this.speed;\n    } else {\n      this.size += this.speed;\n    }\n  }\n}\n\nfunction getEffectiveSpeed(value: number, reducedMotion: boolean) {\n  const min = 0;\n  const max = 100;\n  const throttle = 0.001;\n\n  if (value <= min || reducedMotion) {\n    return min;\n  } else if (value >= max) {\n    return max * throttle;\n  } else {\n    return value * throttle;\n  }\n}\n\nconst VARIANTS = {\n  default: {\n    activeColor: null,\n    gap: 5,\n    speed: 35,\n    colors: '#f8fafc,#f1f5f9,#cbd5e1',\n    noFocus: false\n  },\n  blue: {\n    activeColor: '#e0f2fe',\n    gap: 10,\n    speed: 25,\n    colors: '#e0f2fe,#7dd3fc,#0ea5e9',\n    noFocus: false\n  },\n  yellow: {\n    activeColor: '#fef08a',\n    gap: 3,\n    speed: 20,\n    colors: '#fef08a,#fde047,#eab308',\n    noFocus: false\n  },\n  pink: {\n    activeColor: '#fecdd3',\n    gap: 6,\n    speed: 80,\n    colors: '#fecdd3,#fda4af,#e11d48',\n    noFocus: true\n  }\n};\n\ninterface PixelCardProps {\n  variant?: 'default' | 'blue' | 'yellow' | 'pink';\n  gap?: number;\n  speed?: number;\n  colors?: string;\n  noFocus?: boolean;\n  className?: string;\n  children: React.ReactNode;\n}\n\ninterface VariantConfig {\n  activeColor: string | null;\n  gap: number;\n  speed: number;\n  colors: string;\n  noFocus: boolean;\n}\n\nexport default function PixelCard({\n  variant = 'default',\n  gap,\n  speed,\n  colors,\n  noFocus,\n  className = '',\n  children\n}: PixelCardProps): JSX.Element {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const pixelsRef = useRef<Pixel[]>([]);\n  const animationRef = useRef<ReturnType<typeof requestAnimationFrame> | null>(null);\n  const timePreviousRef = useRef(performance.now());\n  const reducedMotion = useRef(window.matchMedia('(prefers-reduced-motion: reduce)').matches).current;\n\n  const variantCfg: VariantConfig = VARIANTS[variant] || VARIANTS.default;\n  const finalGap = gap ?? variantCfg.gap;\n  const finalSpeed = speed ?? variantCfg.speed;\n  const finalColors = colors ?? variantCfg.colors;\n  const finalNoFocus = noFocus ?? variantCfg.noFocus;\n\n  const initPixels = () => {\n    if (!containerRef.current || !canvasRef.current) return;\n\n    const rect = containerRef.current.getBoundingClientRect();\n    const width = Math.floor(rect.width);\n    const height = Math.floor(rect.height);\n    const ctx = canvasRef.current.getContext('2d');\n\n    canvasRef.current.width = width;\n    canvasRef.current.height = height;\n    canvasRef.current.style.width = `${width}px`;\n    canvasRef.current.style.height = `${height}px`;\n\n    const colorsArray = finalColors.split(',');\n    const pxs = [];\n    for (let x = 0; x < width; x += parseInt(finalGap.toString(), 10)) {\n      for (let y = 0; y < height; y += parseInt(finalGap.toString(), 10)) {\n        const color = colorsArray[Math.floor(Math.random() * colorsArray.length)];\n\n        const dx = x - width / 2;\n        const dy = y - height / 2;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const delay = reducedMotion ? 0 : distance;\n        if (!ctx) return;\n        pxs.push(new Pixel(canvasRef.current, ctx, x, y, color, getEffectiveSpeed(finalSpeed, reducedMotion), delay));\n      }\n    }\n    pixelsRef.current = pxs;\n  };\n\n  const doAnimate = (fnName: keyof Pixel) => {\n    animationRef.current = requestAnimationFrame(() => doAnimate(fnName));\n    const timeNow = performance.now();\n    const timePassed = timeNow - timePreviousRef.current;\n    const timeInterval = 1000 / 60;\n\n    if (timePassed < timeInterval) return;\n    timePreviousRef.current = timeNow - (timePassed % timeInterval);\n\n    const ctx = canvasRef.current?.getContext('2d');\n    if (!ctx || !canvasRef.current) return;\n\n    ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n\n    let allIdle = true;\n    for (let i = 0; i < pixelsRef.current.length; i++) {\n      const pixel = pixelsRef.current[i];\n      // @ts-ignore\n      pixel[fnName]();\n      if (!pixel.isIdle) {\n        allIdle = false;\n      }\n    }\n    if (allIdle) {\n      cancelAnimationFrame(animationRef.current);\n    }\n  };\n\n  const handleAnimation = (name: keyof Pixel) => {\n    if (animationRef.current !== null) {\n      cancelAnimationFrame(animationRef.current);\n    }\n    animationRef.current = requestAnimationFrame(() => doAnimate(name));\n  };\n\n  const onMouseEnter = () => handleAnimation('appear');\n  const onMouseLeave = () => handleAnimation('disappear');\n  const onFocus: React.FocusEventHandler<HTMLDivElement> = e => {\n    if (e.currentTarget.contains(e.relatedTarget)) return;\n    handleAnimation('appear');\n  };\n  const onBlur: React.FocusEventHandler<HTMLDivElement> = e => {\n    if (e.currentTarget.contains(e.relatedTarget)) return;\n    handleAnimation('disappear');\n  };\n\n  useEffect(() => {\n    initPixels();\n    const observer = new ResizeObserver(() => {\n      initPixels();\n    });\n    if (containerRef.current) {\n      observer.observe(containerRef.current);\n    }\n    return () => {\n      observer.disconnect();\n      if (animationRef.current !== null) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [finalGap, finalSpeed, finalColors, finalNoFocus]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`h-[400px] w-[300px] relative overflow-hidden grid place-items-center aspect-[4/5] border border-[#27272a] rounded-[25px] isolate transition-colors duration-200 ease-[cubic-bezier(0.5,1,0.89,1)] select-none ${className}`}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      onFocus={finalNoFocus ? undefined : onFocus}\n      onBlur={finalNoFocus ? undefined : onBlur}\n      tabIndex={finalNoFocus ? -1 : 0}\n    >\n      <canvas className=\"w-full h-full block\" ref={canvasRef} />\n      {children}\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "profile-card",
      "type": "component",
      "description": "A layouts profile card component",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/profile-card.tsx",
          "content": "import React, { useEffect, useRef, useCallback, useMemo, useState } from 'react';\n\nconst DEFAULT_INNER_GRADIENT = 'linear-gradient(145deg,#60496e8c 0%,#71C4FF44 100%)';\n\nconst ANIMATION_CONFIG = {\n  INITIAL_DURATION: 1200,\n  INITIAL_X_OFFSET: 70,\n  INITIAL_Y_OFFSET: 60,\n  DEVICE_BETA_OFFSET: 20,\n  ENTER_TRANSITION_MS: 180\n} as const;\n\nconst clamp = (v: number, min = 0, max = 100): number => Math.min(Math.max(v, min), max);\nconst round = (v: number, precision = 3): number => parseFloat(v.toFixed(precision));\nconst adjust = (v: number, fMin: number, fMax: number, tMin: number, tMax: number): number =>\n  round(tMin + ((tMax - tMin) * (v - fMin)) / (fMax - fMin));\n\n// Inject keyframes once\nconst KEYFRAMES_ID = 'pc-keyframes';\nif (typeof document !== 'undefined' && !document.getElementById(KEYFRAMES_ID)) {\n  const style = document.createElement('style');\n  style.id = KEYFRAMES_ID;\n  style.textContent = `\n    @keyframes pc-holo-bg {\n      0% { background-position: 0 var(--background-y), 0 0, center; }\n      100% { background-position: 0 var(--background-y), 90% 90%, center; }\n    }\n  `;\n  document.head.appendChild(style);\n}\n\ninterface ProfileCardProps {\n  avatarUrl?: string;\n  iconUrl?: string;\n  grainUrl?: string;\n  innerGradient?: string;\n  behindGlowEnabled?: boolean;\n  behindGlowColor?: string;\n  behindGlowSize?: string;\n  className?: string;\n  enableTilt?: boolean;\n  enableMobileTilt?: boolean;\n  mobileTiltSensitivity?: number;\n  miniAvatarUrl?: string;\n  name?: string;\n  title?: string;\n  handle?: string;\n  status?: string;\n  contactText?: string;\n  showUserInfo?: boolean;\n  onContactClick?: () => void;\n}\n\ninterface TiltEngine {\n  setImmediate: (x: number, y: number) => void;\n  setTarget: (x: number, y: number) => void;\n  toCenter: () => void;\n  beginInitial: (durationMs: number) => void;\n  getCurrent: () => { x: number; y: number; tx: number; ty: number };\n  cancel: () => void;\n}\n\nconst ProfileCardComponent: React.FC<ProfileCardProps> = ({\n  avatarUrl = '<Placeholder for avatar URL>',\n  iconUrl = '<Placeholder for icon URL>',\n  grainUrl = '<Placeholder for grain URL>',\n  innerGradient,\n  behindGlowEnabled = true,\n  behindGlowColor,\n  behindGlowSize,\n  className = '',\n  enableTilt = true,\n  enableMobileTilt = false,\n  mobileTiltSensitivity = 5,\n  miniAvatarUrl,\n  name = 'Javi A. Torres',\n  title = 'Software Engineer',\n  handle = 'javicodes',\n  status = 'Online',\n  contactText = 'Contact',\n  showUserInfo = true,\n  onContactClick\n}) => {\n  const wrapRef = useRef<HTMLDivElement>(null);\n  const shellRef = useRef<HTMLDivElement>(null);\n\n  const enterTimerRef = useRef<number | null>(null);\n  const leaveRafRef = useRef<number | null>(null);\n\n  const tiltEngine = useMemo<TiltEngine | null>(() => {\n    if (!enableTilt) return null;\n\n    let rafId: number | null = null;\n    let running = false;\n    let lastTs = 0;\n\n    let currentX = 0;\n    let currentY = 0;\n    let targetX = 0;\n    let targetY = 0;\n\n    const DEFAULT_TAU = 0.14;\n    const INITIAL_TAU = 0.6;\n    let initialUntil = 0;\n\n    const setVarsFromXY = (x: number, y: number): void => {\n      const shell = shellRef.current;\n      const wrap = wrapRef.current;\n      if (!shell || !wrap) return;\n\n      const width = shell.clientWidth || 1;\n      const height = shell.clientHeight || 1;\n\n      const percentX = clamp((100 / width) * x);\n      const percentY = clamp((100 / height) * y);\n\n      const centerX = percentX - 50;\n      const centerY = percentY - 50;\n\n      const properties: Record<string, string> = {\n        '--pointer-x': `${percentX}%`,\n        '--pointer-y': `${percentY}%`,\n        '--background-x': `${adjust(percentX, 0, 100, 35, 65)}%`,\n        '--background-y': `${adjust(percentY, 0, 100, 35, 65)}%`,\n        '--pointer-from-center': `${clamp(Math.hypot(percentY - 50, percentX - 50) / 50, 0, 1)}`,\n        '--pointer-from-top': `${percentY / 100}`,\n        '--pointer-from-left': `${percentX / 100}`,\n        '--rotate-x': `${round(-(centerX / 5))}deg`,\n        '--rotate-y': `${round(centerY / 4)}deg`\n      };\n\n      for (const [k, v] of Object.entries(properties)) wrap.style.setProperty(k, v);\n    };\n\n    const step = (ts: number): void => {\n      if (!running) return;\n      if (lastTs === 0) lastTs = ts;\n      const dt = (ts - lastTs) / 1000;\n      lastTs = ts;\n\n      const tau = ts < initialUntil ? INITIAL_TAU : DEFAULT_TAU;\n      const k = 1 - Math.exp(-dt / tau);\n\n      currentX += (targetX - currentX) * k;\n      currentY += (targetY - currentY) * k;\n\n      setVarsFromXY(currentX, currentY);\n\n      const stillFar = Math.abs(targetX - currentX) > 0.05 || Math.abs(targetY - currentY) > 0.05;\n\n      if (stillFar || document.hasFocus()) {\n        rafId = requestAnimationFrame(step);\n      } else {\n        running = false;\n        lastTs = 0;\n        if (rafId) {\n          cancelAnimationFrame(rafId);\n          rafId = null;\n        }\n      }\n    };\n\n    const start = (): void => {\n      if (running) return;\n      running = true;\n      lastTs = 0;\n      rafId = requestAnimationFrame(step);\n    };\n\n    return {\n      setImmediate(x: number, y: number): void {\n        currentX = x;\n        currentY = y;\n        setVarsFromXY(currentX, currentY);\n      },\n      setTarget(x: number, y: number): void {\n        targetX = x;\n        targetY = y;\n        start();\n      },\n      toCenter(): void {\n        const shell = shellRef.current;\n        if (!shell) return;\n        this.setTarget(shell.clientWidth / 2, shell.clientHeight / 2);\n      },\n      beginInitial(durationMs: number): void {\n        initialUntil = performance.now() + durationMs;\n        start();\n      },\n      getCurrent(): { x: number; y: number; tx: number; ty: number } {\n        return { x: currentX, y: currentY, tx: targetX, ty: targetY };\n      },\n      cancel(): void {\n        if (rafId) cancelAnimationFrame(rafId);\n        rafId = null;\n        running = false;\n        lastTs = 0;\n      }\n    };\n  }, [enableTilt]);\n\n  const getOffsets = (evt: PointerEvent, el: HTMLElement): { x: number; y: number } => {\n    const rect = el.getBoundingClientRect();\n    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };\n  };\n\n  const handlePointerMove = useCallback(\n    (event: PointerEvent): void => {\n      const shell = shellRef.current;\n      if (!shell || !tiltEngine) return;\n      const { x, y } = getOffsets(event, shell);\n      tiltEngine.setTarget(x, y);\n    },\n    [tiltEngine]\n  );\n\n  const handlePointerEnter = useCallback(\n    (event: PointerEvent): void => {\n      const shell = shellRef.current;\n      if (!shell || !tiltEngine) return;\n\n      shell.classList.add('active');\n      shell.classList.add('entering');\n      if (enterTimerRef.current) window.clearTimeout(enterTimerRef.current);\n      enterTimerRef.current = window.setTimeout(() => {\n        shell.classList.remove('entering');\n      }, ANIMATION_CONFIG.ENTER_TRANSITION_MS);\n\n      const { x, y } = getOffsets(event, shell);\n      tiltEngine.setTarget(x, y);\n    },\n    [tiltEngine]\n  );\n\n  const handlePointerLeave = useCallback((): void => {\n    const shell = shellRef.current;\n    if (!shell || !tiltEngine) return;\n\n    tiltEngine.toCenter();\n\n    const checkSettle = (): void => {\n      const { x, y, tx, ty } = tiltEngine.getCurrent();\n      const settled = Math.hypot(tx - x, ty - y) < 0.6;\n      if (settled) {\n        shell.classList.remove('active');\n        leaveRafRef.current = null;\n      } else {\n        leaveRafRef.current = requestAnimationFrame(checkSettle);\n      }\n    };\n    if (leaveRafRef.current) cancelAnimationFrame(leaveRafRef.current);\n    leaveRafRef.current = requestAnimationFrame(checkSettle);\n  }, [tiltEngine]);\n\n  const handleDeviceOrientation = useCallback(\n    (event: DeviceOrientationEvent): void => {\n      const shell = shellRef.current;\n      if (!shell || !tiltEngine) return;\n\n      const { beta, gamma } = event;\n      if (beta == null || gamma == null) return;\n\n      const centerX = shell.clientWidth / 2;\n      const centerY = shell.clientHeight / 2;\n      const x = clamp(centerX + gamma * mobileTiltSensitivity, 0, shell.clientWidth);\n      const y = clamp(\n        centerY + (beta - ANIMATION_CONFIG.DEVICE_BETA_OFFSET) * mobileTiltSensitivity,\n        0,\n        shell.clientHeight\n      );\n\n      tiltEngine.setTarget(x, y);\n    },\n    [tiltEngine, mobileTiltSensitivity]\n  );\n\n  useEffect(() => {\n    if (!enableTilt || !tiltEngine) return;\n\n    const shell = shellRef.current;\n    if (!shell) return;\n\n    const pointerMoveHandler = handlePointerMove as EventListener;\n    const pointerEnterHandler = handlePointerEnter as EventListener;\n    const pointerLeaveHandler = handlePointerLeave as EventListener;\n    const deviceOrientationHandler = handleDeviceOrientation as EventListener;\n\n    shell.addEventListener('pointerenter', pointerEnterHandler);\n    shell.addEventListener('pointermove', pointerMoveHandler);\n    shell.addEventListener('pointerleave', pointerLeaveHandler);\n\n    const handleClick = (): void => {\n      if (!enableMobileTilt || location.protocol !== 'https:') return;\n      const anyMotion = window.DeviceMotionEvent as typeof DeviceMotionEvent & {\n        requestPermission?: () => Promise<string>;\n      };\n      if (anyMotion && typeof anyMotion.requestPermission === 'function') {\n        anyMotion\n          .requestPermission()\n          .then((state: string) => {\n            if (state === 'granted') {\n              window.addEventListener('deviceorientation', deviceOrientationHandler);\n            }\n          })\n          .catch(console.error);\n      } else {\n        window.addEventListener('deviceorientation', deviceOrientationHandler);\n      }\n    };\n    shell.addEventListener('click', handleClick);\n\n    const initialX = (shell.clientWidth || 0) - ANIMATION_CONFIG.INITIAL_X_OFFSET;\n    const initialY = ANIMATION_CONFIG.INITIAL_Y_OFFSET;\n    tiltEngine.setImmediate(initialX, initialY);\n    tiltEngine.toCenter();\n    tiltEngine.beginInitial(ANIMATION_CONFIG.INITIAL_DURATION);\n\n    return () => {\n      shell.removeEventListener('pointerenter', pointerEnterHandler);\n      shell.removeEventListener('pointermove', pointerMoveHandler);\n      shell.removeEventListener('pointerleave', pointerLeaveHandler);\n      shell.removeEventListener('click', handleClick);\n      window.removeEventListener('deviceorientation', deviceOrientationHandler);\n      if (enterTimerRef.current) window.clearTimeout(enterTimerRef.current);\n      if (leaveRafRef.current) cancelAnimationFrame(leaveRafRef.current);\n      tiltEngine.cancel();\n      shell.classList.remove('entering');\n    };\n  }, [\n    enableTilt,\n    enableMobileTilt,\n    tiltEngine,\n    handlePointerMove,\n    handlePointerEnter,\n    handlePointerLeave,\n    handleDeviceOrientation\n  ]);\n\n  const cardRadius = '30px';\n\n  const cardStyle = useMemo(\n    () => ({\n      '--icon': iconUrl ? `url(${iconUrl})` : 'none',\n      '--grain': grainUrl ? `url(${grainUrl})` : 'none',\n      '--inner-gradient': innerGradient ?? DEFAULT_INNER_GRADIENT,\n      '--behind-glow-color': behindGlowColor ?? 'rgba(125, 190, 255, 0.67)',\n      '--behind-glow-size': behindGlowSize ?? '50%',\n      '--pointer-x': '50%',\n      '--pointer-y': '50%',\n      '--pointer-from-center': '0',\n      '--pointer-from-top': '0.5',\n      '--pointer-from-left': '0.5',\n      '--card-opacity': '0',\n      '--rotate-x': '0deg',\n      '--rotate-y': '0deg',\n      '--background-x': '50%',\n      '--background-y': '50%',\n      '--card-radius': cardRadius,\n      '--sunpillar-1': 'hsl(2, 100%, 73%)',\n      '--sunpillar-2': 'hsl(53, 100%, 69%)',\n      '--sunpillar-3': 'hsl(93, 100%, 69%)',\n      '--sunpillar-4': 'hsl(176, 100%, 76%)',\n      '--sunpillar-5': 'hsl(228, 100%, 74%)',\n      '--sunpillar-6': 'hsl(283, 100%, 73%)',\n      '--sunpillar-clr-1': 'var(--sunpillar-1)',\n      '--sunpillar-clr-2': 'var(--sunpillar-2)',\n      '--sunpillar-clr-3': 'var(--sunpillar-3)',\n      '--sunpillar-clr-4': 'var(--sunpillar-4)',\n      '--sunpillar-clr-5': 'var(--sunpillar-5)',\n      '--sunpillar-clr-6': 'var(--sunpillar-6)'\n    }),\n    [iconUrl, grainUrl, innerGradient, behindGlowColor, behindGlowSize, cardRadius]\n  );\n\n  const handleContactClick = useCallback((): void => {\n    onContactClick?.();\n  }, [onContactClick]);\n\n  // Complex styles that require CSS variables and can't be done with Tailwind\n  const shineStyle = {\n    maskImage: 'var(--icon)',\n    maskMode: 'luminance',\n    maskRepeat: 'repeat',\n    maskSize: '150%',\n    maskPosition: 'top calc(200% - (var(--background-y) * 5)) left calc(100% - var(--background-x))',\n    filter: 'brightness(0.66) contrast(1.33) saturate(0.33) opacity(0.5)',\n    animation: 'pc-holo-bg 18s linear infinite',\n    animationPlayState: 'running' as const,\n    mixBlendMode: 'color-dodge' as const,\n    transform: 'translate3d(0, 0, 1px)',\n    overflow: 'hidden' as const,\n    zIndex: 3,\n    background: 'transparent',\n    backgroundSize: 'cover',\n    backgroundPosition: 'center',\n    backgroundImage: `\n      repeating-linear-gradient(\n        0deg,\n        var(--sunpillar-clr-1) 5%,\n        var(--sunpillar-clr-2) 10%,\n        var(--sunpillar-clr-3) 15%,\n        var(--sunpillar-clr-4) 20%,\n        var(--sunpillar-clr-5) 25%,\n        var(--sunpillar-clr-6) 30%,\n        var(--sunpillar-clr-1) 35%\n      ),\n      repeating-linear-gradient(\n        -45deg,\n        #0e152e 0%,\n        hsl(180, 10%, 60%) 3.8%,\n        hsl(180, 29%, 66%) 4.5%,\n        hsl(180, 10%, 60%) 5.2%,\n        #0e152e 10%,\n        #0e152e 12%\n      ),\n      radial-gradient(\n        farthest-corner circle at var(--pointer-x) var(--pointer-y),\n        hsla(0, 0%, 0%, 0.1) 12%,\n        hsla(0, 0%, 0%, 0.15) 20%,\n        hsla(0, 0%, 0%, 0.25) 120%\n      )\n    `.replace(/\\s+/g, ' '),\n    gridArea: '1 / -1',\n    borderRadius: cardRadius,\n    pointerEvents: 'none' as const\n  };\n\n  const glareStyle: React.CSSProperties = {\n    transform: 'translate3d(0, 0, 1.1px)',\n    overflow: 'hidden',\n    backgroundImage: `radial-gradient(\n      farthest-corner circle at var(--pointer-x) var(--pointer-y),\n      hsl(248, 25%, 80%) 12%,\n      hsla(207, 40%, 30%, 0.8) 90%\n    )`,\n    mixBlendMode: 'overlay',\n    filter: 'brightness(0.8) contrast(1.2)',\n    zIndex: 4,\n    gridArea: '1 / -1',\n    borderRadius: cardRadius,\n    pointerEvents: 'none'\n  };\n\n  return (\n    <div\n      ref={wrapRef}\n      className={`relative touch-none ${className}`.trim()}\n      style={{ perspective: '500px', transform: 'translate3d(0, 0, 0.1px)', ...cardStyle } as React.CSSProperties}\n    >\n      {behindGlowEnabled && (\n        <div\n          className=\"absolute inset-0 z-0 pointer-events-none transition-opacity duration-200 ease-out\"\n          style={{\n            background: `radial-gradient(circle at var(--pointer-x) var(--pointer-y), var(--behind-glow-color) 0%, transparent var(--behind-glow-size))`,\n            filter: 'blur(50px) saturate(1.1)',\n            opacity: 'calc(0.8 * var(--card-opacity))'\n          }}\n        />\n      )}\n      <div ref={shellRef} className=\"relative z-[1] group\">\n        <section\n          className=\"grid relative overflow-hidden\"\n          style={{\n            height: '80svh',\n            maxHeight: '540px',\n            aspectRatio: '0.718',\n            borderRadius: cardRadius,\n            backgroundBlendMode: 'color-dodge, normal, normal, normal',\n            boxShadow:\n              'rgba(0, 0, 0, 0.8) calc((var(--pointer-from-left) * 10px) - 3px) calc((var(--pointer-from-top) * 20px) - 6px) 20px -5px',\n            transition: 'transform 1s ease',\n            transform: 'translateZ(0) rotateX(0deg) rotateY(0deg)',\n            background: 'rgba(0, 0, 0, 0.9)',\n            backfaceVisibility: 'hidden'\n          }}\n          onMouseEnter={e => {\n            e.currentTarget.style.transition = 'none';\n            e.currentTarget.style.transform = 'translateZ(0) rotateX(var(--rotate-y)) rotateY(var(--rotate-x))';\n          }}\n          onMouseLeave={e => {\n            const shell = shellRef.current;\n            if (shell?.classList.contains('entering')) {\n              e.currentTarget.style.transition = 'transform 180ms ease-out';\n            } else {\n              e.currentTarget.style.transition = 'transform 1s ease';\n            }\n            e.currentTarget.style.transform = 'translateZ(0) rotateX(0deg) rotateY(0deg)';\n          }}\n        >\n          <div\n            className=\"absolute inset-0\"\n            style={{\n              backgroundImage: 'var(--inner-gradient)',\n              backgroundColor: 'rgba(0, 0, 0, 0.9)',\n              borderRadius: cardRadius,\n              display: 'grid',\n              gridArea: '1 / -1'\n            }}\n          >\n            {/* Shine layer */}\n            <div style={shineStyle} />\n\n            {/* Glare layer */}\n            <div style={glareStyle} />\n\n            {/* Avatar content */}\n            <div\n              className=\"overflow-visible\"\n              style={{\n                mixBlendMode: 'luminosity',\n                transform: 'translateZ(2px)',\n                gridArea: '1 / -1',\n                borderRadius: cardRadius,\n                pointerEvents: 'none',\n                backfaceVisibility: 'hidden'\n              }}\n            >\n              <img\n                className=\"w-full absolute left-1/2 bottom-[-1px] will-change-transform transition-transform duration-[120ms] ease-out\"\n                src={avatarUrl}\n                alt={`${name || 'User'} avatar`}\n                loading=\"lazy\"\n                style={{\n                  transformOrigin: '50% 100%',\n                  transform:\n                    'translateX(calc(-50% + (var(--pointer-from-left) - 0.5) * 6px)) translateZ(0) scaleY(calc(1 + (var(--pointer-from-top) - 0.5) * 0.02)) scaleX(calc(1 + (var(--pointer-from-left) - 0.5) * 0.01))',\n                  borderRadius: cardRadius,\n                  backfaceVisibility: 'hidden'\n                }}\n                onError={e => {\n                  const t = e.target as HTMLImageElement;\n                  t.style.display = 'none';\n                }}\n              />\n              {showUserInfo && (\n                <div\n                  className=\"absolute z-[2] flex items-center justify-between backdrop-blur-[30px] border border-white/10 pointer-events-auto\"\n                  style={\n                    {\n                      '--ui-inset': '20px',\n                      '--ui-radius-bias': '6px',\n                      bottom: 'var(--ui-inset)',\n                      left: 'var(--ui-inset)',\n                      right: 'var(--ui-inset)',\n                      background: 'rgba(255, 255, 255, 0.1)',\n                      borderRadius: 'calc(max(0px, var(--card-radius) - var(--ui-inset) + var(--ui-radius-bias)))',\n                      padding: '12px 14px'\n                    } as React.CSSProperties\n                  }\n                >\n                  <div className=\"flex items-center gap-3\">\n                    <div\n                      className=\"rounded-full overflow-hidden border border-white/10 flex-shrink-0\"\n                      style={{ width: '48px', height: '48px' }}\n                    >\n                      <img\n                        className=\"w-full h-full object-cover rounded-full\"\n                        src={miniAvatarUrl || avatarUrl}\n                        alt={`${name || 'User'} mini avatar`}\n                        loading=\"lazy\"\n                        style={{ display: 'block', gridArea: 'auto', borderRadius: '50%', pointerEvents: 'auto' }}\n                        onError={e => {\n                          const t = e.target as HTMLImageElement;\n                          t.style.opacity = '0.5';\n                          t.src = avatarUrl;\n                        }}\n                      />\n                    </div>\n                    <div className=\"flex flex-col items-start gap-1.5\">\n                      <div className=\"text-sm font-medium text-white/90 leading-none\">@{handle}</div>\n                      <div className=\"text-sm text-white/70 leading-none\">{status}</div>\n                    </div>\n                  </div>\n                  <button\n                    className=\"border border-white/10 rounded-lg px-4 py-3 text-xs font-semibold text-white/90 cursor-pointer backdrop-blur-[10px] transition-all duration-200 ease-out hover:border-white/40 hover:-translate-y-px\"\n                    onClick={handleContactClick}\n                    style={{ pointerEvents: 'auto', display: 'block', gridArea: 'auto', borderRadius: '8px' }}\n                    type=\"button\"\n                    aria-label={`Contact ${name || 'user'}`}\n                  >\n                    {contactText}\n                  </button>\n                </div>\n              )}\n            </div>\n\n            {/* Details content */}\n            <div\n              className=\"max-h-full overflow-hidden text-center relative z-[5]\"\n              style={{\n                transform:\n                  'translate3d(calc(var(--pointer-from-left) * -6px + 3px), calc(var(--pointer-from-top) * -6px + 3px), 0.1px)',\n                mixBlendMode: 'luminosity',\n                gridArea: '1 / -1',\n                borderRadius: cardRadius,\n                pointerEvents: 'none'\n              }}\n            >\n              <div className=\"w-full absolute flex flex-col\" style={{ top: '3em', display: 'flex', gridArea: 'auto' }}>\n                <h3\n                  className=\"font-semibold m-0\"\n                  style={{\n                    fontSize: 'min(5svh, 3em)',\n                    backgroundImage: 'linear-gradient(to bottom, #fff, #6f6fbe)',\n                    backgroundSize: '1em 1.5em',\n                    WebkitTextFillColor: 'transparent',\n                    backgroundClip: 'text',\n                    WebkitBackgroundClip: 'text',\n                    display: 'block',\n                    gridArea: 'auto',\n                    borderRadius: '0',\n                    pointerEvents: 'auto'\n                  }}\n                >\n                  {name}\n                </h3>\n                <p\n                  className=\"font-semibold whitespace-nowrap mx-auto w-min\"\n                  style={{\n                    position: 'relative',\n                    top: '-12px',\n                    fontSize: '16px',\n                    margin: '0 auto',\n                    backgroundImage: 'linear-gradient(to bottom, #fff, #4a4ac0)',\n                    backgroundSize: '1em 1.5em',\n                    WebkitTextFillColor: 'transparent',\n                    backgroundClip: 'text',\n                    WebkitBackgroundClip: 'text',\n                    display: 'block',\n                    gridArea: 'auto',\n                    borderRadius: '0',\n                    pointerEvents: 'auto'\n                  }}\n                >\n                  {title}\n                </p>\n              </div>\n            </div>\n          </div>\n        </section>\n      </div>\n    </div>\n  );\n};\n\nconst ProfileCard = React.memo(ProfileCardComponent);\nexport default ProfileCard;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "reflective-card",
      "type": "component",
      "description": "A layouts reflective card component",
      "category": "layouts",
      "dependencies": [
        "lucide-react"
      ],
      "files": [
        {
          "path": "components/ui/reflective-card.tsx",
          "content": "import React, { useEffect, useRef, useState } from 'react';\nimport { Fingerprint, User, Activity, Lock } from 'lucide-react';\n\ninterface ReflectiveCardProps {\n  blurStrength?: number;\n  color?: string;\n  metalness?: number;\n  roughness?: number;\n  overlayColor?: string;\n  displacementStrength?: number;\n  noiseScale?: number;\n  specularConstant?: number;\n  grayscale?: number;\n  glassDistortion?: number;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst ReflectiveCard: React.FC<ReflectiveCardProps> = ({\n  blurStrength = 12,\n  color = 'white',\n  metalness = 1,\n  roughness = 0.4,\n  overlayColor = 'rgba(255, 255, 255, 0.1)',\n  displacementStrength = 20,\n  noiseScale = 1,\n  specularConstant = 1.2,\n  grayscale = 1,\n  glassDistortion = 0,\n  className = '',\n  style = {}\n}) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const [streamActive, setStreamActive] = useState(false);\n\n  useEffect(() => {\n    let stream: MediaStream | null = null;\n\n    const startWebcam = async () => {\n      try {\n        stream = await navigator.mediaDevices.getUserMedia({\n          video: {\n            width: { ideal: 640 },\n            height: { ideal: 480 },\n            facingMode: 'user'\n          }\n        });\n\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n          setStreamActive(true);\n        }\n      } catch (err) {\n        console.error('Error accessing webcam:', err);\n      }\n    };\n\n    startWebcam();\n\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, []);\n\n  const baseFrequency = 0.03 / Math.max(0.1, noiseScale);\n  const saturation = 1 - Math.max(0, Math.min(1, grayscale));\n\n  const cssVariables = {\n    '--blur-strength': `${blurStrength}px`,\n    '--metalness': metalness,\n    '--roughness': roughness,\n    '--overlay-color': overlayColor,\n    '--text-color': color,\n    '--saturation': saturation\n  } as React.CSSProperties;\n\n  return (\n    <div\n      className={`relative w-[320px] h-[500px] rounded-[20px] overflow-hidden bg-[#1a1a1a] shadow-[0_20px_50px_rgba(0,0,0,0.5),0_0_0_1px_rgba(255,255,255,0.1)_inset] isolate font-sans ${className}`}\n      style={{ ...style, ...cssVariables }}\n    >\n      <svg className=\"absolute w-0 h-0 pointer-events-none opacity-0\" aria-hidden=\"true\">\n        <defs>\n          <filter id=\"metallic-displacement\" x=\"-20%\" y=\"-20%\" width=\"140%\" height=\"140%\">\n            <feTurbulence type=\"turbulence\" baseFrequency={baseFrequency} numOctaves=\"2\" result=\"noise\" />\n            <feColorMatrix in=\"noise\" type=\"luminanceToAlpha\" result=\"noiseAlpha\" />\n            <feDisplacementMap\n              in=\"SourceGraphic\"\n              in2=\"noise\"\n              scale={displacementStrength}\n              xChannelSelector=\"R\"\n              yChannelSelector=\"G\"\n              result=\"rippled\"\n            />\n            <feSpecularLighting\n              in=\"noiseAlpha\"\n              surfaceScale={displacementStrength}\n              specularConstant={specularConstant}\n              specularExponent=\"20\"\n              lightingColor=\"#ffffff\"\n              result=\"light\"\n            >\n              <fePointLight x=\"0\" y=\"0\" z=\"300\" />\n            </feSpecularLighting>\n            <feComposite in=\"light\" in2=\"rippled\" operator=\"in\" result=\"light-effect\" />\n            <feBlend in=\"light-effect\" in2=\"rippled\" mode=\"screen\" result=\"metallic-result\" />\n            <feColorMatrix\n              in=\"SourceAlpha\"\n              type=\"matrix\"\n              values=\"0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0\"\n              result=\"solidAlpha\"\n            />\n            <feMorphology in=\"solidAlpha\" operator=\"erode\" radius=\"45\" result=\"erodedAlpha\" />\n            <feGaussianBlur in=\"erodedAlpha\" stdDeviation=\"10\" result=\"blurredMap\" />\n            <feComponentTransfer in=\"blurredMap\" result=\"glassMap\">\n              <feFuncA type=\"linear\" slope=\"0.5\" intercept=\"0\" />\n            </feComponentTransfer>\n            <feDisplacementMap\n              in=\"metallic-result\"\n              in2=\"glassMap\"\n              scale={glassDistortion}\n              xChannelSelector=\"A\"\n              yChannelSelector=\"A\"\n              result=\"final\"\n            />\n          </filter>\n        </defs>\n      </svg>\n\n      <video\n        ref={videoRef}\n        autoPlay\n        playsInline\n        muted\n        className=\"absolute top-0 left-0 w-full h-full object-cover scale-[1.2] -scale-x-100 z-0 opacity-90 transition-[filter] duration-300\"\n        style={{\n          filter:\n            'saturate(var(--saturation, 0)) contrast(120%) brightness(110%) blur(var(--blur-strength, 12px)) url(#metallic-displacement)'\n        }}\n      />\n\n      <div className=\"absolute inset-0 z-10 opacity-[var(--roughness,0.4)] pointer-events-none bg-[url('data:image/svg+xml,%3Csvg%20viewBox%3D%270%200%20200%20200%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Cfilter%20id%3D%27noiseFilter%27%3E%3CfeTurbulence%20type%3D%27fractalNoise%27%20baseFrequency%3D%270.8%27%20numOctaves%3D%273%27%20stitchTiles%3D%27stitch%27%2F%3E%3C%2Ffilter%3E%3Crect%20width%3D%27100%25%27%20height%3D%27100%25%27%20filter%3D%27url(%23noiseFilter)%27%2F%3E%3C%2Fsvg%3E')] mix-blend-overlay\" />\n\n      <div className=\"absolute inset-0 z-20 bg-[linear-gradient(135deg,rgba(255,255,255,0.4)_0%,rgba(255,255,255,0.1)_40%,rgba(255,255,255,0)_50%,rgba(255,255,255,0.1)_60%,rgba(255,255,255,0.3)_100%)] pointer-events-none mix-blend-overlay opacity-[var(--metalness,1)]\" />\n\n      <div className=\"absolute inset-0 rounded-[20px] p-[1px] bg-[linear-gradient(135deg,rgba(255,255,255,0.8)_0%,rgba(255,255,255,0.2)_50%,rgba(255,255,255,0.6)_100%)] [mask:linear-gradient(#fff_0_0)_content-box,linear-gradient(#fff_0_0)] [mask-composite:exclude] z-20 pointer-events-none\" />\n\n      <div className=\"relative z-10 h-full flex flex-col justify-between p-8 text-[var(--text-color,white)] bg-[var(--overlay-color,rgba(255,255,255,0.05))]\">\n        <div className=\"flex justify-between items-center border-b border-white/20 pb-4\">\n          <div className=\"flex items-center gap-1.5 text-[10px] font-bold tracking-[0.1em] px-2 py-1 bg-white/10 rounded border border-white/20\">\n            <Lock size={14} className=\"opacity-80\" />\n            <span>SECURE ACCESS</span>\n          </div>\n          <Activity className=\"opacity-80\" size={20} />\n        </div>\n\n        <div className=\"flex-1 flex flex-col justify-end items-center text-center gap-6 mb-8\">\n          <div className=\"text-center\">\n            <h2 className=\"text-2xl font-bold tracking-[0.05em] m-0 mb-2 drop-shadow-md\">ALEXANDER DOE</h2>\n            <p className=\"text-xs tracking-[0.2em] opacity-70 m-0 uppercase\">SENIOR DEVELOPER</p>\n          </div>\n        </div>\n\n        <div className=\"flex justify-between items-end border-t border-white/20 pt-6\">\n          <div className=\"flex flex-col gap-1\">\n            <span className=\"text-[9px] tracking-[0.1em] opacity-60\">ID NUMBER</span>\n            <span className=\"font-mono text-sm tracking-[0.05em]\">8901-2345-6789</span>\n          </div>\n          <div className=\"opacity-40\">\n            <Fingerprint size={32} />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ReflectiveCard;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "scroll-stack",
      "type": "component",
      "description": "A layouts scroll stack component",
      "category": "layouts",
      "dependencies": [
        "lenis"
      ],
      "files": [
        {
          "path": "components/ui/scroll-stack.tsx",
          "content": "import React, { useLayoutEffect, useRef, useCallback } from 'react';\nimport type { ReactNode } from 'react';\nimport Lenis from 'lenis';\n\nexport interface ScrollStackItemProps {\n  itemClassName?: string;\n  children: ReactNode;\n}\n\nexport const ScrollStackItem: React.FC<ScrollStackItemProps> = ({ children, itemClassName = '' }) => (\n  <div\n    className={`scroll-stack-card relative w-full h-80 my-8 p-12 rounded-[40px] shadow-[0_0_30px_rgba(0,0,0,0.1)] box-border origin-top will-change-transform ${itemClassName}`.trim()}\n    style={{\n      backfaceVisibility: 'hidden',\n      transformStyle: 'preserve-3d'\n    }}\n  >\n    {children}\n  </div>\n);\n\ninterface ScrollStackProps {\n  className?: string;\n  children: ReactNode;\n  itemDistance?: number;\n  itemScale?: number;\n  itemStackDistance?: number;\n  stackPosition?: string;\n  scaleEndPosition?: string;\n  baseScale?: number;\n  scaleDuration?: number;\n  rotationAmount?: number;\n  blurAmount?: number;\n  useWindowScroll?: boolean;\n  onStackComplete?: () => void;\n}\n\nconst ScrollStack: React.FC<ScrollStackProps> = ({\n  children,\n  className = '',\n  itemDistance = 100,\n  itemScale = 0.03,\n  itemStackDistance = 30,\n  stackPosition = '20%',\n  scaleEndPosition = '10%',\n  baseScale = 0.85,\n  scaleDuration = 0.5,\n  rotationAmount = 0,\n  blurAmount = 0,\n  useWindowScroll = false,\n  onStackComplete\n}) => {\n  const scrollerRef = useRef<HTMLDivElement>(null);\n  const stackCompletedRef = useRef(false);\n  const animationFrameRef = useRef<number | null>(null);\n  const lenisRef = useRef<Lenis | null>(null);\n  const cardsRef = useRef<HTMLElement[]>([]);\n  const lastTransformsRef = useRef(new Map<number, any>());\n  const isUpdatingRef = useRef(false);\n\n  const calculateProgress = useCallback((scrollTop: number, start: number, end: number) => {\n    if (scrollTop < start) return 0;\n    if (scrollTop > end) return 1;\n    return (scrollTop - start) / (end - start);\n  }, []);\n\n  const parsePercentage = useCallback((value: string | number, containerHeight: number) => {\n    if (typeof value === 'string' && value.includes('%')) {\n      return (parseFloat(value) / 100) * containerHeight;\n    }\n    return parseFloat(value as string);\n  }, []);\n\n  const getScrollData = useCallback(() => {\n    if (useWindowScroll) {\n      return {\n        scrollTop: window.scrollY,\n        containerHeight: window.innerHeight,\n        scrollContainer: document.documentElement\n      };\n    } else {\n      const scroller = scrollerRef.current;\n      return {\n        scrollTop: scroller ? scroller.scrollTop : 0,\n        containerHeight: scroller ? scroller.clientHeight : 0,\n        scrollContainer: scroller\n      };\n    }\n  }, [useWindowScroll]);\n\n  const getElementOffset = useCallback(\n    (element: HTMLElement) => {\n      if (useWindowScroll) {\n        const rect = element.getBoundingClientRect();\n        return rect.top + window.scrollY;\n      } else {\n        return element.offsetTop;\n      }\n    },\n    [useWindowScroll]\n  );\n\n  const updateCardTransforms = useCallback(() => {\n    if (!cardsRef.current.length || isUpdatingRef.current) return;\n\n    isUpdatingRef.current = true;\n\n    const { scrollTop, containerHeight, scrollContainer } = getScrollData();\n    const stackPositionPx = parsePercentage(stackPosition, containerHeight);\n    const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);\n\n    const endElement = useWindowScroll\n      ? (document.querySelector('.scroll-stack-end') as HTMLElement | null)\n      : (scrollerRef.current?.querySelector('.scroll-stack-end') as HTMLElement | null);\n\n    const endElementTop = endElement ? getElementOffset(endElement) : 0;\n\n    cardsRef.current.forEach((card, i) => {\n      if (!card) return;\n\n      const cardTop = getElementOffset(card);\n      const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;\n      const triggerEnd = cardTop - scaleEndPositionPx;\n      const pinStart = cardTop - stackPositionPx - itemStackDistance * i;\n      const pinEnd = endElementTop - containerHeight / 2;\n\n      const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);\n      const targetScale = baseScale + i * itemScale;\n      const scale = 1 - scaleProgress * (1 - targetScale);\n      const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;\n\n      let blur = 0;\n      if (blurAmount) {\n        let topCardIndex = 0;\n        for (let j = 0; j < cardsRef.current.length; j++) {\n          const jCardTop = getElementOffset(cardsRef.current[j]);\n          const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;\n          if (scrollTop >= jTriggerStart) {\n            topCardIndex = j;\n          }\n        }\n\n        if (i < topCardIndex) {\n          const depthInStack = topCardIndex - i;\n          blur = Math.max(0, depthInStack * blurAmount);\n        }\n      }\n\n      let translateY = 0;\n      const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;\n\n      if (isPinned) {\n        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;\n      } else if (scrollTop > pinEnd) {\n        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;\n      }\n\n      const newTransform = {\n        translateY: Math.round(translateY * 100) / 100,\n        scale: Math.round(scale * 1000) / 1000,\n        rotation: Math.round(rotation * 100) / 100,\n        blur: Math.round(blur * 100) / 100\n      };\n\n      const lastTransform = lastTransformsRef.current.get(i);\n      const hasChanged =\n        !lastTransform ||\n        Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 ||\n        Math.abs(lastTransform.scale - newTransform.scale) > 0.001 ||\n        Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 ||\n        Math.abs(lastTransform.blur - newTransform.blur) > 0.1;\n\n      if (hasChanged) {\n        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;\n        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';\n\n        card.style.transform = transform;\n        card.style.filter = filter;\n\n        lastTransformsRef.current.set(i, newTransform);\n      }\n\n      if (i === cardsRef.current.length - 1) {\n        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;\n        if (isInView && !stackCompletedRef.current) {\n          stackCompletedRef.current = true;\n          onStackComplete?.();\n        } else if (!isInView && stackCompletedRef.current) {\n          stackCompletedRef.current = false;\n        }\n      }\n    });\n\n    isUpdatingRef.current = false;\n  }, [\n    itemScale,\n    itemStackDistance,\n    stackPosition,\n    scaleEndPosition,\n    baseScale,\n    rotationAmount,\n    blurAmount,\n    useWindowScroll,\n    onStackComplete,\n    calculateProgress,\n    parsePercentage,\n    getScrollData,\n    getElementOffset\n  ]);\n\n  const handleScroll = useCallback(() => {\n    updateCardTransforms();\n  }, [updateCardTransforms]);\n\n  const setupLenis = useCallback(() => {\n    if (useWindowScroll) {\n      const lenis = new Lenis({\n        duration: 1.2,\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n        smoothWheel: true,\n        touchMultiplier: 2,\n        infinite: false,\n        wheelMultiplier: 1,\n        lerp: 0.1,\n        syncTouch: true,\n        syncTouchLerp: 0.075\n      });\n\n      lenis.on('scroll', handleScroll);\n\n      const raf = (time: number) => {\n        lenis.raf(time);\n        animationFrameRef.current = requestAnimationFrame(raf);\n      };\n      animationFrameRef.current = requestAnimationFrame(raf);\n\n      lenisRef.current = lenis;\n      return lenis;\n    } else {\n      const scroller = scrollerRef.current;\n      if (!scroller) return;\n\n      const lenis = new Lenis({\n        wrapper: scroller,\n        content: scroller.querySelector('.scroll-stack-inner') as HTMLElement,\n        duration: 1.2,\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n        smoothWheel: true,\n        touchMultiplier: 2,\n        infinite: false,\n        gestureOrientation: 'vertical',\n        wheelMultiplier: 1,\n        lerp: 0.1,\n        syncTouch: true,\n        syncTouchLerp: 0.075\n      });\n\n      lenis.on('scroll', handleScroll);\n\n      const raf = (time: number) => {\n        lenis.raf(time);\n        animationFrameRef.current = requestAnimationFrame(raf);\n      };\n      animationFrameRef.current = requestAnimationFrame(raf);\n\n      lenisRef.current = lenis;\n      return lenis;\n    }\n  }, [handleScroll, useWindowScroll]);\n\n  useLayoutEffect(() => {\n    if (!useWindowScroll && !scrollerRef.current) return;\n\n    const cards = Array.from(\n      useWindowScroll\n        ? document.querySelectorAll('.scroll-stack-card')\n        : (scrollerRef.current?.querySelectorAll('.scroll-stack-card') ?? [])\n    ) as HTMLElement[];\n    cardsRef.current = cards;\n    const transformsCache = lastTransformsRef.current;\n\n    cards.forEach((card, i) => {\n      if (i < cards.length - 1) {\n        card.style.marginBottom = `${itemDistance}px`;\n      }\n      card.style.willChange = 'transform, filter';\n      card.style.transformOrigin = 'top center';\n      card.style.backfaceVisibility = 'hidden';\n      card.style.transform = 'translateZ(0)';\n      card.style.webkitTransform = 'translateZ(0)';\n      card.style.perspective = '1000px';\n      card.style.webkitPerspective = '1000px';\n    });\n\n    setupLenis();\n\n    updateCardTransforms();\n\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      if (lenisRef.current) {\n        lenisRef.current.destroy();\n      }\n      stackCompletedRef.current = false;\n      cardsRef.current = [];\n      transformsCache.clear();\n      isUpdatingRef.current = false;\n    };\n  }, [\n    itemDistance,\n    itemScale,\n    itemStackDistance,\n    stackPosition,\n    scaleEndPosition,\n    baseScale,\n    scaleDuration,\n    rotationAmount,\n    blurAmount,\n    useWindowScroll,\n    onStackComplete,\n    setupLenis,\n    updateCardTransforms\n  ]);\n\n  return (\n    <div\n      className={`relative w-full h-full overflow-y-auto overflow-x-visible ${className}`.trim()}\n      ref={scrollerRef}\n      style={{\n        overscrollBehavior: 'contain',\n        WebkitOverflowScrolling: 'touch',\n        scrollBehavior: 'smooth',\n        WebkitTransform: 'translateZ(0)',\n        transform: 'translateZ(0)',\n        willChange: 'scroll-position'\n      }}\n    >\n      <div className=\"scroll-stack-inner pt-[20vh] px-20 pb-[50rem] min-h-screen\">\n        {children}\n        {/* Spacer so the last pin can release cleanly */}\n        <div className=\"scroll-stack-end w-full h-px\" />\n      </div>\n    </div>\n  );\n};\n\nexport default ScrollStack;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "spotlight-card",
      "type": "component",
      "description": "A layouts spotlight card component",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/spotlight-card.tsx",
          "content": "import React, { useRef, useState } from 'react';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface SpotlightCardProps extends React.PropsWithChildren {\n  className?: string;\n  spotlightColor?: `rgba(${number}, ${number}, ${number}, ${number})`;\n}\n\nconst SpotlightCard: React.FC<SpotlightCardProps> = ({\n  children,\n  className = '',\n  spotlightColor = 'rgba(255, 255, 255, 0.25)'\n}) => {\n  const divRef = useRef<HTMLDivElement>(null);\n  const [isFocused, setIsFocused] = useState<boolean>(false);\n  const [position, setPosition] = useState<Position>({ x: 0, y: 0 });\n  const [opacity, setOpacity] = useState<number>(0);\n\n  const handleMouseMove: React.MouseEventHandler<HTMLDivElement> = e => {\n    if (!divRef.current || isFocused) return;\n\n    const rect = divRef.current.getBoundingClientRect();\n    setPosition({ x: e.clientX - rect.left, y: e.clientY - rect.top });\n  };\n\n  const handleFocus = () => {\n    setIsFocused(true);\n    setOpacity(0.6);\n  };\n\n  const handleBlur = () => {\n    setIsFocused(false);\n    setOpacity(0);\n  };\n\n  const handleMouseEnter = () => {\n    setOpacity(0.6);\n  };\n\n  const handleMouseLeave = () => {\n    setOpacity(0);\n  };\n\n  return (\n    <div\n      ref={divRef}\n      onMouseMove={handleMouseMove}\n      onFocus={handleFocus}\n      onBlur={handleBlur}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      className={`relative rounded-3xl border border-neutral-800 bg-neutral-900 overflow-hidden p-8 ${className}`}\n    >\n      <div\n        className=\"pointer-events-none absolute inset-0 opacity-0 transition-opacity duration-500 ease-in-out\"\n        style={{\n          opacity,\n          background: `radial-gradient(circle at ${position.x}px ${position.y}px, ${spotlightColor}, transparent 80%)`\n        }}\n      />\n      {children}\n    </div>\n  );\n};\n\nexport default SpotlightCard;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "stack",
      "type": "component",
      "description": "A layouts stack component",
      "category": "layouts",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/stack.tsx",
          "content": "import { motion, useMotionValue, useTransform, type PanInfo } from 'motion/react';\nimport { useState, useEffect } from 'react';\n\ninterface CardRotateProps {\n  children: React.ReactNode;\n  onSendToBack: () => void;\n  sensitivity: number;\n  disableDrag?: boolean;\n}\n\nfunction CardRotate({ children, onSendToBack, sensitivity, disableDrag = false }: CardRotateProps) {\n  const x = useMotionValue(0);\n  const y = useMotionValue(0);\n  const rotateX = useTransform(y, [-100, 100], [60, -60]);\n  const rotateY = useTransform(x, [-100, 100], [-60, 60]);\n\n  function handleDragEnd(_event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) {\n    if (Math.abs(info.offset.x) > sensitivity || Math.abs(info.offset.y) > sensitivity) {\n      onSendToBack();\n    } else {\n      x.set(0);\n      y.set(0);\n    }\n  }\n\n  if (disableDrag) {\n    return (\n      <motion.div className=\"absolute inset-0 cursor-pointer\" style={{ x: 0, y: 0 }}>\n        {children}\n      </motion.div>\n    );\n  }\n\n  return (\n    <motion.div\n      className=\"absolute inset-0 cursor-grab\"\n      style={{ x, y, rotateX, rotateY }}\n      drag\n      dragConstraints={{ top: 0, right: 0, bottom: 0, left: 0 }}\n      dragElastic={0.6}\n      whileTap={{ cursor: 'grabbing' }}\n      onDragEnd={handleDragEnd}\n    >\n      {children}\n    </motion.div>\n  );\n}\n\ninterface StackProps {\n  randomRotation?: boolean;\n  sensitivity?: number;\n  sendToBackOnClick?: boolean;\n  cards?: React.ReactNode[];\n  animationConfig?: { stiffness: number; damping: number };\n  autoplay?: boolean;\n  autoplayDelay?: number;\n  pauseOnHover?: boolean;\n  mobileClickOnly?: boolean;\n  mobileBreakpoint?: number;\n}\n\nexport default function Stack({\n  randomRotation = false,\n  sensitivity = 200,\n  cards = [],\n  animationConfig = { stiffness: 260, damping: 20 },\n  sendToBackOnClick = false,\n  autoplay = false,\n  autoplayDelay = 3000,\n  pauseOnHover = false,\n  mobileClickOnly = false,\n  mobileBreakpoint = 768\n}: StackProps) {\n  const [isMobile, setIsMobile] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n\n  useEffect(() => {\n    const checkMobile = () => {\n      setIsMobile(window.innerWidth < mobileBreakpoint);\n    };\n\n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n    return () => window.removeEventListener('resize', checkMobile);\n  }, [mobileBreakpoint]);\n\n  const shouldDisableDrag = mobileClickOnly && isMobile;\n  const shouldEnableClick = sendToBackOnClick || shouldDisableDrag;\n\n  const [stack, setStack] = useState<{ id: number; content: React.ReactNode }[]>(() => {\n    if (cards.length) {\n      return cards.map((content, index) => ({ id: index + 1, content }));\n    } else {\n      return [\n        {\n          id: 1,\n          content: (\n            <img\n              src=\"https://images.unsplash.com/photo-1480074568708-e7b720bb3f09?q=80&w=500&auto=format\"\n              alt=\"card-1\"\n              className=\"w-full h-full object-cover pointer-events-none\"\n            />\n          )\n        },\n        {\n          id: 2,\n          content: (\n            <img\n              src=\"https://images.unsplash.com/photo-1449844908441-8829872d2607?q=80&w=500&auto=format\"\n              alt=\"card-2\"\n              className=\"w-full h-full object-cover pointer-events-none\"\n            />\n          )\n        },\n        {\n          id: 3,\n          content: (\n            <img\n              src=\"https://images.unsplash.com/photo-1452626212852-811d58933cae?q=80&w=500&auto=format\"\n              alt=\"card-3\"\n              className=\"w-full h-full object-cover pointer-events-none\"\n            />\n          )\n        },\n        {\n          id: 4,\n          content: (\n            <img\n              src=\"https://images.unsplash.com/photo-1572120360610-d971b9d7767c?q=80&w=500&auto=format\"\n              alt=\"card-4\"\n              className=\"w-full h-full object-cover pointer-events-none\"\n            />\n          )\n        }\n      ];\n    }\n  });\n\n  useEffect(() => {\n    if (cards.length) {\n      setStack(cards.map((content, index) => ({ id: index + 1, content })));\n    }\n  }, [cards]);\n\n  const sendToBack = (id: number) => {\n    setStack(prev => {\n      const newStack = [...prev];\n      const index = newStack.findIndex(card => card.id === id);\n      const [card] = newStack.splice(index, 1);\n      newStack.unshift(card);\n      return newStack;\n    });\n  };\n\n  useEffect(() => {\n    if (autoplay && stack.length > 1 && !isPaused) {\n      const interval = setInterval(() => {\n        const topCardId = stack[stack.length - 1].id;\n        sendToBack(topCardId);\n      }, autoplayDelay);\n\n      return () => clearInterval(interval);\n    }\n  }, [autoplay, autoplayDelay, stack, isPaused]);\n\n  return (\n    <div\n      className=\"relative w-full h-full\"\n      style={{\n        perspective: 600\n      }}\n      onMouseEnter={() => pauseOnHover && setIsPaused(true)}\n      onMouseLeave={() => pauseOnHover && setIsPaused(false)}\n    >\n      {stack.map((card, index) => {\n        const randomRotate = randomRotation ? Math.random() * 10 - 5 : 0;\n        return (\n          <CardRotate\n            key={card.id}\n            onSendToBack={() => sendToBack(card.id)}\n            sensitivity={sensitivity}\n            disableDrag={shouldDisableDrag}\n          >\n            <motion.div\n              className=\"rounded-2xl overflow-hidden w-full h-full\"\n              onClick={() => shouldEnableClick && sendToBack(card.id)}\n              animate={{\n                rotateZ: (stack.length - index - 1) * 4 + randomRotate,\n                scale: 1 + index * 0.06 - stack.length * 0.06,\n                transformOrigin: '90% 90%'\n              }}\n              initial={false}\n              transition={{\n                type: 'spring',\n                stiffness: animationConfig.stiffness,\n                damping: animationConfig.damping\n              }}\n            >\n              {card.content}\n            </motion.div>\n          </CardRotate>\n        );\n      })}\n    </div>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "staggered-menu",
      "type": "component",
      "description": "A layouts staggered menu component",
      "category": "layouts",
      "dependencies": [
        "gsap"
      ],
      "files": [
        {
          "path": "components/ui/staggered-menu.tsx",
          "content": "import React, { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport { gsap } from 'gsap';\n\nexport interface StaggeredMenuItem {\n  label: string;\n  ariaLabel: string;\n  link: string;\n}\nexport interface StaggeredMenuSocialItem {\n  label: string;\n  link: string;\n}\nexport interface StaggeredMenuProps {\n  position?: 'left' | 'right';\n  colors?: string[];\n  items?: StaggeredMenuItem[];\n  socialItems?: StaggeredMenuSocialItem[];\n  displaySocials?: boolean;\n  displayItemNumbering?: boolean;\n  className?: string;\n  logoUrl?: string;\n  menuButtonColor?: string;\n  openMenuButtonColor?: string;\n  accentColor?: string;\n  isFixed: boolean;\n  changeMenuColorOnOpen?: boolean;\n  closeOnClickAway?: boolean;\n  onMenuOpen?: () => void;\n  onMenuClose?: () => void;\n}\n\nexport const StaggeredMenu: React.FC<StaggeredMenuProps> = ({\n  position = 'right',\n  colors = ['#B19EEF', '#5227FF'],\n  items = [],\n  socialItems = [],\n  displaySocials = true,\n  displayItemNumbering = true,\n  className,\n  logoUrl = '/src/assets/logos/reactbits-gh-white.svg',\n  menuButtonColor = '#fff',\n  openMenuButtonColor = '#fff',\n  changeMenuColorOnOpen = true,\n  accentColor = '#5227FF',\n  isFixed = false,\n  closeOnClickAway = true,\n  onMenuOpen,\n  onMenuClose\n}: StaggeredMenuProps) => {\n  const [open, setOpen] = useState(false);\n  const openRef = useRef(false);\n\n  const panelRef = useRef<HTMLDivElement | null>(null);\n  const preLayersRef = useRef<HTMLDivElement | null>(null);\n  const preLayerElsRef = useRef<HTMLElement[]>([]);\n\n  const plusHRef = useRef<HTMLSpanElement | null>(null);\n  const plusVRef = useRef<HTMLSpanElement | null>(null);\n  const iconRef = useRef<HTMLSpanElement | null>(null);\n\n  const textInnerRef = useRef<HTMLSpanElement | null>(null);\n  const textWrapRef = useRef<HTMLSpanElement | null>(null);\n  const [textLines, setTextLines] = useState<string[]>(['Menu', 'Close']);\n\n  const openTlRef = useRef<gsap.core.Timeline | null>(null);\n  const closeTweenRef = useRef<gsap.core.Tween | null>(null);\n  const spinTweenRef = useRef<gsap.core.Timeline | null>(null);\n  const textCycleAnimRef = useRef<gsap.core.Tween | null>(null);\n  const colorTweenRef = useRef<gsap.core.Tween | null>(null);\n\n  const toggleBtnRef = useRef<HTMLButtonElement | null>(null);\n  const busyRef = useRef(false);\n\n  const itemEntranceTweenRef = useRef<gsap.core.Tween | null>(null);\n\n  useLayoutEffect(() => {\n    const ctx = gsap.context(() => {\n      const panel = panelRef.current;\n      const preContainer = preLayersRef.current;\n\n      const plusH = plusHRef.current;\n      const plusV = plusVRef.current;\n      const icon = iconRef.current;\n      const textInner = textInnerRef.current;\n\n      if (!panel || !plusH || !plusV || !icon || !textInner) return;\n\n      let preLayers: HTMLElement[] = [];\n      if (preContainer) {\n        preLayers = Array.from(preContainer.querySelectorAll('.sm-prelayer')) as HTMLElement[];\n      }\n      preLayerElsRef.current = preLayers;\n\n      const offscreen = position === 'left' ? -100 : 100;\n      gsap.set([panel, ...preLayers], { xPercent: offscreen });\n\n      gsap.set(plusH, { transformOrigin: '50% 50%', rotate: 0 });\n      gsap.set(plusV, { transformOrigin: '50% 50%', rotate: 90 });\n      gsap.set(icon, { rotate: 0, transformOrigin: '50% 50%' });\n\n      gsap.set(textInner, { yPercent: 0 });\n\n      if (toggleBtnRef.current) gsap.set(toggleBtnRef.current, { color: menuButtonColor });\n    });\n    return () => ctx.revert();\n  }, [menuButtonColor, position]);\n\n  const buildOpenTimeline = useCallback(() => {\n    const panel = panelRef.current;\n    const layers = preLayerElsRef.current;\n    if (!panel) return null;\n\n    openTlRef.current?.kill();\n    if (closeTweenRef.current) {\n      closeTweenRef.current.kill();\n      closeTweenRef.current = null;\n    }\n    itemEntranceTweenRef.current?.kill();\n\n    const itemEls = Array.from(panel.querySelectorAll('.sm-panel-itemLabel')) as HTMLElement[];\n    const numberEls = Array.from(\n      panel.querySelectorAll('.sm-panel-list[data-numbering] .sm-panel-item')\n    ) as HTMLElement[];\n    const socialTitle = panel.querySelector('.sm-socials-title') as HTMLElement | null;\n    const socialLinks = Array.from(panel.querySelectorAll('.sm-socials-link')) as HTMLElement[];\n\n    const layerStates = layers.map(el => ({ el, start: Number(gsap.getProperty(el, 'xPercent')) }));\n    const panelStart = Number(gsap.getProperty(panel, 'xPercent'));\n\n    if (itemEls.length) gsap.set(itemEls, { yPercent: 140, rotate: 10 });\n    if (numberEls.length) gsap.set(numberEls, { ['--sm-num-opacity' as any]: 0 });\n    if (socialTitle) gsap.set(socialTitle, { opacity: 0 });\n    if (socialLinks.length) gsap.set(socialLinks, { y: 25, opacity: 0 });\n\n    const tl = gsap.timeline({ paused: true });\n\n    layerStates.forEach((ls, i) => {\n      tl.fromTo(ls.el, { xPercent: ls.start }, { xPercent: 0, duration: 0.5, ease: 'power4.out' }, i * 0.07);\n    });\n\n    const lastTime = layerStates.length ? (layerStates.length - 1) * 0.07 : 0;\n    const panelInsertTime = lastTime + (layerStates.length ? 0.08 : 0);\n    const panelDuration = 0.65;\n\n    tl.fromTo(\n      panel,\n      { xPercent: panelStart },\n      { xPercent: 0, duration: panelDuration, ease: 'power4.out' },\n      panelInsertTime\n    );\n\n    if (itemEls.length) {\n      const itemsStartRatio = 0.15;\n      const itemsStart = panelInsertTime + panelDuration * itemsStartRatio;\n\n      tl.to(\n        itemEls,\n        { yPercent: 0, rotate: 0, duration: 1, ease: 'power4.out', stagger: { each: 0.1, from: 'start' } },\n        itemsStart\n      );\n\n      if (numberEls.length) {\n        tl.to(\n          numberEls,\n          { duration: 0.6, ease: 'power2.out', ['--sm-num-opacity' as any]: 1, stagger: { each: 0.08, from: 'start' } },\n          itemsStart + 0.1\n        );\n      }\n    }\n\n    if (socialTitle || socialLinks.length) {\n      const socialsStart = panelInsertTime + panelDuration * 0.4;\n\n      if (socialTitle) tl.to(socialTitle, { opacity: 1, duration: 0.5, ease: 'power2.out' }, socialsStart);\n      if (socialLinks.length) {\n        tl.to(\n          socialLinks,\n          {\n            y: 0,\n            opacity: 1,\n            duration: 0.55,\n            ease: 'power3.out',\n            stagger: { each: 0.08, from: 'start' },\n            onComplete: () => {\n              gsap.set(socialLinks, { clearProps: 'opacity' });\n            }\n          },\n          socialsStart + 0.04\n        );\n      }\n    }\n\n    openTlRef.current = tl;\n    return tl;\n  }, [position]);\n\n  const playOpen = useCallback(() => {\n    if (busyRef.current) return;\n    busyRef.current = true;\n    const tl = buildOpenTimeline();\n    if (tl) {\n      tl.eventCallback('onComplete', () => {\n        busyRef.current = false;\n      });\n      tl.play(0);\n    } else {\n      busyRef.current = false;\n    }\n  }, [buildOpenTimeline]);\n\n  const playClose = useCallback(() => {\n    openTlRef.current?.kill();\n    openTlRef.current = null;\n    itemEntranceTweenRef.current?.kill();\n\n    const panel = panelRef.current;\n    const layers = preLayerElsRef.current;\n    if (!panel) return;\n\n    const all: HTMLElement[] = [...layers, panel];\n    closeTweenRef.current?.kill();\n\n    const offscreen = position === 'left' ? -100 : 100;\n\n    closeTweenRef.current = gsap.to(all, {\n      xPercent: offscreen,\n      duration: 0.32,\n      ease: 'power3.in',\n      overwrite: 'auto',\n      onComplete: () => {\n        const itemEls = Array.from(panel.querySelectorAll('.sm-panel-itemLabel')) as HTMLElement[];\n        if (itemEls.length) gsap.set(itemEls, { yPercent: 140, rotate: 10 });\n\n        const numberEls = Array.from(\n          panel.querySelectorAll('.sm-panel-list[data-numbering] .sm-panel-item')\n        ) as HTMLElement[];\n        if (numberEls.length) gsap.set(numberEls, { ['--sm-num-opacity' as any]: 0 });\n\n        const socialTitle = panel.querySelector('.sm-socials-title') as HTMLElement | null;\n        const socialLinks = Array.from(panel.querySelectorAll('.sm-socials-link')) as HTMLElement[];\n        if (socialTitle) gsap.set(socialTitle, { opacity: 0 });\n        if (socialLinks.length) gsap.set(socialLinks, { y: 25, opacity: 0 });\n\n        busyRef.current = false;\n      }\n    });\n  }, [position]);\n\n  const animateIcon = useCallback((opening: boolean) => {\n    const icon = iconRef.current;\n    const h = plusHRef.current;\n    const v = plusVRef.current;\n    if (!icon || !h || !v) return;\n\n    spinTweenRef.current?.kill();\n\n    if (opening) {\n      // ensure container never rotates\n      gsap.set(icon, { rotate: 0, transformOrigin: '50% 50%' });\n      spinTweenRef.current = gsap\n        .timeline({ defaults: { ease: 'power4.out' } })\n        .to(h, { rotate: 45, duration: 0.5 }, 0)\n        .to(v, { rotate: -45, duration: 0.5 }, 0);\n    } else {\n      spinTweenRef.current = gsap\n        .timeline({ defaults: { ease: 'power3.inOut' } })\n        .to(h, { rotate: 0, duration: 0.35 }, 0)\n        .to(v, { rotate: 90, duration: 0.35 }, 0)\n        .to(icon, { rotate: 0, duration: 0.001 }, 0);\n    }\n  }, []);\n\n  const animateColor = useCallback(\n    (opening: boolean) => {\n      const btn = toggleBtnRef.current;\n      if (!btn) return;\n      colorTweenRef.current?.kill();\n      if (changeMenuColorOnOpen) {\n        const targetColor = opening ? openMenuButtonColor : menuButtonColor;\n        colorTweenRef.current = gsap.to(btn, { color: targetColor, delay: 0.18, duration: 0.3, ease: 'power2.out' });\n      } else {\n        gsap.set(btn, { color: menuButtonColor });\n      }\n    },\n    [openMenuButtonColor, menuButtonColor, changeMenuColorOnOpen]\n  );\n\n  React.useEffect(() => {\n    if (toggleBtnRef.current) {\n      if (changeMenuColorOnOpen) {\n        const targetColor = openRef.current ? openMenuButtonColor : menuButtonColor;\n        gsap.set(toggleBtnRef.current, { color: targetColor });\n      } else {\n        gsap.set(toggleBtnRef.current, { color: menuButtonColor });\n      }\n    }\n  }, [changeMenuColorOnOpen, menuButtonColor, openMenuButtonColor]);\n\n  const animateText = useCallback((opening: boolean) => {\n    const inner = textInnerRef.current;\n    if (!inner) return;\n\n    textCycleAnimRef.current?.kill();\n\n    const currentLabel = opening ? 'Menu' : 'Close';\n    const targetLabel = opening ? 'Close' : 'Menu';\n    const cycles = 3;\n\n    const seq: string[] = [currentLabel];\n    let last = currentLabel;\n    for (let i = 0; i < cycles; i++) {\n      last = last === 'Menu' ? 'Close' : 'Menu';\n      seq.push(last);\n    }\n    if (last !== targetLabel) seq.push(targetLabel);\n    seq.push(targetLabel);\n\n    setTextLines(seq);\n    gsap.set(inner, { yPercent: 0 });\n\n    const lineCount = seq.length;\n    const finalShift = ((lineCount - 1) / lineCount) * 100;\n\n    textCycleAnimRef.current = gsap.to(inner, {\n      yPercent: -finalShift,\n      duration: 0.5 + lineCount * 0.07,\n      ease: 'power4.out'\n    });\n  }, []);\n\n  const toggleMenu = useCallback(() => {\n    const target = !openRef.current;\n    openRef.current = target;\n    setOpen(target);\n\n    if (target) {\n      onMenuOpen?.();\n      playOpen();\n    } else {\n      onMenuClose?.();\n      playClose();\n    }\n\n    animateIcon(target);\n    animateColor(target);\n    animateText(target);\n  }, [playOpen, playClose, animateIcon, animateColor, animateText, onMenuOpen, onMenuClose]);\n\n  const closeMenu = useCallback(() => {\n    if (openRef.current) {\n      openRef.current = false;\n      setOpen(false);\n      onMenuClose?.();\n      playClose();\n      animateIcon(false);\n      animateColor(false);\n      animateText(false);\n    }\n  }, [playClose, animateIcon, animateColor, animateText, onMenuClose]);\n\n  React.useEffect(() => {\n    if (!closeOnClickAway || !open) return;\n\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        panelRef.current &&\n        !panelRef.current.contains(event.target as Node) &&\n        toggleBtnRef.current &&\n        !toggleBtnRef.current.contains(event.target as Node)\n      ) {\n        closeMenu();\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [closeOnClickAway, open, closeMenu]);\n\n  return (\n    <div\n      className={`sm-scope z-40 ${isFixed ? 'fixed top-0 left-0 w-screen h-screen overflow-hidden' : 'w-full h-full'}`}\n    >\n      <div\n        className={\n          (className ? className + ' ' : '') + 'staggered-menu-wrapper pointer-events-none relative w-full h-full z-40'\n        }\n        style={accentColor ? ({ ['--sm-accent' as any]: accentColor } as React.CSSProperties) : undefined}\n        data-position={position}\n        data-open={open || undefined}\n      >\n        <div\n          ref={preLayersRef}\n          className=\"sm-prelayers absolute top-0 right-0 bottom-0 pointer-events-none z-[5]\"\n          aria-hidden=\"true\"\n        >\n          {(() => {\n            const raw = colors && colors.length ? colors.slice(0, 4) : ['#1e1e22', '#35353c'];\n            let arr = [...raw];\n            if (arr.length >= 3) {\n              const mid = Math.floor(arr.length / 2);\n              arr.splice(mid, 1);\n            }\n            return arr.map((c, i) => (\n              <div\n                key={i}\n                className=\"sm-prelayer absolute top-0 right-0 h-full w-full translate-x-0\"\n                style={{ background: c }}\n              />\n            ));\n          })()}\n        </div>\n\n        <header\n          className=\"staggered-menu-header absolute top-0 left-0 w-full flex items-center justify-between p-[2em] bg-transparent pointer-events-none z-20\"\n          aria-label=\"Main navigation header\"\n        >\n          <div className=\"sm-logo flex items-center select-none pointer-events-auto\" aria-label=\"Logo\">\n            <img\n              src={logoUrl || '/src/assets/logos/reactbits-gh-white.svg'}\n              alt=\"Logo\"\n              className=\"sm-logo-img block h-8 w-auto object-contain\"\n              draggable={false}\n              width={110}\n              height={24}\n            />\n          </div>\n\n          <button\n            ref={toggleBtnRef}\n            className={`sm-toggle relative inline-flex items-center gap-[0.3rem] bg-transparent border-0 cursor-pointer font-medium leading-none overflow-visible pointer-events-auto ${\n              open ? 'text-black' : 'text-[#e9e9ef]'\n            }`}\n            aria-label={open ? 'Close menu' : 'Open menu'}\n            aria-expanded={open}\n            aria-controls=\"staggered-menu-panel\"\n            onClick={toggleMenu}\n            type=\"button\"\n          >\n            <span\n              ref={textWrapRef}\n              className=\"sm-toggle-textWrap relative inline-block h-[1em] overflow-hidden whitespace-nowrap w-[var(--sm-toggle-width,auto)] min-w-[var(--sm-toggle-width,auto)]\"\n              aria-hidden=\"true\"\n            >\n              <span ref={textInnerRef} className=\"sm-toggle-textInner flex flex-col leading-none\">\n                {textLines.map((l, i) => (\n                  <span className=\"sm-toggle-line block h-[1em] leading-none\" key={i}>\n                    {l}\n                  </span>\n                ))}\n              </span>\n            </span>\n\n            <span\n              ref={iconRef}\n              className=\"sm-icon relative w-[14px] h-[14px] shrink-0 inline-flex items-center justify-center [will-change:transform]\"\n              aria-hidden=\"true\"\n            >\n              <span\n                ref={plusHRef}\n                className=\"sm-icon-line absolute left-1/2 top-1/2 w-full h-[2px] bg-current rounded-[2px] -translate-x-1/2 -translate-y-1/2 [will-change:transform]\"\n              />\n              <span\n                ref={plusVRef}\n                className=\"sm-icon-line sm-icon-line-v absolute left-1/2 top-1/2 w-full h-[2px] bg-current rounded-[2px] -translate-x-1/2 -translate-y-1/2 [will-change:transform]\"\n              />\n            </span>\n          </button>\n        </header>\n\n        <aside\n          id=\"staggered-menu-panel\"\n          ref={panelRef}\n          className=\"staggered-menu-panel absolute top-0 right-0 h-full bg-white flex flex-col p-[6em_2em_2em_2em] overflow-y-auto z-10 backdrop-blur-[12px] pointer-events-auto\"\n          style={{ WebkitBackdropFilter: 'blur(12px)' }}\n          aria-hidden={!open}\n        >\n          <div className=\"sm-panel-inner flex-1 flex flex-col gap-5\">\n            <ul\n              className=\"sm-panel-list list-none m-0 p-0 flex flex-col gap-2\"\n              role=\"list\"\n              data-numbering={displayItemNumbering || undefined}\n            >\n              {items && items.length ? (\n                items.map((it, idx) => (\n                  <li className=\"sm-panel-itemWrap relative overflow-hidden leading-none\" key={it.label + idx}>\n                    <a\n                      className=\"sm-panel-item relative text-black font-semibold text-[4rem] cursor-pointer leading-none tracking-[-2px] uppercase transition-[background,color] duration-150 ease-linear inline-block no-underline pr-[1.4em]\"\n                      href={it.link}\n                      aria-label={it.ariaLabel}\n                      data-index={idx + 1}\n                    >\n                      <span className=\"sm-panel-itemLabel inline-block [transform-origin:50%_100%] will-change-transform\">\n                        {it.label}\n                      </span>\n                    </a>\n                  </li>\n                ))\n              ) : (\n                <li className=\"sm-panel-itemWrap relative overflow-hidden leading-none\" aria-hidden=\"true\">\n                  <span className=\"sm-panel-item relative text-black font-semibold text-[4rem] cursor-pointer leading-none tracking-[-2px] uppercase transition-[background,color] duration-150 ease-linear inline-block no-underline pr-[1.4em]\">\n                    <span className=\"sm-panel-itemLabel inline-block [transform-origin:50%_100%] will-change-transform\">\n                      No items\n                    </span>\n                  </span>\n                </li>\n              )}\n            </ul>\n\n            {displaySocials && socialItems && socialItems.length > 0 && (\n              <div className=\"sm-socials mt-auto pt-8 flex flex-col gap-3\" aria-label=\"Social links\">\n                <h3 className=\"sm-socials-title m-0 text-base font-medium [color:var(--sm-accent,#ff0000)]\">Socials</h3>\n                <ul\n                  className=\"sm-socials-list list-none m-0 p-0 flex flex-row items-center gap-4 flex-wrap\"\n                  role=\"list\"\n                >\n                  {socialItems.map((s, i) => (\n                    <li key={s.label + i} className=\"sm-socials-item\">\n                      <a\n                        href={s.link}\n                        target=\"_blank\"\n                        rel=\"noopener noreferrer\"\n                        className=\"sm-socials-link text-[1.2rem] font-medium text-[#111] no-underline relative inline-block py-[2px] transition-[color,opacity] duration-300 ease-linear\"\n                      >\n                        {s.label}\n                      </a>\n                    </li>\n                  ))}\n                </ul>\n              </div>\n            )}\n          </div>\n        </aside>\n      </div>\n\n      <style>{`\n.sm-scope .staggered-menu-wrapper { position: relative; width: 100%; height: 100%; z-index: 40; pointer-events: none; }\n.sm-scope .staggered-menu-header { position: absolute; top: 0; left: 0; width: 100%; display: flex; align-items: center; justify-content: space-between; padding: 2em; background: transparent; pointer-events: none; z-index: 20; }\n.sm-scope .staggered-menu-header > * { pointer-events: auto; }\n.sm-scope .sm-logo { display: flex; align-items: center; user-select: none; }\n.sm-scope .sm-logo-img { display: block; height: 32px; width: auto; object-fit: contain; }\n.sm-scope .sm-toggle { position: relative; display: inline-flex; align-items: center; gap: 0.3rem; background: transparent; border: none; cursor: pointer; color: #e9e9ef; font-weight: 500; line-height: 1; overflow: visible; }\n.sm-scope .sm-toggle:focus-visible { outline: 2px solid #ffffffaa; outline-offset: 4px; border-radius: 4px; }\n.sm-scope .sm-line:last-of-type { margin-top: 6px; }\n.sm-scope .sm-toggle-textWrap { position: relative; margin-right: 0.5em; display: inline-block; height: 1em; overflow: hidden; white-space: nowrap; width: var(--sm-toggle-width, auto); min-width: var(--sm-toggle-width, auto); }\n.sm-scope .sm-toggle-textInner { display: flex; flex-direction: column; line-height: 1; }\n.sm-scope .sm-toggle-line { display: block; height: 1em; line-height: 1; }\n.sm-scope .sm-icon { position: relative; width: 14px; height: 14px; flex: 0 0 14px; display: inline-flex; align-items: center; justify-content: center; will-change: transform; }\n.sm-scope .sm-panel-itemWrap { position: relative; overflow: hidden; line-height: 1; }\n.sm-scope .sm-icon-line { position: absolute; left: 50%; top: 50%; width: 100%; height: 2px; background: currentColor; border-radius: 2px; transform: translate(-50%, -50%); will-change: transform; }\n.sm-scope .sm-line { display: none !important; }\n.sm-scope .staggered-menu-panel { position: absolute; top: 0; right: 0; width: clamp(260px, 38vw, 420px); height: 100%; background: white; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); display: flex; flex-direction: column; padding: 6em 2em 2em 2em; overflow-y: auto; z-index: 10; }\n.sm-scope [data-position='left'] .staggered-menu-panel { right: auto; left: 0; }\n.sm-scope .sm-prelayers { position: absolute; top: 0; right: 0; bottom: 0; width: clamp(260px, 38vw, 420px); pointer-events: none; z-index: 5; }\n.sm-scope [data-position='left'] .sm-prelayers { right: auto; left: 0; }\n.sm-scope .sm-prelayer { position: absolute; top: 0; right: 0; height: 100%; width: 100%; transform: translateX(0); }\n.sm-scope .sm-panel-inner { flex: 1; display: flex; flex-direction: column; gap: 1.25rem; }\n.sm-scope .sm-socials { margin-top: auto; padding-top: 2rem; display: flex; flex-direction: column; gap: 0.75rem; }\n.sm-scope .sm-socials-title { margin: 0; font-size: 1rem; font-weight: 500; color: var(--sm-accent, #ff0000); }\n.sm-scope .sm-socials-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: row; align-items: center; gap: 1rem; flex-wrap: wrap; }\n.sm-scope .sm-socials-list .sm-socials-link { opacity: 1; transition: opacity 0.3s ease; }\n.sm-scope .sm-socials-list:hover .sm-socials-link:not(:hover) { opacity: 0.35; }\n.sm-scope .sm-socials-list:focus-within .sm-socials-link:not(:focus-visible) { opacity: 0.35; }\n.sm-scope .sm-socials-list .sm-socials-link:hover,\n.sm-scope .sm-socials-list .sm-socials-link:focus-visible { opacity: 1; }\n.sm-scope .sm-socials-link:focus-visible { outline: 2px solid var(--sm-accent, #ff0000); outline-offset: 3px; }\n.sm-scope .sm-socials-link { font-size: 1.2rem; font-weight: 500; color: #111; text-decoration: none; position: relative; padding: 2px 0; display: inline-block; transition: color 0.3s ease, opacity 0.3s ease; }\n.sm-scope .sm-socials-link:hover { color: var(--sm-accent, #ff0000); }\n.sm-scope .sm-panel-title { margin: 0; font-size: 1rem; font-weight: 600; color: #fff; text-transform: uppercase; }\n.sm-scope .sm-panel-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 0.5rem; }\n.sm-scope .sm-panel-item { position: relative; color: #000; font-weight: 600; font-size: 4rem; cursor: pointer; line-height: 1; letter-spacing: -2px; text-transform: uppercase; transition: background 0.25s, color 0.25s; display: inline-block; text-decoration: none; padding-right: 1.4em; }\n.sm-scope .sm-panel-itemLabel { display: inline-block; will-change: transform; transform-origin: 50% 100%; }\n.sm-scope .sm-panel-item:hover { color: var(--sm-accent, #ff0000); }\n.sm-scope .sm-panel-list[data-numbering] { counter-reset: smItem; }\n.sm-scope .sm-panel-list[data-numbering] .sm-panel-item::after { counter-increment: smItem; content: counter(smItem, decimal-leading-zero); position: absolute; top: 0.1em; right: 3.2em; font-size: 18px; font-weight: 400; color: var(--sm-accent, #ff0000); letter-spacing: 0; pointer-events: none; user-select: none; opacity: var(--sm-num-opacity, 0); }\n@media (max-width: 1024px) { .sm-scope .staggered-menu-panel { width: 100%; left: 0; right: 0; } .sm-scope .staggered-menu-wrapper[data-open] .sm-logo-img { filter: invert(100%); } }\n@media (max-width: 640px) { .sm-scope .staggered-menu-panel { width: 100%; left: 0; right: 0; } .sm-scope .staggered-menu-wrapper[data-open] .sm-logo-img { filter: invert(100%); } }\n      `}</style>\n    </div>\n  );\n};\n\nexport default StaggeredMenu;\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "stepper",
      "type": "component",
      "description": "A layouts stepper component",
      "category": "layouts",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/stepper.tsx",
          "content": "import React, { useState, Children, useRef, useLayoutEffect, HTMLAttributes, ReactNode } from 'react';\nimport { motion, AnimatePresence, Variants } from 'motion/react';\n\ninterface StepperProps extends HTMLAttributes<HTMLDivElement> {\n  children: ReactNode;\n  initialStep?: number;\n  onStepChange?: (step: number) => void;\n  onFinalStepCompleted?: () => void;\n  stepCircleContainerClassName?: string;\n  stepContainerClassName?: string;\n  contentClassName?: string;\n  footerClassName?: string;\n  backButtonProps?: React.ButtonHTMLAttributes<HTMLButtonElement>;\n  nextButtonProps?: React.ButtonHTMLAttributes<HTMLButtonElement>;\n  backButtonText?: string;\n  nextButtonText?: string;\n  disableStepIndicators?: boolean;\n  renderStepIndicator?: (props: {\n    step: number;\n    currentStep: number;\n    onStepClick: (clicked: number) => void;\n  }) => ReactNode;\n}\n\nexport default function Stepper({\n  children,\n  initialStep = 1,\n  onStepChange = () => {},\n  onFinalStepCompleted = () => {},\n  stepCircleContainerClassName = '',\n  stepContainerClassName = '',\n  contentClassName = '',\n  footerClassName = '',\n  backButtonProps = {},\n  nextButtonProps = {},\n  backButtonText = 'Back',\n  nextButtonText = 'Continue',\n  disableStepIndicators = false,\n  renderStepIndicator,\n  ...rest\n}: StepperProps) {\n  const [currentStep, setCurrentStep] = useState<number>(initialStep);\n  const [direction, setDirection] = useState<number>(0);\n  const stepsArray = Children.toArray(children);\n  const totalSteps = stepsArray.length;\n  const isCompleted = currentStep > totalSteps;\n  const isLastStep = currentStep === totalSteps;\n\n  const updateStep = (newStep: number) => {\n    setCurrentStep(newStep);\n    if (newStep > totalSteps) {\n      onFinalStepCompleted();\n    } else {\n      onStepChange(newStep);\n    }\n  };\n\n  const handleBack = () => {\n    if (currentStep > 1) {\n      setDirection(-1);\n      updateStep(currentStep - 1);\n    }\n  };\n\n  const handleNext = () => {\n    if (!isLastStep) {\n      setDirection(1);\n      updateStep(currentStep + 1);\n    }\n  };\n\n  const handleComplete = () => {\n    setDirection(1);\n    updateStep(totalSteps + 1);\n  };\n\n  return (\n    <div\n      className=\"flex min-h-full flex-1 flex-col items-center justify-center p-4 sm:aspect-[4/3] md:aspect-[2/1]\"\n      {...rest}\n    >\n      <div\n        className={`mx-auto w-full max-w-md rounded-4xl shadow-xl ${stepCircleContainerClassName}`}\n        style={{ border: '1px solid #222' }}\n      >\n        <div className={`${stepContainerClassName} flex w-full items-center p-8`}>\n          {stepsArray.map((_, index) => {\n            const stepNumber = index + 1;\n            const isNotLastStep = index < totalSteps - 1;\n            return (\n              <React.Fragment key={stepNumber}>\n                {renderStepIndicator ? (\n                  renderStepIndicator({\n                    step: stepNumber,\n                    currentStep,\n                    onStepClick: clicked => {\n                      setDirection(clicked > currentStep ? 1 : -1);\n                      updateStep(clicked);\n                    }\n                  })\n                ) : (\n                  <StepIndicator\n                    step={stepNumber}\n                    disableStepIndicators={disableStepIndicators}\n                    currentStep={currentStep}\n                    onClickStep={clicked => {\n                      setDirection(clicked > currentStep ? 1 : -1);\n                      updateStep(clicked);\n                    }}\n                  />\n                )}\n                {isNotLastStep && <StepConnector isComplete={currentStep > stepNumber} />}\n              </React.Fragment>\n            );\n          })}\n        </div>\n\n        <StepContentWrapper\n          isCompleted={isCompleted}\n          currentStep={currentStep}\n          direction={direction}\n          className={`space-y-2 px-8 ${contentClassName}`}\n        >\n          {stepsArray[currentStep - 1]}\n        </StepContentWrapper>\n\n        {!isCompleted && (\n          <div className={`px-8 pb-8 ${footerClassName}`}>\n            <div className={`mt-10 flex ${currentStep !== 1 ? 'justify-between' : 'justify-end'}`}>\n              {currentStep !== 1 && (\n                <button\n                  onClick={handleBack}\n                  className={`duration-350 rounded px-2 py-1 transition ${\n                    currentStep === 1\n                      ? 'pointer-events-none opacity-50 text-neutral-400'\n                      : 'text-neutral-400 hover:text-neutral-700'\n                  }`}\n                  {...backButtonProps}\n                >\n                  {backButtonText}\n                </button>\n              )}\n              <button\n                onClick={isLastStep ? handleComplete : handleNext}\n                className=\"duration-350 flex items-center justify-center rounded-full bg-green-500 py-1.5 px-3.5 font-medium tracking-tight text-white transition hover:bg-green-600 active:bg-green-700\"\n                {...nextButtonProps}\n              >\n                {isLastStep ? 'Complete' : nextButtonText}\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\ninterface StepContentWrapperProps {\n  isCompleted: boolean;\n  currentStep: number;\n  direction: number;\n  children: ReactNode;\n  className?: string;\n}\n\nfunction StepContentWrapper({\n  isCompleted,\n  currentStep,\n  direction,\n  children,\n  className = ''\n}: StepContentWrapperProps) {\n  const [parentHeight, setParentHeight] = useState<number>(0);\n\n  return (\n    <motion.div\n      style={{ position: 'relative', overflow: 'hidden' }}\n      animate={{ height: isCompleted ? 0 : parentHeight }}\n      transition={{ type: 'spring', duration: 0.4 }}\n      className={className}\n    >\n      <AnimatePresence initial={false} mode=\"sync\" custom={direction}>\n        {!isCompleted && (\n          <SlideTransition key={currentStep} direction={direction} onHeightReady={h => setParentHeight(h)}>\n            {children}\n          </SlideTransition>\n        )}\n      </AnimatePresence>\n    </motion.div>\n  );\n}\n\ninterface SlideTransitionProps {\n  children: ReactNode;\n  direction: number;\n  onHeightReady: (height: number) => void;\n}\n\nfunction SlideTransition({ children, direction, onHeightReady }: SlideTransitionProps) {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    if (containerRef.current) {\n      onHeightReady(containerRef.current.offsetHeight);\n    }\n  }, [children, onHeightReady]);\n\n  return (\n    <motion.div\n      ref={containerRef}\n      custom={direction}\n      variants={stepVariants}\n      initial=\"enter\"\n      animate=\"center\"\n      exit=\"exit\"\n      transition={{ duration: 0.4 }}\n      style={{ position: 'absolute', left: 0, right: 0, top: 0 }}\n    >\n      {children}\n    </motion.div>\n  );\n}\n\nconst stepVariants: Variants = {\n  enter: (dir: number) => ({\n    x: dir >= 0 ? '-100%' : '100%',\n    opacity: 0\n  }),\n  center: {\n    x: '0%',\n    opacity: 1\n  },\n  exit: (dir: number) => ({\n    x: dir >= 0 ? '50%' : '-50%',\n    opacity: 0\n  })\n};\n\ninterface StepProps {\n  children: ReactNode;\n}\n\nexport function Step({ children }: StepProps) {\n  return <div className=\"px-8\">{children}</div>;\n}\n\ninterface StepIndicatorProps {\n  step: number;\n  currentStep: number;\n  onClickStep: (clicked: number) => void;\n  disableStepIndicators?: boolean;\n}\n\nfunction StepIndicator({ step, currentStep, onClickStep, disableStepIndicators = false }: StepIndicatorProps) {\n  const status = currentStep === step ? 'active' : currentStep < step ? 'inactive' : 'complete';\n\n  const handleClick = () => {\n    if (step !== currentStep && !disableStepIndicators) {\n      onClickStep(step);\n    }\n  };\n\n  return (\n    <motion.div\n      onClick={handleClick}\n      className=\"relative cursor-pointer outline-none focus:outline-none\"\n      animate={status}\n      initial={false}\n    >\n      <motion.div\n        variants={{\n          inactive: { scale: 1, backgroundColor: '#222', color: '#a3a3a3' },\n          active: { scale: 1, backgroundColor: '#5227FF', color: '#5227FF' },\n          complete: { scale: 1, backgroundColor: '#5227FF', color: '#3b82f6' }\n        }}\n        transition={{ duration: 0.3 }}\n        className=\"flex h-8 w-8 items-center justify-center rounded-full font-semibold\"\n      >\n        {status === 'complete' ? (\n          <CheckIcon className=\"h-4 w-4 text-black\" />\n        ) : status === 'active' ? (\n          <div className=\"h-3 w-3 rounded-full bg-[#060010]\" />\n        ) : (\n          <span className=\"text-sm\">{step}</span>\n        )}\n      </motion.div>\n    </motion.div>\n  );\n}\n\ninterface StepConnectorProps {\n  isComplete: boolean;\n}\n\nfunction StepConnector({ isComplete }: StepConnectorProps) {\n  const lineVariants: Variants = {\n    incomplete: { width: 0, backgroundColor: 'transparent' },\n    complete: { width: '100%', backgroundColor: '#5227FF' }\n  };\n\n  return (\n    <div className=\"relative mx-2 h-0.5 flex-1 overflow-hidden rounded bg-neutral-600\">\n      <motion.div\n        className=\"absolute left-0 top-0 h-full\"\n        variants={lineVariants}\n        initial={false}\n        animate={isComplete ? 'complete' : 'incomplete'}\n        transition={{ duration: 0.4 }}\n      />\n    </div>\n  );\n}\n\ninterface CheckIconProps extends React.SVGProps<SVGSVGElement> {}\n\nfunction CheckIcon(props: CheckIconProps) {\n  return (\n    <svg {...props} fill=\"none\" stroke=\"currentColor\" strokeWidth={2} viewBox=\"0 0 24 24\">\n      <motion.path\n        initial={{ pathLength: 0 }}\n        animate={{ pathLength: 1 }}\n        transition={{\n          delay: 0.1,\n          type: 'tween',\n          ease: 'easeOut',\n          duration: 0.3\n        }}\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        d=\"M5 13l4 4L19 7\"\n      />\n    </svg>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "terminal",
      "type": "component",
      "description": "A terminal component",
      "category": "layouts",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/terminal.tsx",
          "content": "\"use client\"\n\nimport {\n  Children,\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { motion, MotionProps, useInView } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface SequenceContextValue {\n  completeItem: (index: number) => void\n  activeIndex: number\n  sequenceStarted: boolean\n}\n\nconst SequenceContext = createContext<SequenceContextValue | null>(null)\n\nconst useSequence = () => useContext(SequenceContext)\n\nconst ItemIndexContext = createContext<number | null>(null)\nconst useItemIndex = () => useContext(ItemIndexContext)\n\ninterface AnimatedSpanProps extends MotionProps {\n  children: React.ReactNode\n  delay?: number\n  className?: string\n  startOnView?: boolean\n}\n\nexport const AnimatedSpan = ({\n  children,\n  delay = 0,\n  className,\n  startOnView = false,\n  ...props\n}: AnimatedSpanProps) => {\n  const elementRef = useRef<HTMLDivElement | null>(null)\n  const isInView = useInView(elementRef as React.RefObject<Element>, {\n    amount: 0.3,\n    once: true,\n  })\n\n  const sequence = useSequence()\n  const itemIndex = useItemIndex()\n  const [hasStarted, setHasStarted] = useState(false)\n  useEffect(() => {\n    if (!sequence || itemIndex === null) return\n    if (!sequence.sequenceStarted) return\n    if (hasStarted) return\n    if (sequence.activeIndex === itemIndex) {\n      setHasStarted(true)\n    }\n  }, [sequence?.activeIndex, sequence?.sequenceStarted, hasStarted, itemIndex])\n\n  const shouldAnimate = sequence ? hasStarted : startOnView ? isInView : true\n\n  return (\n    <motion.div\n      ref={elementRef}\n      initial={{ opacity: 0, y: -5 }}\n      animate={shouldAnimate ? { opacity: 1, y: 0 } : { opacity: 0, y: -5 }}\n      transition={{ duration: 0.3, delay: sequence ? 0 : delay / 1000 }}\n      className={cn(\"grid text-sm font-normal tracking-tight\", className)}\n      onAnimationComplete={() => {\n        if (!sequence) return\n        if (itemIndex === null) return\n        sequence.completeItem(itemIndex)\n      }}\n      {...props}\n    >\n      {children}\n    </motion.div>\n  )\n}\n\ninterface TypingAnimationProps extends MotionProps {\n  children: string\n  className?: string\n  duration?: number\n  delay?: number\n  as?: React.ElementType\n  startOnView?: boolean\n}\n\nexport const TypingAnimation = ({\n  children,\n  className,\n  duration = 60,\n  delay = 0,\n  as: Component = \"span\",\n  startOnView = true,\n  ...props\n}: TypingAnimationProps) => {\n  if (typeof children !== \"string\") {\n    throw new Error(\"TypingAnimation: children must be a string. Received:\")\n  }\n\n  const MotionComponent = useMemo(\n    () =>\n      motion.create(Component, {\n        forwardMotionProps: true,\n      }),\n    [Component]\n  )\n\n  const [displayedText, setDisplayedText] = useState<string>(\"\")\n  const [started, setStarted] = useState(false)\n  const elementRef = useRef<HTMLElement | null>(null)\n  const isInView = useInView(elementRef as React.RefObject<Element>, {\n    amount: 0.3,\n    once: true,\n  })\n\n  const sequence = useSequence()\n  const itemIndex = useItemIndex()\n\n  useEffect(() => {\n    if (sequence && itemIndex !== null) {\n      if (!sequence.sequenceStarted) return\n      if (started) return\n      if (sequence.activeIndex === itemIndex) {\n        setStarted(true)\n      }\n      return\n    }\n\n    if (!startOnView) {\n      const startTimeout = setTimeout(() => setStarted(true), delay)\n      return () => clearTimeout(startTimeout)\n    }\n\n    if (!isInView) return\n\n    const startTimeout = setTimeout(() => setStarted(true), delay)\n    return () => clearTimeout(startTimeout)\n  }, [\n    delay,\n    startOnView,\n    isInView,\n    started,\n    sequence?.activeIndex,\n    sequence?.sequenceStarted,\n    itemIndex,\n  ])\n\n  useEffect(() => {\n    if (!started) return\n\n    let i = 0\n    const typingEffect = setInterval(() => {\n      if (i < children.length) {\n        setDisplayedText(children.substring(0, i + 1))\n        i++\n      } else {\n        clearInterval(typingEffect)\n        if (sequence && itemIndex !== null) {\n          sequence.completeItem(itemIndex)\n        }\n      }\n    }, duration)\n\n    return () => {\n      clearInterval(typingEffect)\n    }\n  }, [children, duration, started])\n\n  return (\n    <MotionComponent\n      ref={elementRef}\n      className={cn(\"text-sm font-normal tracking-tight\", className)}\n      {...props}\n    >\n      {displayedText}\n    </MotionComponent>\n  )\n}\n\ninterface TerminalProps {\n  children: React.ReactNode\n  className?: string\n  sequence?: boolean\n  startOnView?: boolean\n}\n\nexport const Terminal = ({\n  children,\n  className,\n  sequence = true,\n  startOnView = true,\n}: TerminalProps) => {\n  const containerRef = useRef<HTMLDivElement | null>(null)\n  const isInView = useInView(containerRef as React.RefObject<Element>, {\n    amount: 0.3,\n    once: true,\n  })\n\n  const [activeIndex, setActiveIndex] = useState(0)\n  const sequenceHasStarted = sequence ? !startOnView || isInView : false\n\n  const contextValue = useMemo<SequenceContextValue | null>(() => {\n    if (!sequence) return null\n    return {\n      completeItem: (index: number) => {\n        setActiveIndex((current) => (index === current ? current + 1 : current))\n      },\n      activeIndex,\n      sequenceStarted: sequenceHasStarted,\n    }\n  }, [sequence, activeIndex, sequenceHasStarted])\n\n  const wrappedChildren = useMemo(() => {\n    if (!sequence) return children\n    const array = Children.toArray(children)\n    return array.map((child, index) => (\n      <ItemIndexContext.Provider key={index} value={index}>\n        {child as React.ReactNode}\n      </ItemIndexContext.Provider>\n    ))\n  }, [children, sequence])\n\n  const content = (\n    <div\n      ref={containerRef}\n      className={cn(\n        \"border-border bg-background z-0 h-full max-h-[400px] w-full max-w-lg rounded-xl border\",\n        className\n      )}\n    >\n      <div className=\"border-border flex flex-col gap-y-2 border-b p-4\">\n        <div className=\"flex flex-row gap-x-2\">\n          <div className=\"h-2 w-2 rounded-full bg-red-500\"></div>\n          <div className=\"h-2 w-2 rounded-full bg-yellow-500\"></div>\n          <div className=\"h-2 w-2 rounded-full bg-green-500\"></div>\n        </div>\n      </div>\n      <pre className=\"p-4\">\n        <code className=\"grid gap-y-1 overflow-auto\">{wrappedChildren}</code>\n      </pre>\n    </div>\n  )\n\n  if (!sequence) return content\n\n  return (\n    <SequenceContext.Provider value={contextValue}>\n      {content}\n    </SequenceContext.Provider>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "tilted-card",
      "type": "component",
      "description": "A layouts tilted card component",
      "category": "layouts",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/tilted-card.tsx",
          "content": "import type { SpringOptions } from 'motion/react';\nimport { useRef, useState } from 'react';\nimport { motion, useMotionValue, useSpring } from 'motion/react';\n\ninterface TiltedCardProps {\n  imageSrc: React.ComponentProps<'img'>['src'];\n  altText?: string;\n  captionText?: string;\n  containerHeight?: React.CSSProperties['height'];\n  containerWidth?: React.CSSProperties['width'];\n  imageHeight?: React.CSSProperties['height'];\n  imageWidth?: React.CSSProperties['width'];\n  scaleOnHover?: number;\n  rotateAmplitude?: number;\n  showMobileWarning?: boolean;\n  showTooltip?: boolean;\n  overlayContent?: React.ReactNode;\n  displayOverlayContent?: boolean;\n}\n\nconst springValues: SpringOptions = {\n  damping: 30,\n  stiffness: 100,\n  mass: 2\n};\n\nexport default function TiltedCard({\n  imageSrc,\n  altText = 'Tilted card image',\n  captionText = '',\n  containerHeight = '300px',\n  containerWidth = '100%',\n  imageHeight = '300px',\n  imageWidth = '300px',\n  scaleOnHover = 1.1,\n  rotateAmplitude = 14,\n  showMobileWarning = true,\n  showTooltip = true,\n  overlayContent = null,\n  displayOverlayContent = false\n}: TiltedCardProps) {\n  const ref = useRef<HTMLElement>(null);\n  const x = useMotionValue(0);\n  const y = useMotionValue(0);\n  const rotateX = useSpring(useMotionValue(0), springValues);\n  const rotateY = useSpring(useMotionValue(0), springValues);\n  const scale = useSpring(1, springValues);\n  const opacity = useSpring(0);\n  const rotateFigcaption = useSpring(0, {\n    stiffness: 350,\n    damping: 30,\n    mass: 1\n  });\n\n  const [lastY, setLastY] = useState(0);\n\n  function handleMouse(e: React.MouseEvent<HTMLElement>) {\n    if (!ref.current) return;\n\n    const rect = ref.current.getBoundingClientRect();\n    const offsetX = e.clientX - rect.left - rect.width / 2;\n    const offsetY = e.clientY - rect.top - rect.height / 2;\n\n    const rotationX = (offsetY / (rect.height / 2)) * -rotateAmplitude;\n    const rotationY = (offsetX / (rect.width / 2)) * rotateAmplitude;\n\n    rotateX.set(rotationX);\n    rotateY.set(rotationY);\n\n    x.set(e.clientX - rect.left);\n    y.set(e.clientY - rect.top);\n\n    const velocityY = offsetY - lastY;\n    rotateFigcaption.set(-velocityY * 0.6);\n    setLastY(offsetY);\n  }\n\n  function handleMouseEnter() {\n    scale.set(scaleOnHover);\n    opacity.set(1);\n  }\n\n  function handleMouseLeave() {\n    opacity.set(0);\n    scale.set(1);\n    rotateX.set(0);\n    rotateY.set(0);\n    rotateFigcaption.set(0);\n  }\n\n  return (\n    <figure\n      ref={ref}\n      className=\"relative w-full h-full [perspective:800px] flex flex-col items-center justify-center\"\n      style={{\n        height: containerHeight,\n        width: containerWidth\n      }}\n      onMouseMove={handleMouse}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n    >\n      {showMobileWarning && (\n        <div className=\"absolute top-4 text-center text-sm block sm:hidden\">\n          This effect is not optimized for mobile. Check on desktop.\n        </div>\n      )}\n\n      <motion.div\n        className=\"relative [transform-style:preserve-3d]\"\n        style={{\n          width: imageWidth,\n          height: imageHeight,\n          rotateX,\n          rotateY,\n          scale\n        }}\n      >\n        <motion.img\n          src={imageSrc}\n          alt={altText}\n          className=\"absolute top-0 left-0 object-cover rounded-[15px] will-change-transform [transform:translateZ(0)]\"\n          style={{\n            width: imageWidth,\n            height: imageHeight\n          }}\n        />\n\n        {displayOverlayContent && overlayContent && (\n          <motion.div className=\"absolute top-0 left-0 z-[2] will-change-transform [transform:translateZ(30px)]\">\n            {overlayContent}\n          </motion.div>\n        )}\n      </motion.div>\n\n      {showTooltip && (\n        <motion.figcaption\n          className=\"pointer-events-none absolute left-0 top-0 rounded-[4px] bg-white px-[10px] py-[4px] text-[10px] text-[#2d2d2d] opacity-0 z-[3] hidden sm:block\"\n          style={{\n            x,\n            y,\n            opacity,\n            rotate: rotateFigcaption\n          }}\n        >\n          {captionText}\n        </motion.figcaption>\n      )}\n    </figure>\n  );\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "layouts"
        ]
      }
    },
    {
      "name": "android",
      "type": "component",
      "description": "A mockup of an Android device.",
      "category": "special",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/android.tsx",
          "content": "import { SVGProps } from \"react\"\n\nexport interface AndroidProps extends SVGProps<SVGSVGElement> {\n  width?: number\n  height?: number\n  src?: string\n  videoSrc?: string\n}\n\nexport function Android({\n  width = 433,\n  height = 882,\n  src,\n  videoSrc,\n  ...props\n}: AndroidProps) {\n  return (\n    <svg\n      width={width}\n      height={height}\n      viewBox={`0 0 ${width} ${height}`}\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      {...props}\n    >\n      <path\n        d=\"M376 153H378C379.105 153 380 153.895 380 155V249C380 250.105 379.105 251 378 251H376V153Z\"\n        className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n      />\n      <path\n        d=\"M376 301H378C379.105 301 380 301.895 380 303V351C380 352.105 379.105 353 378 353H376V301Z\"\n        className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n      />\n      <path\n        d=\"M0 42C0 18.8041 18.804 0 42 0H336C359.196 0 378 18.804 378 42V788C378 811.196 359.196 830 336 830H42C18.804 830 0 811.196 0 788V42Z\"\n        className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n      />\n      <path\n        d=\"M2 43C2 22.0132 19.0132 5 40 5H338C358.987 5 376 22.0132 376 43V787C376 807.987 358.987 825 338 825H40C19.0132 825 2 807.987 2 787V43Z\"\n        className=\"fill-white dark:fill-[#262626]\"\n      />\n\n      <g clipPath=\"url(#clip0_514_20855)\">\n        <path\n          d=\"M9.25 48C9.25 29.3604 24.3604 14.25 43 14.25H335C353.64 14.25 368.75 29.3604 368.75 48V780C368.75 798.64 353.64 813.75 335 813.75H43C24.3604 813.75 9.25 798.64 9.25 780V48Z\"\n          className=\"fill-[#E5E5E5] stroke-[#E5E5E5] stroke-[0.5] dark:fill-[#404040] dark:stroke-[#404040]\"\n        />\n      </g>\n      <circle\n        cx=\"189\"\n        cy=\"28\"\n        r=\"9\"\n        className=\"fill-white dark:fill-[#262626]\"\n      />\n      <circle\n        cx=\"189\"\n        cy=\"28\"\n        r=\"4\"\n        className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n      />\n      {src && (\n        <image\n          href={src}\n          width=\"360\"\n          height=\"800\"\n          className=\"size-full object-cover\"\n          preserveAspectRatio=\"xMidYMid slice\"\n          clipPath=\"url(#clip0_514_20855)\"\n        />\n      )}\n      {videoSrc && (\n        <foreignObject\n          width=\"380\"\n          height=\"820\"\n          clipPath=\"url(#clip0_514_20855)\"\n          preserveAspectRatio=\"xMidYMid slice\"\n        >\n          <video\n            className=\"size-full object-cover\"\n            src={videoSrc}\n            autoPlay\n            loop\n            muted\n            playsInline\n          />\n        </foreignObject>\n      )}\n      <defs>\n        <clipPath id=\"clip0_514_20855\">\n          <rect\n            width=\"360\"\n            height=\"800\"\n            rx=\"33\"\n            ry=\"25\"\n            className=\"fill-white dark:fill-[#262626]\"\n            transform=\"translate(9 14)\"\n          />\n        </clipPath>\n      </defs>\n    </svg>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "avatar-circles",
      "type": "component",
      "description": "Overlapping circles of avatars.",
      "category": "special",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/avatar-circles.tsx",
          "content": "/* eslint-disable @next/next/no-img-element */\n\"use client\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface Avatar {\n  imageUrl: string\n  profileUrl: string\n}\ninterface AvatarCirclesProps {\n  className?: string\n  numPeople?: number\n  avatarUrls: Avatar[]\n}\n\nexport const AvatarCircles = ({\n  numPeople,\n  className,\n  avatarUrls,\n}: AvatarCirclesProps) => {\n  return (\n    <div className={cn(\"z-10 flex -space-x-4 rtl:space-x-reverse\", className)}>\n      {avatarUrls.map((url, index) => (\n        <a\n          key={index}\n          href={url.profileUrl}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          <img\n            key={index}\n            className=\"h-10 w-10 rounded-full border-2 border-white dark:border-gray-800\"\n            src={url.imageUrl}\n            width={40}\n            height={40}\n            alt={`Avatar ${index + 1}`}\n          />\n        </a>\n      ))}\n      {(numPeople ?? 0) > 0 && (\n        <a\n          className=\"flex h-10 w-10 items-center justify-center rounded-full border-2 border-white bg-black text-center text-xs font-medium text-white hover:bg-gray-600 dark:border-gray-800 dark:bg-white dark:text-black\"\n          href=\"\"\n        >\n          +{numPeople}\n        </a>\n      )}\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "client-tweet-card",
      "type": "component",
      "description": "A client-side version of the tweet card.",
      "category": "special",
      "dependencies": [
        "react-tweet"
      ],
      "files": [
        {
          "path": "components/ui/client-tweet-card.tsx",
          "content": "\"use client\"\n\nimport { TweetProps, useTweet } from \"react-tweet\"\n\nimport {\n  MagicTweet,\n  TweetNotFound,\n  TweetSkeleton,\n} from \"@/registry/components/special/tweet-card/component\"\n\nexport const ClientTweetCard = ({\n  id,\n  apiUrl,\n  fallback = <TweetSkeleton />,\n  components,\n  fetchOptions,\n  onError,\n  ...props\n}: TweetProps & { className?: string }) => {\n  const { data, error, isLoading } = useTweet(id, apiUrl, fetchOptions)\n\n  if (isLoading) return fallback\n  if (error || !data) {\n    const NotFound = components?.TweetNotFound || TweetNotFound\n    return <NotFound error={onError ? onError(error) : error} />\n  }\n\n  return <MagicTweet tweet={data} {...props} />\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "code-comparison",
      "type": "component",
      "description": "A component which compares two code snippets.",
      "category": "special",
      "dependencies": [
        "shiki",
        "next-themes"
      ],
      "files": [
        {
          "path": "components/ui/code-comparison.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useMemo, useState } from \"react\"\nimport {\n  transformerNotationDiff,\n  transformerNotationFocus,\n} from \"@shikijs/transformers\"\nimport { FileIcon } from \"lucide-react\"\nimport { useTheme } from \"next-themes\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface CodeComparisonProps {\n  beforeCode: string\n  afterCode: string\n  language: string\n  filename: string\n  lightTheme: string\n  darkTheme: string\n  highlightColor?: string\n}\n\nexport function CodeComparison({\n  beforeCode,\n  afterCode,\n  language,\n  filename,\n  lightTheme,\n  darkTheme,\n  highlightColor = \"#ff3333\",\n}: CodeComparisonProps) {\n  const { theme, systemTheme } = useTheme()\n  const [highlightedBefore, setHighlightedBefore] = useState(\"\")\n  const [highlightedAfter, setHighlightedAfter] = useState(\"\")\n  const [hasLeftFocus, setHasLeftFocus] = useState(false)\n  const [hasRightFocus, setHasRightFocus] = useState(false)\n\n  const selectedTheme = useMemo(() => {\n    const currentTheme = theme === \"system\" ? systemTheme : theme\n    return currentTheme === \"dark\" ? darkTheme : lightTheme\n  }, [theme, systemTheme, darkTheme, lightTheme])\n\n  useEffect(() => {\n    if (highlightedBefore || highlightedAfter) {\n      setHasLeftFocus(highlightedBefore.includes('class=\"line focused\"'))\n      setHasRightFocus(highlightedAfter.includes('class=\"line focused\"'))\n    }\n  }, [highlightedBefore, highlightedAfter])\n\n  useEffect(() => {\n    async function highlightCode() {\n      try {\n        const { codeToHtml } = await import(\"shiki\")\n        const { transformerNotationHighlight } =\n          await import(\"@shikijs/transformers\")\n\n        const before = await codeToHtml(beforeCode, {\n          lang: language,\n          theme: selectedTheme,\n          transformers: [\n            transformerNotationHighlight({ matchAlgorithm: \"v3\" }),\n            transformerNotationDiff({ matchAlgorithm: \"v3\" }),\n            transformerNotationFocus({ matchAlgorithm: \"v3\" }),\n          ],\n        })\n        const after = await codeToHtml(afterCode, {\n          lang: language,\n          theme: selectedTheme,\n          transformers: [\n            transformerNotationHighlight({ matchAlgorithm: \"v3\" }),\n            transformerNotationDiff({ matchAlgorithm: \"v3\" }),\n            transformerNotationFocus({ matchAlgorithm: \"v3\" }),\n          ],\n        })\n        setHighlightedBefore(before)\n        setHighlightedAfter(after)\n      } catch (error) {\n        console.error(\"Error highlighting code:\", error)\n        setHighlightedBefore(`<pre>${beforeCode}</pre>`)\n        setHighlightedAfter(`<pre>${afterCode}</pre>`)\n      }\n    }\n    highlightCode()\n  }, [beforeCode, afterCode, language, selectedTheme])\n\n  const renderCode = (code: string, highlighted: string) => {\n    if (highlighted) {\n      return (\n        <div\n          style={{ \"--highlight-color\": highlightColor } as React.CSSProperties}\n          className={cn(\n            \"bg-background h-full w-full overflow-auto font-mono text-xs\",\n            \"[&>pre]:h-full [&>pre]:!w-screen [&>pre]:py-2\",\n            \"[&>pre>code]:!inline-block [&>pre>code]:!w-full\",\n            \"[&>pre>code>span]:!inline-block [&>pre>code>span]:w-full [&>pre>code>span]:px-4 [&>pre>code>span]:py-0.5\",\n            \"[&>pre>code>.highlighted]:inline-block [&>pre>code>.highlighted]:w-full [&>pre>code>.highlighted]:!bg-[var(--highlight-color)]\",\n            \"group-hover/left:[&>pre>code>:not(.focused)]:!opacity-100 group-hover/left:[&>pre>code>:not(.focused)]:!blur-none\",\n            \"group-hover/right:[&>pre>code>:not(.focused)]:!opacity-100 group-hover/right:[&>pre>code>:not(.focused)]:!blur-none\",\n            \"[&>pre>code>.add]:bg-[rgba(16,185,129,.16)] [&>pre>code>.remove]:bg-[rgba(244,63,94,.16)]\",\n            \"group-hover/left:[&>pre>code>:not(.focused)]:transition-all group-hover/left:[&>pre>code>:not(.focused)]:duration-300\",\n            \"group-hover/right:[&>pre>code>:not(.focused)]:transition-all group-hover/right:[&>pre>code>:not(.focused)]:duration-300\"\n          )}\n          dangerouslySetInnerHTML={{ __html: highlighted }}\n        />\n      )\n    } else {\n      return (\n        <pre className=\"bg-background text-foreground h-full overflow-auto p-4 font-mono text-xs break-all\">\n          {code}\n        </pre>\n      )\n    }\n  }\n\n  return (\n    <div className=\"mx-auto w-full max-w-5xl\">\n      <div className=\"group border-border relative w-full overflow-hidden rounded-md border\">\n        <div className=\"relative grid md:grid-cols-2\">\n          <div\n            className={cn(\n              \"leftside group/left border-primary/20 md:border-r\",\n              hasLeftFocus &&\n                \"[&>div>pre>code>:not(.focused)]:!opacity-50 [&>div>pre>code>:not(.focused)]:!blur-[0.095rem]\",\n              \"[&>div>pre>code>:not(.focused)]:transition-all [&>div>pre>code>:not(.focused)]:duration-300\"\n            )}\n          >\n            <div className=\"border-primary/20 bg-accent text-foreground flex items-center border-b p-2 text-sm\">\n              <FileIcon className=\"mr-2 h-4 w-4\" />\n              {filename}\n              <span className=\"ml-auto hidden md:block\">before</span>\n            </div>\n            {renderCode(beforeCode, highlightedBefore)}\n          </div>\n          <div\n            className={cn(\n              \"rightside group/right border-primary/20 border-t md:border-t-0\",\n              hasRightFocus &&\n                \"[&>div>pre>code>:not(.focused)]:!opacity-50 [&>div>pre>code>:not(.focused)]:!blur-[0.095rem]\",\n              \"[&>div>pre>code>:not(.focused)]:transition-all [&>div>pre>code>:not(.focused)]:duration-300\"\n            )}\n          >\n            <div className=\"border-primary/20 bg-accent text-foreground flex items-center border-b p-2 text-sm\">\n              <FileIcon className=\"mr-2 h-4 w-4\" />\n              {filename}\n              <span className=\"ml-auto hidden md:block\">after</span>\n            </div>\n            {renderCode(afterCode, highlightedAfter)}\n          </div>\n        </div>\n        <div className=\"border-primary/20 bg-accent text-foreground absolute top-1/2 left-1/2 hidden h-8 w-8 -translate-x-1/2 -translate-y-1/2 items-center justify-center rounded-md border text-xs md:flex\">\n          VS\n        </div>\n      </div>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "dotted-map",
      "type": "component",
      "description": "A component with a dotted map.",
      "category": "special",
      "dependencies": [
        "svg-dotted-map"
      ],
      "files": [
        {
          "path": "components/ui/dotted-map.tsx",
          "content": "import * as React from \"react\"\nimport { createMap } from \"svg-dotted-map\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface Marker {\n  lat: number\n  lng: number\n  size?: number\n}\n\nexport interface DottedMapProps extends React.SVGProps<SVGSVGElement> {\n  width?: number\n  height?: number\n  mapSamples?: number\n  markers?: Marker[]\n  dotColor?: string\n  markerColor?: string\n  dotRadius?: number\n  stagger?: boolean\n}\n\nexport function DottedMap({\n  width = 150,\n  height = 75,\n  mapSamples = 5000,\n  markers = [],\n  markerColor = \"#FF6900\",\n  dotRadius = 0.2,\n  stagger = true,\n  className,\n  style,\n}: DottedMapProps) {\n  const { points, addMarkers } = createMap({\n    width,\n    height,\n    mapSamples,\n  })\n\n  const processedMarkers = addMarkers(markers)\n\n  // Compute stagger helpers in a single, simple pass\n  const { xStep, yToRowIndex } = React.useMemo(() => {\n    const sorted = [...points].sort((a, b) => a.y - b.y || a.x - b.x)\n    const rowMap = new Map<number, number>()\n    let step = 0\n    let prevY = Number.NaN\n    let prevXInRow = Number.NaN\n\n    for (const p of sorted) {\n      if (p.y !== prevY) {\n        // new row\n        prevY = p.y\n        prevXInRow = Number.NaN\n        if (!rowMap.has(p.y)) rowMap.set(p.y, rowMap.size)\n      }\n      if (!Number.isNaN(prevXInRow)) {\n        const delta = p.x - prevXInRow\n        if (delta > 0) step = step === 0 ? delta : Math.min(step, delta)\n      }\n      prevXInRow = p.x\n    }\n\n    return { xStep: step || 1, yToRowIndex: rowMap }\n  }, [points])\n\n  return (\n    <svg\n      viewBox={`0 0 ${width} ${height}`}\n      className={cn(\"text-gray-500 dark:text-gray-500\", className)}\n      style={{ width: \"100%\", height: \"100%\", ...style }}\n    >\n      {points.map((point, index) => {\n        const rowIndex = yToRowIndex.get(point.y) ?? 0\n        const offsetX = stagger && rowIndex % 2 === 1 ? xStep / 2 : 0\n        return (\n          <circle\n            cx={point.x + offsetX}\n            cy={point.y}\n            r={dotRadius}\n            fill=\"currentColor\"\n            key={`${point.x}-${point.y}-${index}`}\n          />\n        )\n      })}\n      {processedMarkers.map((marker, index) => {\n        const rowIndex = yToRowIndex.get(marker.y) ?? 0\n        const offsetX = stagger && rowIndex % 2 === 1 ? xStep / 2 : 0\n        return (\n          <circle\n            cx={marker.x + offsetX}\n            cy={marker.y}\n            r={marker.size ?? dotRadius}\n            fill={markerColor}\n            key={`${marker.x}-${marker.y}-${index}`}\n          />\n        )\n      })}\n    </svg>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "file-tree",
      "type": "component",
      "description": "A component used to showcase the folder and file structure of a directory.",
      "category": "special",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/file-tree.tsx",
          "content": "\"use client\"\n\nimport React, {\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { FileIcon, FolderIcon, FolderOpenIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { ScrollArea } from \"@/components/ui/scroll-area\"\n\ntype TreeViewElement = {\n  id: string\n  name: string\n  isSelectable?: boolean\n  children?: TreeViewElement[]\n}\n\ntype TreeContextProps = {\n  selectedId: string | undefined\n  expandedItems: string[] | undefined\n  indicator: boolean\n  handleExpand: (id: string) => void\n  selectItem: (id: string) => void\n  setExpandedItems?: React.Dispatch<React.SetStateAction<string[] | undefined>>\n  openIcon?: React.ReactNode\n  closeIcon?: React.ReactNode\n  direction: \"rtl\" | \"ltr\"\n}\n\nconst TreeContext = createContext<TreeContextProps | null>(null)\n\nconst useTree = () => {\n  const context = useContext(TreeContext)\n  if (!context) {\n    throw new Error(\"useTree must be used within a TreeProvider\")\n  }\n  return context\n}\n\ntype Direction = \"rtl\" | \"ltr\" | undefined\n\ntype TreeViewProps = {\n  initialSelectedId?: string\n  indicator?: boolean\n  elements?: TreeViewElement[]\n  initialExpandedItems?: string[]\n  openIcon?: React.ReactNode\n  closeIcon?: React.ReactNode\n} & React.HTMLAttributes<HTMLDivElement>\n\nconst Tree = forwardRef<HTMLDivElement, TreeViewProps>(\n  (\n    {\n      className,\n      elements,\n      initialSelectedId,\n      initialExpandedItems,\n      children,\n      indicator = true,\n      openIcon,\n      closeIcon,\n      dir,\n      ...props\n    },\n    ref\n  ) => {\n    const [selectedId, setSelectedId] = useState<string | undefined>(\n      initialSelectedId\n    )\n    const [expandedItems, setExpandedItems] = useState<string[] | undefined>(\n      initialExpandedItems\n    )\n\n    const selectItem = useCallback((id: string) => {\n      setSelectedId(id)\n    }, [])\n\n    const handleExpand = useCallback((id: string) => {\n      setExpandedItems((prev) => {\n        if (prev?.includes(id)) {\n          return prev.filter((item) => item !== id)\n        }\n        return [...(prev ?? []), id]\n      })\n    }, [])\n\n    const expandSpecificTargetedElements = useCallback(\n      (elements?: TreeViewElement[], selectId?: string) => {\n        if (!elements || !selectId) return\n        const findParent = (\n          currentElement: TreeViewElement,\n          currentPath: string[] = []\n        ) => {\n          const isSelectable = currentElement.isSelectable ?? true\n          const newPath = [...currentPath, currentElement.id]\n          if (currentElement.id === selectId) {\n            if (isSelectable) {\n              setExpandedItems((prev) => [...(prev ?? []), ...newPath])\n            } else {\n              if (newPath.includes(currentElement.id)) {\n                newPath.pop()\n                setExpandedItems((prev) => [...(prev ?? []), ...newPath])\n              }\n            }\n            return\n          }\n          if (\n            isSelectable &&\n            currentElement.children &&\n            currentElement.children.length > 0\n          ) {\n            currentElement.children.forEach((child) => {\n              findParent(child, newPath)\n            })\n          }\n        }\n        elements.forEach((element) => {\n          findParent(element)\n        })\n      },\n      []\n    )\n\n    useEffect(() => {\n      if (initialSelectedId) {\n        expandSpecificTargetedElements(elements, initialSelectedId)\n      }\n    }, [initialSelectedId, elements])\n\n    const direction = dir === \"rtl\" ? \"rtl\" : \"ltr\"\n\n    return (\n      <TreeContext.Provider\n        value={{\n          selectedId,\n          expandedItems,\n          handleExpand,\n          selectItem,\n          setExpandedItems,\n          indicator,\n          openIcon,\n          closeIcon,\n          direction,\n        }}\n      >\n        <div className={cn(\"size-full\", className)}>\n          <ScrollArea\n            ref={ref}\n            className=\"relative h-full px-2\"\n            dir={dir as Direction}\n          >\n            <AccordionPrimitive.Root\n              {...props}\n              type=\"multiple\"\n              defaultValue={expandedItems}\n              value={expandedItems}\n              className=\"flex flex-col gap-1\"\n              onValueChange={(value) =>\n                setExpandedItems((prev) => [...(prev ?? []), value[0]])\n              }\n              dir={dir as Direction}\n            >\n              {children}\n            </AccordionPrimitive.Root>\n          </ScrollArea>\n        </div>\n      </TreeContext.Provider>\n    )\n  }\n)\n\nTree.displayName = \"Tree\"\n\nconst TreeIndicator = forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { direction } = useTree()\n\n  return (\n    <div\n      dir={direction}\n      ref={ref}\n      className={cn(\n        \"bg-muted absolute left-1.5 h-full w-px rounded-md py-3 duration-300 ease-in-out hover:bg-slate-300 rtl:right-1.5\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\n\nTreeIndicator.displayName = \"TreeIndicator\"\n\ntype FolderProps = {\n  expandedItems?: string[]\n  element: string\n  isSelectable?: boolean\n  isSelect?: boolean\n} & React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n\nconst Folder = forwardRef<\n  HTMLDivElement,\n  FolderProps & React.HTMLAttributes<HTMLDivElement>\n>(\n  (\n    {\n      className,\n      element,\n      value,\n      isSelectable = true,\n      isSelect,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const {\n      direction,\n      handleExpand,\n      expandedItems,\n      indicator,\n      setExpandedItems,\n      openIcon,\n      closeIcon,\n    } = useTree()\n\n    return (\n      <AccordionPrimitive.Item\n        {...props}\n        value={value}\n        className=\"relative h-full overflow-hidden\"\n      >\n        <AccordionPrimitive.Trigger\n          className={cn(\n            `flex items-center gap-1 rounded-md text-sm`,\n            className,\n            {\n              \"bg-muted rounded-md\": isSelect && isSelectable,\n              \"cursor-pointer\": isSelectable,\n              \"cursor-not-allowed opacity-50\": !isSelectable,\n            }\n          )}\n          disabled={!isSelectable}\n          onClick={() => handleExpand(value)}\n        >\n          {expandedItems?.includes(value)\n            ? (openIcon ?? <FolderOpenIcon className=\"size-4\" />)\n            : (closeIcon ?? <FolderIcon className=\"size-4\" />)}\n          <span>{element}</span>\n        </AccordionPrimitive.Trigger>\n        <AccordionPrimitive.Content className=\"data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down relative h-full overflow-hidden text-sm\">\n          {element && indicator && <TreeIndicator aria-hidden=\"true\" />}\n          <AccordionPrimitive.Root\n            dir={direction}\n            type=\"multiple\"\n            className=\"ml-5 flex flex-col gap-1 py-1 rtl:mr-5\"\n            defaultValue={expandedItems}\n            value={expandedItems}\n            onValueChange={(value) => {\n              setExpandedItems?.((prev) => [...(prev ?? []), value[0]])\n            }}\n          >\n            {children}\n          </AccordionPrimitive.Root>\n        </AccordionPrimitive.Content>\n      </AccordionPrimitive.Item>\n    )\n  }\n)\n\nFolder.displayName = \"Folder\"\n\nconst File = forwardRef<\n  HTMLButtonElement,\n  {\n    value: string\n    handleSelect?: (id: string) => void\n    isSelectable?: boolean\n    isSelect?: boolean\n    fileIcon?: React.ReactNode\n  } & React.ButtonHTMLAttributes<HTMLButtonElement>\n>(\n  (\n    {\n      value,\n      className,\n      handleSelect,\n      isSelectable = true,\n      isSelect,\n      fileIcon,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const { direction, selectedId, selectItem } = useTree()\n    const isSelected = isSelect ?? selectedId === value\n    return (\n      <button\n        ref={ref}\n        type=\"button\"\n        disabled={!isSelectable}\n        className={cn(\n          \"flex w-fit items-center gap-1 rounded-md pr-1 text-sm duration-200 ease-in-out rtl:pr-0 rtl:pl-1\",\n          {\n            \"bg-muted\": isSelected && isSelectable,\n          },\n          isSelectable ? \"cursor-pointer\" : \"cursor-not-allowed opacity-50\",\n          direction === \"rtl\" ? \"rtl\" : \"ltr\",\n          className\n        )}\n        onClick={() => selectItem(value)}\n        {...props}\n      >\n        {fileIcon ?? <FileIcon className=\"size-4\" />}\n        {children}\n      </button>\n    )\n  }\n)\n\nFile.displayName = \"File\"\n\nconst CollapseButton = forwardRef<\n  HTMLButtonElement,\n  {\n    elements: TreeViewElement[]\n    expandAll?: boolean\n  } & React.HTMLAttributes<HTMLButtonElement>\n>(({ className, elements, expandAll = false, children, ...props }, ref) => {\n  const { expandedItems, setExpandedItems } = useTree()\n\n  const expendAllTree = useCallback((elements: TreeViewElement[]) => {\n    const expandTree = (element: TreeViewElement) => {\n      const isSelectable = element.isSelectable ?? true\n      if (isSelectable && element.children && element.children.length > 0) {\n        setExpandedItems?.((prev) => [...(prev ?? []), element.id])\n        element.children.forEach(expandTree)\n      }\n    }\n\n    elements.forEach(expandTree)\n  }, [])\n\n  const closeAll = useCallback(() => {\n    setExpandedItems?.([])\n  }, [])\n\n  useEffect(() => {\n    console.log(expandAll)\n    if (expandAll) {\n      expendAllTree(elements)\n    }\n  }, [expandAll])\n\n  return (\n    <Button\n      variant={\"ghost\"}\n      className=\"absolute right-2 bottom-1 h-8 w-fit p-1\"\n      onClick={\n        expandedItems && expandedItems.length > 0\n          ? closeAll\n          : () => expendAllTree(elements)\n      }\n      ref={ref}\n      {...props}\n    >\n      {children}\n      <span className=\"sr-only\">Toggle</span>\n    </Button>\n  )\n})\n\nCollapseButton.displayName = \"CollapseButton\"\n\nexport { CollapseButton, File, Folder, Tree, type TreeViewElement }\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "globe",
      "type": "component",
      "description": "An autorotating, interactive, and highly performant globe made using WebGL.",
      "category": "special",
      "dependencies": [
        "cobe",
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/globe.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useRef } from \"react\"\nimport createGlobe, { COBEOptions } from \"cobe\"\nimport { useMotionValue, useSpring } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst MOVEMENT_DAMPING = 1400\n\nconst GLOBE_CONFIG: COBEOptions = {\n  width: 800,\n  height: 800,\n  onRender: () => {},\n  devicePixelRatio: 2,\n  phi: 0,\n  theta: 0.3,\n  dark: 0,\n  diffuse: 0.4,\n  mapSamples: 16000,\n  mapBrightness: 1.2,\n  baseColor: [1, 1, 1],\n  markerColor: [251 / 255, 100 / 255, 21 / 255],\n  glowColor: [1, 1, 1],\n  markers: [\n    { location: [14.5995, 120.9842], size: 0.03 },\n    { location: [19.076, 72.8777], size: 0.1 },\n    { location: [23.8103, 90.4125], size: 0.05 },\n    { location: [30.0444, 31.2357], size: 0.07 },\n    { location: [39.9042, 116.4074], size: 0.08 },\n    { location: [-23.5505, -46.6333], size: 0.1 },\n    { location: [19.4326, -99.1332], size: 0.1 },\n    { location: [40.7128, -74.006], size: 0.1 },\n    { location: [34.6937, 135.5022], size: 0.05 },\n    { location: [41.0082, 28.9784], size: 0.06 },\n  ],\n}\n\nexport function Globe({\n  className,\n  config = GLOBE_CONFIG,\n}: {\n  className?: string\n  config?: COBEOptions\n}) {\n  let phi = 0\n  let width = 0\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const pointerInteracting = useRef<number | null>(null)\n  const pointerInteractionMovement = useRef(0)\n\n  const r = useMotionValue(0)\n  const rs = useSpring(r, {\n    mass: 1,\n    damping: 30,\n    stiffness: 100,\n  })\n\n  const updatePointerInteraction = (value: number | null) => {\n    pointerInteracting.current = value\n    if (canvasRef.current) {\n      canvasRef.current.style.cursor = value !== null ? \"grabbing\" : \"grab\"\n    }\n  }\n\n  const updateMovement = (clientX: number) => {\n    if (pointerInteracting.current !== null) {\n      const delta = clientX - pointerInteracting.current\n      pointerInteractionMovement.current = delta\n      r.set(r.get() + delta / MOVEMENT_DAMPING)\n    }\n  }\n\n  useEffect(() => {\n    const onResize = () => {\n      if (canvasRef.current) {\n        width = canvasRef.current.offsetWidth\n      }\n    }\n\n    window.addEventListener(\"resize\", onResize)\n    onResize()\n\n    const globe = createGlobe(canvasRef.current!, {\n      ...config,\n      width: width * 2,\n      height: width * 2,\n      onRender: (state) => {\n        if (!pointerInteracting.current) phi += 0.005\n        state.phi = phi + rs.get()\n        state.width = width * 2\n        state.height = width * 2\n      },\n    })\n\n    setTimeout(() => (canvasRef.current!.style.opacity = \"1\"), 0)\n    return () => {\n      globe.destroy()\n      window.removeEventListener(\"resize\", onResize)\n    }\n  }, [rs, config])\n\n  return (\n    <div\n      className={cn(\n        \"absolute inset-0 mx-auto aspect-[1/1] w-full max-w-[600px]\",\n        className\n      )}\n    >\n      <canvas\n        className={cn(\n          \"size-full opacity-0 transition-opacity duration-500 [contain:layout_paint_size]\"\n        )}\n        ref={canvasRef}\n        onPointerDown={(e) => {\n          pointerInteracting.current = e.clientX\n          updatePointerInteraction(e.clientX)\n        }}\n        onPointerUp={() => updatePointerInteraction(null)}\n        onPointerOut={() => updatePointerInteraction(null)}\n        onMouseMove={(e) => updateMovement(e.clientX)}\n        onTouchMove={(e) =>\n          e.touches[0] && updateMovement(e.touches[0].clientX)\n        }\n      />\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "iphone",
      "type": "component",
      "description": "A mockup of the iPhone",
      "category": "special",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/iphone.tsx",
          "content": "import type { HTMLAttributes } from \"react\"\n\nconst PHONE_WIDTH = 433\nconst PHONE_HEIGHT = 882\nconst SCREEN_X = 21.25\nconst SCREEN_Y = 19.25\nconst SCREEN_WIDTH = 389.5\nconst SCREEN_HEIGHT = 843.5\nconst SCREEN_RADIUS = 55.75\n\n// Calculated percentages\nconst LEFT_PCT = (SCREEN_X / PHONE_WIDTH) * 100\nconst TOP_PCT = (SCREEN_Y / PHONE_HEIGHT) * 100\nconst WIDTH_PCT = (SCREEN_WIDTH / PHONE_WIDTH) * 100\nconst HEIGHT_PCT = (SCREEN_HEIGHT / PHONE_HEIGHT) * 100\nconst RADIUS_H = (SCREEN_RADIUS / SCREEN_WIDTH) * 100\nconst RADIUS_V = (SCREEN_RADIUS / SCREEN_HEIGHT) * 100\n\nexport interface IphoneProps extends HTMLAttributes<HTMLDivElement> {\n  src?: string\n  videoSrc?: string\n}\n\nexport function Iphone({\n  src,\n  videoSrc,\n  className,\n  style,\n  ...props\n}: IphoneProps) {\n  const hasVideo = !!videoSrc\n  const hasMedia = hasVideo || !!src\n\n  return (\n    <div\n      className={`relative inline-block w-full align-middle leading-none ${className}`}\n      style={{\n        aspectRatio: `${PHONE_WIDTH}/${PHONE_HEIGHT}`,\n        ...style,\n      }}\n      {...props}\n    >\n      {hasVideo && (\n        <div\n          className=\"pointer-events-none absolute z-0 overflow-hidden\"\n          style={{\n            left: `${LEFT_PCT}%`,\n            top: `${TOP_PCT}%`,\n            width: `${WIDTH_PCT}%`,\n            height: `${HEIGHT_PCT}%`,\n            borderRadius: `${RADIUS_H}% / ${RADIUS_V}%`,\n          }}\n        >\n          <video\n            className=\"block size-full object-cover\"\n            src={videoSrc}\n            autoPlay\n            loop\n            muted\n            playsInline\n            preload=\"metadata\"\n          />\n        </div>\n      )}\n\n      {!hasVideo && src && (\n        <div\n          className=\"pointer-events-none absolute z-0 overflow-hidden\"\n          style={{\n            left: `${LEFT_PCT}%`,\n            top: `${TOP_PCT}%`,\n            width: `${WIDTH_PCT}%`,\n            height: `${HEIGHT_PCT}%`,\n            borderRadius: `${RADIUS_H}% / ${RADIUS_V}%`,\n          }}\n        >\n          <img\n            src={src}\n            alt=\"\"\n            className=\"block size-full object-cover object-top\"\n          />\n        </div>\n      )}\n\n      <svg\n        viewBox={`0 0 ${PHONE_WIDTH} ${PHONE_HEIGHT}`}\n        fill=\"none\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        className=\"absolute inset-0 size-full\"\n        style={{ transform: \"translateZ(0)\" }}\n      >\n        <g mask={hasMedia ? \"url(#screenPunch)\" : undefined}>\n          <path\n            d=\"M2 73C2 32.6832 34.6832 0 75 0H357C397.317 0 430 32.6832 430 73V809C430 849.317 397.317 882 357 882H75C34.6832 882 2 849.317 2 809V73Z\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <path\n            d=\"M0 171C0 170.448 0.447715 170 1 170H3V204H1C0.447715 204 0 203.552 0 203V171Z\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <path\n            d=\"M1 234C1 233.448 1.44772 233 2 233H3.5V300H2C1.44772 300 1 299.552 1 299V234Z\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <path\n            d=\"M1 319C1 318.448 1.44772 318 2 318H3.5V385H2C1.44772 385 1 384.552 1 384V319Z\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <path\n            d=\"M430 279H432C432.552 279 433 279.448 433 280V384C433 384.552 432.552 385 432 385H430V279Z\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <path\n            d=\"M6 74C6 35.3401 37.3401 4 76 4H356C394.66 4 426 35.3401 426 74V808C426 846.66 394.66 878 356 878H76C37.3401 878 6 846.66 6 808V74Z\"\n            className=\"fill-white dark:fill-[#262626]\"\n          />\n        </g>\n\n        <path\n          opacity=\"0.5\"\n          d=\"M174 5H258V5.5C258 6.60457 257.105 7.5 256 7.5H176C174.895 7.5 174 6.60457 174 5.5V5Z\"\n          className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n        />\n\n        <path\n          d={`M${SCREEN_X} 75C${SCREEN_X} 44.2101 46.2101 ${SCREEN_Y} 77 ${SCREEN_Y}H355C385.79 ${SCREEN_Y} 410.75 44.2101 410.75 75V807C410.75 837.79 385.79 862.75 355 862.75H77C46.2101 862.75 ${SCREEN_X} 837.79 ${SCREEN_X} 807V75Z`}\n          className=\"fill-[#E5E5E5] stroke-[#E5E5E5] stroke-[0.5] dark:fill-[#404040] dark:stroke-[#404040]\"\n          mask={hasMedia ? \"url(#screenPunch)\" : undefined}\n        />\n\n        <path\n          d=\"M154 48.5C154 38.2827 162.283 30 172.5 30H259.5C269.717 30 278 38.2827 278 48.5C278 58.7173 269.717 67 259.5 67H172.5C162.283 67 154 58.7173 154 48.5Z\"\n          className=\"fill-[#F5F5F5] dark:fill-[#262626]\"\n        />\n        <path\n          d=\"M249 48.5C249 42.701 253.701 38 259.5 38C265.299 38 270 42.701 270 48.5C270 54.299 265.299 59 259.5 59C253.701 59 249 54.299 249 48.5Z\"\n          className=\"fill-[#F5F5F5] dark:fill-[#262626]\"\n        />\n        <path\n          d=\"M254 48.5C254 45.4624 256.462 43 259.5 43C262.538 43 265 45.4624 265 48.5C265 51.5376 262.538 54 259.5 54C256.462 54 254 51.5376 254 48.5Z\"\n          className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n        />\n\n        <defs>\n          <mask id=\"screenPunch\" maskUnits=\"userSpaceOnUse\">\n            <rect\n              x=\"0\"\n              y=\"0\"\n              width={PHONE_WIDTH}\n              height={PHONE_HEIGHT}\n              fill=\"white\"\n            />\n            <rect\n              x={SCREEN_X}\n              y={SCREEN_Y}\n              width={SCREEN_WIDTH}\n              height={SCREEN_HEIGHT}\n              rx={SCREEN_RADIUS}\n              ry={SCREEN_RADIUS}\n              fill=\"black\"\n            />\n          </mask>\n          <clipPath id=\"roundedCorners\">\n            <rect\n              x={SCREEN_X}\n              y={SCREEN_Y}\n              width={SCREEN_WIDTH}\n              height={SCREEN_HEIGHT}\n              rx={SCREEN_RADIUS}\n              ry={SCREEN_RADIUS}\n            />\n          </clipPath>\n        </defs>\n      </svg>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "lens",
      "type": "component",
      "description": "A interactive component that enables zooming into images, videos and other elements.",
      "category": "special",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/lens.tsx",
          "content": "\"use client\"\n\nimport React, { useCallback, useMemo, useRef, useState } from \"react\"\nimport { AnimatePresence, motion, useMotionTemplate } from \"motion/react\"\n\ninterface Position {\n  /** The x coordinate of the lens */\n  x: number\n  /** The y coordinate of the lens */\n  y: number\n}\n\ninterface LensProps {\n  /** The children of the lens */\n  children: React.ReactNode\n  /** The zoom factor of the lens */\n  zoomFactor?: number\n  /** The size of the lens */\n  lensSize?: number\n  /** The position of the lens */\n  position?: Position\n  /** The default position of the lens */\n  defaultPosition?: Position\n  /** Whether the lens is static */\n  isStatic?: boolean\n  /** The duration of the animation */\n  duration?: number\n  /** The color of the lens */\n  lensColor?: string\n  /** The aria label of the lens */\n  ariaLabel?: string\n}\n\nexport function Lens({\n  children,\n  zoomFactor = 1.3,\n  lensSize = 170,\n  isStatic = false,\n  position = { x: 0, y: 0 },\n  defaultPosition,\n  duration = 0.1,\n  lensColor = \"black\",\n  ariaLabel = \"Zoom Area\",\n}: LensProps) {\n  if (zoomFactor < 1) {\n    throw new Error(\"zoomFactor must be greater than 1\")\n  }\n  if (lensSize < 0) {\n    throw new Error(\"lensSize must be greater than 0\")\n  }\n\n  const [isHovering, setIsHovering] = useState(false)\n  const [mousePosition, setMousePosition] = useState<Position>(position)\n  const containerRef = useRef<HTMLDivElement>(null)\n\n  const currentPosition = useMemo(() => {\n    if (isStatic) return position\n    if (defaultPosition && !isHovering) return defaultPosition\n    return mousePosition\n  }, [isStatic, position, defaultPosition, isHovering, mousePosition])\n\n  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLDivElement>) => {\n    const rect = e.currentTarget.getBoundingClientRect()\n    setMousePosition({\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top,\n    })\n  }, [])\n\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (e.key === \"Escape\") setIsHovering(false)\n  }, [])\n\n  const maskImage = useMotionTemplate`radial-gradient(circle ${\n    lensSize / 2\n  }px at ${currentPosition.x}px ${\n    currentPosition.y\n  }px, ${lensColor} 100%, transparent 100%)`\n\n  const LensContent = useMemo(() => {\n    const { x, y } = currentPosition\n\n    return (\n      <motion.div\n        initial={{ opacity: 0, scale: 0.58 }}\n        animate={{ opacity: 1, scale: 1 }}\n        exit={{ opacity: 0, scale: 0.8 }}\n        transition={{ duration }}\n        className=\"absolute inset-0 overflow-hidden\"\n        style={{\n          maskImage,\n          WebkitMaskImage: maskImage,\n          transformOrigin: `${x}px ${y}px`,\n          zIndex: 50,\n        }}\n      >\n        <div\n          className=\"absolute inset-0\"\n          style={{\n            transform: `scale(${zoomFactor})`,\n            transformOrigin: `${x}px ${y}px`,\n          }}\n        >\n          {children}\n        </div>\n      </motion.div>\n    )\n  }, [currentPosition, lensSize, lensColor, zoomFactor, children, duration])\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"relative z-20 overflow-hidden rounded-xl\"\n      onMouseEnter={() => setIsHovering(true)}\n      onMouseLeave={() => setIsHovering(false)}\n      onMouseMove={handleMouseMove}\n      onKeyDown={handleKeyDown}\n      role=\"region\"\n      aria-label={ariaLabel}\n      tabIndex={0}\n    >\n      {children}\n      {isStatic || defaultPosition ? (\n        LensContent\n      ) : (\n        <AnimatePresence mode=\"popLayout\">\n          {isHovering && LensContent}\n        </AnimatePresence>\n      )}\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "pointer",
      "type": "component",
      "description": "A component that displays a pointer when hovering over an element",
      "category": "special",
      "dependencies": [
        "motion"
      ],
      "files": [
        {
          "path": "components/ui/pointer.tsx",
          "content": "\"use client\"\n\nimport { useEffect, useRef, useState } from \"react\"\nimport {\n  AnimatePresence,\n  HTMLMotionProps,\n  motion,\n  useMotionValue,\n} from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\n/**\n * A custom pointer component that displays an animated cursor.\n * Add this as a child to any component to enable a custom pointer when hovering.\n * You can pass custom children to render as the pointer.\n *\n * @component\n * @param {HTMLMotionProps<\"div\">} props - The component props\n */\nexport function Pointer({\n  className,\n  style,\n  children,\n  ...props\n}: HTMLMotionProps<\"div\">): React.ReactNode {\n  const x = useMotionValue(0)\n  const y = useMotionValue(0)\n  const [isActive, setIsActive] = useState<boolean>(false)\n  const containerRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    if (typeof window !== \"undefined\" && containerRef.current) {\n      // Get the parent element directly from the ref\n      const parentElement = containerRef.current.parentElement\n\n      if (parentElement) {\n        // Add cursor-none to parent\n        parentElement.style.cursor = \"none\"\n\n        // Add event listeners to parent\n        const handleMouseMove = (e: MouseEvent) => {\n          x.set(e.clientX)\n          y.set(e.clientY)\n          setIsActive(true)\n        }\n\n        const handleMouseEnter = (e: MouseEvent) => {\n          x.set(e.clientX)\n          y.set(e.clientY)\n          setIsActive(true)\n        }\n\n        const handleMouseLeave = () => {\n          setIsActive(false)\n        }\n\n        parentElement.addEventListener(\"mousemove\", handleMouseMove)\n        parentElement.addEventListener(\"mouseenter\", handleMouseEnter)\n        parentElement.addEventListener(\"mouseleave\", handleMouseLeave)\n\n        return () => {\n          parentElement.style.cursor = \"\"\n          parentElement.removeEventListener(\"mousemove\", handleMouseMove)\n          parentElement.removeEventListener(\"mouseenter\", handleMouseEnter)\n          parentElement.removeEventListener(\"mouseleave\", handleMouseLeave)\n        }\n      }\n    }\n  }, [x, y])\n\n  return (\n    <>\n      <div ref={containerRef} />\n      <AnimatePresence>\n        {isActive && (\n          <motion.div\n            className=\"pointer-events-none fixed z-50 transform-[translate(-50%,-50%)]\"\n            style={{\n              top: y,\n              left: x,\n              ...style,\n            }}\n            initial={{\n              scale: 0,\n              opacity: 0,\n            }}\n            animate={{\n              scale: 1,\n              opacity: 1,\n            }}\n            exit={{\n              scale: 0,\n              opacity: 0,\n            }}\n            {...props}\n          >\n            {children || (\n              <svg\n                stroke=\"currentColor\"\n                fill=\"currentColor\"\n                strokeWidth=\"1\"\n                viewBox=\"0 0 16 16\"\n                height=\"24\"\n                width=\"24\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n                className={cn(\n                  \"rotate-[-70deg] stroke-white text-black\",\n                  className\n                )}\n              >\n                <path d=\"M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z\" />\n              </svg>\n            )}\n          </motion.div>\n        )}\n      </AnimatePresence>\n    </>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "progressive-blur",
      "type": "component",
      "description": "Adds a smooth blur gradient effect to scrollable content.",
      "category": "special",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/progressive-blur.tsx",
          "content": "\"use client\"\n\nimport React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface ProgressiveBlurProps {\n  className?: string\n  height?: string\n  position?: \"top\" | \"bottom\" | \"both\"\n  blurLevels?: number[]\n  children?: React.ReactNode\n}\n\nexport function ProgressiveBlur({\n  className,\n  height = \"30%\",\n  position = \"bottom\",\n  blurLevels = [0.5, 1, 2, 4, 8, 16, 32, 64],\n}: ProgressiveBlurProps) {\n  // Create array with length equal to blurLevels.length - 2 (for before/after pseudo elements)\n  const divElements = Array(blurLevels.length - 2).fill(null)\n\n  return (\n    <div\n      className={cn(\n        \"gradient-blur pointer-events-none absolute inset-x-0 z-10\",\n        className,\n        position === \"top\"\n          ? \"top-0\"\n          : position === \"bottom\"\n            ? \"bottom-0\"\n            : \"inset-y-0\"\n      )}\n      style={{\n        height: position === \"both\" ? \"100%\" : height,\n      }}\n    >\n      {/* First blur layer (pseudo element) */}\n      <div\n        className=\"absolute inset-0\"\n        style={{\n          zIndex: 1,\n          backdropFilter: `blur(${blurLevels[0]}px)`,\n          WebkitBackdropFilter: `blur(${blurLevels[0]}px)`,\n          maskImage:\n            position === \"bottom\"\n              ? `linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 12.5%, rgba(0,0,0,1) 25%, rgba(0,0,0,0) 37.5%)`\n              : position === \"top\"\n                ? `linear-gradient(to top, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 12.5%, rgba(0,0,0,1) 25%, rgba(0,0,0,0) 37.5%)`\n                : `linear-gradient(rgba(0,0,0,0) 0%, rgba(0,0,0,1) 5%, rgba(0,0,0,1) 95%, rgba(0,0,0,0) 100%)`,\n          WebkitMaskImage:\n            position === \"bottom\"\n              ? `linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 12.5%, rgba(0,0,0,1) 25%, rgba(0,0,0,0) 37.5%)`\n              : position === \"top\"\n                ? `linear-gradient(to top, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 12.5%, rgba(0,0,0,1) 25%, rgba(0,0,0,0) 37.5%)`\n                : `linear-gradient(rgba(0,0,0,0) 0%, rgba(0,0,0,1) 5%, rgba(0,0,0,1) 95%, rgba(0,0,0,0) 100%)`,\n        }}\n      />\n\n      {/* Middle blur layers */}\n      {divElements.map((_, index) => {\n        const blurIndex = index + 1\n        const startPercent = blurIndex * 12.5\n        const midPercent = (blurIndex + 1) * 12.5\n        const endPercent = (blurIndex + 2) * 12.5\n\n        const maskGradient =\n          position === \"bottom\"\n            ? `linear-gradient(to bottom, rgba(0,0,0,0) ${startPercent}%, rgba(0,0,0,1) ${midPercent}%, rgba(0,0,0,1) ${endPercent}%, rgba(0,0,0,0) ${endPercent + 12.5}%)`\n            : position === \"top\"\n              ? `linear-gradient(to top, rgba(0,0,0,0) ${startPercent}%, rgba(0,0,0,1) ${midPercent}%, rgba(0,0,0,1) ${endPercent}%, rgba(0,0,0,0) ${endPercent + 12.5}%)`\n              : `linear-gradient(rgba(0,0,0,0) 0%, rgba(0,0,0,1) 5%, rgba(0,0,0,1) 95%, rgba(0,0,0,0) 100%)`\n\n        return (\n          <div\n            key={`blur-${index}`}\n            className=\"absolute inset-0\"\n            style={{\n              zIndex: index + 2,\n              backdropFilter: `blur(${blurLevels[blurIndex]}px)`,\n              WebkitBackdropFilter: `blur(${blurLevels[blurIndex]}px)`,\n              maskImage: maskGradient,\n              WebkitMaskImage: maskGradient,\n            }}\n          />\n        )\n      })}\n\n      {/* Last blur layer (pseudo element) */}\n      <div\n        className=\"absolute inset-0\"\n        style={{\n          zIndex: blurLevels.length,\n          backdropFilter: `blur(${blurLevels[blurLevels.length - 1]}px)`,\n          WebkitBackdropFilter: `blur(${blurLevels[blurLevels.length - 1]}px)`,\n          maskImage:\n            position === \"bottom\"\n              ? `linear-gradient(to bottom, rgba(0,0,0,0) 87.5%, rgba(0,0,0,1) 100%)`\n              : position === \"top\"\n                ? `linear-gradient(to top, rgba(0,0,0,0) 87.5%, rgba(0,0,0,1) 100%)`\n                : `linear-gradient(rgba(0,0,0,0) 0%, rgba(0,0,0,1) 5%, rgba(0,0,0,1) 95%, rgba(0,0,0,0) 100%)`,\n          WebkitMaskImage:\n            position === \"bottom\"\n              ? `linear-gradient(to bottom, rgba(0,0,0,0) 87.5%, rgba(0,0,0,1) 100%)`\n              : position === \"top\"\n                ? `linear-gradient(to top, rgba(0,0,0,0) 87.5%, rgba(0,0,0,1) 100%)`\n                : `linear-gradient(rgba(0,0,0,0) 0%, rgba(0,0,0,1) 5%, rgba(0,0,0,1) 95%, rgba(0,0,0,0) 100%)`,\n        }}\n      />\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "safari",
      "type": "component",
      "description": "A safari browser mockup to showcase your website.",
      "category": "special",
      "dependencies": [],
      "files": [
        {
          "path": "components/ui/safari.tsx",
          "content": "import type { HTMLAttributes } from \"react\"\n\nconst SAFARI_WIDTH = 1203\nconst SAFARI_HEIGHT = 753\nconst SCREEN_X = 1\nconst SCREEN_Y = 52\nconst SCREEN_WIDTH = 1200\nconst SCREEN_HEIGHT = 700\n\n// Calculated percentages\nconst LEFT_PCT = (SCREEN_X / SAFARI_WIDTH) * 100\nconst TOP_PCT = (SCREEN_Y / SAFARI_HEIGHT) * 100\nconst WIDTH_PCT = (SCREEN_WIDTH / SAFARI_WIDTH) * 100\nconst HEIGHT_PCT = (SCREEN_HEIGHT / SAFARI_HEIGHT) * 100\n\ntype SafariMode = \"default\" | \"simple\"\n\nexport interface SafariProps extends HTMLAttributes<HTMLDivElement> {\n  url?: string\n  imageSrc?: string\n  videoSrc?: string\n  mode?: SafariMode\n}\n\nexport function Safari({\n  imageSrc,\n  videoSrc,\n  url,\n  mode = \"default\",\n  className,\n  style,\n  ...props\n}: SafariProps) {\n  const hasVideo = !!videoSrc\n  const hasMedia = hasVideo || !!imageSrc\n\n  return (\n    <div\n      className={`relative inline-block w-full align-middle leading-none ${className ?? \"\"}`}\n      style={{\n        aspectRatio: `${SAFARI_WIDTH}/${SAFARI_HEIGHT}`,\n        ...style,\n      }}\n      {...props}\n    >\n      {hasVideo && (\n        <div\n          className=\"pointer-events-none absolute z-0 overflow-hidden\"\n          style={{\n            left: `${LEFT_PCT}%`,\n            top: `${TOP_PCT}%`,\n            width: `${WIDTH_PCT}%`,\n            height: `${HEIGHT_PCT}%`,\n          }}\n        >\n          <video\n            className=\"block size-full object-cover\"\n            src={videoSrc}\n            autoPlay\n            loop\n            muted\n            playsInline\n            preload=\"metadata\"\n          />\n        </div>\n      )}\n\n      {!hasVideo && imageSrc && (\n        <div\n          className=\"pointer-events-none absolute z-0 overflow-hidden\"\n          style={{\n            left: `${LEFT_PCT}%`,\n            top: `${TOP_PCT}%`,\n            width: `${WIDTH_PCT}%`,\n            height: `${HEIGHT_PCT}%`,\n            borderRadius: \"0 0 11px 11px\",\n          }}\n        >\n          <img\n            src={imageSrc}\n            alt=\"\"\n            className=\"block size-full object-cover object-top\"\n          />\n        </div>\n      )}\n\n      <svg\n        viewBox={`0 0 ${SAFARI_WIDTH} ${SAFARI_HEIGHT}`}\n        fill=\"none\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        className=\"absolute inset-0 z-10 size-full\"\n        style={{ transform: \"translateZ(0)\" }}\n      >\n        <defs>\n          <mask id=\"safariPunch\" maskUnits=\"userSpaceOnUse\">\n            <rect\n              x=\"0\"\n              y=\"0\"\n              width={SAFARI_WIDTH}\n              height={SAFARI_HEIGHT}\n              fill=\"white\"\n            />\n            <path\n              d=\"M1 52H1201V741C1201 747.075 1196.08 752 1190 752H12C5.92486 752 1 747.075 1 741V52Z\"\n              fill=\"black\"\n            />\n          </mask>\n\n          <clipPath id=\"path0\">\n            <rect width={SAFARI_WIDTH} height={SAFARI_HEIGHT} fill=\"white\" />\n          </clipPath>\n\n          <clipPath id=\"roundedBottom\">\n            <path\n              d=\"M1 52H1201V741C1201 747.075 1196.08 752 1190 752H12C5.92486 752 1 747.075 1 741V52Z\"\n              fill=\"white\"\n            />\n          </clipPath>\n        </defs>\n\n        <g\n          clipPath=\"url(#path0)\"\n          mask={hasMedia ? \"url(#safariPunch)\" : undefined}\n        >\n          <path\n            d=\"M0 52H1202V741C1202 747.627 1196.63 753 1190 753H12C5.37258 753 0 747.627 0 741V52Z\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <path\n            fillRule=\"evenodd\"\n            clipRule=\"evenodd\"\n            d=\"M0 12C0 5.37258 5.37258 0 12 0H1190C1196.63 0 1202 5.37258 1202 12V52H0L0 12Z\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <path\n            fillRule=\"evenodd\"\n            clipRule=\"evenodd\"\n            d=\"M1.06738 12C1.06738 5.92487 5.99225 1 12.0674 1H1189.93C1196.01 1 1200.93 5.92487 1200.93 12V51H1.06738V12Z\"\n            className=\"fill-white dark:fill-[#262626]\"\n          />\n          <circle\n            cx=\"27\"\n            cy=\"25\"\n            r=\"6\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <circle\n            cx=\"47\"\n            cy=\"25\"\n            r=\"6\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <circle\n            cx=\"67\"\n            cy=\"25\"\n            r=\"6\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <path\n            d=\"M286 17C286 13.6863 288.686 11 292 11H946C949.314 11 952 13.6863 952 17V35C952 38.3137 949.314 41 946 41H292C288.686 41 286 38.3137 286 35V17Z\"\n            className=\"fill-[#E5E5E5] dark:fill-[#404040]\"\n          />\n          <g className=\"mix-blend-luminosity\">\n            <path\n              d=\"M566.269 32.0852H572.426C573.277 32.0852 573.696 31.6663 573.696 30.7395V25.9851C573.696 25.1472 573.353 24.7219 572.642 24.6521V23.0842C572.642 20.6721 571.036 19.5105 569.348 19.5105C567.659 19.5105 566.053 20.6721 566.053 23.0842V24.6711C565.393 24.7727 565 25.1917 565 25.9851V30.7395C565 31.6663 565.418 32.0852 566.269 32.0852ZM567.272 22.97C567.272 21.491 568.211 20.6785 569.348 20.6785C570.478 20.6785 571.423 21.491 571.423 22.97V24.6394L567.272 24.6458V22.97Z\"\n              fill=\"#A3A3A3\"\n            />\n          </g>\n\n          <g className=\"mix-blend-luminosity\">\n            <text\n              x=\"580\"\n              y=\"30\"\n              fill=\"#A3A3A3\"\n              fontSize=\"12\"\n              fontFamily=\"Arial, sans-serif\"\n            >\n              {url}\n            </text>\n          </g>\n\n          {mode === \"default\" ? (\n            <>\n              <g className=\"mix-blend-luminosity\">\n                <path\n                  d=\"M265.5 33.8984C265.641 33.8984 265.852 33.8516 266.047 33.7422C270.547 31.2969 272.109 30.1641 272.109 27.3203V21.4219C272.109 20.4844 271.742 20.1484 270.961 19.8125C270.094 19.4453 267.18 18.4297 266.328 18.1406C266.07 18.0547 265.766 18 265.5 18C265.234 18 264.93 18.0703 264.672 18.1406C263.82 18.3828 260.906 19.4531 260.039 19.8125C259.258 20.1406 258.891 20.4844 258.891 21.4219V27.3203C258.891 30.1641 260.461 31.2812 264.945 33.7422C265.148 33.8516 265.359 33.8984 265.5 33.8984ZM265.922 19.5781C266.945 19.9766 269.172 20.7656 270.344 21.1875C270.562 21.2656 270.617 21.3828 270.617 21.6641V27.0234C270.617 29.3125 269.469 29.9375 265.945 32.0625C265.727 32.1875 265.617 32.2344 265.508 32.2344V19.4844C265.617 19.4844 265.734 19.5156 265.922 19.5781Z\"\n                  fill=\"#A3A3A3\"\n                />\n              </g>\n              <g className=\"mix-blend-luminosity\">\n                <path\n                  d=\"M936.273 24.9766C936.5 24.9766 936.68 24.9062 936.82 24.7578L940.023 21.5312C940.195 21.3594 940.273 21.1719 940.273 20.9531C940.273 20.7422 940.188 20.5391 940.023 20.3828L936.82 17.125C936.68 16.9688 936.5 16.8906 936.273 16.8906C935.852 16.8906 935.516 17.2422 935.516 17.6719C935.516 17.8828 935.594 18.0547 935.727 18.2031L937.594 20.0312C937.227 19.9766 936.852 19.9453 936.477 19.9453C932.609 19.9453 929.516 23.0391 929.516 26.9141C929.516 30.7891 932.633 33.9062 936.5 33.9062C940.375 33.9062 943.484 30.7891 943.484 26.9141C943.484 26.4453 943.156 26.1094 942.688 26.1094C942.234 26.1094 941.93 26.4453 941.93 26.9141C941.93 29.9297 939.516 32.3516 936.5 32.3516C933.492 32.3516 931.07 29.9297 931.07 26.9141C931.07 23.875 933.469 21.4688 936.477 21.4688C936.984 21.4688 937.453 21.5078 937.867 21.5781L935.734 23.6875C935.594 23.8281 935.516 24 935.516 24.2109C935.516 24.6406 935.852 24.9766 936.273 24.9766Z\"\n                  fill=\"#A3A3A3\"\n                />\n              </g>\n              <g className=\"mix-blend-luminosity\">\n                <path\n                  d=\"M1134 33.0156C1134.49 33.0156 1134.89 32.6094 1134.89 32.1484V27.2578H1139.66C1140.13 27.2578 1140.54 26.8594 1140.54 26.3672C1140.54 25.8828 1140.13 25.4766 1139.66 25.4766H1134.89V20.5859C1134.89 20.1172 1134.49 19.7188 1134 19.7188C1133.52 19.7188 1133.11 20.1172 1133.11 20.5859V25.4766H1128.34C1127.88 25.4766 1127.46 25.8828 1127.46 26.3672C1127.46 26.8594 1127.88 27.2578 1128.34 27.2578H1133.11V32.1484C1133.11 32.6094 1133.52 33.0156 1134 33.0156Z\"\n                  fill=\"#A3A3A3\"\n                />\n              </g>\n              <g className=\"mix-blend-luminosity\">\n                <path\n                  d=\"M1161.8 31.0703H1163.23V32.375C1163.23 34.0547 1164.12 34.9219 1165.81 34.9219H1174.2C1175.89 34.9219 1176.77 34.0547 1176.77 32.3828V24.0469C1176.77 22.375 1175.89 21.5 1174.2 21.5H1172.77V20.2578C1172.77 18.5859 1171.88 17.7109 1170.19 17.7109H1161.8C1160.1 17.7109 1159.23 18.5781 1159.23 20.2578V28.5234C1159.23 30.1953 1160.1 31.0703 1161.8 31.0703ZM1161.9 29.5078C1161.18 29.5078 1160.78 29.1328 1160.78 28.3828V20.3984C1160.78 19.6406 1161.18 19.2656 1161.9 19.2656H1170.09C1170.8 19.2656 1171.2 19.6406 1171.2 20.3984V21.5H1165.81C1164.12 21.5 1163.23 22.375 1163.23 24.0469V29.5078H1161.9ZM1165.91 33.3672C1165.19 33.3672 1164.8 32.9922 1164.8 32.2422V24.1875C1164.8 23.4297 1165.19 23.0625 1165.91 23.0625H1174.1C1174.81 23.0625 1175.21 23.4297 1175.21 24.1875V32.2422C1175.21 32.9922 1174.81 33.3672 1174.1 33.3672H1165.91Z\"\n                  fill=\"#A3A3A3\"\n                />\n              </g>\n              <g className=\"mix-blend-luminosity\">\n                <path\n                  d=\"M1099.51 28.4141C1099.91 28.4141 1100.24 28.0859 1100.24 27.6953V19.8359L1100.18 18.6797L1100.66 19.25L1101.75 20.4141C1101.88 20.5547 1102.06 20.625 1102.24 20.625C1102.6 20.625 1102.9 20.3672 1102.9 20C1102.9 19.8047 1102.82 19.6641 1102.69 19.5312L1100.06 17.0078C1099.88 16.8203 1099.7 16.7578 1099.51 16.7578C1099.32 16.7578 1099.14 16.8203 1098.95 17.0078L1096.33 19.5312C1096.2 19.6641 1096.12 19.8047 1096.12 20C1096.12 20.3672 1096.41 20.625 1096.77 20.625C1096.95 20.625 1097.14 20.5547 1097.27 20.4141L1098.35 19.25L1098.84 18.6719L1098.78 19.8359V27.6953C1098.78 28.0859 1099.11 28.4141 1099.51 28.4141ZM1095 34.6562H1104C1105.7 34.6562 1106.57 33.7812 1106.57 32.1094V24.4297C1106.57 22.7578 1105.7 21.8828 1104 21.8828H1101.89V23.4375H1103.9C1104.61 23.4375 1105.02 23.8125 1105.02 24.5625V31.9688C1105.02 32.7188 1104.61 33.0938 1103.9 33.0938H1095.1C1094.38 33.0938 1093.98 32.7188 1093.98 31.9688V24.5625C1093.98 23.8125 1094.38 23.4375 1095.1 23.4375H1097.13V21.8828H1095C1093.31 21.8828 1092.43 22.75 1092.43 24.4297V32.1094C1092.43 33.7812 1093.31 34.6562 1095 34.6562Z\"\n                  fill=\"#A3A3A3\"\n                />\n              </g>\n              <g className=\"mix-blend-luminosity\">\n                <path\n                  d=\"M99.5703 33.6016H112.938C114.633 33.6016 115.516 32.7266 115.516 31.0547V21.5469C115.516 19.875 114.633 19 112.938 19H99.5703C97.8828 19 97 19.8672 97 21.5469V31.0547C97 32.7266 97.8828 33.6016 99.5703 33.6016ZM99.6719 32.0469C98.9531 32.0469 98.5547 31.6719 98.5547 30.9141V21.6875C98.5547 20.9297 98.9531 20.5547 99.6719 20.5547H103.234V32.0469H99.6719ZM112.836 20.5547C113.555 20.5547 113.953 20.9297 113.953 21.6875V30.9141C113.953 31.6719 113.555 32.0469 112.836 32.0469H104.711V20.5547H112.836ZM101.703 23.4141C101.984 23.4141 102.219 23.1719 102.219 22.9062C102.219 22.6406 101.984 22.4062 101.703 22.4062H100.102C99.8203 22.4062 99.5859 22.6406 99.5859 22.9062C99.5859 23.1719 99.8203 23.4141 100.102 23.4141H101.703ZM101.703 25.5156C101.984 25.5156 102.219 25.2812 102.219 25.0078C102.219 24.7422 101.984 24.5078 101.703 24.5078H100.102C99.8203 24.5078 99.5859 24.7422 99.5859 25.0078C99.5859 25.2812 99.8203 25.5156 100.102 25.5156H101.703ZM101.703 27.6094C101.984 27.6094 102.219 27.3828 102.219 27.1094C102.219 26.8438 101.984 26.6172 101.703 26.6172H100.102C99.8203 26.6172 99.5859 26.8438 99.5859 27.1094C99.5859 27.3828 99.8203 27.6094 100.102 27.6094H101.703Z\"\n                  fill=\"#A3A3A3\"\n                />\n              </g>\n              <g className=\"mix-blend-luminosity\">\n                <path\n                  d=\"M143.914 32.5938C144.094 32.7656 144.312 32.8594 144.562 32.8594C145.086 32.8594 145.492 32.4531 145.492 31.9375C145.492 31.6797 145.391 31.4453 145.211 31.2656L139.742 25.9219L145.211 20.5938C145.391 20.4141 145.492 20.1719 145.492 19.9219C145.492 19.4062 145.086 19 144.562 19C144.312 19 144.094 19.0938 143.922 19.2656L137.844 25.2031C137.625 25.4062 137.516 25.6562 137.516 25.9297C137.516 26.2031 137.625 26.4375 137.836 26.6484L143.914 32.5938Z\"\n                  fill=\"#A3A3A3\"\n                />\n              </g>\n              <g className=\"mix-blend-luminosity\">\n                <path\n                  d=\"M168.422 32.8594C168.68 32.8594 168.891 32.7656 169.07 32.5938L175.148 26.6562C175.359 26.4375 175.469 26.2109 175.469 25.9297C175.469 25.6562 175.367 25.4141 175.148 25.2109L169.07 19.2656C168.891 19.0938 168.68 19 168.422 19C167.898 19 167.492 19.4062 167.492 19.9219C167.492 20.1719 167.602 20.4141 167.773 20.5938L173.25 25.9375L167.773 31.2656C167.594 31.4531 167.492 31.6797 167.492 31.9375C167.492 32.4531 167.898 32.8594 168.422 32.8594Z\"\n                  fill=\"#A3A3A3\"\n                />\n              </g>\n            </>\n          ) : null}\n        </g>\n      </svg>\n    </div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "smooth-cursor",
      "type": "component",
      "description": "A customizable, physics-based smooth cursor animation component",
      "category": "special",
      "dependencies": [
        "framer-motion"
      ],
      "files": [
        {
          "path": "components/ui/smooth-cursor.tsx",
          "content": "\"use client\"\n\nimport { FC, useEffect, useRef, useState } from \"react\"\nimport { motion, useSpring } from \"motion/react\"\n\ninterface Position {\n  x: number\n  y: number\n}\n\nexport interface SmoothCursorProps {\n  cursor?: React.ReactNode\n  springConfig?: {\n    damping: number\n    stiffness: number\n    mass: number\n    restDelta: number\n  }\n}\n\nconst DefaultCursorSVG: FC = () => {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={50}\n      height={54}\n      viewBox=\"0 0 50 54\"\n      fill=\"none\"\n      style={{ scale: 0.5 }}\n    >\n      <g filter=\"url(#filter0_d_91_7928)\">\n        <path\n          d=\"M42.6817 41.1495L27.5103 6.79925C26.7269 5.02557 24.2082 5.02558 23.3927 6.79925L7.59814 41.1495C6.75833 42.9759 8.52712 44.8902 10.4125 44.1954L24.3757 39.0496C24.8829 38.8627 25.4385 38.8627 25.9422 39.0496L39.8121 44.1954C41.6849 44.8902 43.4884 42.9759 42.6817 41.1495Z\"\n          fill=\"black\"\n        />\n        <path\n          d=\"M43.7146 40.6933L28.5431 6.34306C27.3556 3.65428 23.5772 3.69516 22.3668 6.32755L6.57226 40.6778C5.3134 43.4156 7.97238 46.298 10.803 45.2549L24.7662 40.109C25.0221 40.0147 25.2999 40.0156 25.5494 40.1082L39.4193 45.254C42.2261 46.2953 44.9254 43.4347 43.7146 40.6933Z\"\n          stroke=\"white\"\n          strokeWidth={2.25825}\n        />\n      </g>\n      <defs>\n        <filter\n          id=\"filter0_d_91_7928\"\n          x={0.602397}\n          y={0.952444}\n          width={49.0584}\n          height={52.428}\n          filterUnits=\"userSpaceOnUse\"\n          colorInterpolationFilters=\"sRGB\"\n        >\n          <feFlood floodOpacity={0} result=\"BackgroundImageFix\" />\n          <feColorMatrix\n            in=\"SourceAlpha\"\n            type=\"matrix\"\n            values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\"\n            result=\"hardAlpha\"\n          />\n          <feOffset dy={2.25825} />\n          <feGaussianBlur stdDeviation={2.25825} />\n          <feComposite in2=\"hardAlpha\" operator=\"out\" />\n          <feColorMatrix\n            type=\"matrix\"\n            values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.08 0\"\n          />\n          <feBlend\n            mode=\"normal\"\n            in2=\"BackgroundImageFix\"\n            result=\"effect1_dropShadow_91_7928\"\n          />\n          <feBlend\n            mode=\"normal\"\n            in=\"SourceGraphic\"\n            in2=\"effect1_dropShadow_91_7928\"\n            result=\"shape\"\n          />\n        </filter>\n      </defs>\n    </svg>\n  )\n}\n\nexport function SmoothCursor({\n  cursor = <DefaultCursorSVG />,\n  springConfig = {\n    damping: 45,\n    stiffness: 400,\n    mass: 1,\n    restDelta: 0.001,\n  },\n}: SmoothCursorProps) {\n  const [isMoving, setIsMoving] = useState(false)\n  const lastMousePos = useRef<Position>({ x: 0, y: 0 })\n  const velocity = useRef<Position>({ x: 0, y: 0 })\n  const lastUpdateTime = useRef(Date.now())\n  const previousAngle = useRef(0)\n  const accumulatedRotation = useRef(0)\n\n  const cursorX = useSpring(0, springConfig)\n  const cursorY = useSpring(0, springConfig)\n  const rotation = useSpring(0, {\n    ...springConfig,\n    damping: 60,\n    stiffness: 300,\n  })\n  const scale = useSpring(1, {\n    ...springConfig,\n    stiffness: 500,\n    damping: 35,\n  })\n\n  useEffect(() => {\n    const updateVelocity = (currentPos: Position) => {\n      const currentTime = Date.now()\n      const deltaTime = currentTime - lastUpdateTime.current\n\n      if (deltaTime > 0) {\n        velocity.current = {\n          x: (currentPos.x - lastMousePos.current.x) / deltaTime,\n          y: (currentPos.y - lastMousePos.current.y) / deltaTime,\n        }\n      }\n\n      lastUpdateTime.current = currentTime\n      lastMousePos.current = currentPos\n    }\n\n    const smoothMouseMove = (e: MouseEvent) => {\n      const currentPos = { x: e.clientX, y: e.clientY }\n      updateVelocity(currentPos)\n\n      const speed = Math.sqrt(\n        Math.pow(velocity.current.x, 2) + Math.pow(velocity.current.y, 2)\n      )\n\n      cursorX.set(currentPos.x)\n      cursorY.set(currentPos.y)\n\n      if (speed > 0.1) {\n        const currentAngle =\n          Math.atan2(velocity.current.y, velocity.current.x) * (180 / Math.PI) +\n          90\n\n        let angleDiff = currentAngle - previousAngle.current\n        if (angleDiff > 180) angleDiff -= 360\n        if (angleDiff < -180) angleDiff += 360\n        accumulatedRotation.current += angleDiff\n        rotation.set(accumulatedRotation.current)\n        previousAngle.current = currentAngle\n\n        scale.set(0.95)\n        setIsMoving(true)\n\n        const timeout = setTimeout(() => {\n          scale.set(1)\n          setIsMoving(false)\n        }, 150)\n\n        return () => clearTimeout(timeout)\n      }\n    }\n\n    let rafId: number\n    const throttledMouseMove = (e: MouseEvent) => {\n      if (rafId) return\n\n      rafId = requestAnimationFrame(() => {\n        smoothMouseMove(e)\n        rafId = 0\n      })\n    }\n\n    document.body.style.cursor = \"none\"\n    window.addEventListener(\"mousemove\", throttledMouseMove)\n\n    return () => {\n      window.removeEventListener(\"mousemove\", throttledMouseMove)\n      document.body.style.cursor = \"auto\"\n      if (rafId) cancelAnimationFrame(rafId)\n    }\n  }, [cursorX, cursorY, rotation, scale])\n\n  return (\n    <motion.div\n      style={{\n        position: \"fixed\",\n        left: cursorX,\n        top: cursorY,\n        translateX: \"-50%\",\n        translateY: \"-50%\",\n        rotate: rotation,\n        scale: scale,\n        zIndex: 100,\n        pointerEvents: \"none\",\n        willChange: \"transform\",\n      }}\n      initial={{ scale: 0 }}\n      animate={{ scale: 1 }}\n      transition={{\n        type: \"spring\",\n        stiffness: 400,\n        damping: 30,\n      }}\n    >\n      {cursor}\n    </motion.div>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    },
    {
      "name": "tweet-card",
      "type": "component",
      "description": "A card that displays a tweet with the author's name, handle, and profile picture.",
      "category": "special",
      "dependencies": [
        "react-tweet"
      ],
      "files": [
        {
          "path": "components/ui/tweet-card.tsx",
          "content": "/* eslint-disable @next/next/no-img-element */\nimport { Suspense } from \"react\"\nimport { enrichTweet, type EnrichedTweet, type TweetProps } from \"react-tweet\"\nimport { getTweet, type Tweet } from \"react-tweet/api\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface TwitterIconProps {\n  className?: string\n  [key: string]: unknown\n}\nconst Twitter = ({ className, ...props }: TwitterIconProps) => (\n  <svg\n    stroke=\"currentColor\"\n    fill=\"currentColor\"\n    strokeWidth=\"0\"\n    viewBox=\"0 0 24 24\"\n    height=\"1em\"\n    width=\"1em\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    className={className}\n    {...props}\n  >\n    <g>\n      <path fill=\"none\" d=\"M0 0h24v24H0z\"></path>\n      <path d=\"M22.162 5.656a8.384 8.384 0 0 1-2.402.658A4.196 4.196 0 0 0 21.6 4c-.82.488-1.719.83-2.656 1.015a4.182 4.182 0 0 0-7.126 3.814 11.874 11.874 0 0 1-8.62-4.37 4.168 4.168 0 0 0-.566 2.103c0 1.45.738 2.731 1.86 3.481a4.168 4.168 0 0 1-1.894-.523v.052a4.185 4.185 0 0 0 3.355 4.101 4.21 4.21 0 0 1-1.89.072A4.185 4.185 0 0 0 7.97 16.65a8.394 8.394 0 0 1-6.191 1.732 11.83 11.83 0 0 0 6.41 1.88c7.693 0 11.9-6.373 11.9-11.9 0-.18-.005-.362-.013-.54a8.496 8.496 0 0 0 2.087-2.165z\"></path>\n    </g>\n  </svg>\n)\n\nconst Verified = ({ className, ...props }: TwitterIconProps) => (\n  <svg\n    aria-label=\"Verified Account\"\n    viewBox=\"0 0 24 24\"\n    className={className}\n    {...props}\n  >\n    <g fill=\"currentColor\">\n      <path d=\"M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-.115-.094-2.415-2.415c-.293-.293-.293-.768 0-1.06s.768-.294 1.06 0l1.77 1.767 3.825-5.74c.23-.345.696-.436 1.04-.207.346.23.44.696.21 1.04z\" />\n    </g>\n  </svg>\n)\n\nexport const truncate = (str: string | null, length: number) => {\n  if (!str || str.length <= length) return str\n  return `${str.slice(0, length - 3)}...`\n}\n\nconst Skeleton = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => {\n  return (\n    <div className={cn(\"bg-primary/10 rounded-md\", className)} {...props} />\n  )\n}\n\nexport const TweetSkeleton = ({\n  className,\n  ...props\n}: {\n  className?: string\n  [key: string]: unknown\n}) => (\n  <div\n    className={cn(\n      \"flex size-full max-h-max min-w-72 flex-col gap-2 rounded-xl border p-4\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"flex flex-row gap-2\">\n      <Skeleton className=\"size-10 shrink-0 rounded-full\" />\n      <Skeleton className=\"h-10 w-full\" />\n    </div>\n    <Skeleton className=\"h-20 w-full\" />\n  </div>\n)\n\nexport const TweetNotFound = ({\n  className,\n  ...props\n}: {\n  className?: string\n  [key: string]: unknown\n}) => (\n  <div\n    className={cn(\n      \"flex size-full flex-col items-center justify-center gap-2 rounded-lg border p-4\",\n      className\n    )}\n    {...props}\n  >\n    <h3>Tweet not found</h3>\n  </div>\n)\n\nexport const TweetHeader = ({ tweet }: { tweet: EnrichedTweet }) => (\n  <div className=\"flex flex-row items-start justify-between tracking-normal\">\n    <div className=\"flex items-center space-x-3\">\n      <a\n        href={tweet.user.url}\n        target=\"_blank\"\n        rel=\"noreferrer\"\n        className=\"shrink-0\"\n      >\n        <img\n          title={`Profile picture of ${tweet.user.name}`}\n          alt={tweet.user.screen_name}\n          height={48}\n          width={48}\n          src={tweet.user.profile_image_url_https}\n          className=\"border-border/50 overflow-hidden rounded-full border\"\n        />\n      </a>\n      <div className=\"flex flex-col gap-0.5\">\n        <a\n          href={tweet.user.url}\n          target=\"_blank\"\n          rel=\"noreferrer\"\n          className=\"text-foreground flex items-center font-medium whitespace-nowrap transition-opacity hover:opacity-80\"\n        >\n          {truncate(tweet.user.name, 20)}\n          {tweet.user.verified ||\n            (tweet.user.is_blue_verified && (\n              <Verified className=\"ml-1 inline size-4 text-blue-500\" />\n            ))}\n        </a>\n        <div className=\"flex items-center space-x-1\">\n          <a\n            href={tweet.user.url}\n            target=\"_blank\"\n            rel=\"noreferrer\"\n            className=\"text-muted-foreground hover:text-foreground text-sm transition-colors\"\n          >\n            @{truncate(tweet.user.screen_name, 16)}\n          </a>\n        </div>\n      </div>\n    </div>\n    <a href={tweet.url} target=\"_blank\" rel=\"noreferrer\">\n      <span className=\"sr-only\">Link to tweet</span>\n      <Twitter className=\"text-muted-foreground hover:text-foreground size-5 items-start transition-all ease-in-out hover:scale-105\" />\n    </a>\n  </div>\n)\n\nexport const TweetBody = ({ tweet }: { tweet: EnrichedTweet }) => (\n  <div className=\"text-[15px] leading-relaxed tracking-normal wrap-break-word\">\n    {tweet.entities.map((entity, idx) => {\n      switch (entity.type) {\n        case \"url\":\n        case \"symbol\":\n        case \"hashtag\":\n        case \"mention\":\n          return (\n            <a\n              key={idx}\n              href={entity.href}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"text-muted-foreground hover:text-foreground text-[15px] font-normal transition-colors\"\n            >\n              <span>{entity.text}</span>\n            </a>\n          )\n        case \"text\":\n          return (\n            <span\n              key={idx}\n              className=\"text-foreground text-[15px] font-normal\"\n              dangerouslySetInnerHTML={{ __html: entity.text }}\n            />\n          )\n      }\n    })}\n  </div>\n)\n\nexport const TweetMedia = ({ tweet }: { tweet: EnrichedTweet }) => {\n  if (!tweet.video && !tweet.photos) return null\n  return (\n    <div className=\"flex flex-1 items-center justify-center\">\n      {tweet.video && (\n        <video\n          poster={tweet.video.poster}\n          autoPlay\n          loop\n          muted\n          playsInline\n          className=\"rounded-xl border shadow-sm\"\n        >\n          <source src={tweet.video.variants[0].src} type=\"video/mp4\" />\n          Your browser does not support the video tag.\n        </video>\n      )}\n      {tweet.photos && (\n        <div className=\"relative flex transform-gpu snap-x snap-mandatory gap-4 overflow-x-auto\">\n          <div className=\"shrink-0 snap-center sm:w-2\" />\n          {tweet.photos.map((photo) => (\n            <img\n              key={photo.url}\n              src={photo.url}\n              width={photo.width}\n              height={photo.height}\n              title={\"Photo by \" + tweet.user.name}\n              alt={tweet.text}\n              className=\"h-64 w-5/6 shrink-0 snap-center snap-always rounded-xl border object-cover shadow-sm\"\n            />\n          ))}\n          <div className=\"shrink-0 snap-center sm:w-2\" />\n        </div>\n      )}\n      {!tweet.video &&\n        !tweet.photos &&\n        // @ts-expect-error package doesn't have type definitions\n        tweet?.card?.binding_values?.thumbnail_image_large?.image_value.url && (\n          <img\n            src={\n              // @ts-expect-error package doesn't have type definitions\n              tweet.card.binding_values.thumbnail_image_large.image_value.url\n            }\n            className=\"h-64 rounded-xl border object-cover shadow-sm\"\n            alt={tweet.text}\n          />\n        )}\n    </div>\n  )\n}\n\nexport const MagicTweet = ({\n  tweet,\n  className,\n  ...props\n}: {\n  tweet: Tweet\n  className?: string\n}) => {\n  const enrichedTweet = enrichTweet(tweet)\n  return (\n    <div\n      className={cn(\n        \"relative flex h-fit w-full max-w-lg flex-col gap-4 overflow-hidden rounded-xl border p-5\",\n        className\n      )}\n      {...props}\n    >\n      <TweetHeader tweet={enrichedTweet} />\n      <TweetBody tweet={enrichedTweet} />\n      <TweetMedia tweet={enrichedTweet} />\n    </div>\n  )\n}\n\n/**\n * TweetCard (Server Side Only)\n */\nexport const TweetCard = async ({\n  id,\n  components,\n  fallback = <TweetSkeleton />,\n  onError,\n  ...props\n}: TweetProps & {\n  className?: string\n}) => {\n  const tweet = id\n    ? await getTweet(id).catch((err) => {\n        if (onError) {\n          onError(err)\n        } else {\n          console.error(err)\n        }\n      })\n    : undefined\n\n  if (!tweet) {\n    const NotFound = components?.TweetNotFound || TweetNotFound\n    return <NotFound {...props} />\n  }\n\n  return (\n    <Suspense fallback={fallback}>\n      <MagicTweet tweet={tweet} {...props} />\n    </Suspense>\n  )\n}\n",
          "type": "component"
        }
      ],
      "meta": {
        "tags": [
          "special"
        ]
      }
    }
  ],
  "categories": [
    {
      "name": "backgrounds",
      "label": "Backgrounds",
      "description": "Background patterns and effects",
      "icon": "Layers",
      "order": 1
    },
    {
      "name": "animations",
      "label": "Animations",
      "description": "Motion and animated components",
      "icon": "Zap",
      "order": 2
    },
    {
      "name": "text",
      "label": "Text Effects",
      "description": "Text animations and effects",
      "icon": "Type",
      "order": 3
    },
    {
      "name": "buttons",
      "label": "Buttons",
      "description": "Interactive button components",
      "icon": "MousePointer",
      "order": 4
    },
    {
      "name": "layouts",
      "label": "Layouts",
      "description": "Layout and grid systems",
      "icon": "Layout",
      "order": 5
    },
    {
      "name": "shaders",
      "label": "Shaders",
      "description": "Advanced shader-based effects",
      "icon": "Sparkles",
      "order": 6
    },
    {
      "name": "special",
      "label": "Special",
      "description": "Complex and unique components",
      "icon": "Star",
      "order": 7
    }
  ],
  "version": "0.1.0",
  "updatedAt": "2026-02-13T10:24:47.096Z"
}